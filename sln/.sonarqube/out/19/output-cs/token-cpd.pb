€
cC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\AssemblyInfo.cs
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 1
)1 2
]2 3
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str O
)O P
]P Q
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 7
)7 8
]8 9
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str .
). /
]/ 0
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 6
)6 7
]7 8
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 4
)4 5
]5 6
[		 
assembly		 	
:			 

InternalsVisibleTo		 
(		 
$str		 5
)		5 6
]		6 7
[

 
assembly

 	
:

	 

InternalsVisibleTo

 
(

 
$str

 ;
)

; <
]

< =
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 6
)6 7
]7 8
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str -
)- .
]. /
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 3
)3 4
]4 5
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 6
)6 7
]7 8
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str ;
); <
]< =
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 4
)4 5
]5 6
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 5
)5 6
]6 7
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 3
)3 4
]4 5
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 9
)9 :
]: ;
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str ;
); <
]< =
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str ,
), -
]- .
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 3
)3 4
]4 5
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str 6
)6 7
]7 8
[ 
assembly 	
:	 

InternalsVisibleTo 
( 
$str ?
)? @
]@ A¡ë
]C:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\Memory.cs
	namespace 	
Unity
 
. 
Collections 
{		 
[

 
BurstCompatible

 
]

 
unsafe 

internal 
struct 
Memory !
{ 
internal 
const 
long #
k_MaximumRamSizeInBytes 3
=4 5
$num6 8
<<9 ;
$num< >
;> ?
[ 	
BurstCompatible	 
] 
internal 
struct 
	Unmanaged !
{ 	
internal 
static 
void  
*  !
Allocate" *
(* +
long+ /
size0 4
,4 5
int6 9
align: ?
,? @
AllocatorManagerA Q
.Q R
AllocatorHandleR a
	allocatorb k
)k l
{ 
return 
Array 
. 
Resize #
(# $
null$ (
,( )
$num* +
,+ ,
$num- .
,. /
	allocator0 9
,9 :
size; ?
,? @
alignA F
)F G
;G H
} 
internal 
static 
void  
Free! %
(% &
void& *
** +
pointer, 3
,3 4
AllocatorManager5 E
.E F
AllocatorHandleF U
	allocatorV _
)_ `
{ 
if 
( 
pointer 
== 
null #
)# $
return 
; 
Array 
. 
Resize 
( 
pointer $
,$ %
$num& '
,' (
$num) *
,* +
	allocator, 5
,5 6
$num7 8
,8 9
$num: ;
); <
;< =
} 
[ 
BurstCompatible 
(  
GenericTypeArguments 1
=2 3
new4 7
[8 9
]9 :
{; <
typeof= C
(C D
intD G
)G H
}I J
)J K
]K L
internal 
static 
T 
* 
Allocate '
<' (
T( )
>) *
(* +
AllocatorManager+ ;
.; <
AllocatorHandle< K
	allocatorL U
)U V
whereW \
T] ^
:_ `
	unmanageda j
{   
return!! 
Array!! 
.!! 
Resize!! #
<!!# $
T!!$ %
>!!% &
(!!& '
null!!' +
,!!+ ,
$num!!- .
,!!. /
$num!!0 1
,!!1 2
	allocator!!3 <
)!!< =
;!!= >
}"" 
[$$ 
BurstCompatible$$ 
($$  
GenericTypeArguments$$ 1
=$$2 3
new$$4 7
[$$8 9
]$$9 :
{$$; <
typeof$$= C
($$C D
int$$D G
)$$G H
}$$I J
)$$J K
]$$K L
internal%% 
static%% 
void%%  
Free%%! %
<%%% &
T%%& '
>%%' (
(%%( )
T%%) *
*%%* +
pointer%%, 3
,%%3 4
AllocatorManager%%5 E
.%%E F
AllocatorHandle%%F U
	allocator%%V _
)%%_ `
where%%a f
T%%g h
:%%i j
	unmanaged%%k t
{&& 
if'' 
('' 
pointer'' 
=='' 
null'' #
)''# $
return(( 
;(( 
Array)) 
.)) 
Resize)) 
()) 
pointer)) $
,))$ %
$num))& '
,))' (
$num))) *
,))* +
	allocator)), 5
)))5 6
;))6 7
}** 
[,, 
BurstCompatible,, 
],, 
internal-- 
struct-- 
Array-- !
{.. 
static// 
bool// 
IsCustom// $
(//$ %
AllocatorManager//% 5
.//5 6
AllocatorHandle//6 E
	allocator//F O
)//O P
{00 
return11 
(11 
int11 
)11  
	allocator11! *
.11* +
Index11+ 0
>=111 3
AllocatorManager114 D
.11D E
FirstUserIndex11E S
;11S T
}22 
static44 
void44 
*44 
CustomResize44 )
(44) *
void44* .
*44. /

oldPointer440 :
,44: ;
long44< @
oldCount44A I
,44I J
long44K O
newCount44P X
,44X Y
AllocatorManager44Z j
.44j k
AllocatorHandle44k z
	allocator	44{ Ñ
,
44Ñ Ö
long
44Ü ä
size
44ã è
,
44è ê
int
44ë î
align
44ï ö
)
44ö õ
{55 
AllocatorManager66 $
.66$ %
Block66% *
block66+ 0
=661 2
default663 :
;66: ;
block77 
.77 
Range77 
.77  
	Allocator77  )
=77* +
	allocator77, 5
;775 6
block88 
.88 
Range88 
.88  
Items88  %
=88& '
(88( )
int88) ,
)88, -
newCount88- 5
;885 6
block99 
.99 
Range99 
.99  
Pointer99  '
=99( )
(99* +
IntPtr99+ 1
)991 2

oldPointer992 <
;99< =
block:: 
.:: 
BytesPerItem:: &
=::' (
(::) *
int::* -
)::- .
size::. 2
;::2 3
block;; 
.;; 
	Alignment;; #
=;;$ %
align;;& +
;;;+ ,
block<< 
.<< 
AllocatedItems<< (
=<<) *
(<<+ ,
int<<, /
)<</ 0
oldCount<<0 8
;<<8 9
var== 
error== 
=== 
AllocatorManager==  0
.==0 1
Try==1 4
(==4 5
ref==5 8
block==9 >
)==> ?
;==? @
AllocatorManager>> $
.>>$ %!
CheckFailedToAllocate>>% :
(>>: ;
error>>; @
)>>@ A
;>>A B
return?? 
(?? 
void??  
*??  !
)??! "
block??" '
.??' (
Range??( -
.??- .
Pointer??. 5
;??5 6
}@@ 
internalBB 
staticBB 
voidBB  $
*BB$ %
ResizeBB& ,
(BB, -
voidBB- 1
*BB1 2

oldPointerBB3 =
,BB= >
longBB? C
oldCountBBD L
,BBL M
longBBN R
newCountBBS [
,BB[ \
AllocatorManagerBB] m
.BBm n
AllocatorHandleBBn }
	allocator	BB~ á
,
BBá à
longCC 
sizeCC 
,CC 
intCC "
alignCC# (
)CC( )
{DD 
varFF 
	alignmentFF !
=FF" #
mathFF$ (
.FF( )
maxFF) ,
(FF, -
JobsUtilityFF- 8
.FF8 9
CacheLineSizeFF9 F
,FFF G
alignFFH M
)FFM N
;FFN O
ifHH 
(HH 
IsCustomHH  
(HH  !
	allocatorHH! *
)HH* +
)HH+ ,
returnII 
CustomResizeII +
(II+ ,

oldPointerII, 6
,II6 7
oldCountII8 @
,II@ A
newCountIIB J
,IIJ K
	allocatorIIL U
,IIU V
sizeIIW [
,II[ \
	alignmentII] f
)IIf g
;IIg h
voidJJ 
*JJ 

newPointerJJ $
=JJ% &
defaultJJ' .
;JJ. /
ifKK 
(KK 
newCountKK  
>KK! "
$numKK# $
)KK$ %
{LL 
longMM 
bytesToAllocateMM ,
=MM- .
newCountMM/ 7
*MM8 9
sizeMM: >
;MM> ?&
CheckByteCountIsReasonableNN 2
(NN2 3
bytesToAllocateNN3 B
)NNB C
;NNC D

newPointerOO "
=OO# $
UnsafeUtilityOO% 2
.OO2 3
MallocOO3 9
(OO9 :
bytesToAllocateOO: I
,OOI J
	alignmentOOK T
,OOT U
	allocatorOOV _
.OO_ `
ToAllocatorOO` k
)OOk l
;OOl m
ifPP 
(PP 
oldCountPP $
>PP% &
$numPP' (
)PP( )
{QQ 
longRR  
countRR! &
=RR' (
mathRR) -
.RR- .
minRR. 1
(RR1 2
oldCountRR2 :
,RR: ;
newCountRR< D
)RRD E
;RRE F
longSS  
bytesToCopySS! ,
=SS- .
countSS/ 4
*SS5 6
sizeSS7 ;
;SS; <&
CheckByteCountIsReasonableTT 6
(TT6 7
bytesToCopyTT7 B
)TTB C
;TTC D
UnsafeUtilityUU )
.UU) *
MemCpyUU* 0
(UU0 1

newPointerUU1 ;
,UU; <

oldPointerUU= G
,UUG H
bytesToCopyUUI T
)UUT U
;UUU V
}VV 
}WW 
ifXX 
(XX 
oldCountXX  
>XX! "
$numXX# $
)XX$ %
UnsafeUtilityYY %
.YY% &
FreeYY& *
(YY* +

oldPointerYY+ 5
,YY5 6
	allocatorYY7 @
.YY@ A
ToAllocatorYYA L
)YYL M
;YYM N
returnZZ 

newPointerZZ %
;ZZ% &
}[[ 
[]] 
BurstCompatible]]  
(]]  ! 
GenericTypeArguments]]! 5
=]]6 7
new]]8 ;
[]]< =
]]]= >
{]]? @
typeof]]A G
(]]G H
int]]H K
)]]K L
}]]M N
)]]N O
]]]O P
internal^^ 
static^^ 
T^^  !
*^^! "
Resize^^# )
<^^) *
T^^* +
>^^+ ,
(^^, -
T^^- .
*^^. /

oldPointer^^0 :
,^^: ;
long^^< @
oldCount^^A I
,^^I J
long^^K O
newCount^^P X
,^^X Y
AllocatorManager^^Z j
.^^j k
AllocatorHandle^^k z
	allocator	^^{ Ñ
)
^^Ñ Ö
where
^^Ü ã
T
^^å ç
:
^^é è
	unmanaged
^^ê ô
{__ 
return`` 
(`` 
T`` 
*`` 
)`` 
Resize`` %
(``% &
(``& '
byte``' +
*``+ ,
)``, -

oldPointer``- 7
,``7 8
oldCount``9 A
,``A B
newCount``C K
,``K L
	allocator``M V
,``V W
UnsafeUtility``X e
.``e f
SizeOf``f l
<``l m
T``m n
>``n o
(``o p
)``p q
,``q r
UnsafeUtility	``s Ä
.
``Ä Å
AlignOf
``Å à
<
``à â
T
``â ä
>
``ä ã
(
``ã å
)
``å ç
)
``ç é
;
``é è
}aa 
[cc 
BurstCompatiblecc  
(cc  ! 
GenericTypeArgumentscc! 5
=cc6 7
newcc8 ;
[cc< =
]cc= >
{cc? @
typeofccA G
(ccG H
intccH K
)ccK L
}ccM N
)ccN O
]ccO P
internaldd 
staticdd 
Tdd  !
*dd! "
Allocatedd# +
<dd+ ,
Tdd, -
>dd- .
(dd. /
longdd/ 3
countdd4 9
,dd9 :
AllocatorManagerdd; K
.ddK L
AllocatorHandleddL [
	allocatordd\ e
)dde f
whereee 
Tee 
:ee 
	unmanagedee '
{ff 
returngg 
Resizegg !
<gg! "
Tgg" #
>gg# $
(gg$ %
nullgg% )
,gg) *
$numgg+ ,
,gg, -
countgg. 3
,gg3 4
	allocatorgg5 >
)gg> ?
;gg? @
}hh 
[jj 
BurstCompatiblejj  
(jj  ! 
GenericTypeArgumentsjj! 5
=jj6 7
newjj8 ;
[jj< =
]jj= >
{jj? @
typeofjjA G
(jjG H
intjjH K
)jjK L
}jjM N
)jjN O
]jjO P
internalkk 
statickk 
voidkk  $
Freekk% )
<kk) *
Tkk* +
>kk+ ,
(kk, -
Tkk- .
*kk. /
pointerkk0 7
,kk7 8
longkk9 =
countkk> C
,kkC D
AllocatorManagerkkE U
.kkU V
AllocatorHandlekkV e
	allocatorkkf o
)kko p
wherell 
Tll 
:ll 
	unmanagedll '
{mm 
ifnn 
(nn 
pointernn 
==nn  "
nullnn# '
)nn' (
returnoo 
;oo 
Resizepp 
(pp 
pointerpp "
,pp" #
countpp$ )
,pp) *
$numpp+ ,
,pp, -
	allocatorpp. 7
)pp7 8
;pp8 9
}qq 
}rr 
}ss 	
[uu 	
BurstCompatibleuu	 
]uu 
internalvv 
structvv 
Arrayvv 
{ww 	
[xx 
BurstCompatiblexx 
(xx  
GenericTypeArgumentsxx 1
=xx2 3
newxx4 7
[xx8 9
]xx9 :
{xx; <
typeofxx= C
(xxC D
intxxD G
)xxG H
}xxI J
)xxJ K
]xxK L
internalyy 
staticyy 
voidyy  
Setyy! $
<yy$ %
Tyy% &
>yy& '
(yy' (
Tyy( )
*yy) *
pointeryy+ 2
,yy2 3
longyy4 8
countyy9 >
,yy> ?
Tyy@ A
tyyB C
=yyD E
defaultyyF M
)yyM N
whereyyO T
TyyU V
:yyW X
	unmanagedyyY b
{zz 
long{{ 

bytesToSet{{ 
={{  !
count{{" '
*{{( )
UnsafeUtility{{* 7
.{{7 8
SizeOf{{8 >
<{{> ?
T{{? @
>{{@ A
({{A B
){{B C
;{{C D&
CheckByteCountIsReasonable|| *
(||* +

bytesToSet||+ 5
)||5 6
;||6 7
for}} 
(}} 
var}} 
i}} 
=}} 
$num}} 
;}} 
i}}  !
<}}" #
count}}$ )
;}}) *
++}}+ -
i}}- .
)}}. /
pointer~~ 
[~~ 
i~~ 
]~~ 
=~~  
t~~! "
;~~" #
} 
[
ÅÅ 
BurstCompatible
ÅÅ 
(
ÅÅ "
GenericTypeArguments
ÅÅ 1
=
ÅÅ2 3
new
ÅÅ4 7
[
ÅÅ8 9
]
ÅÅ9 :
{
ÅÅ; <
typeof
ÅÅ= C
(
ÅÅC D
int
ÅÅD G
)
ÅÅG H
}
ÅÅI J
)
ÅÅJ K
]
ÅÅK L
internal
ÇÇ 
static
ÇÇ 
void
ÇÇ  
Clear
ÇÇ! &
<
ÇÇ& '
T
ÇÇ' (
>
ÇÇ( )
(
ÇÇ) *
T
ÇÇ* +
*
ÇÇ+ ,
pointer
ÇÇ- 4
,
ÇÇ4 5
long
ÇÇ6 :
count
ÇÇ; @
)
ÇÇ@ A
where
ÇÇB G
T
ÇÇH I
:
ÇÇJ K
	unmanaged
ÇÇL U
{
ÉÉ 
long
ÑÑ 
bytesToClear
ÑÑ !
=
ÑÑ" #
count
ÑÑ$ )
*
ÑÑ* +
UnsafeUtility
ÑÑ, 9
.
ÑÑ9 :
SizeOf
ÑÑ: @
<
ÑÑ@ A
T
ÑÑA B
>
ÑÑB C
(
ÑÑC D
)
ÑÑD E
;
ÑÑE F(
CheckByteCountIsReasonable
ÖÖ *
(
ÖÖ* +
bytesToClear
ÖÖ+ 7
)
ÖÖ7 8
;
ÖÖ8 9
UnsafeUtility
ÜÜ 
.
ÜÜ 
MemClear
ÜÜ &
(
ÜÜ& '
pointer
ÜÜ' .
,
ÜÜ. /
bytesToClear
ÜÜ0 <
)
ÜÜ< =
;
ÜÜ= >
}
áá 
[
ââ 
BurstCompatible
ââ 
(
ââ "
GenericTypeArguments
ââ 1
=
ââ2 3
new
ââ4 7
[
ââ8 9
]
ââ9 :
{
ââ; <
typeof
ââ= C
(
ââC D
int
ââD G
)
ââG H
}
ââI J
)
ââJ K
]
ââK L
internal
ää 
static
ää 
void
ää  
Copy
ää! %
<
ää% &
T
ää& '
>
ää' (
(
ää( )
T
ää) *
*
ää* +
dest
ää, 0
,
ää0 1
T
ää2 3
*
ää3 4
src
ää5 8
,
ää8 9
long
ää: >
count
ää? D
)
ääD E
where
ääF K
T
ääL M
:
ääN O
	unmanaged
ääP Y
{
ãã 
long
åå 
bytesToCopy
åå  
=
åå! "
count
åå# (
*
åå) *
UnsafeUtility
åå+ 8
.
åå8 9
SizeOf
åå9 ?
<
åå? @
T
åå@ A
>
ååA B
(
ååB C
)
ååC D
;
ååD E(
CheckByteCountIsReasonable
çç *
(
çç* +
bytesToCopy
çç+ 6
)
çç6 7
;
çç7 8
UnsafeUtility
éé 
.
éé 
MemCpy
éé $
(
éé$ %
dest
éé% )
,
éé) *
src
éé+ .
,
éé. /
bytesToCopy
éé0 ;
)
éé; <
;
éé< =
}
èè 
}
êê 	
[
íí 	
Conditional
íí	 
(
íí 
$str
íí 6
)
íí6 7
]
íí7 8
internal
ìì 
static
ìì 
void
ìì (
CheckByteCountIsReasonable
ìì 7
(
ìì7 8
long
ìì8 <
size
ìì= A
)
ììA B
{
îî 	
if
ïï 
(
ïï 
size
ïï 
<
ïï 
$num
ïï 
)
ïï 
throw
ññ 
new
ññ '
InvalidOperationException
ññ 3
(
ññ3 4
$str
ññ4 q
)
ññq r
;
ññr s
if
óó 
(
óó 
size
óó 
>
óó %
k_MaximumRamSizeInBytes
óó .
)
óó. /
throw
òò 
new
òò '
InvalidOperationException
òò 3
(
òò3 4
$str
òò4 m
)
òòm n
;
òòn o
}
ôô 	
}
õõ 
}úú Ÿë
cC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\xxHash3.AVX2.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[ 
BurstCompatible 
] 
public		 

static		 
partial		 
class		 
xxHash3		  '
{

 
internal 
static 
unsafe 
void #$
Avx2HashLongInternalLoop$ <
(< =
ulong= B
*B C
accD G
,G H
byteI M
*M N
inputO T
,T U
byteV Z
*Z [
dest\ `
,` a
longb f
lengthg m
,m n
byteo s
*s t
secretu {
,{ |
int	} Ä
isHash64
Å â
)
â ä
{ 	
if 
( 
X86 
. 
Avx2 
. 
IsAvx2Supported (
)( )
{ 
var 
	nb_blocks 
= 
(  !
length! '
-' (
$num( )
)) *
/+ ,
	BLOCK_LEN- 6
;6 7
for 
( 
int 
n 
= 
$num 
; 
n  !
<" #
	nb_blocks$ -
;- .
n/ 0
++0 2
)2 3
{ 
Avx2Accumulate "
(" #
acc# &
,& '
input( -
+. /
n0 1
*2 3
	BLOCK_LEN4 =
,= >
dest? C
==D F
nullG K
?L M
nullN R
:S T
destU Y
+Z [
n\ ]
*^ _
	BLOCK_LEN` i
,i j
secretk q
,q r
	NB_ROUNDSs |
,| }
isHash64	~ Ü
)
Ü á
;
á à
Avx2ScrambleAcc #
(# $
acc$ '
,' (
secret) /
+0 1
SECRET_KEY_SIZE2 A
-B C

STRIPE_LEND N
)N O
;O P
} 
var 
	nbStripes 
= 
(  !
(! "
length" (
-( )
$num) *
)* +
-, -
(. /
	BLOCK_LEN/ 8
*9 :
	nb_blocks; D
)D E
)E F
/G H

STRIPE_LENI S
;S T
Avx2Accumulate 
( 
acc "
," #
input$ )
+* +
	nb_blocks, 5
*6 7
	BLOCK_LEN8 A
,A B
destC G
==H J
nullK O
?P Q
nullR V
:W X
destY ]
+^ _
	nb_blocks` i
*j k
	BLOCK_LENl u
,u v
secretw }
,} ~
	nbStripes	 à
,
à â
isHash64
ä í
)
í ì
;
ì î
var 
p 
= 
input 
+ 
length  &
-' (

STRIPE_LEN) 3
;3 4
Avx2Accumulate512 !
(! "
acc" %
,% &
p' (
,( )
null* .
,. /
secret0 6
+7 8
SECRET_KEY_SIZE9 H
-I J

STRIPE_LENK U
-V W 
SECRET_LASTACC_STARTX l
)l m
;m n
if 
( 
dest 
!= 
null  
)  !
{ 
var 
	remaining !
=" #
length$ *
%+ ,

STRIPE_LEN- 7
;7 8
if   
(   
	remaining   !
!=  " $
$num  % &
)  & '
{!! 
UnsafeUtility"" %
.""% &
MemCpy""& ,
("", -
dest""- 1
+""2 3
length""4 :
-""; <
	remaining""= F
,""F G
input""H M
+""N O
length""P V
-""W X
	remaining""Y b
,""b c
	remaining""d m
)""m n
;""n o
}## 
}$$ 
}%% 
}&& 	
internal(( 
static(( 
unsafe(( 
void(( #
Avx2ScrambleAcc(($ 3
(((3 4
ulong((4 9
*((9 :
acc((; >
,((> ?
byte((@ D
*((D E
secret((F L
)((L M
{)) 	
if** 
(** 
X86** 
.** 
Avx2** 
.** 
IsAvx2Supported** (
)**( )
{++ 
var,, 
xAcc,, 
=,, 
(,, 
v256,,  
*,,  !
),,! "
acc,,# &
;,,& '
var-- 
xSecret-- 
=-- 
(-- 
v256-- #
*--# $
)--$ %
secret--& ,
;--, -
var.. 
prime32.. 
=.. 
X86.. !
...! "
Avx.." %
...% &
mm256_set1_epi32..& 6
(..6 7
	unchecked..7 @
(..@ A
(..A B
int..B E
)..E F
	PRIME32_1..G P
)..P Q
)..Q R
;..R S
var11 
acc_vec11 
=11 
xAcc11 "
[11" #
$num11# $
]11$ %
;11% &
var22 
shifted22 
=22 
X8622 !
.22! "
Avx222" &
.22& '
mm256_srli_epi6422' 7
(227 8
acc_vec228 ?
,22? @
$num22A C
)22C D
;22D E
var33 
data_vec33 
=33 
X8633 "
.33" #
Avx233# '
.33' (
mm256_xor_si25633( 7
(337 8
acc_vec338 ?
,33? @
shifted33A H
)33H I
;33I J
var55 
key_vec55 
=55 
X8655 !
.55! "
Avx55" %
.55% &
mm256_loadu_si25655& 7
(557 8
xSecret558 ?
+55@ A
$num55B C
)55C D
;55D E
var66 
data_key66 
=66 
X8666 "
.66" #
Avx266# '
.66' (
mm256_xor_si25666( 7
(667 8
data_vec668 @
,66@ A
key_vec66B I
)66I J
;66J K
var88 
data_key_hi88 
=88  !
X8688" %
.88% &
Avx288& *
.88* +
mm256_shuffle_epi3288+ >
(88> ?
data_key88? G
,88G H
X8688I L
.88L M
Sse88M P
.88P Q
SHUFFLE88Q X
(88X Y
$num88Y Z
,88Z [
$num88\ ]
,88] ^
$num88_ `
,88` a
$num88b c
)88c d
)88d e
;88e f
var99 
prod_lo99 
=99 
X8699 !
.99! "
Avx299" &
.99& '
mm256_mul_epu3299' 6
(996 7
data_key997 ?
,99? @
prime3299A H
)99H I
;99I J
var:: 
prod_hi:: 
=:: 
X86:: !
.::! "
Avx2::" &
.::& '
mm256_mul_epu32::' 6
(::6 7
data_key_hi::7 B
,::B C
prime32::D K
)::K L
;::L M
xAcc<< 
[<< 
$num<< 
]<< 
=<< 
X86<< 
.<< 
Avx2<< "
.<<" #
mm256_add_epi64<<# 2
(<<2 3
prod_lo<<3 :
,<<: ;
X86<<< ?
.<<? @
Avx2<<@ D
.<<D E
mm256_slli_epi64<<E U
(<<U V
prod_hi<<V ]
,<<] ^
$num<<_ a
)<<a b
)<<b c
;<<c d
acc_vec?? 
=?? 
xAcc?? 
[?? 
$num??  
]??  !
;??! "
shifted@@ 
=@@ 
X86@@ 
.@@ 
Avx2@@ "
.@@" #
mm256_srli_epi64@@# 3
(@@3 4
acc_vec@@4 ;
,@@; <
$num@@= ?
)@@? @
;@@@ A
data_vecAA 
=AA 
X86AA 
.AA 
Avx2AA #
.AA# $
mm256_xor_si256AA$ 3
(AA3 4
acc_vecAA4 ;
,AA; <
shiftedAA= D
)AAD E
;AAE F
key_vecCC 
=CC 
X86CC 
.CC 
AvxCC !
.CC! "
mm256_loadu_si256CC" 3
(CC3 4
xSecretCC4 ;
+CC< =
$numCC> ?
)CC? @
;CC@ A
data_keyDD 
=DD 
X86DD 
.DD 
Avx2DD #
.DD# $
mm256_xor_si256DD$ 3
(DD3 4
data_vecDD4 <
,DD< =
key_vecDD> E
)DDE F
;DDF G
data_key_hiFF 
=FF 
X86FF !
.FF! "
Avx2FF" &
.FF& '
mm256_shuffle_epi32FF' :
(FF: ;
data_keyFF; C
,FFC D
X86FFE H
.FFH I
SseFFI L
.FFL M
SHUFFLEFFM T
(FFT U
$numFFU V
,FFV W
$numFFX Y
,FFY Z
$numFF[ \
,FF\ ]
$numFF^ _
)FF_ `
)FF` a
;FFa b
prod_loGG 
=GG 
X86GG 
.GG 
Avx2GG "
.GG" #
mm256_mul_epu32GG# 2
(GG2 3
data_keyGG3 ;
,GG; <
prime32GG= D
)GGD E
;GGE F
prod_hiHH 
=HH 
X86HH 
.HH 
Avx2HH "
.HH" #
mm256_mul_epu32HH# 2
(HH2 3
data_key_hiHH3 >
,HH> ?
prime32HH@ G
)HHG H
;HHH I
xAccJJ 
[JJ 
$numJJ 
]JJ 
=JJ 
X86JJ 
.JJ 
Avx2JJ "
.JJ" #
mm256_add_epi64JJ# 2
(JJ2 3
prod_loJJ3 :
,JJ: ;
X86JJ< ?
.JJ? @
Avx2JJ@ D
.JJD E
mm256_slli_epi64JJE U
(JJU V
prod_hiJJV ]
,JJ] ^
$numJJ_ a
)JJa b
)JJb c
;JJc d
}KK 
}LL 	
internalNN 
staticNN 
unsafeNN 
voidNN #
Avx2AccumulateNN$ 2
(NN2 3
ulongNN3 8
*NN8 9
accNN: =
,NN= >
byteNN? C
*NNC D
inputNNE J
,NNJ K
byteNNL P
*NNP Q
destNNR V
,NNV W
byteNNX \
*NN\ ]
secretNN^ d
,NNd e
longNNf j
	nbStripesNNk t
,NNt u
intOO 
isHash64OO 
)OO 
{PP 	
ifQQ 
(QQ 
X86QQ 
.QQ 
Avx2QQ 
.QQ 
IsAvx2SupportedQQ (
)QQ( )
{RR 
forSS 
(SS 
varSS 
nSS 
=SS 
$numSS 
;SS 
nSS  !
<SS" #
	nbStripesSS$ -
;SS- .
nSS/ 0
++SS0 2
)SS2 3
{TT 
varUU 
xInputUU 
=UU  
inputUU! &
+UU' (
nUU) *
*UU+ ,

STRIPE_LENUU- 7
;UU7 8
Avx2Accumulate512VV %
(VV% &
accVV& )
,VV) *
xInputVV+ 1
,VV1 2
destVV3 7
==VV8 :
nullVV; ?
?VV@ A
nullVVB F
:VVG H
destVVI M
+VVN O
nVVP Q
*VVR S

STRIPE_LENVVT ^
,VV^ _
secretWW 
+WW  
nWW! "
*WW# $
SECRET_CONSUME_RATEWW% 8
)WW8 9
;WW9 :
}XX 
}YY 
}ZZ 	
internal\\ 
static\\ 
unsafe\\ 
void\\ #
Avx2Accumulate512\\$ 5
(\\5 6
ulong\\6 ;
*\\; <
acc\\= @
,\\@ A
byte\\B F
*\\F G
input\\H M
,\\M N
byte\\O S
*\\S T
dest\\U Y
,\\Y Z
byte\\[ _
*\\_ `
secret\\a g
)\\g h
{]] 	
if^^ 
(^^ 
X86^^ 
.^^ 
Avx2^^ 
.^^ 
IsAvx2Supported^^ (
)^^( )
{__ 
var`` 
xAcc`` 
=`` 
(`` 
v256``  
*``  !
)``! "
acc``# &
;``& '
varaa 
xSecretaa 
=aa 
(aa 
v256aa #
*aa# $
)aa$ %
secretaa& ,
;aa, -
varbb 
xInputbb 
=bb 
(bb 
v256bb "
*bb" #
)bb# $
inputbb% *
;bb* +
varee 
data_vecee 
=ee 
X86ee "
.ee" #
Avxee# &
.ee& '
mm256_loadu_si256ee' 8
(ee8 9
xInputee9 ?
+ee@ A
$numeeB C
)eeC D
;eeD E
varff 
key_vecff 
=ff 
X86ff "
.ff" #
Avxff# &
.ff& '
mm256_loadu_si256ff' 8
(ff8 9
xSecretff9 @
+ffA B
$numffC D
)ffD E
;ffE F
vargg 
data_keygg 
=gg 
X86gg "
.gg" #
Avx2gg# '
.gg' (
mm256_xor_si256gg( 7
(gg7 8
data_vecgg8 @
,gg@ A
key_vecggB I
)ggI J
;ggJ K
ifii 
(ii 
destii 
!=ii 
nullii  
)ii  !
{jj 
X86kk 
.kk 
Avxkk 
.kk 
mm256_storeu_si256kk .
(kk. /
destkk/ 3
,kk3 4
data_veckk5 =
)kk= >
;kk> ?
}ll 
varnn 
data_key_lonn 
=nn  !
X86nn" %
.nn% &
Avx2nn& *
.nn* +
mm256_shuffle_epi32nn+ >
(nn> ?
data_keynn? G
,nnG H
X86nnI L
.nnL M
SsennM P
.nnP Q
SHUFFLEnnQ X
(nnX Y
$numnnY Z
,nnZ [
$numnn\ ]
,nn] ^
$numnn_ `
,nn` a
$numnnb c
)nnc d
)nnd e
;nne f
varoo 
productoo 
=oo 
X86oo !
.oo! "
Avx2oo" &
.oo& '
mm256_mul_epu32oo' 6
(oo6 7
data_keyoo7 ?
,oo? @
data_key_loooA L
)ooL M
;ooM N
varpp 
	data_swappp 
=pp 
X86pp "
.pp" #
Avx2pp# '
.pp' (
mm256_shuffle_epi32pp( ;
(pp; <
data_vecpp< D
,ppD E
X86ppF I
.ppI J
SseppJ M
.ppM N
SHUFFLEppN U
(ppU V
$numppV W
,ppW X
$numppY Z
,ppZ [
$numpp\ ]
,pp] ^
$numpp_ `
)pp` a
)ppa b
;ppb c
varqq 
sumqq 
=qq 
X86qq 
.qq 
Avx2qq !
.qq! "
mm256_add_epi64qq" 1
(qq1 2
xAccqq2 6
[qq6 7
$numqq7 8
]qq8 9
,qq9 :
	data_swapqq; D
)qqD E
;qqE F
xAccss 
[ss 
$numss 
]ss 
=ss 
X86ss 
.ss 
Avx2ss "
.ss" #
mm256_add_epi64ss# 2
(ss2 3
productss3 :
,ss: ;
sumss< ?
)ss? @
;ss@ A
data_vecvv 
=vv 
X86vv 
.vv 
Avxvv "
.vv" #
mm256_loadu_si256vv# 4
(vv4 5
xInputvv5 ;
+vv< =
$numvv> ?
)vv? @
;vv@ A
key_vecww 
=ww 
X86ww 
.ww 
Avxww !
.ww! "
mm256_loadu_si256ww" 3
(ww3 4
xSecretww4 ;
+ww< =
$numww> ?
)ww? @
;ww@ A
data_keyxx 
=xx 
X86xx 
.xx 
Avx2xx #
.xx# $
mm256_xor_si256xx$ 3
(xx3 4
data_vecxx4 <
,xx< =
key_vecxx> E
)xxE F
;xxF G
ifzz 
(zz 
destzz 
!=zz 
nullzz  
)zz  !
{{{ 
X86|| 
.|| 
Avx|| 
.|| 
mm256_storeu_si256|| .
(||. /
dest||/ 3
+||4 5
$num||6 8
,||8 9
data_vec||: B
)||B C
;||C D
}}} 
data_key_lo 
= 
X86 !
.! "
Avx2" &
.& '
mm256_shuffle_epi32' :
(: ;
data_key; C
,C D
X86E H
.H I
SseI L
.L M
SHUFFLEM T
(T U
$numU V
,V W
$numX Y
,Y Z
$num[ \
,\ ]
$num^ _
)_ `
)` a
;a b
product
ÄÄ 
=
ÄÄ 
X86
ÄÄ 
.
ÄÄ 
Avx2
ÄÄ "
.
ÄÄ" #
mm256_mul_epu32
ÄÄ# 2
(
ÄÄ2 3
data_key
ÄÄ3 ;
,
ÄÄ; <
data_key_lo
ÄÄ= H
)
ÄÄH I
;
ÄÄI J
	data_swap
ÅÅ 
=
ÅÅ 
X86
ÅÅ 
.
ÅÅ  
Avx2
ÅÅ  $
.
ÅÅ$ %!
mm256_shuffle_epi32
ÅÅ% 8
(
ÅÅ8 9
data_vec
ÅÅ9 A
,
ÅÅA B
X86
ÅÅC F
.
ÅÅF G
Sse
ÅÅG J
.
ÅÅJ K
SHUFFLE
ÅÅK R
(
ÅÅR S
$num
ÅÅS T
,
ÅÅT U
$num
ÅÅV W
,
ÅÅW X
$num
ÅÅY Z
,
ÅÅZ [
$num
ÅÅ\ ]
)
ÅÅ] ^
)
ÅÅ^ _
;
ÅÅ_ `
sum
ÇÇ 
=
ÇÇ 
X86
ÇÇ 
.
ÇÇ 
Avx2
ÇÇ 
.
ÇÇ 
mm256_add_epi64
ÇÇ .
(
ÇÇ. /
xAcc
ÇÇ/ 3
[
ÇÇ3 4
$num
ÇÇ4 5
]
ÇÇ5 6
,
ÇÇ6 7
	data_swap
ÇÇ8 A
)
ÇÇA B
;
ÇÇB C
xAcc
ÑÑ 
[
ÑÑ 
$num
ÑÑ 
]
ÑÑ 
=
ÑÑ 
X86
ÑÑ 
.
ÑÑ 
Avx2
ÑÑ "
.
ÑÑ" #
mm256_add_epi64
ÑÑ# 2
(
ÑÑ2 3
product
ÑÑ3 :
,
ÑÑ: ;
sum
ÑÑ< ?
)
ÑÑ? @
;
ÑÑ@ A
}
ÖÖ 
}
ÜÜ 	
}
àà 
}ââ öù
iC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\FixedStringMethods.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[		 
BurstCompatible		 
]		 
public

 

unsafe

 
static

 
partial

  
class

! &
FixedStringMethods

' 9
{ 
[ 	
BurstCompatible	 
(  
GenericTypeArguments -
=. /
new0 3
[3 4
]4 5
{6 7
typeof8 >
(> ?
FixedString128Bytes? R
)R S
}T U
)U V
]V W
public 
static 
int 
IndexOf !
<! "
T" #
># $
($ %
ref% (
this) -
T. /
fs0 2
,2 3
byte4 8
*8 9
bytes: ?
,? @
intA D
bytesLenE M
)M N
where 
T 
: 
struct 
, 
INativeList )
<) *
byte* .
>. /
,/ 0

IUTF8Bytes1 ;
{ 	
var 
dst 
= 
fs 
. 
GetUnsafePtr %
(% &
)& '
;' (
var 
dstLen 
= 
fs 
. 
Length "
;" #
for 
( 
var 
i 
= 
$num 
; 
i 
<=  
dstLen! '
-( )
bytesLen* 2
;2 3
++4 6
i6 7
)7 8
{ 
for 
( 
var 
j 
= 
$num 
; 
j  !
<" #
bytesLen$ ,
;, -
++. 0
j0 1
)1 2
if 
( 
dst 
[ 
i 
+ 
j  !
]! "
!=# %
bytes& +
[+ ,
j, -
]- .
). /
goto 
end_of_loop (
;( )
return 
i 
; 
end_of_loop   
:   
{   
}    
}!! 
return"" 
-"" 
$num"" 
;"" 
}## 	
[// 	
BurstCompatible//	 
(//  
GenericTypeArguments// -
=//. /
new//0 3
[//3 4
]//4 5
{//6 7
typeof//8 >
(//> ?
FixedString128Bytes//? R
)//R S
}//T U
)//U V
]//V W
public00 
static00 
int00 
IndexOf00 !
<00! "
T00" #
>00# $
(00$ %
ref00% (
this00) -
T00. /
fs000 2
,002 3
byte004 8
*008 9
bytes00: ?
,00? @
int00A D
bytesLen00E M
,00M N
int00O R

startIndex00S ]
,00] ^
int00_ b
distance00c k
=00l m
Int3200n s
.00s t
MaxValue00t |
)00| }
where11 
T11 
:11 
struct11 
,11 
INativeList11 )
<11) *
byte11* .
>11. /
,11/ 0

IUTF8Bytes111 ;
{22 	
var33 
dst33 
=33 
fs33 
.33 
GetUnsafePtr33 %
(33% &
)33& '
;33' (
var44 
dstLen44 
=44 
fs44 
.44 
Length44 "
;44" #
var55 
searchrange55 
=55 
Math55 "
.55" #
Min55# &
(55& '
distance55' /
-550 1
$num552 3
,553 4
dstLen555 ;
-55< =
bytesLen55> F
)55F G
;55G H
for66 
(66 
var66 
i66 
=66 

startIndex66 #
;66# $
i66% &
<=66' )
searchrange66* 5
;665 6
++667 9
i669 :
)66: ;
{77 
for88 
(88 
var88 
j88 
=88 
$num88 
;88 
j88  !
<88" #
bytesLen88$ ,
;88, -
++88. 0
j880 1
)881 2
if99 
(99 
dst99 
[99 
i99 
+99 
j99  !
]99! "
!=99# %
bytes99& +
[99+ ,
j99, -
]99- .
)99. /
goto:: 
end_of_loop:: (
;::( )
return;; 
i;; 
;;; 
end_of_loop<< 
:<< 
{<< 
}<<  
}== 
return>> 
->> 
$num>> 
;>> 
}?? 	
[II 	
BurstCompatibleII	 
(II  
GenericTypeArgumentsII -
=II. /
newII0 3
[II3 4
]II4 5
{II6 7
typeofII8 >
(II> ?
FixedString128BytesII? R
)IIR S
,IIS T
typeofIIU [
(II[ \
FixedString128BytesII\ o
)IIo p
}IIq r
)IIr s
]IIs t
publicJJ 
staticJJ 
intJJ 
IndexOfJJ !
<JJ! "
TJJ" #
,JJ# $
T2JJ$ &
>JJ& '
(JJ' (
refJJ( +
thisJJ, 0
TJJ1 2
fsJJ3 5
,JJ5 6
inJJ7 9
T2JJ: <
otherJJ= B
)JJB C
whereKK 
TKK 
:KK 
structKK 
,KK 
INativeListKK )
<KK) *
byteKK* .
>KK. /
,KK/ 0

IUTF8BytesKK1 ;
whereLL 
T2LL 
:LL 
structLL 
,LL 
INativeListLL *
<LL* +
byteLL+ /
>LL/ 0
,LL0 1

IUTF8BytesLL2 <
{MM 	
refNN 
varNN 
orefNN 
=NN 
refNN #
UnsafeUtilityExtensionsNN 6
.NN6 7
AsRefNN7 <
(NN< =
inNN= ?
otherNN@ E
)NNE F
;NNF G
returnOO 
fsOO 
.OO 
IndexOfOO 
(OO 
orefOO "
.OO" #
GetUnsafePtrOO# /
(OO/ 0
)OO0 1
,OO1 2
orefOO3 7
.OO7 8
LengthOO8 >
)OO> ?
;OO? @
}PP 	
[\\ 	
BurstCompatible\\	 
(\\  
GenericTypeArguments\\ -
=\\. /
new\\0 3
[\\3 4
]\\4 5
{\\6 7
typeof\\8 >
(\\> ?
FixedString128Bytes\\? R
)\\R S
,\\S T
typeof\\U [
(\\[ \
FixedString128Bytes\\\ o
)\\o p
}\\q r
)\\r s
]\\s t
public]] 
static]] 
int]] 
IndexOf]] !
<]]! "
T]]" #
,]]# $
T2]]$ &
>]]& '
(]]' (
ref]]( +
this]], 0
T]]1 2
fs]]3 5
,]]5 6
in]]7 9
T2]]: <
other]]= B
,]]B C
int]]D G

startIndex]]H R
,]]R S
int]]T W
distance]]X `
=]]a b
Int32]]c h
.]]h i
MaxValue]]i q
)]]q r
where^^ 
T^^ 
:^^ 
struct^^ 
,^^ 
INativeList^^ )
<^^) *
byte^^* .
>^^. /
,^^/ 0

IUTF8Bytes^^1 ;
where__ 
T2__ 
:__ 
struct__ 
,__ 
INativeList__ *
<__* +
byte__+ /
>__/ 0
,__0 1

IUTF8Bytes__2 <
{`` 	
refaa 
varaa 
orefaa 
=aa 
refaa #
UnsafeUtilityExtensionsaa 6
.aa6 7
AsRefaa7 <
(aa< =
inaa= ?
otheraa@ E
)aaE F
;aaF G
returnbb 
fsbb 
.bb 
IndexOfbb 
(bb 
orefbb "
.bb" #
GetUnsafePtrbb# /
(bb/ 0
)bb0 1
,bb1 2
orefbb3 7
.bb7 8
Lengthbb8 >
,bb> ?

startIndexbb@ J
,bbJ K
distancebbL T
)bbT U
;bbU V
}cc 	
[mm 	
BurstCompatiblemm	 
(mm  
GenericTypeArgumentsmm -
=mm. /
newmm0 3
[mm3 4
]mm4 5
{mm6 7
typeofmm8 >
(mm> ?
FixedString128Bytesmm? R
)mmR S
,mmS T
typeofmmU [
(mm[ \
FixedString128Bytesmm\ o
)mmo p
}mmq r
)mmr s
]mms t
publicnn 
staticnn 
boolnn 
Containsnn #
<nn# $
Tnn$ %
,nn% &
T2nn& (
>nn( )
(nn) *
refnn* -
thisnn. 2
Tnn3 4
fsnn5 7
,nn7 8
innn9 ;
T2nn< >
othernn? D
)nnD E
whereoo 
Too 
:oo 
structoo 
,oo 
INativeListoo )
<oo) *
byteoo* .
>oo. /
,oo/ 0

IUTF8Bytesoo1 ;
wherepp 
T2pp 
:pp 
structpp 
,pp 
INativeListpp *
<pp* +
bytepp+ /
>pp/ 0
,pp0 1

IUTF8Bytespp2 <
{qq 	
returnrr 
fsrr 
.rr 
IndexOfrr 
(rr 
inrr  
otherrr! &
)rr& '
!=rr( *
-rr+ ,
$numrr, -
;rr- .
}ss 	
[}} 	
BurstCompatible}}	 
(}}  
GenericTypeArguments}} -
=}}. /
new}}0 3
[}}3 4
]}}4 5
{}}6 7
typeof}}8 >
(}}> ?
FixedString128Bytes}}? R
)}}R S
}}}T U
)}}U V
]}}V W
public~~ 
static~~ 
int~~ 
LastIndexOf~~ %
<~~% &
T~~& '
>~~' (
(~~( )
ref~~) ,
this~~- 1
T~~2 3
fs~~4 6
,~~6 7
byte~~8 <
*~~< =
bytes~~> C
,~~C D
int~~E H
bytesLen~~I Q
)~~Q R
where 
T 
: 
struct 
, 
INativeList )
<) *
byte* .
>. /
,/ 0

IUTF8Bytes1 ;
{
ÄÄ 	
var
ÅÅ 
dst
ÅÅ 
=
ÅÅ 
fs
ÅÅ 
.
ÅÅ 
GetUnsafePtr
ÅÅ %
(
ÅÅ% &
)
ÅÅ& '
;
ÅÅ' (
var
ÇÇ 
dstLen
ÇÇ 
=
ÇÇ 
fs
ÇÇ 
.
ÇÇ 
Length
ÇÇ "
;
ÇÇ" #
for
ÉÉ 
(
ÉÉ 
var
ÉÉ 
i
ÉÉ 
=
ÉÉ 
dstLen
ÉÉ 
-
ÉÉ  !
bytesLen
ÉÉ" *
;
ÉÉ* +
i
ÉÉ, -
>=
ÉÉ. 0
$num
ÉÉ1 2
;
ÉÉ2 3
--
ÉÉ4 6
i
ÉÉ6 7
)
ÉÉ7 8
{
ÑÑ 
for
ÖÖ 
(
ÖÖ 
var
ÖÖ 
j
ÖÖ 
=
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
j
ÖÖ  !
<
ÖÖ" #
bytesLen
ÖÖ$ ,
;
ÖÖ, -
++
ÖÖ. 0
j
ÖÖ0 1
)
ÖÖ1 2
if
ÜÜ 
(
ÜÜ 
dst
ÜÜ 
[
ÜÜ 
i
ÜÜ 
+
ÜÜ 
j
ÜÜ  !
]
ÜÜ! "
!=
ÜÜ# %
bytes
ÜÜ& +
[
ÜÜ+ ,
j
ÜÜ, -
]
ÜÜ- .
)
ÜÜ. /
goto
áá 
end_of_loop
áá (
;
áá( )
return
àà 
i
àà 
;
àà 
end_of_loop
ââ 
:
ââ 
{
ââ 
}
ââ  
}
ää 
return
ãã 
-
ãã 
$num
ãã 
;
ãã 
}
åå 	
[
òò 	
BurstCompatible
òò	 
(
òò "
GenericTypeArguments
òò -
=
òò. /
new
òò0 3
[
òò3 4
]
òò4 5
{
òò6 7
typeof
òò8 >
(
òò> ?!
FixedString128Bytes
òò? R
)
òòR S
}
òòT U
)
òòU V
]
òòV W
public
ôô 
static
ôô 
int
ôô 
LastIndexOf
ôô %
<
ôô% &
T
ôô& '
>
ôô' (
(
ôô( )
ref
ôô) ,
this
ôô- 1
T
ôô2 3
fs
ôô4 6
,
ôô6 7
byte
ôô8 <
*
ôô< =
bytes
ôô> C
,
ôôC D
int
ôôE H
bytesLen
ôôI Q
,
ôôQ R
int
ôôS V

startIndex
ôôW a
,
ôôa b
int
ôôc f
distance
ôôg o
=
ôôp q
int
ôôr u
.
ôôu v
MaxValue
ôôv ~
)
ôô~ 
where
öö 
T
öö 
:
öö 
struct
öö 
,
öö 
INativeList
öö )
<
öö) *
byte
öö* .
>
öö. /
,
öö/ 0

IUTF8Bytes
öö1 ;
{
õõ 	
var
úú 
dst
úú 
=
úú 
fs
úú 
.
úú 
GetUnsafePtr
úú %
(
úú% &
)
úú& '
;
úú' (
var
ùù 
dstLen
ùù 
=
ùù 
fs
ùù 
.
ùù 
Length
ùù "
;
ùù" #

startIndex
ûû 
=
ûû 
Math
ûû 
.
ûû 
Min
ûû !
(
ûû! "
dstLen
ûû" (
-
ûû) *
bytesLen
ûû+ 3
,
ûû3 4

startIndex
ûû5 ?
)
ûû? @
;
ûû@ A
var
üü 
searchrange
üü 
=
üü 
Math
üü "
.
üü" #
Max
üü# &
(
üü& '
$num
üü' (
,
üü( )

startIndex
üü* 4
-
üü5 6
distance
üü7 ?
)
üü? @
;
üü@ A
for
†† 
(
†† 
var
†† 
i
†† 
=
†† 

startIndex
†† #
;
††# $
i
††% &
>=
††' )
searchrange
††* 5
;
††5 6
--
††7 9
i
††9 :
)
††: ;
{
°° 
for
¢¢ 
(
¢¢ 
var
¢¢ 
j
¢¢ 
=
¢¢ 
$num
¢¢ 
;
¢¢ 
j
¢¢  !
<
¢¢" #
bytesLen
¢¢$ ,
;
¢¢, -
++
¢¢. 0
j
¢¢0 1
)
¢¢1 2
if
££ 
(
££ 
dst
££ 
[
££ 
i
££ 
+
££ 
j
££  !
]
££! "
!=
££# %
bytes
££& +
[
££+ ,
j
££, -
]
££- .
)
££. /
goto
§§ 
end_of_loop
§§ (
;
§§( )
return
•• 
i
•• 
;
•• 
end_of_loop
¶¶ 
:
¶¶ 
{
¶¶ 
}
¶¶  
}
ßß 
return
®® 
-
®® 
$num
®® 
;
®® 
}
©© 	
[
≥≥ 	
BurstCompatible
≥≥	 
(
≥≥ "
GenericTypeArguments
≥≥ -
=
≥≥. /
new
≥≥0 3
[
≥≥3 4
]
≥≥4 5
{
≥≥6 7
typeof
≥≥8 >
(
≥≥> ?!
FixedString128Bytes
≥≥? R
)
≥≥R S
,
≥≥S T
typeof
≥≥U [
(
≥≥[ \!
FixedString128Bytes
≥≥\ o
)
≥≥o p
}
≥≥q r
)
≥≥r s
]
≥≥s t
public
¥¥ 
static
¥¥ 
int
¥¥ 
LastIndexOf
¥¥ %
<
¥¥% &
T
¥¥& '
,
¥¥' (
T2
¥¥( *
>
¥¥* +
(
¥¥+ ,
ref
¥¥, /
this
¥¥0 4
T
¥¥5 6
fs
¥¥7 9
,
¥¥9 :
in
¥¥; =
T2
¥¥> @
other
¥¥A F
)
¥¥F G
where
µµ 
T
µµ 
:
µµ 
struct
µµ 
,
µµ 
INativeList
µµ )
<
µµ) *
byte
µµ* .
>
µµ. /
,
µµ/ 0

IUTF8Bytes
µµ1 ;
where
∂∂ 
T2
∂∂ 
:
∂∂ 
struct
∂∂ 
,
∂∂ 
INativeList
∂∂ *
<
∂∂* +
byte
∂∂+ /
>
∂∂/ 0
,
∂∂0 1

IUTF8Bytes
∂∂2 <
{
∑∑ 	
ref
∏∏ 
var
∏∏ 
oref
∏∏ 
=
∏∏ 
ref
∏∏ %
UnsafeUtilityExtensions
∏∏ 6
.
∏∏6 7
AsRef
∏∏7 <
(
∏∏< =
in
∏∏= ?
other
∏∏@ E
)
∏∏E F
;
∏∏F G
return
ππ 
fs
ππ 
.
ππ 
LastIndexOf
ππ !
(
ππ! "
oref
ππ" &
.
ππ& '
GetUnsafePtr
ππ' 3
(
ππ3 4
)
ππ4 5
,
ππ5 6
oref
ππ7 ;
.
ππ; <
Length
ππ< B
)
ππB C
;
ππC D
}
∫∫ 	
[
∆∆ 	
BurstCompatible
∆∆	 
(
∆∆ "
GenericTypeArguments
∆∆ -
=
∆∆. /
new
∆∆0 3
[
∆∆3 4
]
∆∆4 5
{
∆∆6 7
typeof
∆∆8 >
(
∆∆> ?!
FixedString128Bytes
∆∆? R
)
∆∆R S
,
∆∆S T
typeof
∆∆U [
(
∆∆[ \!
FixedString128Bytes
∆∆\ o
)
∆∆o p
}
∆∆q r
)
∆∆r s
]
∆∆s t
public
«« 
static
«« 
int
«« 
LastIndexOf
«« %
<
««% &
T
««& '
,
««' (
T2
««( *
>
««* +
(
««+ ,
ref
««, /
this
««0 4
T
««5 6
fs
««7 9
,
««9 :
in
««; =
T2
««> @
other
««A F
,
««F G
int
««H K

startIndex
««L V
,
««V W
int
««X [
distance
««\ d
=
««e f
Int32
««g l
.
««l m
MaxValue
««m u
)
««u v
where
»» 
T
»» 
:
»» 
struct
»» 
,
»» 
INativeList
»» )
<
»») *
byte
»»* .
>
»». /
,
»»/ 0

IUTF8Bytes
»»1 ;
where
…… 
T2
…… 
:
…… 
struct
…… 
,
…… 
INativeList
…… *
<
……* +
byte
……+ /
>
……/ 0
,
……0 1

IUTF8Bytes
……2 <
{
   	
ref
ÀÀ 
var
ÀÀ 
oref
ÀÀ 
=
ÀÀ 
ref
ÀÀ %
UnsafeUtilityExtensions
ÀÀ 6
.
ÀÀ6 7
AsRef
ÀÀ7 <
(
ÀÀ< =
in
ÀÀ= ?
other
ÀÀ@ E
)
ÀÀE F
;
ÀÀF G
return
ÃÃ 
fs
ÃÃ 
.
ÃÃ 
LastIndexOf
ÃÃ !
(
ÃÃ! "
oref
ÃÃ" &
.
ÃÃ& '
GetUnsafePtr
ÃÃ' 3
(
ÃÃ3 4
)
ÃÃ4 5
,
ÃÃ5 6
oref
ÃÃ7 ;
.
ÃÃ; <
Length
ÃÃ< B
,
ÃÃB C

startIndex
ÃÃD N
,
ÃÃN O
distance
ÃÃP X
)
ÃÃX Y
;
ÃÃY Z
}
ÕÕ 	
[
‹‹ 	
BurstCompatible
‹‹	 
(
‹‹ "
GenericTypeArguments
‹‹ -
=
‹‹. /
new
‹‹0 3
[
‹‹3 4
]
‹‹4 5
{
‹‹6 7
typeof
‹‹8 >
(
‹‹> ?!
FixedString128Bytes
‹‹? R
)
‹‹R S
}
‹‹T U
)
‹‹U V
]
‹‹V W
public
›› 
static
›› 
int
›› 
	CompareTo
›› #
<
››# $
T
››$ %
>
››% &
(
››& '
ref
››' *
this
››+ /
T
››0 1
fs
››2 4
,
››4 5
byte
››6 :
*
››: ;
bytes
››< A
,
››A B
int
››C F
bytesLen
››G O
)
››O P
where
ﬁﬁ 
T
ﬁﬁ 
:
ﬁﬁ 
struct
ﬁﬁ 
,
ﬁﬁ 
INativeList
ﬁﬁ )
<
ﬁﬁ) *
byte
ﬁﬁ* .
>
ﬁﬁ. /
,
ﬁﬁ/ 0

IUTF8Bytes
ﬁﬁ1 ;
{
ﬂﬂ 	
var
‡‡ 
a
‡‡ 
=
‡‡ 
fs
‡‡ 
.
‡‡ 
GetUnsafePtr
‡‡ #
(
‡‡# $
)
‡‡$ %
;
‡‡% &
var
·· 
aa
·· 
=
·· 
fs
·· 
.
·· 
Length
·· 
;
·· 
int
‚‚ 
chars
‚‚ 
=
‚‚ 
aa
‚‚ 
<
‚‚ 
bytesLen
‚‚ %
?
‚‚& '
aa
‚‚( *
:
‚‚+ ,
bytesLen
‚‚- 5
;
‚‚5 6
for
„„ 
(
„„ 
var
„„ 
i
„„ 
=
„„ 
$num
„„ 
;
„„ 
i
„„ 
<
„„ 
chars
„„  %
;
„„% &
++
„„' )
i
„„) *
)
„„* +
{
‰‰ 
if
ÂÂ 
(
ÂÂ 
a
ÂÂ 
[
ÂÂ 
i
ÂÂ 
]
ÂÂ 
<
ÂÂ 
bytes
ÂÂ  
[
ÂÂ  !
i
ÂÂ! "
]
ÂÂ" #
)
ÂÂ# $
return
ÊÊ 
-
ÊÊ 
$num
ÊÊ 
;
ÊÊ 
if
ÁÁ 
(
ÁÁ 
a
ÁÁ 
[
ÁÁ 
i
ÁÁ 
]
ÁÁ 
>
ÁÁ 
bytes
ÁÁ  
[
ÁÁ  !
i
ÁÁ! "
]
ÁÁ" #
)
ÁÁ# $
return
ËË 
$num
ËË 
;
ËË 
}
ÈÈ 
if
ÍÍ 
(
ÍÍ 
aa
ÍÍ 
<
ÍÍ 
bytesLen
ÍÍ 
)
ÍÍ 
return
ÎÎ 
-
ÎÎ 
$num
ÎÎ 
;
ÎÎ 
if
ÏÏ 
(
ÏÏ 
aa
ÏÏ 
>
ÏÏ 
bytesLen
ÏÏ 
)
ÏÏ 
return
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
return
ÓÓ 
$num
ÓÓ 
;
ÓÓ 
}
ÔÔ 	
[
˛˛ 	
BurstCompatible
˛˛	 
(
˛˛ "
GenericTypeArguments
˛˛ -
=
˛˛. /
new
˛˛0 3
[
˛˛3 4
]
˛˛4 5
{
˛˛6 7
typeof
˛˛8 >
(
˛˛> ?!
FixedString128Bytes
˛˛? R
)
˛˛R S
,
˛˛S T
typeof
˛˛U [
(
˛˛[ \!
FixedString128Bytes
˛˛\ o
)
˛˛o p
}
˛˛q r
)
˛˛r s
]
˛˛s t
public
ˇˇ 
static
ˇˇ 
int
ˇˇ 
	CompareTo
ˇˇ #
<
ˇˇ# $
T
ˇˇ$ %
,
ˇˇ% &
T2
ˇˇ& (
>
ˇˇ( )
(
ˇˇ) *
ref
ˇˇ* -
this
ˇˇ. 2
T
ˇˇ3 4
fs
ˇˇ5 7
,
ˇˇ7 8
in
ˇˇ9 ;
T2
ˇˇ< >
other
ˇˇ? D
)
ˇˇD E
where
ÄÄ 
T
ÄÄ 
:
ÄÄ 
struct
ÄÄ 
,
ÄÄ 
INativeList
ÄÄ )
<
ÄÄ) *
byte
ÄÄ* .
>
ÄÄ. /
,
ÄÄ/ 0

IUTF8Bytes
ÄÄ1 ;
where
ÅÅ 
T2
ÅÅ 
:
ÅÅ 
struct
ÅÅ 
,
ÅÅ 
INativeList
ÅÅ *
<
ÅÅ* +
byte
ÅÅ+ /
>
ÅÅ/ 0
,
ÅÅ0 1

IUTF8Bytes
ÅÅ2 <
{
ÇÇ 	
ref
ÉÉ 
var
ÉÉ 
oref
ÉÉ 
=
ÉÉ 
ref
ÉÉ %
UnsafeUtilityExtensions
ÉÉ 6
.
ÉÉ6 7
AsRef
ÉÉ7 <
(
ÉÉ< =
in
ÉÉ= ?
other
ÉÉ@ E
)
ÉÉE F
;
ÉÉF G
return
ÑÑ 
fs
ÑÑ 
.
ÑÑ 
	CompareTo
ÑÑ 
(
ÑÑ  
oref
ÑÑ  $
.
ÑÑ$ %
GetUnsafePtr
ÑÑ% 1
(
ÑÑ1 2
)
ÑÑ2 3
,
ÑÑ3 4
oref
ÑÑ5 9
.
ÑÑ9 :
Length
ÑÑ: @
)
ÑÑ@ A
;
ÑÑA B
}
ÖÖ 	
[
èè 	
BurstCompatible
èè	 
(
èè "
GenericTypeArguments
èè -
=
èè. /
new
èè0 3
[
èè3 4
]
èè4 5
{
èè6 7
typeof
èè8 >
(
èè> ?!
FixedString128Bytes
èè? R
)
èèR S
}
èèT U
)
èèU V
]
èèV W
public
êê 
static
êê 
bool
êê 
Equals
êê !
<
êê! "
T
êê" #
>
êê# $
(
êê$ %
ref
êê% (
this
êê) -
T
êê. /
fs
êê0 2
,
êê2 3
byte
êê4 8
*
êê8 9
bytes
êê: ?
,
êê? @
int
êêA D
bytesLen
êêE M
)
êêM N
where
ëë 
T
ëë 
:
ëë 
struct
ëë 
,
ëë 
INativeList
ëë )
<
ëë) *
byte
ëë* .
>
ëë. /
,
ëë/ 0

IUTF8Bytes
ëë1 ;
{
íí 	
var
ìì 
a
ìì 
=
ìì 
fs
ìì 
.
ìì 
GetUnsafePtr
ìì #
(
ìì# $
)
ìì$ %
;
ìì% &
var
îî 
aa
îî 
=
îî 
fs
îî 
.
îî 
Length
îî 
;
îî 
if
ïï 
(
ïï 
aa
ïï 
!=
ïï 
bytesLen
ïï 
)
ïï 
return
ññ 
false
ññ 
;
ññ 
if
óó 
(
óó 
a
óó 
==
óó 
bytes
óó 
)
óó 
return
òò 
true
òò 
;
òò 
return
ôô 
fs
ôô 
.
ôô 
	CompareTo
ôô 
(
ôô  
bytes
ôô  %
,
ôô% &
bytesLen
ôô' /
)
ôô/ 0
==
ôô1 3
$num
ôô4 5
;
ôô5 6
}
öö 	
[
§§ 	
BurstCompatible
§§	 
(
§§ "
GenericTypeArguments
§§ -
=
§§. /
new
§§0 3
[
§§3 4
]
§§4 5
{
§§6 7
typeof
§§8 >
(
§§> ?!
FixedString128Bytes
§§? R
)
§§R S
,
§§S T
typeof
§§U [
(
§§[ \!
FixedString128Bytes
§§\ o
)
§§o p
}
§§q r
)
§§r s
]
§§s t
public
•• 
static
•• 
bool
•• 
Equals
•• !
<
••! "
T
••" #
,
••# $
T2
••$ &
>
••& '
(
••' (
ref
••( +
this
••, 0
T
••1 2
fs
••3 5
,
••5 6
in
••7 9
T2
••: <
other
••= B
)
••B C
where
¶¶ 
T
¶¶ 
:
¶¶ 
struct
¶¶ 
,
¶¶ 
INativeList
¶¶ )
<
¶¶) *
byte
¶¶* .
>
¶¶. /
,
¶¶/ 0

IUTF8Bytes
¶¶1 ;
where
ßß 
T2
ßß 
:
ßß 
struct
ßß 
,
ßß 
INativeList
ßß *
<
ßß* +
byte
ßß+ /
>
ßß/ 0
,
ßß0 1

IUTF8Bytes
ßß2 <
{
®® 	
ref
©© 
var
©© 
oref
©© 
=
©© 
ref
©© %
UnsafeUtilityExtensions
©© 6
.
©©6 7
AsRef
©©7 <
(
©©< =
in
©©= ?
other
©©@ E
)
©©E F
;
©©F G
return
™™ 
fs
™™ 
.
™™ 
Equals
™™ 
(
™™ 
oref
™™ !
.
™™! "
GetUnsafePtr
™™" .
(
™™. /
)
™™/ 0
,
™™0 1
oref
™™2 6
.
™™6 7
Length
™™7 =
)
™™= >
;
™™> ?
}
´´ 	
[
µµ 	
BurstCompatible
µµ	 
(
µµ "
GenericTypeArguments
µµ -
=
µµ. /
new
µµ0 3
[
µµ3 4
]
µµ4 5
{
µµ6 7
typeof
µµ8 >
(
µµ> ?!
FixedString128Bytes
µµ? R
)
µµR S
}
µµT U
)
µµU V
]
µµV W
public
∂∂ 
static
∂∂ 
Unicode
∂∂ 
.
∂∂ 
Rune
∂∂ "
Peek
∂∂# '
<
∂∂' (
T
∂∂( )
>
∂∂) *
(
∂∂* +
ref
∂∂+ .
this
∂∂/ 3
T
∂∂4 5
fs
∂∂6 8
,
∂∂8 9
int
∂∂: =
index
∂∂> C
)
∂∂C D
where
∑∑ 
T
∑∑ 
:
∑∑ 
struct
∑∑ 
,
∑∑ 
INativeList
∑∑ )
<
∑∑) *
byte
∑∑* .
>
∑∑. /
,
∑∑/ 0

IUTF8Bytes
∑∑1 ;
{
∏∏ 	
if
ππ 
(
ππ 
index
ππ 
>=
ππ 
fs
ππ 
.
ππ 
Length
ππ "
)
ππ" #
return
∫∫ 
Unicode
∫∫ 
.
∫∫ 
BadRune
∫∫ &
;
∫∫& '
Unicode
ªª 
.
ªª 
	Utf8ToUcs
ªª 
(
ªª 
out
ªª !
var
ªª" %
rune
ªª& *
,
ªª* +
fs
ªª, .
.
ªª. /
GetUnsafePtr
ªª/ ;
(
ªª; <
)
ªª< =
,
ªª= >
ref
ªª? B
index
ªªC H
,
ªªH I
fs
ªªJ L
.
ªªL M
Capacity
ªªM U
)
ªªU V
;
ªªV W
return
ºº 
rune
ºº 
;
ºº 
}
ΩΩ 	
[
«« 	
BurstCompatible
««	 
(
«« "
GenericTypeArguments
«« -
=
««. /
new
««0 3
[
««3 4
]
««4 5
{
««6 7
typeof
««8 >
(
««> ?!
FixedString128Bytes
««? R
)
««R S
}
««T U
)
««U V
]
««V W
public
»» 
static
»» 
Unicode
»» 
.
»» 
Rune
»» "
Read
»»# '
<
»»' (
T
»»( )
>
»») *
(
»»* +
ref
»»+ .
this
»»/ 3
T
»»4 5
fs
»»6 8
,
»»8 9
ref
»»: =
int
»»> A
index
»»B G
)
»»G H
where
…… 
T
…… 
:
…… 
struct
…… 
,
…… 
INativeList
…… )
<
……) *
byte
……* .
>
……. /
,
……/ 0

IUTF8Bytes
……1 ;
{
   	
if
ÀÀ 
(
ÀÀ 
index
ÀÀ 
>=
ÀÀ 
fs
ÀÀ 
.
ÀÀ 
Length
ÀÀ "
)
ÀÀ" #
return
ÃÃ 
Unicode
ÃÃ 
.
ÃÃ 
BadRune
ÃÃ &
;
ÃÃ& '
Unicode
ÕÕ 
.
ÕÕ 
	Utf8ToUcs
ÕÕ 
(
ÕÕ 
out
ÕÕ !
var
ÕÕ" %
rune
ÕÕ& *
,
ÕÕ* +
fs
ÕÕ, .
.
ÕÕ. /
GetUnsafePtr
ÕÕ/ ;
(
ÕÕ; <
)
ÕÕ< =
,
ÕÕ= >
ref
ÕÕ? B
index
ÕÕC H
,
ÕÕH I
fs
ÕÕJ L
.
ÕÕL M
Capacity
ÕÕM U
)
ÕÕU V
;
ÕÕV W
return
ŒŒ 
rune
ŒŒ 
;
ŒŒ 
}
œœ 	
[
ŸŸ 	
BurstCompatible
ŸŸ	 
(
ŸŸ "
GenericTypeArguments
ŸŸ -
=
ŸŸ. /
new
ŸŸ0 3
[
ŸŸ3 4
]
ŸŸ4 5
{
ŸŸ6 7
typeof
ŸŸ8 >
(
ŸŸ> ?!
FixedString128Bytes
ŸŸ? R
)
ŸŸR S
}
ŸŸT U
)
ŸŸU V
]
ŸŸV W
public
⁄⁄ 
static
⁄⁄ 
FormatError
⁄⁄ !
Write
⁄⁄" '
<
⁄⁄' (
T
⁄⁄( )
>
⁄⁄) *
(
⁄⁄* +
ref
⁄⁄+ .
this
⁄⁄/ 3
T
⁄⁄4 5
fs
⁄⁄6 8
,
⁄⁄8 9
ref
⁄⁄: =
int
⁄⁄> A
index
⁄⁄B G
,
⁄⁄G H
Unicode
⁄⁄I P
.
⁄⁄P Q
Rune
⁄⁄Q U
rune
⁄⁄V Z
)
⁄⁄Z [
where
€€ 
T
€€ 
:
€€ 
struct
€€ 
,
€€ 
INativeList
€€ )
<
€€) *
byte
€€* .
>
€€. /
,
€€/ 0

IUTF8Bytes
€€1 ;
{
‹‹ 	
var
›› 
err
›› 
=
›› 
Unicode
›› 
.
›› 
	UcsToUtf8
›› '
(
››' (
fs
››( *
.
››* +
GetUnsafePtr
››+ 7
(
››7 8
)
››8 9
,
››9 :
ref
››; >
index
››? D
,
››D E
fs
››F H
.
››H I
Capacity
››I Q
,
››Q R
rune
››S W
)
››W X
;
››X Y
if
ﬁﬁ 
(
ﬁﬁ 
err
ﬁﬁ 
!=
ﬁﬁ 
ConversionError
ﬁﬁ &
.
ﬁﬁ& '
None
ﬁﬁ' +
)
ﬁﬁ+ ,
return
ﬂﬂ 
FormatError
ﬂﬂ "
.
ﬂﬂ" #
Overflow
ﬂﬂ# +
;
ﬂﬂ+ ,
return
‡‡ 
FormatError
‡‡ 
.
‡‡ 
None
‡‡ #
;
‡‡# $
}
·· 	
[
ÈÈ 	 
NotBurstCompatible
ÈÈ	 
]
ÈÈ 
public
ÍÍ 
static
ÍÍ 
String
ÍÍ 
ConvertToString
ÍÍ ,
<
ÍÍ, -
T
ÍÍ- .
>
ÍÍ. /
(
ÍÍ/ 0
ref
ÍÍ0 3
this
ÍÍ4 8
T
ÍÍ9 :
fs
ÍÍ; =
)
ÍÍ= >
where
ÎÎ 
T
ÎÎ 
:
ÎÎ 
struct
ÎÎ 
,
ÎÎ 
INativeList
ÎÎ )
<
ÎÎ) *
byte
ÎÎ* .
>
ÎÎ. /
,
ÎÎ/ 0

IUTF8Bytes
ÎÎ1 ;
{
ÏÏ 	
var
ÌÌ 
c
ÌÌ 
=
ÌÌ 

stackalloc
ÌÌ 
char
ÌÌ #
[
ÌÌ# $
fs
ÌÌ$ &
.
ÌÌ& '
Length
ÌÌ' -
*
ÌÌ. /
$num
ÌÌ0 1
]
ÌÌ1 2
;
ÌÌ2 3
int
ÓÓ 
length
ÓÓ 
=
ÓÓ 
$num
ÓÓ 
;
ÓÓ 
Unicode
ÔÔ 
.
ÔÔ 
Utf8ToUtf16
ÔÔ 
(
ÔÔ  
fs
ÔÔ  "
.
ÔÔ" #
GetUnsafePtr
ÔÔ# /
(
ÔÔ/ 0
)
ÔÔ0 1
,
ÔÔ1 2
fs
ÔÔ3 5
.
ÔÔ5 6
Length
ÔÔ6 <
,
ÔÔ< =
c
ÔÔ> ?
,
ÔÔ? @
out
ÔÔA D
length
ÔÔE K
,
ÔÔK L
fs
ÔÔM O
.
ÔÔO P
Length
ÔÔP V
*
ÔÔW X
$num
ÔÔY Z
)
ÔÔZ [
;
ÔÔ[ \
return
 
new
 
String
 
(
 
c
 
,
  
$num
! "
,
" #
length
$ *
)
* +
;
+ ,
}
ÒÒ 	
[
˘˘ 	
BurstCompatible
˘˘	 
(
˘˘ "
GenericTypeArguments
˘˘ -
=
˘˘. /
new
˘˘0 3
[
˘˘3 4
]
˘˘4 5
{
˘˘6 7
typeof
˘˘8 >
(
˘˘> ?!
FixedString128Bytes
˘˘? R
)
˘˘R S
}
˘˘T U
)
˘˘U V
]
˘˘V W
public
˙˙ 
static
˙˙ 
int
˙˙ 
ComputeHashCode
˙˙ )
<
˙˙) *
T
˙˙* +
>
˙˙+ ,
(
˙˙, -
ref
˙˙- 0
this
˙˙1 5
T
˙˙6 7
fs
˙˙8 :
)
˙˙: ;
where
˚˚ 
T
˚˚ 
:
˚˚ 
struct
˚˚ 
,
˚˚ 
INativeList
˚˚ )
<
˚˚) *
byte
˚˚* .
>
˚˚. /
,
˚˚/ 0

IUTF8Bytes
˚˚1 ;
{
¸¸ 	
return
˝˝ 
(
˝˝ 
int
˝˝ 
)
˝˝ 
CollectionHelper
˝˝ (
.
˝˝( )
Hash
˝˝) -
(
˝˝- .
fs
˝˝. 0
.
˝˝0 1
GetUnsafePtr
˝˝1 =
(
˝˝= >
)
˝˝> ?
,
˝˝? @
fs
˝˝A C
.
˝˝C D
Length
˝˝D J
)
˝˝J K
;
˝˝K L
}
˛˛ 	
[
åå 	
BurstCompatible
åå	 
(
åå "
GenericTypeArguments
åå -
=
åå. /
new
åå0 3
[
åå3 4
]
åå4 5
{
åå6 7
typeof
åå8 >
(
åå> ?!
FixedString128Bytes
åå? R
)
ååR S
}
ååT U
)
ååU V
]
ååV W
public
çç 
static
çç 
int
çç 
EffectiveSizeOf
çç )
<
çç) *
T
çç* +
>
çç+ ,
(
çç, -
ref
çç- 0
this
çç1 5
T
çç6 7
fs
çç8 :
)
çç: ;
where
éé 
T
éé 
:
éé 
struct
éé 
,
éé 
INativeList
éé )
<
éé) *
byte
éé* .
>
éé. /
,
éé/ 0

IUTF8Bytes
éé1 ;
{
èè 	
return
êê 
sizeof
êê 
(
êê 
ushort
êê  
)
êê  !
+
êê" #
fs
êê$ &
.
êê& '
Length
êê' -
+
êê. /
$num
êê0 1
;
êê1 2
}
ëë 	
}
íí 
}ìì …
aC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\Attributes.cs
	namespace 	
Unity
 
. 
Collections 
{ 
class 	#
CreatePropertyAttribute
 !
:" #
	Attribute$ -
{. /
}0 1
} ´æ
cC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeStream.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{ 
[		 
BurstCompatible		 
]		 
internal

 
unsafe

 
struct

 
UnsafeStreamBlock

 ,
{ 
internal 
UnsafeStreamBlock "
*" #
Next$ (
;( )
internal 
fixed 
byte 
Data  
[  !
$num! "
]" #
;# $
} 
[ 
BurstCompatible 
] 
internal 
unsafe 
struct 
UnsafeStreamRange ,
{ 
internal 
UnsafeStreamBlock "
*" #
Block$ )
;) *
internal 
int 
OffsetInFirstBlock '
;' (
internal 
int 
ElementCount !
;! "
internal 
int 

LastOffset 
;  
internal 
int 
NumberOfBlocks #
;# $
} 
[ 
BurstCompatible 
] 
internal 
unsafe 
struct !
UnsafeStreamBlockData 0
{ 
internal 
const 
int 
AllocationSize )
=* +
$num, -
*. /
$num0 4
;4 5
internal   
AllocatorManager   !
.  ! "
AllocatorHandle  " 1
	Allocator  2 ;
;  ; <
internal"" 
UnsafeStreamBlock"" "
*""" #
*""# $
Blocks""% +
;""+ ,
internal## 
int## 

BlockCount## 
;##  
internal%% 
UnsafeStreamBlock%% "
*%%" #
Free%%$ (
;%%( )
internal'' 
UnsafeStreamRange'' "
*''" #
Ranges''$ *
;''* +
internal(( 
int(( 

RangeCount(( 
;((  
internal** 
UnsafeStreamBlock** "
***" #
Allocate**$ ,
(**, -
UnsafeStreamBlock**- >
***> ?
oldBlock**@ H
,**H I
int**J M
threadIndex**N Y
)**Y Z
{++ 	
Assert,, 
.,, 
IsTrue,, 
(,, 
threadIndex,, %
<,,& '

BlockCount,,( 2
&&,,3 5
threadIndex,,6 A
>=,,B D
$num,,E F
),,F G
;,,G H
UnsafeStreamBlock.. 
*.. 
block.. $
=..% &
(..' (
UnsafeStreamBlock..( 9
*..9 :
)..: ;
Memory..; A
...A B
	Unmanaged..B K
...K L
Allocate..L T
(..T U
AllocationSize..U c
,..c d
$num..e g
,..g h
	Allocator..i r
)..r s
;..s t
block// 
->// 
Next// 
=// 
null// 
;// 
if11 
(11 
oldBlock11 
==11 
null11  
)11  !
{22 
block44 
->44 
Next44 
=44 
Blocks44 $
[44$ %
threadIndex44% 0
]440 1
;441 2
Blocks55 
[55 
threadIndex55 "
]55" #
=55$ %
block55& +
;55+ ,
}66 
else77 
{88 
oldBlock99 
->99 
Next99 
=99  
block99! &
;99& '
}:: 
return<< 
block<< 
;<< 
}== 	
}>> 
[VV 
BurstCompatibleVV 
]VV 
publicWW 

unsafeWW 
structWW 
UnsafeStreamWW %
:XX 	
INativeDisposableXX
 
{YY 
[ZZ 	-
!NativeDisableUnsafePtrRestrictionZZ	 *
]ZZ* +
internal[[ !
UnsafeStreamBlockData[[ &
*[[& '
m_Block[[( /
;[[/ 0
internal\\ 
AllocatorManager\\ !
.\\! "
AllocatorHandle\\" 1
m_Allocator\\2 =
;\\= >
publicdd 
UnsafeStreamdd 
(dd 
intdd 
bufferCountdd  +
,dd+ ,
AllocatorManagerdd- =
.dd= >
AllocatorHandledd> M
	allocatorddN W
)ddW X
{ee 	
AllocateBlockff 
(ff 
outff 
thisff "
,ff" #
	allocatorff$ -
)ff- .
;ff. /
AllocateForEachgg 
(gg 
bufferCountgg '
)gg' (
;gg( )
}hh 	
[ww 	
NotBurstCompatibleww	 
]
wwú ù
publicxx 
staticxx 
	JobHandlexx 
ScheduleConstructxx  1
<xx1 2
Txx2 3
>xx3 4
(xx4 5
outxx5 8
UnsafeStreamxx9 E
streamxxF L
,xxL M

NativeListxxN X
<xxX Y
TxxY Z
>xxZ [
bufferCountxx\ g
,xxg h
	JobHandlexxi r

dependencyxxs }
,xx} ~
AllocatorManager	xx è
.
xxè ê
AllocatorHandle
xxê ü
	allocator
xx† ©
)
xx© ™
whereyy 
Tyy 
:yy 
	unmanagedyy 
{zz 	
AllocateBlock{{ 
({{ 
out{{ 
stream{{ $
,{{$ %
	allocator{{& /
){{/ 0
;{{0 1
var|| 
jobData|| 
=|| 
new|| 
ConstructJobList|| .
{||/ 0
List||1 5
=||6 7
(||8 9
UntypedUnsafeList||9 J
*||J K
)||K L
bufferCount||L W
.||W X
GetUnsafeList||X e
(||e f
)||f g
,||g h
	Container||i r
=||s t
stream||u {
}||| }
;||} ~
return}} 
jobData}} 
.}} 
Schedule}} #
(}}# $

dependency}}$ .
)}}. /
;}}/ 0
}~~ 	
[
åå 	 
NotBurstCompatible
åå	 
]ååú ù
public
çç 
static
çç 
	JobHandle
çç 
ScheduleConstruct
çç  1
(
çç1 2
out
çç2 5
UnsafeStream
çç6 B
stream
ççC I
,
ççI J
NativeArray
ççK V
<
ççV W
int
ççW Z
>
ççZ [
bufferCount
çç\ g
,
ççg h
	JobHandle
ççi r

dependency
ççs }
,
çç} ~
AllocatorManagerçç è
.ççè ê
AllocatorHandleççê ü
	allocatorçç† ©
)çç© ™
{
éé 	
AllocateBlock
èè 
(
èè 
out
èè 
stream
èè $
,
èè$ %
	allocator
èè& /
)
èè/ 0
;
èè0 1
var
êê 
jobData
êê 
=
êê 
new
êê 
ConstructJob
êê *
{
êê+ ,
Length
êê- 3
=
êê4 5
bufferCount
êê6 A
,
êêA B
	Container
êêC L
=
êêM N
stream
êêO U
}
êêV W
;
êêW X
return
ëë 
jobData
ëë 
.
ëë 
Schedule
ëë #
(
ëë# $

dependency
ëë$ .
)
ëë. /
;
ëë/ 0
}
íí 	
internal
îî 
static
îî 
void
îî 
AllocateBlock
îî *
(
îî* +
out
îî+ .
UnsafeStream
îî/ ;
stream
îî< B
,
îîB C
AllocatorManager
îîD T
.
îîT U
AllocatorHandle
îîU d
	allocator
îîe n
)
îîn o
{
ïï 	
int
ññ 

blockCount
ññ 
=
ññ 
JobsUtility
ññ (
.
ññ( )
MaxJobThreadCount
ññ) :
;
ññ: ;
int
òò 
allocationSize
òò 
=
òò  
sizeof
òò! '
(
òò' (#
UnsafeStreamBlockData
òò( =
)
òò= >
+
òò? @
sizeof
òòA G
(
òòG H
UnsafeStreamBlock
òòH Y
*
òòY Z
)
òòZ [
*
òò\ ]

blockCount
òò^ h
;
òòh i
byte
ôô 
*
ôô 
buffer
ôô 
=
ôô 
(
ôô 
byte
ôô  
*
ôô  !
)
ôô! "
Memory
ôô" (
.
ôô( )
	Unmanaged
ôô) 2
.
ôô2 3
Allocate
ôô3 ;
(
ôô; <
allocationSize
ôô< J
,
ôôJ K
$num
ôôL N
,
ôôN O
	allocator
ôôP Y
)
ôôY Z
;
ôôZ [
UnsafeUtility
öö 
.
öö 
MemClear
öö "
(
öö" #
buffer
öö# )
,
öö) *
allocationSize
öö+ 9
)
öö9 :
;
öö: ;
var
úú 
block
úú 
=
úú 
(
úú #
UnsafeStreamBlockData
úú .
*
úú. /
)
úú/ 0
buffer
úú0 6
;
úú6 7
stream
ûû 
.
ûû 
m_Block
ûû 
=
ûû 
block
ûû "
;
ûû" #
stream
üü 
.
üü 
m_Allocator
üü 
=
üü  
	allocator
üü! *
;
üü* +
block
°° 
->
°° 
	Allocator
°° 
=
°° 
	allocator
°° (
;
°°( )
block
¢¢ 
->
¢¢ 

BlockCount
¢¢ 
=
¢¢ 

blockCount
¢¢  *
;
¢¢* +
block
££ 
->
££ 
Blocks
££ 
=
££ 
(
££ 
UnsafeStreamBlock
££ .
*
££. /
*
££/ 0
)
££0 1
(
££1 2
buffer
££2 8
+
££9 :
sizeof
££; A
(
££A B#
UnsafeStreamBlockData
££B W
)
££W X
)
££X Y
;
££Y Z
block
•• 
->
•• 
Ranges
•• 
=
•• 
null
••  
;
••  !
block
¶¶ 
->
¶¶ 

RangeCount
¶¶ 
=
¶¶ 
$num
¶¶  !
;
¶¶! "
}
ßß 	
internal
©© 
void
©© 
AllocateForEach
©© %
(
©©% &
int
©©& )
forEachCount
©©* 6
)
©©6 7
{
™™ 	
long
´´ 
allocationSize
´´ 
=
´´  !
sizeof
´´" (
(
´´( )
UnsafeStreamRange
´´) :
)
´´: ;
*
´´< =
forEachCount
´´> J
;
´´J K
m_Block
¨¨ 
->
¨¨ 
Ranges
¨¨ 
=
¨¨ 
(
¨¨ 
UnsafeStreamRange
¨¨ 0
*
¨¨0 1
)
¨¨1 2
Memory
¨¨2 8
.
¨¨8 9
	Unmanaged
¨¨9 B
.
¨¨B C
Allocate
¨¨C K
(
¨¨K L
allocationSize
¨¨L Z
,
¨¨Z [
$num
¨¨\ ^
,
¨¨^ _
m_Allocator
¨¨` k
)
¨¨k l
;
¨¨l m
m_Block
≠≠ 
->
≠≠ 

RangeCount
≠≠ 
=
≠≠  !
forEachCount
≠≠" .
;
≠≠. /
UnsafeUtility
ÆÆ 
.
ÆÆ 
MemClear
ÆÆ "
(
ÆÆ" #
m_Block
ÆÆ# *
->
ÆÆ* ,
Ranges
ÆÆ, 2
,
ÆÆ2 3
allocationSize
ÆÆ4 B
)
ÆÆB C
;
ÆÆC D
}
ØØ 	
public
µµ 
bool
µµ 
IsEmpty
µµ 
(
µµ 
)
µµ 
{
∂∂ 	
if
∑∑ 
(
∑∑ 
!
∑∑ 
	IsCreated
∑∑ 
)
∑∑ 
{
∏∏ 
return
ππ 
true
ππ 
;
ππ 
}
∫∫ 
for
ºº 
(
ºº 
int
ºº 
i
ºº 
=
ºº 
$num
ºº 
;
ºº 
i
ºº 
!=
ºº  
m_Block
ºº! (
->
ºº( *

RangeCount
ºº* 4
;
ºº4 5
i
ºº6 7
++
ºº7 9
)
ºº9 :
{
ΩΩ 
if
ææ 
(
ææ 
m_Block
ææ 
->
ææ 
Ranges
ææ #
[
ææ# $
i
ææ$ %
]
ææ% &
.
ææ& '
ElementCount
ææ' 3
>
ææ4 5
$num
ææ6 7
)
ææ7 8
{
øø 
return
¿¿ 
false
¿¿  
;
¿¿  !
}
¡¡ 
}
¬¬ 
return
ƒƒ 
true
ƒƒ 
;
ƒƒ 
}
≈≈ 	
public
ÃÃ 
bool
ÃÃ 
	IsCreated
ÃÃ 
=>
ÃÃ  
m_Block
ÃÃ! (
!=
ÃÃ) +
null
ÃÃ, 0
;
ÃÃ0 1
public
““ 
int
““ 
ForEachCount
““ 
=>
““  "
m_Block
““# *
->
““* ,

RangeCount
““, 6
;
““6 7
public
ÿÿ 
Reader
ÿÿ 
AsReader
ÿÿ 
(
ÿÿ 
)
ÿÿ  
{
ŸŸ 	
return
⁄⁄ 
new
⁄⁄ 
Reader
⁄⁄ 
(
⁄⁄ 
ref
⁄⁄ !
this
⁄⁄" &
)
⁄⁄& '
;
⁄⁄' (
}
€€ 	
public
·· 
Writer
·· 
AsWriter
·· 
(
·· 
)
··  
{
‚‚ 	
return
„„ 
new
„„ 
Writer
„„ 
(
„„ 
ref
„„ !
this
„„" &
)
„„& '
;
„„' (
}
‰‰ 	
public
ÎÎ 
int
ÎÎ 
Count
ÎÎ 
(
ÎÎ 
)
ÎÎ 
{
ÏÏ 	
int
ÌÌ 
	itemCount
ÌÌ 
=
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
for
ÔÔ 
(
ÔÔ 
int
ÔÔ 
i
ÔÔ 
=
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
i
ÔÔ 
!=
ÔÔ  
m_Block
ÔÔ! (
->
ÔÔ( *

RangeCount
ÔÔ* 4
;
ÔÔ4 5
i
ÔÔ6 7
++
ÔÔ7 9
)
ÔÔ9 :
{
 
	itemCount
ÒÒ 
+=
ÒÒ 
m_Block
ÒÒ $
->
ÒÒ$ &
Ranges
ÒÒ& ,
[
ÒÒ, -
i
ÒÒ- .
]
ÒÒ. /
.
ÒÒ/ 0
ElementCount
ÒÒ0 <
;
ÒÒ< =
}
ÚÚ 
return
ÙÙ 
	itemCount
ÙÙ 
;
ÙÙ 
}
ıı 	
[
ÅÅ 	
BurstCompatible
ÅÅ	 
(
ÅÅ "
GenericTypeArguments
ÅÅ -
=
ÅÅ. /
new
ÅÅ0 3
[
ÅÅ3 4
]
ÅÅ4 5
{
ÅÅ6 7
typeof
ÅÅ8 >
(
ÅÅ> ?
int
ÅÅ? B
)
ÅÅB C
}
ÅÅD E
)
ÅÅE F
]
ÅÅF G
public
ÇÇ 
NativeArray
ÇÇ 
<
ÇÇ 
T
ÇÇ 
>
ÇÇ 
ToNativeArray
ÇÇ +
<
ÇÇ+ ,
T
ÇÇ, -
>
ÇÇ- .
(
ÇÇ. /
AllocatorManager
ÇÇ/ ?
.
ÇÇ? @
AllocatorHandle
ÇÇ@ O
	allocator
ÇÇP Y
)
ÇÇY Z
where
ÇÇ[ `
T
ÇÇa b
:
ÇÇc d
struct
ÇÇe k
{
ÉÉ 	
var
ÑÑ 
array
ÑÑ 
=
ÑÑ 
CollectionHelper
ÑÑ (
.
ÑÑ( )
CreateNativeArray
ÑÑ) :
<
ÑÑ: ;
T
ÑÑ; <
>
ÑÑ< =
(
ÑÑ= >
Count
ÑÑ> C
(
ÑÑC D
)
ÑÑD E
,
ÑÑE F
	allocator
ÑÑG P
,
ÑÑP Q 
NativeArrayOptions
ÑÑR d
.
ÑÑd e!
UninitializedMemory
ÑÑe x
)
ÑÑx y
;
ÑÑy z
var
ÖÖ 
reader
ÖÖ 
=
ÖÖ 
AsReader
ÖÖ !
(
ÖÖ! "
)
ÖÖ" #
;
ÖÖ# $
int
áá 
offset
áá 
=
áá 
$num
áá 
;
áá 
for
àà 
(
àà 
int
àà 
i
àà 
=
àà 
$num
àà 
;
àà 
i
àà 
!=
àà  
reader
àà! '
.
àà' (
ForEachCount
àà( 4
;
àà4 5
i
àà6 7
++
àà7 9
)
àà9 :
{
ââ 
reader
ää 
.
ää 
BeginForEachIndex
ää (
(
ää( )
i
ää) *
)
ää* +
;
ää+ ,
int
ãã 
rangeItemCount
ãã "
=
ãã# $
reader
ãã% +
.
ãã+ , 
RemainingItemCount
ãã, >
;
ãã> ?
for
åå 
(
åå 
int
åå 
j
åå 
=
åå 
$num
åå 
;
åå 
j
åå  !
<
åå" #
rangeItemCount
åå$ 2
;
åå2 3
++
åå4 6
j
åå6 7
)
åå7 8
{
çç 
array
éé 
[
éé 
offset
éé  
]
éé  !
=
éé" #
reader
éé$ *
.
éé* +
Read
éé+ /
<
éé/ 0
T
éé0 1
>
éé1 2
(
éé2 3
)
éé3 4
;
éé4 5
offset
èè 
++
èè 
;
èè 
}
êê 
reader
ëë 
.
ëë 
EndForEachIndex
ëë &
(
ëë& '
)
ëë' (
;
ëë( )
}
íí 
return
îî 
array
îî 
;
îî 
}
ïï 	
void
óó 

Deallocate
óó 
(
óó 
)
óó 
{
òò 	
if
ôô 
(
ôô 
m_Block
ôô 
==
ôô 
null
ôô 
)
ôô  
{
öö 
return
õõ 
;
õõ 
}
úú 
for
ûû 
(
ûû 
int
ûû 
i
ûû 
=
ûû 
$num
ûû 
;
ûû 
i
ûû 
!=
ûû  
m_Block
ûû! (
->
ûû( *

BlockCount
ûû* 4
;
ûû4 5
i
ûû6 7
++
ûû7 9
)
ûû9 :
{
üü 
UnsafeStreamBlock
†† !
*
††! "
block
††# (
=
††) *
m_Block
††+ 2
->
††2 4
Blocks
††4 :
[
††: ;
i
††; <
]
††< =
;
††= >
while
°° 
(
°° 
block
°° 
!=
°° 
null
°°  $
)
°°$ %
{
¢¢ 
UnsafeStreamBlock
££ %
*
££% &
next
££' +
=
££, -
block
££. 3
->
££3 5
Next
££5 9
;
££9 :
Memory
§§ 
.
§§ 
	Unmanaged
§§ $
.
§§$ %
Free
§§% )
(
§§) *
block
§§* /
,
§§/ 0
m_Allocator
§§1 <
)
§§< =
;
§§= >
block
•• 
=
•• 
next
••  
;
••  !
}
¶¶ 
}
ßß 
Memory
©© 
.
©© 
	Unmanaged
©© 
.
©© 
Free
©© !
(
©©! "
m_Block
©©" )
->
©©) +
Ranges
©©+ 1
,
©©1 2
m_Allocator
©©3 >
)
©©> ?
;
©©? @
Memory
™™ 
.
™™ 
	Unmanaged
™™ 
.
™™ 
Free
™™ !
(
™™! "
m_Block
™™" )
,
™™) *
m_Allocator
™™+ 6
)
™™6 7
;
™™7 8
m_Block
´´ 
=
´´ 
null
´´ 
;
´´ 
m_Allocator
¨¨ 
=
¨¨ 
	Allocator
¨¨ #
.
¨¨# $
None
¨¨$ (
;
¨¨( )
}
≠≠ 	
public
≤≤ 
void
≤≤ 
Dispose
≤≤ 
(
≤≤ 
)
≤≤ 
{
≥≥ 	

Deallocate
¥¥ 
(
¥¥ 
)
¥¥ 
;
¥¥ 
}
µµ 	
[
ºº 	 
NotBurstCompatible
ºº	 
]ººú ù
public
ΩΩ 
	JobHandle
ΩΩ 
Dispose
ΩΩ  
(
ΩΩ  !
	JobHandle
ΩΩ! *
	inputDeps
ΩΩ+ 4
)
ΩΩ4 5
{
ææ 	
var
øø 
	jobHandle
øø 
=
øø 
new
øø 

DisposeJob
øø  *
{
øø+ ,
	Container
øø- 6
=
øø7 8
this
øø9 =
}
øø> ?
.
øø? @
Schedule
øø@ H
(
øøH I
	inputDeps
øøI R
)
øøR S
;
øøS T
m_Block
¡¡ 
=
¡¡ 
null
¡¡ 
;
¡¡ 
return
√√ 
	jobHandle
√√ 
;
√√ 
}
ƒƒ 	
[
∆∆ 	
BurstCompile
∆∆	 
]
∆∆ 
struct
«« 

DisposeJob
«« 
:
«« 
IJob
««  
{
»» 	
public
…… 
UnsafeStream
…… 
	Container
……  )
;
……) *
public
ÀÀ 
void
ÀÀ 
Execute
ÀÀ 
(
ÀÀ  
)
ÀÀ  !
{
ÃÃ 
	Container
ÕÕ 
.
ÕÕ 

Deallocate
ÕÕ $
(
ÕÕ$ %
)
ÕÕ% &
;
ÕÕ& '
}
ŒŒ 
}
œœ 	
[
—— 	
BurstCompile
——	 
]
—— 
struct
““ 
ConstructJobList
““ 
:
““  !
IJob
““" &
{
”” 	
public
‘‘ 
UnsafeStream
‘‘ 
	Container
‘‘  )
;
‘‘) *
[
÷÷ 
ReadOnly
÷÷ 
]
÷÷ 
[
◊◊ /
!NativeDisableUnsafePtrRestriction
◊◊ .
]
◊◊. /
public
ÿÿ 
UntypedUnsafeList
ÿÿ $
*
ÿÿ$ %
List
ÿÿ& *
;
ÿÿ* +
public
⁄⁄ 
void
⁄⁄ 
Execute
⁄⁄ 
(
⁄⁄  
)
⁄⁄  !
{
€€ 
	Container
‹‹ 
.
‹‹ 
AllocateForEach
‹‹ )
(
‹‹) *
List
‹‹* .
->
‹‹. 0
m_length
‹‹0 8
)
‹‹8 9
;
‹‹9 :
}
›› 
}
ﬁﬁ 	
[
‡‡ 	
BurstCompile
‡‡	 
]
‡‡ 
struct
·· 
ConstructJob
·· 
:
·· 
IJob
·· "
{
‚‚ 	
public
„„ 
UnsafeStream
„„ 
	Container
„„  )
;
„„) *
[
ÂÂ 
ReadOnly
ÂÂ 
]
ÂÂ 
public
ÊÊ 
NativeArray
ÊÊ 
<
ÊÊ 
int
ÊÊ "
>
ÊÊ" #
Length
ÊÊ$ *
;
ÊÊ* +
public
ËË 
void
ËË 
Execute
ËË 
(
ËË  
)
ËË  !
{
ÈÈ 
	Container
ÍÍ 
.
ÍÍ 
AllocateForEach
ÍÍ )
(
ÍÍ) *
Length
ÍÍ* 0
[
ÍÍ0 1
$num
ÍÍ1 2
]
ÍÍ2 3
)
ÍÍ3 4
;
ÍÍ4 5
}
ÎÎ 
}
ÏÏ 	
[
ÛÛ 	
BurstCompatible
ÛÛ	 
]
ÛÛ 
public
ÙÙ 
unsafe
ÙÙ 
struct
ÙÙ 
Writer
ÙÙ #
{
ıı 	
[
ˆˆ /
!NativeDisableUnsafePtrRestriction
ˆˆ .
]
ˆˆ. /
internal
˜˜ #
UnsafeStreamBlockData
˜˜ *
*
˜˜* +
m_BlockStream
˜˜, 9
;
˜˜9 :
[
˘˘ /
!NativeDisableUnsafePtrRestriction
˘˘ .
]
˘˘. /
UnsafeStreamBlock
˙˙ 
*
˙˙ 
m_CurrentBlock
˙˙ -
;
˙˙- .
[
¸¸ /
!NativeDisableUnsafePtrRestriction
¸¸ .
]
¸¸. /
byte
˝˝ 
*
˝˝ 
m_CurrentPtr
˝˝ 
;
˝˝ 
[
ˇˇ /
!NativeDisableUnsafePtrRestriction
ˇˇ .
]
ˇˇ. /
byte
ÄÄ 
*
ÄÄ 
m_CurrentBlockEnd
ÄÄ #
;
ÄÄ# $
internal
ÇÇ 
int
ÇÇ 
m_ForeachIndex
ÇÇ '
;
ÇÇ' (
int
ÉÉ 
m_ElementCount
ÉÉ 
;
ÉÉ 
[
ÖÖ /
!NativeDisableUnsafePtrRestriction
ÖÖ .
]
ÖÖ. /
UnsafeStreamBlock
ÜÜ 
*
ÜÜ 
m_FirstBlock
ÜÜ +
;
ÜÜ+ ,
int
àà 
m_FirstOffset
àà 
;
àà 
int
ââ 
m_NumberOfBlocks
ââ  
;
ââ  !
[
ãã "
NativeSetThreadIndex
ãã !
]
ãã! "
int
åå 
m_ThreadIndex
åå 
;
åå 
internal
éé 
Writer
éé 
(
éé 
ref
éé 
UnsafeStream
éé  ,
stream
éé- 3
)
éé3 4
{
èè 
m_BlockStream
êê 
=
êê 
stream
êê  &
.
êê& '
m_Block
êê' .
;
êê. /
m_ForeachIndex
ëë 
=
ëë  
int
ëë! $
.
ëë$ %
MinValue
ëë% -
;
ëë- .
m_ElementCount
íí 
=
íí  
-
íí! "
$num
íí" #
;
íí# $
m_CurrentBlock
ìì 
=
ìì  
null
ìì! %
;
ìì% &
m_CurrentBlockEnd
îî !
=
îî" #
null
îî$ (
;
îî( )
m_CurrentPtr
ïï 
=
ïï 
null
ïï #
;
ïï# $
m_FirstBlock
ññ 
=
ññ 
null
ññ #
;
ññ# $
m_NumberOfBlocks
óó  
=
óó! "
$num
óó# $
;
óó$ %
m_FirstOffset
òò 
=
òò 
$num
òò  !
;
òò! "
m_ThreadIndex
ôô 
=
ôô 
$num
ôô  !
;
ôô! "
}
öö 
public
†† 
int
†† 
ForEachCount
†† #
=>
††$ &
m_BlockStream
††' 4
->
††4 6

RangeCount
††6 @
;
††@ A
public
©© 
void
©© 
BeginForEachIndex
©© )
(
©©) *
int
©©* -
foreachIndex
©©. :
)
©©: ;
{
™™ 
m_ForeachIndex
´´ 
=
´´  
foreachIndex
´´! -
;
´´- .
m_ElementCount
¨¨ 
=
¨¨  
$num
¨¨! "
;
¨¨" #
m_NumberOfBlocks
≠≠  
=
≠≠! "
$num
≠≠# $
;
≠≠$ %
m_FirstBlock
ÆÆ 
=
ÆÆ 
m_CurrentBlock
ÆÆ -
;
ÆÆ- .
m_FirstOffset
ØØ 
=
ØØ 
(
ØØ  !
int
ØØ! $
)
ØØ$ %
(
ØØ% &
m_CurrentPtr
ØØ& 2
-
ØØ3 4
(
ØØ5 6
byte
ØØ6 :
*
ØØ: ;
)
ØØ; <
m_CurrentBlock
ØØ< J
)
ØØJ K
;
ØØK L
}
∞∞ 
public
∂∂ 
void
∂∂ 
EndForEachIndex
∂∂ '
(
∂∂' (
)
∂∂( )
{
∑∑ 
m_BlockStream
∏∏ 
->
∏∏ 
Ranges
∏∏ %
[
∏∏% &
m_ForeachIndex
∏∏& 4
]
∏∏4 5
.
∏∏5 6
ElementCount
∏∏6 B
=
∏∏C D
m_ElementCount
∏∏E S
;
∏∏S T
m_BlockStream
ππ 
->
ππ 
Ranges
ππ %
[
ππ% &
m_ForeachIndex
ππ& 4
]
ππ4 5
.
ππ5 6 
OffsetInFirstBlock
ππ6 H
=
ππI J
m_FirstOffset
ππK X
;
ππX Y
m_BlockStream
∫∫ 
->
∫∫ 
Ranges
∫∫ %
[
∫∫% &
m_ForeachIndex
∫∫& 4
]
∫∫4 5
.
∫∫5 6
Block
∫∫6 ;
=
∫∫< =
m_FirstBlock
∫∫> J
;
∫∫J K
m_BlockStream
ºº 
->
ºº 
Ranges
ºº %
[
ºº% &
m_ForeachIndex
ºº& 4
]
ºº4 5
.
ºº5 6

LastOffset
ºº6 @
=
ººA B
(
ººC D
int
ººD G
)
ººG H
(
ººH I
m_CurrentPtr
ººI U
-
ººV W
(
ººX Y
byte
ººY ]
*
ºº] ^
)
ºº^ _
m_CurrentBlock
ºº_ m
)
ººm n
;
ººn o
m_BlockStream
ΩΩ 
->
ΩΩ 
Ranges
ΩΩ %
[
ΩΩ% &
m_ForeachIndex
ΩΩ& 4
]
ΩΩ4 5
.
ΩΩ5 6
NumberOfBlocks
ΩΩ6 D
=
ΩΩE F
m_NumberOfBlocks
ΩΩG W
;
ΩΩW X
}
ææ 
[
«« 
BurstCompatible
«« 
(
«« "
GenericTypeArguments
«« 1
=
««2 3
new
««4 7
[
««7 8
]
««8 9
{
««: ;
typeof
««< B
(
««B C
int
««C F
)
««F G
}
««H I
)
««I J
]
««J K
public
»» 
void
»» 
Write
»» 
<
»» 
T
»» 
>
»»  
(
»»  !
T
»»! "
value
»»# (
)
»»( )
where
»»* /
T
»»0 1
:
»»2 3
struct
»»4 :
{
…… 
ref
   
T
   
dst
   
=
   
ref
   
Allocate
    (
<
  ( )
T
  ) *
>
  * +
(
  + ,
)
  , -
;
  - .
dst
ÀÀ 
=
ÀÀ 
value
ÀÀ 
;
ÀÀ 
}
ÃÃ 
[
’’ 
BurstCompatible
’’ 
(
’’ "
GenericTypeArguments
’’ 1
=
’’2 3
new
’’4 7
[
’’7 8
]
’’8 9
{
’’: ;
typeof
’’< B
(
’’B C
int
’’C F
)
’’F G
}
’’H I
)
’’I J
]
’’J K
public
÷÷ 
ref
÷÷ 
T
÷÷ 
Allocate
÷÷ !
<
÷÷! "
T
÷÷" #
>
÷÷# $
(
÷÷$ %
)
÷÷% &
where
÷÷' ,
T
÷÷- .
:
÷÷/ 0
struct
÷÷1 7
{
◊◊ 
int
ÿÿ 
size
ÿÿ 
=
ÿÿ 
UnsafeUtility
ÿÿ (
.
ÿÿ( )
SizeOf
ÿÿ) /
<
ÿÿ/ 0
T
ÿÿ0 1
>
ÿÿ1 2
(
ÿÿ2 3
)
ÿÿ3 4
;
ÿÿ4 5
return
ŸŸ 
ref
ŸŸ 
UnsafeUtility
ŸŸ (
.
ŸŸ( )
AsRef
ŸŸ) .
<
ŸŸ. /
T
ŸŸ/ 0
>
ŸŸ0 1
(
ŸŸ1 2
Allocate
ŸŸ2 :
(
ŸŸ: ;
size
ŸŸ; ?
)
ŸŸ? @
)
ŸŸ@ A
;
ŸŸA B
}
⁄⁄ 
public
„„ 
byte
„„ 
*
„„ 
Allocate
„„ !
(
„„! "
int
„„" %
size
„„& *
)
„„* +
{
‰‰ 
byte
ÂÂ 
*
ÂÂ 
ptr
ÂÂ 
=
ÂÂ 
m_CurrentPtr
ÂÂ (
;
ÂÂ( )
m_CurrentPtr
ÊÊ 
+=
ÊÊ 
size
ÊÊ  $
;
ÊÊ$ %
if
ËË 
(
ËË 
m_CurrentPtr
ËË  
>
ËË! "
m_CurrentBlockEnd
ËË# 4
)
ËË4 5
{
ÈÈ 
UnsafeStreamBlock
ÍÍ %
*
ÍÍ% &
oldBlock
ÍÍ' /
=
ÍÍ0 1
m_CurrentBlock
ÍÍ2 @
;
ÍÍ@ A
m_CurrentBlock
ÏÏ "
=
ÏÏ# $
m_BlockStream
ÏÏ% 2
->
ÏÏ2 4
Allocate
ÏÏ4 <
(
ÏÏ< =
oldBlock
ÏÏ= E
,
ÏÏE F
m_ThreadIndex
ÏÏG T
)
ÏÏT U
;
ÏÏU V
m_CurrentPtr
ÌÌ  
=
ÌÌ! "
m_CurrentBlock
ÌÌ# 1
->
ÌÌ1 3
Data
ÌÌ3 7
;
ÌÌ7 8
if
ÔÔ 
(
ÔÔ 
m_FirstBlock
ÔÔ $
==
ÔÔ% '
null
ÔÔ( ,
)
ÔÔ, -
{
 
m_FirstOffset
ÒÒ %
=
ÒÒ& '
(
ÒÒ( )
int
ÒÒ) ,
)
ÒÒ, -
(
ÒÒ- .
m_CurrentPtr
ÒÒ. :
-
ÒÒ; <
(
ÒÒ= >
byte
ÒÒ> B
*
ÒÒB C
)
ÒÒC D
m_CurrentBlock
ÒÒD R
)
ÒÒR S
;
ÒÒS T
m_FirstBlock
ÚÚ $
=
ÚÚ% &
m_CurrentBlock
ÚÚ' 5
;
ÚÚ5 6
}
ÛÛ 
else
ÙÙ 
{
ıı 
m_NumberOfBlocks
ˆˆ (
++
ˆˆ( *
;
ˆˆ* +
}
˜˜ 
m_CurrentBlockEnd
˘˘ %
=
˘˘& '
(
˘˘( )
byte
˘˘) -
*
˘˘- .
)
˘˘. /
m_CurrentBlock
˘˘/ =
+
˘˘> ?#
UnsafeStreamBlockData
˘˘@ U
.
˘˘U V
AllocationSize
˘˘V d
;
˘˘d e
ptr
˙˙ 
=
˙˙ 
m_CurrentPtr
˙˙ &
;
˙˙& '
m_CurrentPtr
˚˚  
+=
˚˚! #
size
˚˚$ (
;
˚˚( )
}
¸¸ 
m_ElementCount
˛˛ 
++
˛˛  
;
˛˛  !
return
ÄÄ 
ptr
ÄÄ 
;
ÄÄ 
}
ÅÅ 
}
ÇÇ 	
[
ââ 	
BurstCompatible
ââ	 
]
ââ 
public
ää 
unsafe
ää 
struct
ää 
Reader
ää #
{
ãã 	
[
åå /
!NativeDisableUnsafePtrRestriction
åå .
]
åå. /
internal
çç #
UnsafeStreamBlockData
çç *
*
çç* +
m_BlockStream
çç, 9
;
çç9 :
[
èè /
!NativeDisableUnsafePtrRestriction
èè .
]
èè. /
internal
êê 
UnsafeStreamBlock
êê &
*
êê& '
m_CurrentBlock
êê( 6
;
êê6 7
[
íí /
!NativeDisableUnsafePtrRestriction
íí .
]
íí. /
internal
ìì 
byte
ìì 
*
ìì 
m_CurrentPtr
ìì '
;
ìì' (
[
ïï /
!NativeDisableUnsafePtrRestriction
ïï .
]
ïï. /
internal
ññ 
byte
ññ 
*
ññ 
m_CurrentBlockEnd
ññ ,
;
ññ, -
internal
òò 
int
òò "
m_RemainingItemCount
òò -
;
òò- .
internal
ôô 
int
ôô 
m_LastBlockSize
ôô (
;
ôô( )
internal
õõ 
Reader
õõ 
(
õõ 
ref
õõ 
UnsafeStream
õõ  ,
stream
õõ- 3
)
õõ3 4
{
úú 
m_BlockStream
ùù 
=
ùù 
stream
ùù  &
.
ùù& '
m_Block
ùù' .
;
ùù. /
m_CurrentBlock
ûû 
=
ûû  
null
ûû! %
;
ûû% &
m_CurrentPtr
üü 
=
üü 
null
üü #
;
üü# $
m_CurrentBlockEnd
†† !
=
††" #
null
††$ (
;
††( )"
m_RemainingItemCount
°° $
=
°°% &
$num
°°' (
;
°°( )
m_LastBlockSize
¢¢ 
=
¢¢  !
$num
¢¢" #
;
¢¢# $
}
££ 
public
≠≠ 
int
≠≠ 
BeginForEachIndex
≠≠ (
(
≠≠( )
int
≠≠) ,
foreachIndex
≠≠- 9
)
≠≠9 :
{
ÆÆ "
m_RemainingItemCount
ØØ $
=
ØØ% &
m_BlockStream
ØØ' 4
->
ØØ4 6
Ranges
ØØ6 <
[
ØØ< =
foreachIndex
ØØ= I
]
ØØI J
.
ØØJ K
ElementCount
ØØK W
;
ØØW X
m_LastBlockSize
∞∞ 
=
∞∞  !
m_BlockStream
∞∞" /
->
∞∞/ 1
Ranges
∞∞1 7
[
∞∞7 8
foreachIndex
∞∞8 D
]
∞∞D E
.
∞∞E F

LastOffset
∞∞F P
;
∞∞P Q
m_CurrentBlock
≤≤ 
=
≤≤  
m_BlockStream
≤≤! .
->
≤≤. 0
Ranges
≤≤0 6
[
≤≤6 7
foreachIndex
≤≤7 C
]
≤≤C D
.
≤≤D E
Block
≤≤E J
;
≤≤J K
m_CurrentPtr
≥≥ 
=
≥≥ 
(
≥≥  
byte
≥≥  $
*
≥≥$ %
)
≥≥% &
m_CurrentBlock
≥≥& 4
+
≥≥5 6
m_BlockStream
≥≥7 D
->
≥≥D F
Ranges
≥≥F L
[
≥≥L M
foreachIndex
≥≥M Y
]
≥≥Y Z
.
≥≥Z [ 
OffsetInFirstBlock
≥≥[ m
;
≥≥m n
m_CurrentBlockEnd
¥¥ !
=
¥¥" #
(
¥¥$ %
byte
¥¥% )
*
¥¥) *
)
¥¥* +
m_CurrentBlock
¥¥+ 9
+
¥¥: ;#
UnsafeStreamBlockData
¥¥< Q
.
¥¥Q R
AllocationSize
¥¥R `
;
¥¥` a
return
∂∂ "
m_RemainingItemCount
∂∂ +
;
∂∂+ ,
}
∑∑ 
public
ΩΩ 
void
ΩΩ 
EndForEachIndex
ΩΩ '
(
ΩΩ' (
)
ΩΩ( )
{
ææ 
}
øø 
public
≈≈ 
int
≈≈ 
ForEachCount
≈≈ #
=>
≈≈$ &
m_BlockStream
≈≈' 4
->
≈≈4 6

RangeCount
≈≈6 @
;
≈≈@ A
public
ÀÀ 
int
ÀÀ  
RemainingItemCount
ÀÀ )
=>
ÀÀ* ,"
m_RemainingItemCount
ÀÀ- A
;
ÀÀA B
public
”” 
byte
”” 
*
”” 
ReadUnsafePtr
”” &
(
””& '
int
””' *
size
””+ /
)
””/ 0
{
‘‘ "
m_RemainingItemCount
’’ $
--
’’$ &
;
’’& '
byte
◊◊ 
*
◊◊ 
ptr
◊◊ 
=
◊◊ 
m_CurrentPtr
◊◊ (
;
◊◊( )
m_CurrentPtr
ÿÿ 
+=
ÿÿ 
size
ÿÿ  $
;
ÿÿ$ %
if
⁄⁄ 
(
⁄⁄ 
m_CurrentPtr
⁄⁄  
>
⁄⁄! "
m_CurrentBlockEnd
⁄⁄# 4
)
⁄⁄4 5
{
€€ 
m_CurrentBlock
‹‹ "
=
‹‹# $
m_CurrentBlock
‹‹% 3
->
‹‹3 5
Next
‹‹5 9
;
‹‹9 :
m_CurrentPtr
››  
=
››! "
m_CurrentBlock
››# 1
->
››1 3
Data
››3 7
;
››7 8
m_CurrentBlockEnd
ﬂﬂ %
=
ﬂﬂ& '
(
ﬂﬂ( )
byte
ﬂﬂ) -
*
ﬂﬂ- .
)
ﬂﬂ. /
m_CurrentBlock
ﬂﬂ/ =
+
ﬂﬂ> ?#
UnsafeStreamBlockData
ﬂﬂ@ U
.
ﬂﬂU V
AllocationSize
ﬂﬂV d
;
ﬂﬂd e
ptr
·· 
=
·· 
m_CurrentPtr
·· &
;
··& '
m_CurrentPtr
‚‚  
+=
‚‚! #
size
‚‚$ (
;
‚‚( )
}
„„ 
return
ÂÂ 
ptr
ÂÂ 
;
ÂÂ 
}
ÊÊ 
[
ÓÓ 
BurstCompatible
ÓÓ 
(
ÓÓ "
GenericTypeArguments
ÓÓ 1
=
ÓÓ2 3
new
ÓÓ4 7
[
ÓÓ7 8
]
ÓÓ8 9
{
ÓÓ: ;
typeof
ÓÓ< B
(
ÓÓB C
int
ÓÓC F
)
ÓÓF G
}
ÓÓH I
)
ÓÓI J
]
ÓÓJ K
public
ÔÔ 
ref
ÔÔ 
T
ÔÔ 
Read
ÔÔ 
<
ÔÔ 
T
ÔÔ 
>
ÔÔ  
(
ÔÔ  !
)
ÔÔ! "
where
ÔÔ# (
T
ÔÔ) *
:
ÔÔ+ ,
struct
ÔÔ- 3
{
 
int
ÒÒ 
size
ÒÒ 
=
ÒÒ 
UnsafeUtility
ÒÒ (
.
ÒÒ( )
SizeOf
ÒÒ) /
<
ÒÒ/ 0
T
ÒÒ0 1
>
ÒÒ1 2
(
ÒÒ2 3
)
ÒÒ3 4
;
ÒÒ4 5
return
ÚÚ 
ref
ÚÚ 
UnsafeUtility
ÚÚ (
.
ÚÚ( )
AsRef
ÚÚ) .
<
ÚÚ. /
T
ÚÚ/ 0
>
ÚÚ0 1
(
ÚÚ1 2
ReadUnsafePtr
ÚÚ2 ?
(
ÚÚ? @
size
ÚÚ@ D
)
ÚÚD E
)
ÚÚE F
;
ÚÚF G
}
ÛÛ 
[
˙˙ 
BurstCompatible
˙˙ 
(
˙˙ "
GenericTypeArguments
˙˙ 1
=
˙˙2 3
new
˙˙4 7
[
˙˙7 8
]
˙˙8 9
{
˙˙: ;
typeof
˙˙< B
(
˙˙B C
int
˙˙C F
)
˙˙F G
}
˙˙H I
)
˙˙I J
]
˙˙J K
public
˚˚ 
ref
˚˚ 
T
˚˚ 
Peek
˚˚ 
<
˚˚ 
T
˚˚ 
>
˚˚  
(
˚˚  !
)
˚˚! "
where
˚˚# (
T
˚˚) *
:
˚˚+ ,
struct
˚˚- 3
{
¸¸ 
int
˝˝ 
size
˝˝ 
=
˝˝ 
UnsafeUtility
˝˝ (
.
˝˝( )
SizeOf
˝˝) /
<
˝˝/ 0
T
˝˝0 1
>
˝˝1 2
(
˝˝2 3
)
˝˝3 4
;
˝˝4 5
byte
ˇˇ 
*
ˇˇ 
ptr
ˇˇ 
=
ˇˇ 
m_CurrentPtr
ˇˇ (
;
ˇˇ( )
if
ÄÄ 
(
ÄÄ 
ptr
ÄÄ 
+
ÄÄ 
size
ÄÄ 
>
ÄÄ  
m_CurrentBlockEnd
ÄÄ! 2
)
ÄÄ2 3
{
ÅÅ 
ptr
ÇÇ 
=
ÇÇ 
m_CurrentBlock
ÇÇ (
->
ÇÇ( *
Next
ÇÇ* .
->
ÇÇ. 0
Data
ÇÇ0 4
;
ÇÇ4 5
}
ÉÉ 
return
ÖÖ 
ref
ÖÖ 
UnsafeUtility
ÖÖ (
.
ÖÖ( )
AsRef
ÖÖ) .
<
ÖÖ. /
T
ÖÖ/ 0
>
ÖÖ0 1
(
ÖÖ1 2
ptr
ÖÖ2 5
)
ÖÖ5 6
;
ÖÖ6 7
}
ÜÜ 
public
åå 
int
åå 
Count
åå 
(
åå 
)
åå 
{
çç 
int
éé 
	itemCount
éé 
=
éé 
$num
éé  !
;
éé! "
for
èè 
(
èè 
int
èè 
i
èè 
=
èè 
$num
èè 
;
èè 
i
èè  !
!=
èè" $
m_BlockStream
èè% 2
->
èè2 4

RangeCount
èè4 >
;
èè> ?
i
èè@ A
++
èèA C
)
èèC D
{
êê 
	itemCount
ëë 
+=
ëë  
m_BlockStream
ëë! .
->
ëë. 0
Ranges
ëë0 6
[
ëë6 7
i
ëë7 8
]
ëë8 9
.
ëë9 :
ElementCount
ëë: F
;
ëëF G
}
íí 
return
îî 
	itemCount
îî  
;
îî  !
}
ïï 
}
ññ 	
}
óó 
}òò ÄA
fC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeUtilityEx.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{ 
[ 
BurstCompatible 
] 
public 

unsafe 
static 
class #
UnsafeUtilityExtensions 6
{ 
internal 
static 
void 
MemSwap $
($ %
void% )
*) *
ptr+ .
,. /
void0 4
*4 5
otherPtr6 >
,> ?
long@ D
sizeE I
)I J
{ 	
byte 
* 
dst 
= 
( 
byte 
* 
) 
ptr  #
;# $
byte 
* 
src 
= 
( 
byte 
* 
) 
otherPtr  (
;( )
CheckMemSwapOverlap 
(  
dst  #
,# $
src% (
,( )
size* .
). /
;/ 0
var 
tmp 
= 

stackalloc  
byte! %
[% &
$num& *
]* +
;+ ,
while 
( 
size 
> 
$num 
) 
{ 
var   
numBytes   
=   
math   #
.  # $
min  $ '
(  ' (
size  ( ,
,  , -
$num  . 2
)  2 3
;  3 4
UnsafeUtility!! 
.!! 
MemCpy!! $
(!!$ %
tmp!!% (
,!!( )
dst!!* -
,!!- .
numBytes!!/ 7
)!!7 8
;!!8 9
UnsafeUtility"" 
."" 
MemCpy"" $
(""$ %
dst""% (
,""( )
src""* -
,""- .
numBytes""/ 7
)""7 8
;""8 9
UnsafeUtility## 
.## 
MemCpy## $
(##$ %
src##% (
,##( )
tmp##* -
,##- .
numBytes##/ 7
)##7 8
;##8 9
size%% 
-=%% 
numBytes%%  
;%%  !
src&& 
+=&& 
numBytes&& 
;&&  
dst'' 
+='' 
numBytes'' 
;''  
}(( 
})) 	
[44 	
BurstCompatible44	 
(44  
GenericTypeArguments44 -
=44. /
new440 3
[444 5
]445 6
{447 8
typeof449 ?
(44? @
int44@ C
)44C D
}44E F
)44F G
]44G H
public55 
unsafe55 
static55 
T55 )
ReadArrayElementBoundsChecked55 <
<55< =
T55= >
>55> ?
(55? @
void55@ D
*55D E
source55F L
,55L M
int55N Q
index55R W
,55W X
int55Y \
capacity55] e
)55e f
{66 	
CheckIndexRange77 
(77 
index77 !
,77! "
capacity77# +
)77+ ,
;77, -
return99 
UnsafeUtility99  
.99  !
ReadArrayElement99! 1
<991 2
T992 3
>993 4
(994 5
source995 ;
,99; <
index99= B
)99B C
;99C D
}:: 	
[EE 	
BurstCompatibleEE	 
(EE  
GenericTypeArgumentsEE -
=EE. /
newEE0 3
[EE4 5
]EE5 6
{EE7 8
typeofEE9 ?
(EE? @
intEE@ C
)EEC D
}EEE F
)EEF G
]EEG H
publicFF 
unsafeFF 
staticFF 
voidFF !*
WriteArrayElementBoundsCheckedFF" @
<FF@ A
TFFA B
>FFB C
(FFC D
voidFFD H
*FFH I
destinationFFJ U
,FFU V
intFFW Z
indexFF[ `
,FF` a
TFFb c
valueFFd i
,FFi j
intFFk n
capacityFFo w
)FFw x
{GG 	
CheckIndexRangeHH 
(HH 
indexHH !
,HH! "
capacityHH# +
)HH+ ,
;HH, -
UnsafeUtilityJJ 
.JJ 
WriteArrayElementJJ +
<JJ+ ,
TJJ, -
>JJ- .
(JJ. /
destinationJJ/ :
,JJ: ;
indexJJ< A
,JJA B
valueJJC H
)JJH I
;JJI J
}KK 	
[SS 	

MethodImplSS	 
(SS 
MethodImplOptionsSS %
.SS% &
AggressiveInliningSS& 8
)SS8 9
]SS9 :
[TT 	
BurstCompatibleTT	 
(TT  
GenericTypeArgumentsTT -
=TT. /
newTT0 3
[TT4 5
]TT5 6
{TT7 8
typeofTT9 ?
(TT? @
intTT@ C
)TTC D
}TTE F
)TTF G
]TTG H
publicUU 
staticUU 
voidUU 
*UU 
	AddressOfUU %
<UU% &
TUU& '
>UU' (
(UU( )
inUU) +
TUU, -
valueUU. 3
)UU3 4
whereVV 
TVV 
:VV 
structVV 
{WW 	
returnXX 
	ILSupportXX 
.XX 
	AddressOfXX &
(XX& '
inXX' )
valueXX* /
)XX/ 0
;XX0 1
}YY 	
[cc 	

MethodImplcc	 
(cc 
MethodImplOptionscc %
.cc% &
AggressiveInliningcc& 8
)cc8 9
]cc9 :
[dd 	
BurstCompatibledd	 
(dd  
GenericTypeArgumentsdd -
=dd. /
newdd0 3
[dd4 5
]dd5 6
{dd7 8
typeofdd9 ?
(dd? @
intdd@ C
)ddC D
}ddE F
)ddF G
]ddG H
publicee 
staticee 
refee 
Tee 
AsRefee !
<ee! "
Tee" #
>ee# $
(ee$ %
inee% '
Tee( )
valueee* /
)ee/ 0
whereff 
Tff 
:ff 
structff 
{gg 	
returnhh 
refhh 
	ILSupporthh  
.hh  !
AsRefhh! &
(hh& '
inhh' )
valuehh* /
)hh/ 0
;hh0 1
}ii 	
[kk 	
Conditionalkk	 
(kk 
$strkk 6
)kk6 7
]kk7 8
staticll 
unsafell 
voidll 
CheckMemSwapOverlapll .
(ll. /
bytell/ 3
*ll3 4
dstll5 8
,ll8 9
bytell: >
*ll> ?
srcll@ C
,llC D
longllE I
sizellJ N
)llN O
{mm 	
ifnn 
(nn 
dstnn 
+nn 
sizenn 
>nn 
srcnn  
&&nn! #
srcnn$ '
+nn( )
sizenn* .
>nn/ 0
dstnn1 4
)nn4 5
{oo 
throwpp 
newpp %
InvalidOperationExceptionpp 3
(pp3 4
$strpp4 [
)pp[ \
;pp\ ]
}qq 
}rr 	
[tt 	
Conditionaltt	 
(tt 
$strtt 6
)tt6 7
]tt7 8
staticuu 
voiduu 
CheckIndexRangeuu #
(uu# $
intuu$ '
indexuu( -
,uu- .
intuu/ 2
capacityuu3 ;
)uu; <
{vv 	
ifww 
(ww 
(ww 
indexww 
>ww 
capacityww !
-ww" #
$numww$ %
)ww% &
||ww' )
(ww* +
indexww+ 0
<ww1 2
$numww3 4
)ww4 5
)ww5 6
{xx 
throwyy 
newyy $
IndexOutOfRangeExceptionyy 2
(yy2 3
$"zz 
$strzz @
{zz@ A
indexzzA F
}zzF G
$strzzG s
{zzs t
capacityzzt |
}zz| }
$strzz} 
"	zz Ä
+{{ 
$str{{ Z
)|| 
;|| 
}}} 
}~~ 	
} 
}ÄÄ ¥M
jC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeAtomicCounter.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{ 
[

 
BurstCompatible

 
]

 
public 

unsafe 
struct !
UnsafeAtomicCounter32 .
{ 
public 
int 
* 
Counter 
; 
public !
UnsafeAtomicCounter32 $
($ %
void% )
*) *
ptr+ .
). /
{ 	
Counter 
= 
( 
int 
* 
) 
ptr 
;  
} 	
public   
void   
Reset   
(   
int   
value   #
=  $ %
$num  & '
)  ' (
{!! 	
*"" 
Counter"" 
="" 
value"" 
;"" 
}## 	
public** 
int** 
Add** 
(** 
int** 
value**  
)**  !
{++ 	
return,, 
Interlocked,, 
.,, 
Add,, "
(,," #
ref,,# &
UnsafeUtility,,' 4
.,,4 5
AsRef,,5 :
<,,: ;
int,,; >
>,,> ?
(,,? @
Counter,,@ G
),,G H
,,,H I
value,,J O
),,O P
-,,Q R
value,,S X
;,,X Y
}-- 	
public44 
int44 
Sub44 
(44 
int44 
value44  
)44  !
=>44" $
Add44% (
(44( )
-44) *
value44* /
)44/ 0
;440 1
public<< 
int<< 
AddSat<< 
(<< 
int<< 
value<< #
,<<# $
int<<% (
max<<) ,
=<<- .
int<</ 2
.<<2 3
MaxValue<<3 ;
)<<; <
{== 	
int>> 
oldVal>> 
;>> 
int?? 
newVal?? 
=?? 
*?? 
Counter?? !
;??! "
do@@ 
{AA 
oldValBB 
=BB 
newValBB 
;BB  
newValCC 
=CC 
newValCC 
>=CC  "
maxCC# &
?CC' (
maxCC) ,
:CC- .
mathCC/ 3
.CC3 4
minCC4 7
(CC7 8
maxCC8 ;
,CC; <
newValCC= C
+CCD E
valueCCF K
)CCK L
;CCL M
newValDD 
=DD 
InterlockedDD $
.DD$ %
CompareExchangeDD% 4
(DD4 5
refDD5 8
UnsafeUtilityDD9 F
.DDF G
AsRefDDG L
<DDL M
intDDM P
>DDP Q
(DDQ R
CounterDDR Y
)DDY Z
,DDZ [
newValDD\ b
,DDb c
oldValDDd j
)DDj k
;DDk l
}EE 
whileFF 
(FF 
oldValFF 
!=FF 
newValFF #
&&FF$ &
oldValFF' -
!=FF. 0
maxFF1 4
)FF4 5
;FF5 6
returnHH 
oldValHH 
;HH 
}II 	
publicQQ 
intQQ 
SubSatQQ 
(QQ 
intQQ 
valueQQ #
,QQ# $
intQQ% (
minQQ) ,
=QQ- .
intQQ/ 2
.QQ2 3
MinValueQQ3 ;
)QQ; <
{RR 	
intSS 
oldValSS 
;SS 
intTT 
newValTT 
=TT 
*TT 
CounterTT !
;TT! "
doUU 
{VV 
oldValWW 
=WW 
newValWW 
;WW  
newValXX 
=XX 
newValXX 
<=XX  "
minXX# &
?XX' (
minXX) ,
:XX- .
mathXX/ 3
.XX3 4
maxXX4 7
(XX7 8
minXX8 ;
,XX; <
newValXX= C
-XXD E
valueXXF K
)XXK L
;XXL M
newValYY 
=YY 
InterlockedYY $
.YY$ %
CompareExchangeYY% 4
(YY4 5
refYY5 8
UnsafeUtilityYY9 F
.YYF G
AsRefYYG L
<YYL M
intYYM P
>YYP Q
(YYQ R
CounterYYR Y
)YYY Z
,YYZ [
newValYY\ b
,YYb c
oldValYYd j
)YYj k
;YYk l
}ZZ 
while[[ 
([[ 
oldVal[[ 
!=[[ 
newVal[[ #
&&[[$ &
oldVal[[' -
!=[[. 0
min[[1 4
)[[4 5
;[[5 6
return]] 
oldVal]] 
;]] 
}^^ 	
}__ 
[ee 
BurstCompatibleee 
]ee 
publicff 

unsafeff 
structff !
UnsafeAtomicCounter64ff .
{gg 
publicll 
longll 
*ll 
Counterll 
;ll 
publicrr !
UnsafeAtomicCounter64rr $
(rr$ %
voidrr% )
*rr) *
ptrrr+ .
)rr. /
{ss 	
Countertt 
=tt 
(tt 
longtt 
*tt 
)tt 
ptrtt  
;tt  !
}uu 	
public{{ 
void{{ 
Reset{{ 
({{ 
long{{ 
value{{ $
={{% &
$num{{' (
){{( )
{|| 	
*}} 
Counter}} 
=}} 
value}} 
;}} 
}~~ 	
public
ÖÖ 
long
ÖÖ 
Add
ÖÖ 
(
ÖÖ 
long
ÖÖ 
value
ÖÖ "
)
ÖÖ" #
{
ÜÜ 	
return
áá 
Interlocked
áá 
.
áá 
Add
áá "
(
áá" #
ref
áá# &
UnsafeUtility
áá' 4
.
áá4 5
AsRef
áá5 :
<
áá: ;
long
áá; ?
>
áá? @
(
áá@ A
Counter
ááA H
)
ááH I
,
ááI J
value
ááK P
)
ááP Q
-
ááR S
value
ááT Y
;
ááY Z
}
àà 	
public
èè 
long
èè 
Sub
èè 
(
èè 
long
èè 
value
èè "
)
èè" #
=>
èè$ &
Add
èè' *
(
èè* +
-
èè+ ,
value
èè, 1
)
èè1 2
;
èè2 3
public
óó 
long
óó 
AddSat
óó 
(
óó 
long
óó 
value
óó  %
,
óó% &
long
óó' +
max
óó, /
=
óó0 1
long
óó2 6
.
óó6 7
MaxValue
óó7 ?
)
óó? @
{
òò 	
long
ôô 
oldVal
ôô 
;
ôô 
long
öö 
newVal
öö 
=
öö 
*
öö 
Counter
öö "
;
öö" #
do
õõ 
{
úú 
oldVal
ùù 
=
ùù 
newVal
ùù 
;
ùù  
newVal
ûû 
=
ûû 
newVal
ûû 
>=
ûû  "
max
ûû# &
?
ûû' (
max
ûû) ,
:
ûû- .
math
ûû/ 3
.
ûû3 4
min
ûû4 7
(
ûû7 8
max
ûû8 ;
,
ûû; <
newVal
ûû= C
+
ûûD E
value
ûûF K
)
ûûK L
;
ûûL M
newVal
üü 
=
üü 
Interlocked
üü $
.
üü$ %
CompareExchange
üü% 4
(
üü4 5
ref
üü5 8
UnsafeUtility
üü9 F
.
üüF G
AsRef
üüG L
<
üüL M
long
üüM Q
>
üüQ R
(
üüR S
Counter
üüS Z
)
üüZ [
,
üü[ \
newVal
üü] c
,
üüc d
oldVal
üüe k
)
üük l
;
üül m
}
†† 
while
°° 
(
°° 
oldVal
°° 
!=
°° 
newVal
°° #
&&
°°$ &
oldVal
°°' -
!=
°°. 0
max
°°1 4
)
°°4 5
;
°°5 6
return
££ 
oldVal
££ 
;
££ 
}
§§ 	
public
¨¨ 
long
¨¨ 
SubSat
¨¨ 
(
¨¨ 
long
¨¨ 
value
¨¨  %
,
¨¨% &
long
¨¨' +
min
¨¨, /
=
¨¨0 1
long
¨¨2 6
.
¨¨6 7
MinValue
¨¨7 ?
)
¨¨? @
{
≠≠ 	
long
ÆÆ 
oldVal
ÆÆ 
;
ÆÆ 
long
ØØ 
newVal
ØØ 
=
ØØ 
*
ØØ 
Counter
ØØ "
;
ØØ" #
do
∞∞ 
{
±± 
oldVal
≤≤ 
=
≤≤ 
newVal
≤≤ 
;
≤≤  
newVal
≥≥ 
=
≥≥ 
newVal
≥≥ 
<=
≥≥  "
min
≥≥# &
?
≥≥' (
min
≥≥) ,
:
≥≥- .
math
≥≥/ 3
.
≥≥3 4
max
≥≥4 7
(
≥≥7 8
min
≥≥8 ;
,
≥≥; <
newVal
≥≥= C
-
≥≥D E
value
≥≥F K
)
≥≥K L
;
≥≥L M
newVal
¥¥ 
=
¥¥ 
Interlocked
¥¥ $
.
¥¥$ %
CompareExchange
¥¥% 4
(
¥¥4 5
ref
¥¥5 8
UnsafeUtility
¥¥9 F
.
¥¥F G
AsRef
¥¥G L
<
¥¥L M
long
¥¥M Q
>
¥¥Q R
(
¥¥R S
Counter
¥¥S Z
)
¥¥Z [
,
¥¥[ \
newVal
¥¥] c
,
¥¥c d
oldVal
¥¥e k
)
¥¥k l
;
¥¥l m
}
µµ 
while
∂∂ 
(
∂∂ 
oldVal
∂∂ 
!=
∂∂ 
newVal
∂∂ #
&&
∂∂$ &
oldVal
∂∂' -
!=
∂∂. 0
min
∂∂1 4
)
∂∂4 5
;
∂∂5 6
return
∏∏ 
oldVal
∏∏ 
;
∏∏ 
}
ππ 	
}
∫∫ 
}ªª öœ
gC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\AllocatorManager.cs
	namespace 	
Unity
 
. 
Collections 
{ 
public 

static 
class 
AllocatorManager (
{ 
internal 
static 
Block 
AllocateBlock +
<+ ,
T, -
>- .
(. /
ref/ 2
this3 7
T8 9
t: ;
,; <
int= @
sizeOfA G
,G H
intI L
alignOfM T
,T U
intV Y
itemsZ _
)_ `
wherea f
Tg h
:i j
	unmanagedk t
,t u

IAllocator	v Ä
{ 	

CheckValid 
( 
t 
. 
Handle 
)  
;  !
Block 
block 
= 
default !
;! "
block 
. 
Range 
. 
Pointer 
=  !
IntPtr" (
.( )
Zero) -
;- .
block 
. 
Range 
. 
Items 
= 
items  %
;% &
block 
. 
Range 
. 
	Allocator !
=" #
t$ %
.% &
Handle& ,
;, -
block 
. 
BytesPerItem 
=  
sizeOf! '
;' (
block   
.   
	Alignment   
=   
math   "
.  " #
max  # &
(  & '
JobsUtility  ' 2
.  2 3
CacheLineSize  3 @
,  @ A
alignOf  B I
)  I J
;  J K
var"" 
error"" 
="" 
t"" 
."" 
Try"" 
("" 
ref"" !
block""" '
)""' (
;""( )!
CheckFailedToAllocate## !
(##! "
error##" '
)##' (
;##( )
return$$ 
block$$ 
;$$ 
}%% 	
internal'' 
static'' 
Block'' 
AllocateBlock'' +
<''+ ,
T'', -
,''- .
U''. /
>''/ 0
(''0 1
ref''1 4
this''5 9
T'': ;
t''< =
,''= >
U''? @
u''A B
,''B C
int''D G
items''H M
)''M N
where''O T
T''U V
:''W X
	unmanaged''Y b
,''b c

IAllocator''d n
where''o t
U''u v
:''w x
	unmanaged	''y Ç
{(( 	
return)) 
AllocateBlock))  
())  !
ref))! $
t))% &
,))& '
UnsafeUtility))( 5
.))5 6
SizeOf))6 <
<))< =
U))= >
>))> ?
())? @
)))@ A
,))A B
UnsafeUtility))C P
.))P Q
AlignOf))Q X
<))X Y
U))Y Z
>))Z [
())[ \
)))\ ]
,))] ^
items))_ d
)))d e
;))e f
}** 	
internal,, 
static,, 
unsafe,, 
void,, #
*,,# $
Allocate,,% -
<,,- .
T,,. /
>,,/ 0
(,,0 1
ref,,1 4
this,,5 9
T,,: ;
t,,< =
,,,= >
int,,? B
sizeOf,,C I
,,,I J
int,,K N
alignOf,,O V
,,,V W
int,,X [
items,,\ a
),,a b
where,,c h
T,,i j
:,,k l
	unmanaged,,m v
,,,v w

IAllocator	,,x Ç
{-- 	
return.. 
(.. 
void.. 
*.. 
).. 
AllocateBlock.. '
(..' (
ref..( +
t.., -
,..- .
sizeOf../ 5
,..5 6
alignOf..7 >
,..> ?
items..@ E
)..E F
...F G
Range..G L
...L M
Pointer..M T
;..T U
}// 	
internal11 
static11 
unsafe11 
U11  
*11  !
Allocate11" *
<11* +
T11+ ,
,11, -
U11- .
>11. /
(11/ 0
ref110 3
this114 8
T119 :
t11; <
,11< =
U11> ?
u11@ A
,11A B
int11C F
items11G L
)11L M
where11N S
T11T U
:11V W
	unmanaged11X a
,11a b

IAllocator11c m
where11n s
U11t u
:11v w
	unmanaged	11x Å
{22 	
return33 
(33 
U33 
*33 
)33 
Allocate33 
(33  
ref33  #
t33$ %
,33% &
UnsafeUtility33' 4
.334 5
SizeOf335 ;
<33; <
U33< =
>33= >
(33> ?
)33? @
,33@ A
UnsafeUtility33B O
.33O P
AlignOf33P W
<33W X
U33X Y
>33Y Z
(33Z [
)33[ \
,33\ ]
items33^ c
)33c d
;33d e
}44 	
internal66 
static66 
unsafe66 
void66 #
*66# $
AllocateStruct66% 3
<663 4
T664 5
,665 6
U667 8
>668 9
(669 :
ref66: =
this66> B
T66C D
t66E F
,66F G
U66H I
u66J K
,66K L
int66M P
items66Q V
)66V W
where66X ]
T66^ _
:66` a
	unmanaged66b k
,66k l

IAllocator66m w
where66x }
U66~ 
:
66Ä Å
struct
66Ç à
{77 	
return88 
(88 
void88 
*88 
)88 
Allocate88 "
(88" #
ref88# &
t88' (
,88( )
UnsafeUtility88* 7
.887 8
SizeOf888 >
<88> ?
U88? @
>88@ A
(88A B
)88B C
,88C D
UnsafeUtility88E R
.88R S
AlignOf88S Z
<88Z [
U88[ \
>88\ ]
(88] ^
)88^ _
,88_ `
items88a f
)88f g
;88g h
}99 	
internal;; 
static;; 
unsafe;; 
void;; #
	FreeBlock;;$ -
<;;- .
T;;. /
>;;/ 0
(;;0 1
ref;;1 4
this;;5 9
T;;: ;
t;;< =
,;;= >
ref;;? B
Block;;C H
block;;I N
);;N O
where;;P U
T;;V W
:;;X Y
	unmanaged;;Z c
,;;c d

IAllocator;;e o
{<< 	

CheckValid== 
(== 
t== 
.== 
Handle== 
)==  
;==  !
block>> 
.>> 
Range>> 
.>> 
Items>> 
=>> 
$num>>  !
;>>! "
var?? 
error?? 
=?? 
t?? 
.?? 
Try?? 
(?? 
ref?? !
block??" '
)??' (
;??( )
CheckFailedToFree@@ 
(@@ 
error@@ #
)@@# $
;@@$ %
}AA 	
internalCC 
staticCC 
unsafeCC 
voidCC #
FreeCC$ (
<CC( )
TCC) *
>CC* +
(CC+ ,
refCC, /
thisCC0 4
TCC5 6
tCC7 8
,CC8 9
voidCC: >
*CC> ?
pointerCC@ G
,CCG H
intCCI L
sizeOfCCM S
,CCS T
intCCU X
alignOfCCY `
,CC` a
intCCb e
itemsCCf k
)CCk l
whereCCm r
TCCs t
:CCu v
	unmanaged	CCw Ä
,
CCÄ Å

IAllocator
CCÇ å
{DD 	
ifEE 
(EE 
pointerEE 
==EE 
nullEE 
)EE  
returnFF 
;FF 
BlockGG 
blockGG 
=GG 
defaultGG !
;GG! "
blockHH 
.HH 
AllocatedItemsHH  
=HH! "
itemsHH# (
;HH( )
blockII 
.II 
RangeII 
.II 
PointerII 
=II  !
(II" #
IntPtrII# )
)II) *
pointerII* 1
;II1 2
blockJJ 
.JJ 
BytesPerItemJJ 
=JJ  
sizeOfJJ! '
;JJ' (
blockKK 
.KK 
	AlignmentKK 
=KK 
alignOfKK %
;KK% &
tLL 
.LL 
	FreeBlockLL 
(LL 
refLL 
blockLL !
)LL! "
;LL" #
}MM 	
internalOO 
staticOO 
unsafeOO 
voidOO #
FreeOO$ (
<OO( )
TOO) *
,OO* +
UOO+ ,
>OO, -
(OO- .
refOO. 1
thisOO2 6
TOO7 8
tOO9 :
,OO: ;
UOO< =
*OO= >
pointerOO? F
,OOF G
intOOH K
itemsOOL Q
)OOQ R
whereOOS X
TOOY Z
:OO[ \
	unmanagedOO] f
,OOf g

IAllocatorOOh r
whereOOs x
UOOy z
:OO{ |
	unmanaged	OO} Ü
{PP 	
FreeQQ 
(QQ 
refQQ 
tQQ 
,QQ 
pointerQQ 
,QQ  
UnsafeUtilityQQ! .
.QQ. /
SizeOfQQ/ 5
<QQ5 6
UQQ6 7
>QQ7 8
(QQ8 9
)QQ9 :
,QQ: ;
UnsafeUtilityQQ< I
.QQI J
AlignOfQQJ Q
<QQQ R
UQQR S
>QQS T
(QQT U
)QQU V
,QQV W
itemsQQX ]
)QQ] ^
;QQ^ _
}RR 	
public\\ 
unsafe\\ 
static\\ 
void\\ !
*\\! "
Allocate\\# +
(\\+ ,
AllocatorHandle\\, ;
handle\\< B
,\\B C
int\\D G
itemSizeInBytes\\H W
,\\W X
int\\Y \
alignmentInBytes\\] m
,\\m n
int\\o r
items\\s x
=\\y z
$num\\{ |
)\\| }
{]] 	
return^^ 
handle^^ 
.^^ 
Allocate^^ "
(^^" #
itemSizeInBytes^^# 2
,^^2 3
alignmentInBytes^^4 D
,^^D E
items^^F K
)^^K L
;^^L M
}__ 	
publichh 
unsafehh 
statichh 
Thh 
*hh 
Allocatehh  (
<hh( )
Thh) *
>hh* +
(hh+ ,
AllocatorHandlehh, ;
handlehh< B
,hhB C
inthhD G
itemshhH M
=hhN O
$numhhP Q
)hhQ R
wherehhS X
ThhY Z
:hh[ \
	unmanagedhh] f
{ii 	
returnjj 
handlejj 
.jj 
Allocatejj "
(jj" #
defaultjj# *
(jj* +
Tjj+ ,
)jj, -
,jj- .
itemsjj/ 4
)jj4 5
;jj5 6
}kk 	
publicww 
unsafeww 
staticww 
voidww !
Freeww" &
(ww& '
AllocatorHandleww' 6
handleww7 =
,ww= >
voidww? C
*wwC D
pointerwwE L
,wwL M
intwwN Q
itemSizeInByteswwR a
,wwa b
intwwc f
alignmentInByteswwg w
,www x
intwwy |
items	ww} Ç
=
wwÉ Ñ
$num
wwÖ Ü
)
wwÜ á
{xx 	
handleyy 
.yy 
Freeyy 
(yy 
pointeryy 
,yy  
itemSizeInBytesyy! 0
,yy0 1
alignmentInBytesyy2 B
,yyB C
itemsyyD I
)yyI J
;yyJ K
}zz 	
public
ÅÅ 
unsafe
ÅÅ 
static
ÅÅ 
void
ÅÅ !
Free
ÅÅ" &
(
ÅÅ& '
AllocatorHandle
ÅÅ' 6
handle
ÅÅ7 =
,
ÅÅ= >
void
ÅÅ? C
*
ÅÅC D
pointer
ÅÅE L
)
ÅÅL M
{
ÇÇ 	
handle
ÉÉ 
.
ÉÉ 
Free
ÉÉ 
(
ÉÉ 
(
ÉÉ 
byte
ÉÉ 
*
ÉÉ 
)
ÉÉ 
pointer
ÉÉ &
,
ÉÉ& '
$num
ÉÉ( )
)
ÉÉ) *
;
ÉÉ* +
}
ÑÑ 	
public
èè 
unsafe
èè 
static
èè 
void
èè !
Free
èè" &
<
èè& '
T
èè' (
>
èè( )
(
èè) *
AllocatorHandle
èè* 9
handle
èè: @
,
èè@ A
T
èèB C
*
èèC D
pointer
èèE L
,
èèL M
int
èèN Q
items
èèR W
=
èèX Y
$num
èèZ [
)
èè[ \
where
èè] b
T
èèc d
:
èèe f
	unmanaged
èèg p
{
êê 	
handle
ëë 
.
ëë 
Free
ëë 
(
ëë 
pointer
ëë 
,
ëë  
items
ëë! &
)
ëë& '
;
ëë' (
}
íí 	
public
òò 
static
òò 
readonly
òò 
AllocatorHandle
òò .
Invalid
òò/ 6
=
òò7 8
new
òò9 <
AllocatorHandle
òò= L
{
òòM N
Index
òòO T
=
òòU V
$num
òòW X
}
òòY Z
;
òòZ [
public
ûû 
static
ûû 
readonly
ûû 
AllocatorHandle
ûû .
None
ûû/ 3
=
ûû4 5
new
ûû6 9
AllocatorHandle
ûû: I
{
ûûJ K
Index
ûûL Q
=
ûûR S
$num
ûûT U
}
ûûV W
;
ûûW X
public
§§ 
static
§§ 
readonly
§§ 
AllocatorHandle
§§ .
Temp
§§/ 3
=
§§4 5
new
§§6 9
AllocatorHandle
§§: I
{
§§J K
Index
§§L Q
=
§§R S
$num
§§T U
}
§§V W
;
§§W X
public
™™ 
static
™™ 
readonly
™™ 
AllocatorHandle
™™ .
TempJob
™™/ 6
=
™™7 8
new
™™9 <
AllocatorHandle
™™= L
{
™™M N
Index
™™O T
=
™™U V
$num
™™W X
}
™™Y Z
;
™™Z [
public
∞∞ 
static
∞∞ 
readonly
∞∞ 
AllocatorHandle
∞∞ .

Persistent
∞∞/ 9
=
∞∞: ;
new
∞∞< ?
AllocatorHandle
∞∞@ O
{
∞∞P Q
Index
∞∞R W
=
∞∞X Y
$num
∞∞Z [
}
∞∞\ ]
;
∞∞] ^
public
∂∂ 
static
∂∂ 
readonly
∂∂ 
AllocatorHandle
∂∂ .
AudioKernel
∂∂/ :
=
∂∂; <
new
∂∂= @
AllocatorHandle
∂∂A P
{
∂∂Q R
Index
∂∂S X
=
∂∂Y Z
$num
∂∂[ \
}
∂∂] ^
;
∂∂^ _
public
ªª 
delegate
ªª 
int
ªª 
TryFunction
ªª '
(
ªª' (
IntPtr
ªª( .
allocatorState
ªª/ =
,
ªª= >
ref
ªª? B
Block
ªªC H
block
ªªI N
)
ªªN O
;
ªªO P
[
¿¿ 	
StructLayout
¿¿	 
(
¿¿ 

LayoutKind
¿¿  
.
¿¿  !

Sequential
¿¿! +
)
¿¿+ ,
]
¿¿, -
public
¡¡ 
struct
¡¡ 
AllocatorHandle
¡¡ %
:
¡¡& '

IAllocator
¡¡( 2
{
¬¬ 	
internal
√√ 
ref
√√ 

TableEntry
√√ #

TableEntry
√√$ .
=>
√√/ 1
ref
√√2 5
SharedStatics
√√6 C
.
√√C D

TableEntry
√√D N
.
√√N O
Ref
√√O R
.
√√R S
Data
√√S W
.
√√W X
	ElementAt
√√X a
(
√√a b
Index
√√b g
)
√√g h
;
√√h i
internal
ƒƒ 
bool
ƒƒ 
IsInstalled
ƒƒ %
=>
ƒƒ& (
(
ƒƒ) *
(
ƒƒ* +
SharedStatics
ƒƒ+ 8
.
ƒƒ8 9
IsInstalled
ƒƒ9 D
.
ƒƒD E
Ref
ƒƒE H
.
ƒƒH I
Data
ƒƒI M
.
ƒƒM N
	ElementAt
ƒƒN W
(
ƒƒW X
Index
ƒƒX ]
>>
ƒƒ] _
$num
ƒƒ_ `
)
ƒƒ` a
>>
ƒƒb d
(
ƒƒe f
Index
ƒƒf k
&
ƒƒk l
$num
ƒƒl n
)
ƒƒn o
)
ƒƒo p
&
ƒƒq r
$num
ƒƒs t
)
ƒƒt u
!=
ƒƒv x
$num
ƒƒy z
;
ƒƒz {
internal
∆∆ 
void
∆∆ 
IncrementVersion
∆∆ *
(
∆∆* +
)
∆∆+ ,
{
«« 
if
…… 
(
…… 
IsInstalled
…… 
&&
……  "
	IsCurrent
……# ,
)
……, -
{
   
Version
ŒŒ 
=
ŒŒ 
OfficialVersion
ŒŒ -
=
ŒŒ. /
(
ŒŒ0 1
ushort
ŒŒ1 7
)
ŒŒ7 8
(
ŒŒ8 9
++
ŒŒ9 ;
OfficialVersion
ŒŒ; J
&
ŒŒK L
$num
ŒŒM S
)
ŒŒS T
;
ŒŒT U
}
œœ 
}
—— 
internal
”” 
void
”” 
Rewind
””  
(
””  !
)
””! "
{
‘‘ "
InvalidateDependents
÷÷ $
(
÷÷$ %
)
÷÷% &
;
÷÷& '
IncrementVersion
◊◊  
(
◊◊  !
)
◊◊! "
;
◊◊" #
}
ŸŸ 
internal
€€ 
void
€€ 
Install
€€ !
(
€€! "

TableEntry
€€" ,

tableEntry
€€- 7
)
€€7 8
{
‹‹ 
if
·· 
(
··  
ChildSafetyHandles
·· %
.
··% &
	Allocator
··& /
.
··/ 0
Value
··0 5
!=
··6 8
(
··9 :
int
··: =
)
··= >
	Allocator
··> G
.
··G H

Persistent
··H R
)
··R S
{
‚‚  
ChildSafetyHandles
„„ &
=
„„' (
new
„„) ,

UnsafeList
„„- 7
<
„„7 8 
AtomicSafetyHandle
„„8 J
>
„„J K
(
„„K L
$num
„„L M
,
„„M N
	Allocator
„„O X
.
„„X Y

Persistent
„„Y c
)
„„c d
;
„„d e
ChildAllocators
‰‰ #
=
‰‰$ %
new
‰‰& )

UnsafeList
‰‰* 4
<
‰‰4 5
AllocatorHandle
‰‰5 D
>
‰‰D E
(
‰‰E F
$num
‰‰F G
,
‰‰G H
	Allocator
‰‰I R
.
‰‰R S

Persistent
‰‰S ]
)
‰‰] ^
;
‰‰^ _
}
ÂÂ 
Rewind
ÁÁ 
(
ÁÁ 
)
ÁÁ 
;
ÁÁ 

TableEntry
ËË 
=
ËË 

tableEntry
ËË '
;
ËË' (
}
ÈÈ 
internal
ÏÏ 
ref
ÏÏ 
ushort
ÏÏ 
OfficialVersion
ÏÏ  /
=>
ÏÏ0 2
ref
ÏÏ3 6
SharedStatics
ÏÏ7 D
.
ÏÏD E
Version
ÏÏE L
.
ÏÏL M
Ref
ÏÏM P
.
ÏÏP Q
Data
ÏÏQ U
.
ÏÏU V
	ElementAt
ÏÏV _
(
ÏÏ_ `
Index
ÏÏ` e
)
ÏÏe f
;
ÏÏf g
internal
ÌÌ 
ref
ÌÌ 

UnsafeList
ÌÌ #
<
ÌÌ# $ 
AtomicSafetyHandle
ÌÌ$ 6
>
ÌÌ6 7 
ChildSafetyHandles
ÌÌ8 J
=>
ÌÌK M
ref
ÌÌN Q
SharedStatics
ÌÌR _
.
ÌÌ_ ` 
ChildSafetyHandles
ÌÌ` r
.
ÌÌr s
Ref
ÌÌs v
.
ÌÌv w
Data
ÌÌw {
.
ÌÌ{ |
	ElementAtÌÌ| Ö
(ÌÌÖ Ü
IndexÌÌÜ ã
)ÌÌã å
;ÌÌå ç
internal
ÓÓ 
ref
ÓÓ 

UnsafeList
ÓÓ #
<
ÓÓ# $
AllocatorHandle
ÓÓ$ 3
>
ÓÓ3 4
ChildAllocators
ÓÓ5 D
=>
ÓÓE G
ref
ÓÓH K
SharedStatics
ÓÓL Y
.
ÓÓY Z
ChildAllocators
ÓÓZ i
.
ÓÓi j
Ref
ÓÓj m
.
ÓÓm n
Data
ÓÓn r
.
ÓÓr s
	ElementAt
ÓÓs |
(
ÓÓ| }
IndexÓÓ} Ç
)ÓÓÇ É
;ÓÓÉ Ñ
internal
ÔÔ 
ref
ÔÔ 
AllocatorHandle
ÔÔ (
Parent
ÔÔ) /
=>
ÔÔ0 2
ref
ÔÔ3 6
SharedStatics
ÔÔ7 D
.
ÔÔD E
Parent
ÔÔE K
.
ÔÔK L
Ref
ÔÔL O
.
ÔÔO P
Data
ÔÔP T
.
ÔÔT U
	ElementAt
ÔÔU ^
(
ÔÔ^ _
Index
ÔÔ_ d
)
ÔÔd e
;
ÔÔe f
internal
 
ref
 
int
 
IndexInParent
 *
=>
+ -
ref
. 1
SharedStatics
2 ?
.
? @
IndexInParent
@ M
.
M N
Ref
N Q
.
Q R
Data
R V
.
V W
	ElementAt
W `
(
` a
Index
a f
)
f g
;
g h
internal
ÚÚ 
bool
ÚÚ 
	IsCurrent
ÚÚ #
=>
ÚÚ$ &
(
ÚÚ' (
Version
ÚÚ( /
==
ÚÚ0 2
$num
ÚÚ3 4
)
ÚÚ4 5
||
ÚÚ6 8
(
ÚÚ9 :
Version
ÚÚ: A
==
ÚÚB D
OfficialVersion
ÚÚE T
)
ÚÚT U
;
ÚÚU V
internal
ÛÛ 
bool
ÛÛ 
IsValid
ÛÛ !
=>
ÛÛ" $
(
ÛÛ% &
Index
ÛÛ& +
<
ÛÛ, -
FirstUserIndex
ÛÛ. <
)
ÛÛ< =
||
ÛÛ> @
(
ÛÛA B
IsInstalled
ÛÛB M
&&
ÛÛN P
	IsCurrent
ÛÛQ Z
)
ÛÛZ [
;
ÛÛ[ \
internal
˘˘ 
static
˘˘ 
unsafe
˘˘ "
bool
˘˘# '
CheckExists
˘˘( 3
(
˘˘3 4 
AtomicSafetyHandle
˘˘4 F
handle
˘˘G M
)
˘˘M N
{
˙˙ 
bool
˚˚ 
res
˚˚ 
=
˚˚ 
false
˚˚  
;
˚˚  !
int
ÅÅ 
*
ÅÅ 
versionNode
ÅÅ  
=
ÅÅ! "
(
ÅÅ# $
int
ÅÅ$ '
*
ÅÅ' (
)
ÅÅ( )
(
ÅÅ* +
void
ÅÅ+ /
*
ÅÅ/ 0
)
ÅÅ0 1
handle
ÅÅ2 8
.
ÅÅ8 9
versionNode
ÅÅ9 D
;
ÅÅD E
res
ÇÇ 
=
ÇÇ 
(
ÇÇ 
handle
ÇÇ 
.
ÇÇ 
version
ÇÇ %
==
ÇÇ& (
(
ÇÇ) *
*
ÇÇ* +
versionNode
ÇÇ+ 6
&
ÇÇ7 8 
AtomicSafetyHandle
ÇÇ9 K
.
ÇÇK L#
ReadWriteDisposeCheck
ÇÇL a
)
ÇÇa b
)
ÇÇb c
;
ÇÇc d
return
ÑÑ 
res
ÑÑ 
;
ÑÑ 
}
ÖÖ 
internal
áá 
static
áá 
unsafe
áá "
bool
áá# '

AreTheSame
áá( 2
(
áá2 3 
AtomicSafetyHandle
áá3 E
a
ááF G
,
ááG H 
AtomicSafetyHandle
ááI [
b
áá\ ]
)
áá] ^
{
àà 
if
ââ 
(
ââ 
a
ââ 
.
ââ 
version
ââ 
!=
ââ 
b
ââ  !
.
ââ! "
version
ââ" )
)
ââ) *
return
ää 
false
ää  
;
ää  !
if
éé 
(
éé 
a
éé 
.
éé 
versionNode
éé  
!=
éé! #
b
éé$ %
.
éé% &
versionNode
éé& 1
)
éé1 2
return
êê 
false
êê  
;
êê  !
return
ëë 
true
ëë 
;
ëë 
}
íí 
internal
îî 
static
îî 
bool
îî  

AreTheSame
îî! +
(
îî+ ,
AllocatorHandle
îî, ;
a
îî< =
,
îî= >
AllocatorHandle
îî? N
b
îîO P
)
îîP Q
{
ïï 
if
ññ 
(
ññ 
a
ññ 
.
ññ 
Index
ññ 
!=
ññ 
b
ññ 
.
ññ  
Index
ññ  %
)
ññ% &
return
óó 
false
óó  
;
óó  !
if
òò 
(
òò 
a
òò 
.
òò 
Version
òò 
!=
òò 
b
òò  !
.
òò! "
Version
òò" )
)
òò) *
return
ôô 
false
ôô  
;
ôô  !
return
öö 
true
öö 
;
öö 
}
õõ 
internal
ùù 
bool
ùù '
NeedsUseAfterFreeTracking
ùù 3
(
ùù3 4
)
ùù4 5
{
ûû 
if
üü 
(
üü 
IsValid
üü 
==
üü 
false
üü #
)
üü# $
return
†† 
false
††  
;
††  !
if
°° 
(
°°  
ChildSafetyHandles
°° %
.
°°% &
	Allocator
°°& /
.
°°/ 0
Value
°°0 5
!=
°°6 8
(
°°9 :
int
°°: =
)
°°= >
	Allocator
°°> G
.
°°G H

Persistent
°°H R
)
°°R S
return
¢¢ 
false
¢¢  
;
¢¢  !
return
££ 
true
££ 
;
££ 
}
§§ 
public
™™ 
const
™™ 
int
™™ +
InvalidChildSafetyHandleIndex
™™ :
=
™™; <
-
™™= >
$num
™™> ?
;
™™? @
internal
¨¨ 
int
¨¨ 
AddSafetyHandle
¨¨ (
(
¨¨( ) 
AtomicSafetyHandle
¨¨) ;
handle
¨¨< B
)
¨¨B C
{
≠≠ 
if
ÆÆ 
(
ÆÆ 
!
ÆÆ '
NeedsUseAfterFreeTracking
ÆÆ -
(
ÆÆ- .
)
ÆÆ. /
)
ÆÆ/ 0
return
ØØ +
InvalidChildSafetyHandleIndex
ØØ 8
;
ØØ8 9
var
∞∞ 
result
∞∞ 
=
∞∞  
ChildSafetyHandles
∞∞ /
.
∞∞/ 0
Length
∞∞0 6
;
∞∞6 7 
ChildSafetyHandles
±± "
.
±±" #
Add
±±# &
(
±±& '
handle
±±' -
)
±±- .
;
±±. /
return
≤≤ 
result
≤≤ 
;
≤≤ 
}
≥≥ 
internal
µµ 
bool
µµ #
TryRemoveSafetyHandle
µµ /
(
µµ/ 0 
AtomicSafetyHandle
µµ0 B
handle
µµC I
,
µµI J
int
µµK N
safetyHandleIndex
µµO `
)
µµ` a
{
∂∂ 
if
∑∑ 
(
∑∑ 
!
∑∑ '
NeedsUseAfterFreeTracking
∑∑ -
(
∑∑- .
)
∑∑. /
)
∑∑/ 0
return
∏∏ 
false
∏∏  
;
∏∏  !
if
ππ 
(
ππ 
safetyHandleIndex
ππ $
==
ππ% '+
InvalidChildSafetyHandleIndex
ππ( E
)
ππE F
return
∫∫ 
false
∫∫  
;
∫∫  !
safetyHandleIndex
ªª !
=
ªª" #
math
ªª$ (
.
ªª( )
min
ªª) ,
(
ªª, -
safetyHandleIndex
ªª- >
,
ªª> ? 
ChildSafetyHandles
ªª@ R
.
ªªR S
Length
ªªS Y
-
ªªZ [
$num
ªª\ ]
)
ªª] ^
;
ªª^ _
while
ºº 
(
ºº 
safetyHandleIndex
ºº '
>=
ºº( *
$num
ºº+ ,
)
ºº, -
{
ΩΩ 
unsafe
ææ 
{
øø 
var
¿¿ 
safetyHandle
¿¿ (
=
¿¿) * 
ChildSafetyHandles
¿¿+ =
.
¿¿= >
Ptr
¿¿> A
+
¿¿B C
safetyHandleIndex
¿¿D U
;
¿¿U V
if
¡¡ 
(
¡¡ 

AreTheSame
¡¡ %
(
¡¡% &
*
¡¡& '
safetyHandle
¡¡' 3
,
¡¡3 4
handle
¡¡5 ;
)
¡¡; <
)
¡¡< =
{
¬¬  
ChildSafetyHandles
√√ .
.
√√. /
RemoveAtSwapBack
√√/ ?
(
√√? @
safetyHandleIndex
√√@ Q
)
√√Q R
;
√√R S
return
ƒƒ "
true
ƒƒ# '
;
ƒƒ' (
}
≈≈ 
}
∆∆ 
--
«« 
safetyHandleIndex
«« '
;
««' (
}
»» 
return
…… 
false
…… 
;
…… 
}
   
public
–– 
const
–– 
int
–– (
InvalidChildAllocatorIndex
–– 7
=
––8 9
-
––: ;
$num
––; <
;
––< =
internal
““ 
int
““ 
AddChildAllocator
““ *
(
““* +
AllocatorHandle
““+ :
handle
““; A
)
““A B
{
”” 
if
‘‘ 
(
‘‘ 
!
‘‘ '
NeedsUseAfterFreeTracking
‘‘ -
(
‘‘- .
)
‘‘. /
)
‘‘/ 0
return
’’ (
InvalidChildAllocatorIndex
’’ 5
;
’’5 6
var
÷÷ 
result
÷÷ 
=
÷÷ 
ChildAllocators
÷÷ ,
.
÷÷, -
Length
÷÷- 3
;
÷÷3 4
ChildAllocators
◊◊ 
.
◊◊  
Add
◊◊  #
(
◊◊# $
handle
◊◊$ *
)
◊◊* +
;
◊◊+ ,
handle
ÿÿ 
.
ÿÿ 
Parent
ÿÿ 
=
ÿÿ 
this
ÿÿ  $
;
ÿÿ$ %
handle
ŸŸ 
.
ŸŸ 
IndexInParent
ŸŸ $
=
ŸŸ% &
result
ŸŸ' -
;
ŸŸ- .
return
⁄⁄ 
result
⁄⁄ 
;
⁄⁄ 
}
€€ 
internal
›› 
bool
›› %
TryRemoveChildAllocator
›› 1
(
››1 2
AllocatorHandle
››2 A
handle
››B H
,
››H I
int
››J M!
childAllocatorIndex
››N a
)
››a b
{
ﬁﬁ 
if
ﬂﬂ 
(
ﬂﬂ 
!
ﬂﬂ '
NeedsUseAfterFreeTracking
ﬂﬂ -
(
ﬂﬂ- .
)
ﬂﬂ. /
)
ﬂﬂ/ 0
return
‡‡ 
false
‡‡  
;
‡‡  !
if
·· 
(
·· !
childAllocatorIndex
·· &
==
··' )(
InvalidChildAllocatorIndex
··* D
)
··D E
return
‚‚ 
false
‚‚  
;
‚‚  !!
childAllocatorIndex
„„ #
=
„„$ %
math
„„& *
.
„„* +
min
„„+ .
(
„„. /!
childAllocatorIndex
„„/ B
,
„„B C
ChildAllocators
„„D S
.
„„S T
Length
„„T Z
-
„„[ \
$num
„„] ^
)
„„^ _
;
„„_ `
while
‰‰ 
(
‰‰ !
childAllocatorIndex
‰‰ )
>=
‰‰* ,
$num
‰‰- .
)
‰‰. /
{
ÂÂ 
unsafe
ÊÊ 
{
ÁÁ 
var
ËË 
allocatorHandle
ËË +
=
ËË, -
ChildAllocators
ËË. =
.
ËË= >
Ptr
ËË> A
+
ËËB C!
childAllocatorIndex
ËËD W
;
ËËW X
if
ÈÈ 
(
ÈÈ 

AreTheSame
ÈÈ %
(
ÈÈ% &
*
ÈÈ& '
allocatorHandle
ÈÈ' 6
,
ÈÈ6 7
handle
ÈÈ8 >
)
ÈÈ> ?
)
ÈÈ? @
{
ÍÍ 
ChildAllocators
ÎÎ +
.
ÎÎ+ ,
RemoveAtSwapBack
ÎÎ, <
(
ÎÎ< =!
childAllocatorIndex
ÎÎ= P
)
ÎÎP Q
;
ÎÎQ R
return
ÏÏ "
true
ÏÏ# '
;
ÏÏ' (
}
ÌÌ 
}
ÓÓ 
--
ÔÔ !
childAllocatorIndex
ÔÔ )
;
ÔÔ) *
}
 
return
ÒÒ 
false
ÒÒ 
;
ÒÒ 
}
ÚÚ 
[
ÖÖ  
NotBurstCompatible
ÖÖ 
]
ÖÖ  
internal
ÜÜ 
void
ÜÜ "
InvalidateDependents
ÜÜ .
(
ÜÜ. /
)
ÜÜ/ 0
{
áá 
if
àà 
(
àà 
!
àà '
NeedsUseAfterFreeTracking
àà -
(
àà- .
)
àà. /
)
àà/ 0
return
ââ 
;
ââ 
for
ää 
(
ää 
var
ää 
i
ää 
=
ää 
$num
ää 
;
ää 
i
ää  
<
ää! " 
ChildSafetyHandles
ää# 5
.
ää5 6
Length
ää6 <
;
ää< =
++
ää> @
i
ää@ A
)
ääA B
{
ãã 
unsafe
åå 
{
çç  
AtomicSafetyHandle
éé *
*
éé* +
handle
éé, 2
=
éé3 4 
ChildSafetyHandles
éé5 G
.
ééG H
Ptr
ééH K
+
ééL M
i
ééN O
;
ééO P
if
èè 
(
èè 
CheckExists
èè &
(
èè& '
*
èè' (
handle
èè( .
)
èè. /
)
èè/ 0 
AtomicSafetyHandle
êê .
.
êê. /
Release
êê/ 6
(
êê6 7
*
êê7 8
handle
êê8 >
)
êê> ?
;
êê? @
}
ëë 
}
íí  
ChildSafetyHandles
ìì "
.
ìì" #
Clear
ìì# (
(
ìì( )
)
ìì) *
;
ìì* +
if
îî 
(
îî 
Parent
îî 
.
îî 
IsValid
îî !
)
îî! "
Parent
ïï 
.
ïï %
TryRemoveChildAllocator
ïï 2
(
ïï2 3
this
ïï3 7
,
ïï7 8
IndexInParent
ïï9 F
)
ïïF G
;
ïïG H
Parent
ññ 
=
ññ 
default
ññ  
;
ññ  !
IndexInParent
óó 
=
óó (
InvalidChildAllocatorIndex
óó  :
;
óó: ;
for
òò 
(
òò 
var
òò 
i
òò 
=
òò 
$num
òò 
;
òò 
i
òò  
<
òò! "
ChildAllocators
òò# 2
.
òò2 3
Length
òò3 9
;
òò9 :
++
òò; =
i
òò= >
)
òò> ?
{
ôô 
unsafe
öö 
{
õõ 
AllocatorHandle
úú '
*
úú' (
handle
úú) /
=
úú0 1
(
úú2 3
AllocatorHandle
úú3 B
*
úúB C
)
úúC D
ChildAllocators
úúD S
.
úúS T
Ptr
úúT W
+
úúX Y
i
úúZ [
;
úú[ \
if
ùù 
(
ùù 
handle
ùù !
->
ùù! #
IsValid
ùù# *
)
ùù* +
handle
ûû "
->
ûû" $!
UnmanagedUnregister
ûû$ 7
(
ûû7 8
)
ûû8 9
;
ûû9 :
}
üü 
}
†† 
ChildAllocators
°° 
.
°°  
Clear
°°  %
(
°°% &
)
°°& '
;
°°' (
}
¢¢ 
public
´´ 
static
´´ 
implicit
´´ "
operator
´´# +
AllocatorHandle
´´, ;
(
´´; <
	Allocator
´´< E
a
´´F G
)
´´G H
=>
´´I K
new
´´L O
AllocatorHandle
´´P _
{
¨¨ 
Index
≠≠ 
=
≠≠ 
(
≠≠ 
ushort
≠≠ 
)
≠≠  
(
≠≠  !
(
≠≠! "
uint
≠≠" &
)
≠≠& '
a
≠≠' (
&
≠≠) *
$num
≠≠+ 1
)
≠≠1 2
,
≠≠2 3
Version
ÆÆ 
=
ÆÆ 
(
ÆÆ 
ushort
ÆÆ !
)
ÆÆ! "
(
ÆÆ" #
(
ÆÆ# $
uint
ÆÆ$ (
)
ÆÆ( )
a
ÆÆ) *
>>
ÆÆ+ -
$num
ÆÆ. 0
)
ÆÆ0 1
}
ØØ 
;
ØØ 
public
µµ 
ushort
µµ 
Index
µµ 
;
µµ  
public
¿¿ 
ushort
¿¿ 
Version
¿¿ !
;
¿¿! "
public
∆∆ 
int
∆∆ 
Value
∆∆ 
=>
∆∆ 
Index
∆∆  %
;
∆∆% &
public
œœ 
int
œœ 
TryAllocateBlock
œœ '
<
œœ' (
T
œœ( )
>
œœ) *
(
œœ* +
out
œœ+ .
Block
œœ/ 4
block
œœ5 :
,
œœ: ;
int
œœ< ?
items
œœ@ E
)
œœE F
where
œœG L
T
œœM N
:
œœO P
struct
œœQ W
{
–– 
block
—— 
=
—— 
new
—— 
Block
—— !
{
““ 
Range
”” 
=
”” 
new
”” 
Range
””  %
{
””& '
Items
””( -
=
””. /
items
””0 5
,
””5 6
	Allocator
””7 @
=
””A B
this
””C G
}
””H I
,
””I J
BytesPerItem
‘‘  
=
‘‘! "
UnsafeUtility
‘‘# 0
.
‘‘0 1
SizeOf
‘‘1 7
<
‘‘7 8
T
‘‘8 9
>
‘‘9 :
(
‘‘: ;
)
‘‘; <
,
‘‘< =
	Alignment
’’ 
=
’’ 
$num
’’  !
<<
’’" $
math
’’% )
.
’’) *
min
’’* -
(
’’- .
$num
’’. /
,
’’/ 0
math
’’1 5
.
’’5 6
tzcnt
’’6 ;
(
’’; <
UnsafeUtility
’’< I
.
’’I J
SizeOf
’’J P
<
’’P Q
T
’’Q R
>
’’R S
(
’’S T
)
’’T U
)
’’U V
)
’’V W
}
÷÷ 
;
÷÷ 
var
◊◊ 

returnCode
◊◊ 
=
◊◊  
Try
◊◊! $
(
◊◊$ %
ref
◊◊% (
block
◊◊) .
)
◊◊. /
;
◊◊/ 0
return
ÿÿ 

returnCode
ÿÿ !
;
ÿÿ! "
}
ŸŸ 
public
‚‚ 
Block
‚‚ 
AllocateBlock
‚‚ &
<
‚‚& '
T
‚‚' (
>
‚‚( )
(
‚‚) *
int
‚‚* -
items
‚‚. 3
)
‚‚3 4
where
‚‚5 :
T
‚‚; <
:
‚‚= >
struct
‚‚? E
{
„„ 

CheckValid
‰‰ 
(
‰‰ 
this
‰‰ 
)
‰‰  
;
‰‰  !
var
ÂÂ 
error
ÂÂ 
=
ÂÂ 
TryAllocateBlock
ÂÂ ,
<
ÂÂ, -
T
ÂÂ- .
>
ÂÂ. /
(
ÂÂ/ 0
out
ÂÂ0 3
Block
ÂÂ4 9
block
ÂÂ: ?
,
ÂÂ? @
items
ÂÂA F
)
ÂÂF G
;
ÂÂG H(
CheckAllocatedSuccessfully
ÊÊ *
(
ÊÊ* +
error
ÊÊ+ 0
)
ÊÊ0 1
;
ÊÊ1 2
return
ÁÁ 
block
ÁÁ 
;
ÁÁ 
}
ËË 
[
ÍÍ 
Conditional
ÍÍ 
(
ÍÍ 
$str
ÍÍ 9
)
ÍÍ9 :
]
ÍÍ: ;
static
ÎÎ 
void
ÎÎ (
CheckAllocatedSuccessfully
ÎÎ 2
(
ÎÎ2 3
int
ÎÎ3 6
error
ÎÎ7 <
)
ÎÎ< =
{
ÏÏ 
if
ÌÌ 
(
ÌÌ 
error
ÌÌ 
!=
ÌÌ 
$num
ÌÌ 
)
ÌÌ 
throw
ÓÓ 
new
ÓÓ 
ArgumentException
ÓÓ /
(
ÓÓ/ 0
$"
ÓÓ0 2
$str
ÓÓ2 8
{
ÓÓ8 9
error
ÓÓ9 >
}
ÓÓ> ?
$str
ÓÓ? S
"
ÓÓS T
)
ÓÓT U
;
ÓÓU V
}
ÔÔ 
public
ıı 
TryFunction
ıı 
Function
ıı '
=>
ıı( *
default
ıı+ 2
;
ıı2 3
public
¸¸ 
int
¸¸ 
Try
¸¸ 
(
¸¸ 
ref
¸¸ 
Block
¸¸ $
block
¸¸% *
)
¸¸* +
{
˝˝ 
block
˛˛ 
.
˛˛ 
Range
˛˛ 
.
˛˛ 
	Allocator
˛˛ %
=
˛˛& '
this
˛˛( ,
;
˛˛, -
var
ˇˇ 
error
ˇˇ 
=
ˇˇ 
AllocatorManager
ˇˇ ,
.
ˇˇ, -
Try
ˇˇ- 0
(
ˇˇ0 1
ref
ˇˇ1 4
block
ˇˇ5 :
)
ˇˇ: ;
;
ˇˇ; <
return
ÄÄ 
error
ÄÄ 
;
ÄÄ 
}
ÅÅ 
public
áá 
AllocatorHandle
áá "
Handle
áá# )
{
áá* +
get
áá, /
{
áá0 1
return
áá2 8
this
áá9 =
;
áá= >
}
áá? @
set
ááA D
{
ááE F
this
ááG K
=
ááL M
value
ááN S
;
ááS T
}
ááU V
}
ááW X
public
çç 
	Allocator
çç 
ToAllocator
çç (
{
éé 
get
èè 
{
êê 
uint
ëë 
lo
ëë 
=
ëë 
Index
ëë #
;
ëë# $
uint
íí 
hi
íí 
=
íí 
Version
íí %
;
íí% &
uint
ìì 
value
ìì 
=
ìì  
(
ìì! "
hi
ìì" $
<<
ìì% '
$num
ìì( *
)
ìì* +
|
ìì, -
lo
ìì. 0
;
ìì0 1
return
îî 
(
îî 
	Allocator
îî %
)
îî% &
value
îî& +
;
îî+ ,
}
ïï 
}
ññ 
public
ùù 
bool
ùù 
IsCustomAllocator
ùù )
{
ùù* +
get
ùù, /
{
ùù0 1
return
ùù2 8
this
ùù9 =
.
ùù= >
Index
ùù> C
>=
ùùD F
FirstUserIndex
ùùG U
;
ùùU V
}
ùùW X
}
ùùY Z
public
¢¢ 
void
¢¢ 
Dispose
¢¢ 
(
¢¢  
)
¢¢  !
{
££ 
Rewind
§§ 
(
§§ 
)
§§ 
;
§§ 
}
•• 
}
¶¶ 	
[
´´ 	
StructLayout
´´	 
(
´´ 

LayoutKind
´´  
.
´´  !

Sequential
´´! +
)
´´+ ,
]
´´, -
public
¨¨ 
struct
¨¨ 
BlockHandle
¨¨ !
{
≠≠ 	
public
≤≤ 
ushort
≤≤ 
Value
≤≤ 
;
≤≤  
}
≥≥ 	
[
ºº 	
StructLayout
ºº	 
(
ºº 

LayoutKind
ºº  
.
ºº  !

Sequential
ºº! +
)
ºº+ ,
]
ºº, -
public
ΩΩ 
struct
ΩΩ 
Range
ΩΩ 
:
ΩΩ 
IDisposable
ΩΩ )
{
ææ 	
public
√√ 
IntPtr
√√ 
Pointer
√√ !
;
√√! "
public
   
int
   
Items
   
;
   
public
–– 
AllocatorHandle
–– "
	Allocator
––# ,
;
––, -
public
⁄⁄ 
void
⁄⁄ 
Dispose
⁄⁄ 
(
⁄⁄  
)
⁄⁄  !
{
€€ 
Block
‹‹ 
block
‹‹ 
=
‹‹ 
new
‹‹ !
Block
‹‹" '
{
‹‹( )
Range
‹‹* /
=
‹‹0 1
this
‹‹2 6
}
‹‹7 8
;
‹‹8 9
block
›› 
.
›› 
Dispose
›› 
(
›› 
)
›› 
;
››  
this
ﬁﬁ 
=
ﬁﬁ 
block
ﬁﬁ 
.
ﬁﬁ 
Range
ﬁﬁ "
;
ﬁﬁ" #
}
ﬂﬂ 
}
‡‡ 	
[
ÊÊ 	
StructLayout
ÊÊ	 
(
ÊÊ 

LayoutKind
ÊÊ  
.
ÊÊ  !

Sequential
ÊÊ! +
)
ÊÊ+ ,
]
ÊÊ, -
public
ÁÁ 
struct
ÁÁ 
Block
ÁÁ 
:
ÁÁ 
IDisposable
ÁÁ )
{
ËË 	
public
ÌÌ 
Range
ÌÌ 
Range
ÌÌ 
;
ÌÌ 
public
ÛÛ 
int
ÛÛ 
BytesPerItem
ÛÛ #
;
ÛÛ# $
public
˘˘ 
int
˘˘ 
AllocatedItems
˘˘ %
;
˘˘% &
public
ÄÄ 
byte
ÄÄ 
Log2Alignment
ÄÄ %
;
ÄÄ% &
public
ÜÜ 
byte
ÜÜ 
Padding0
ÜÜ  
;
ÜÜ  !
public
åå 
ushort
åå 
Padding1
åå "
;
åå" #
public
íí 
uint
íí 
Padding2
íí  
;
íí  !
public
ôô 
long
ôô 
Bytes
ôô 
=>
ôô  
BytesPerItem
ôô! -
*
ôô. /
Range
ôô0 5
.
ôô5 6
Items
ôô6 ;
;
ôô; <
public
†† 
long
†† 
AllocatedBytes
†† &
=>
††' )
BytesPerItem
††* 6
*
††7 8
AllocatedItems
††9 G
;
††G H
public
™™ 
int
™™ 
	Alignment
™™  
{
´´ 
get
¨¨ 
=>
¨¨ 
$num
¨¨ 
<<
¨¨ 
Log2Alignment
¨¨ )
;
¨¨) *
set
≠≠ 
=>
≠≠ 
Log2Alignment
≠≠ $
=
≠≠% &
(
≠≠' (
byte
≠≠( ,
)
≠≠, -
(
≠≠- .
$num
≠≠. 0
-
≠≠1 2
math
≠≠3 7
.
≠≠7 8
lzcnt
≠≠8 =
(
≠≠= >
math
≠≠> B
.
≠≠B C
max
≠≠C F
(
≠≠F G
$num
≠≠G H
,
≠≠H I
value
≠≠J O
)
≠≠O P
-
≠≠Q R
$num
≠≠S T
)
≠≠T U
)
≠≠U V
;
≠≠V W
}
ÆÆ 
public
¥¥ 
void
¥¥ 
Dispose
¥¥ 
(
¥¥  
)
¥¥  !
{
µµ 
TryFree
∂∂ 
(
∂∂ 
)
∂∂ 
;
∂∂ 
}
∑∑ 
public
ΩΩ 
int
ΩΩ 
TryAllocate
ΩΩ "
(
ΩΩ" #
)
ΩΩ# $
{
ææ 
Range
øø 
.
øø 
Pointer
øø 
=
øø 
IntPtr
øø  &
.
øø& '
Zero
øø' +
;
øø+ ,
return
¿¿ 
Try
¿¿ 
(
¿¿ 
ref
¿¿ 
this
¿¿ #
)
¿¿# $
;
¿¿$ %
}
¡¡ 
public
«« 
int
«« 
TryFree
«« 
(
«« 
)
««  
{
»» 
Range
…… 
.
…… 
Items
…… 
=
…… 
$num
…… 
;
……  
return
   
Try
   
(
   
ref
   
this
   #
)
  # $
;
  $ %
}
ÀÀ 
public
—— 
void
—— 
Allocate
——  
(
——  !
)
——! "
{
““ 
var
”” 
error
”” 
=
”” 
TryAllocate
”” '
(
””' (
)
””( )
;
””) *#
CheckFailedToAllocate
‘‘ %
(
‘‘% &
error
‘‘& +
)
‘‘+ ,
;
‘‘, -
}
’’ 
public
€€ 
void
€€ 
Free
€€ 
(
€€ 
)
€€ 
{
‹‹ 
var
›› 
error
›› 
=
›› 
TryFree
›› #
(
››# $
)
››$ %
;
››% &
CheckFailedToFree
ﬁﬁ !
(
ﬁﬁ! "
error
ﬁﬁ" '
)
ﬁﬁ' (
;
ﬁﬁ( )
}
ﬂﬂ 
[
·· 
Conditional
·· 
(
·· 
$str
·· 9
)
··9 :
]
··: ;
void
‚‚ #
CheckFailedToAllocate
‚‚ &
(
‚‚& '
int
‚‚' *
error
‚‚+ 0
)
‚‚0 1
{
„„ 
if
‰‰ 
(
‰‰ 
error
‰‰ 
!=
‰‰ 
$num
‰‰ 
)
‰‰ 
throw
ÂÂ 
new
ÂÂ 
ArgumentException
ÂÂ /
(
ÂÂ/ 0
$"
ÂÂ0 2
$str
ÂÂ2 8
{
ÂÂ8 9
error
ÂÂ9 >
}
ÂÂ> ?
$str
ÂÂ? T
{
ÂÂT U
this
ÂÂU Y
}
ÂÂY Z
"
ÂÂZ [
)
ÂÂ[ \
;
ÂÂ\ ]
}
ÊÊ 
[
ËË 
Conditional
ËË 
(
ËË 
$str
ËË 9
)
ËË9 :
]
ËË: ;
void
ÈÈ 
CheckFailedToFree
ÈÈ "
(
ÈÈ" #
int
ÈÈ# &
error
ÈÈ' ,
)
ÈÈ, -
{
ÍÍ 
if
ÎÎ 
(
ÎÎ 
error
ÎÎ 
!=
ÎÎ 
$num
ÎÎ 
)
ÎÎ 
throw
ÏÏ 
new
ÏÏ 
ArgumentException
ÏÏ /
(
ÏÏ/ 0
$"
ÏÏ0 2
$str
ÏÏ2 8
{
ÏÏ8 9
error
ÏÏ9 >
}
ÏÏ> ?
$str
ÏÏ? P
{
ÏÏP Q
this
ÏÏQ U
}
ÏÏU V
"
ÏÏV W
)
ÏÏW X
;
ÏÏX Y
}
ÌÌ 
}
ÓÓ 	
public
ÛÛ 
	interface
ÛÛ 

IAllocator
ÛÛ #
:
ÛÛ$ %
IDisposable
ÛÛ& 1
{
ÙÙ 	
TryFunction
¯¯ 
Function
¯¯  
{
¯¯! "
get
¯¯# &
;
¯¯& '
}
¯¯( )
int
ˇˇ 
Try
ˇˇ 
(
ˇˇ 
ref
ˇˇ 
Block
ˇˇ 
block
ˇˇ #
)
ˇˇ# $
;
ˇˇ$ %
AllocatorHandle
ÖÖ 
Handle
ÖÖ "
{
ÖÖ# $
get
ÖÖ% (
;
ÖÖ( )
set
ÖÖ* -
;
ÖÖ- .
}
ÖÖ/ 0
	Allocator
ää 
ToAllocator
ää !
{
ää" #
get
ää$ '
;
ää' (
}
ää) *
bool
èè 
IsCustomAllocator
èè "
{
èè# $
get
èè% (
;
èè( )
}
èè* +
}
êê 	
public
ññ 
const
ññ 
int
ññ 

kErrorNone
ññ #
=
ññ$ %
$num
ññ& '
;
ññ' (
public
õõ 
const
õõ 
int
õõ "
kErrorBufferOverflow
õõ -
=
õõ. /
-
õõ0 1
$num
õõ1 2
;
õõ2 3
[
üü 	
BurstDiscard
üü	 
]
üü 
private
†† 
static
†† 
void
†† 
CheckDelegate
†† )
(
††) *
ref
††* -
bool
††. 2
useDelegate
††3 >
)
††> ?
{
°° 	
useDelegate
££ 
=
££ 
true
££ 
;
££ 
}
§§ 	
private
¶¶ 
static
¶¶ 
bool
¶¶ 
UseDelegate
¶¶ '
(
¶¶' (
)
¶¶( )
{
ßß 	
bool
®® 
result
®® 
=
®® 
false
®® 
;
®®  
CheckDelegate
©© 
(
©© 
ref
©© 
result
©© $
)
©©$ %
;
©©% &
return
™™ 
result
™™ 
;
™™ 
}
´´ 	
private
ÆÆ 
static
ÆÆ 
int
ÆÆ 
allocate_block
ÆÆ )
(
ÆÆ) *
ref
ÆÆ* -
Block
ÆÆ. 3
block
ÆÆ4 9
)
ÆÆ9 :
{
ØØ 	

TableEntry
∞∞ 

tableEntry
∞∞ !
=
∞∞" #
default
∞∞$ +
;
∞∞+ ,

tableEntry
±± 
=
±± 
block
±± 
.
±± 
Range
±± $
.
±±$ %
	Allocator
±±% .
.
±±. /

TableEntry
±±/ 9
;
±±9 :
var
≤≤ 
function
≤≤ 
=
≤≤ 
new
≤≤ 
FunctionPointer
≤≤ .
<
≤≤. /
TryFunction
≤≤/ :
>
≤≤: ;
(
≤≤; <

tableEntry
≤≤< F
.
≤≤F G
function
≤≤G O
)
≤≤O P
;
≤≤P Q
return
¥¥ 
function
¥¥ 
.
¥¥ 
Invoke
¥¥ "
(
¥¥" #

tableEntry
¥¥# -
.
¥¥- .
state
¥¥. 3
,
¥¥3 4
ref
¥¥5 8
block
¥¥9 >
)
¥¥> ?
;
¥¥? @
}
µµ 	
[
∏∏ 	
BurstDiscard
∏∏	 
]
∏∏ 
private
ππ 
static
ππ 
void
ππ )
forward_mono_allocate_block
ππ 7
(
ππ7 8
ref
ππ8 ;
Block
ππ< A
block
ππB G
,
ππG H
ref
ππI L
int
ππM P
error
ππQ V
)
ππV W
{
∫∫ 	

TableEntry
ªª 

tableEntry
ªª !
=
ªª" #
default
ªª$ +
;
ªª+ ,

tableEntry
ºº 
=
ºº 
block
ºº 
.
ºº 
Range
ºº $
.
ºº$ %
	Allocator
ºº% .
.
ºº. /

TableEntry
ºº/ 9
;
ºº9 :
var
ææ 
index
ææ 
=
ææ 
block
ææ 
.
ææ 
Range
ææ #
.
ææ# $
	Allocator
ææ$ -
.
ææ- .
Handle
ææ. 4
.
ææ4 5
Index
ææ5 :
;
ææ: ;
if
øø 
(
øø 
index
øø 
>=
øø 
Managed
øø  
.
øø  !$
kMaxNumCustomAllocator
øø! 7
)
øø7 8
{
¿¿ 
throw
¡¡ 
new
¡¡ 
ArgumentException
¡¡ +
(
¡¡+ ,
$str
¡¡, n
)
¡¡n o
;
¡¡o p
}
¬¬ 
ref
√√ 
TryFunction
√√ 
function
√√ $
=
√√% &
ref
√√' *
Managed
√√+ 2
.
√√2 3"
TryFunctionDelegates
√√3 G
[
√√G H
block
√√H M
.
√√M N
Range
√√N S
.
√√S T
	Allocator
√√T ]
.
√√] ^
Handle
√√^ d
.
√√d e
Index
√√e j
]
√√j k
;
√√k l
error
ƒƒ 
=
ƒƒ 
function
ƒƒ 
(
ƒƒ 

tableEntry
ƒƒ '
.
ƒƒ' (
state
ƒƒ( -
,
ƒƒ- .
ref
ƒƒ/ 2
block
ƒƒ3 8
)
ƒƒ8 9
;
ƒƒ9 :
}
≈≈ 	
internal
»» 
static
»» 
	Allocator
»» !
LegacyOf
»»" *
(
»»* +
AllocatorHandle
»»+ :
handle
»»; A
)
»»A B
{
…… 	
if
   
(
   
handle
   
.
   
Value
   
>=
   
FirstUserIndex
    .
)
  . /
return
ÀÀ 
	Allocator
ÀÀ  
.
ÀÀ  !

Persistent
ÀÀ! +
;
ÀÀ+ ,
return
ÃÃ 
(
ÃÃ 
	Allocator
ÃÃ 
)
ÃÃ 
handle
ÃÃ %
.
ÃÃ% &
Value
ÃÃ& +
;
ÃÃ+ ,
}
ÕÕ 	
static
œœ 
unsafe
œœ 
int
œœ 
	TryLegacy
œœ #
(
œœ# $
ref
œœ$ '
Block
œœ( -
block
œœ. 3
)
œœ3 4
{
–– 	
if
—— 
(
—— 
block
—— 
.
—— 
Range
—— 
.
—— 
Pointer
—— #
==
——$ &
IntPtr
——' -
.
——- .
Zero
——. 2
)
——2 3
{
““ 
block
”” 
.
”” 
Range
”” 
.
”” 
Pointer
”” #
=
””$ %
(
””& '
IntPtr
””' -
)
””- .
Memory
””. 4
.
””4 5
	Unmanaged
””5 >
.
””> ?
Allocate
””? G
(
””G H
block
””H M
.
””M N
Bytes
””N S
,
””S T
block
””U Z
.
””Z [
	Alignment
””[ d
,
””d e
LegacyOf
””f n
(
””n o
block
””o t
.
””t u
Range
””u z
.
””z {
	Allocator””{ Ñ
)””Ñ Ö
)””Ö Ü
;””Ü á
block
‘‘ 
.
‘‘ 
AllocatedItems
‘‘ $
=
‘‘% &
block
‘‘' ,
.
‘‘, -
Range
‘‘- 2
.
‘‘2 3
Items
‘‘3 8
;
‘‘8 9
return
’’ 
(
’’ 
block
’’ 
.
’’ 
Range
’’ #
.
’’# $
Pointer
’’$ +
==
’’, .
IntPtr
’’/ 5
.
’’5 6
Zero
’’6 :
)
’’: ;
?
’’< =
-
’’> ?
$num
’’? @
:
’’A B
$num
’’C D
;
’’D E
}
÷÷ 
if
◊◊ 
(
◊◊ 
block
◊◊ 
.
◊◊ 
Bytes
◊◊ 
==
◊◊ 
$num
◊◊  
)
◊◊  !
{
ÿÿ 
if
ŸŸ 
(
ŸŸ 
LegacyOf
ŸŸ 
(
ŸŸ 
block
ŸŸ "
.
ŸŸ" #
Range
ŸŸ# (
.
ŸŸ( )
	Allocator
ŸŸ) 2
)
ŸŸ2 3
!=
ŸŸ4 6
	Allocator
ŸŸ7 @
.
ŸŸ@ A
None
ŸŸA E
)
ŸŸE F
{
⁄⁄ 
Memory
€€ 
.
€€ 
	Unmanaged
€€ $
.
€€$ %
Free
€€% )
(
€€) *
(
€€* +
void
€€+ /
*
€€/ 0
)
€€0 1
block
€€1 6
.
€€6 7
Range
€€7 <
.
€€< =
Pointer
€€= D
,
€€D E
LegacyOf
€€F N
(
€€N O
block
€€O T
.
€€T U
Range
€€U Z
.
€€Z [
	Allocator
€€[ d
)
€€d e
)
€€e f
;
€€f g
}
‹‹ 
block
›› 
.
›› 
Range
›› 
.
›› 
Pointer
›› #
=
››$ %
IntPtr
››& ,
.
››, -
Zero
››- 1
;
››1 2
block
ﬁﬁ 
.
ﬁﬁ 
AllocatedItems
ﬁﬁ $
=
ﬁﬁ% &
$num
ﬁﬁ' (
;
ﬁﬁ( )
return
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 
return
‚‚ 
-
‚‚ 
$num
‚‚ 
;
‚‚ 
}
„„ 	
public
 
static
 
unsafe
 
int
  
Try
! $
(
$ %
ref
% (
Block
) .
block
/ 4
)
4 5
{
ÒÒ 	
if
ÚÚ 
(
ÚÚ 
block
ÚÚ 
.
ÚÚ 
Range
ÚÚ 
.
ÚÚ 
	Allocator
ÚÚ %
.
ÚÚ% &
Value
ÚÚ& +
<
ÚÚ, -
FirstUserIndex
ÚÚ. <
)
ÚÚ< =
return
ÛÛ 
	TryLegacy
ÛÛ  
(
ÛÛ  !
ref
ÛÛ! $
block
ÛÛ% *
)
ÛÛ* +
;
ÛÛ+ ,

TableEntry
ÙÙ 

tableEntry
ÙÙ !
=
ÙÙ" #
default
ÙÙ$ +
;
ÙÙ+ ,

tableEntry
ıı 
=
ıı 
block
ıı 
.
ıı 
Range
ıı $
.
ıı$ %
	Allocator
ıı% .
.
ıı. /

TableEntry
ıı/ 9
;
ıı9 :
var
ˆˆ 
function
ˆˆ 
=
ˆˆ 
new
ˆˆ 
FunctionPointer
ˆˆ .
<
ˆˆ. /
TryFunction
ˆˆ/ :
>
ˆˆ: ;
(
ˆˆ; <

tableEntry
ˆˆ< F
.
ˆˆF G
function
ˆˆG O
)
ˆˆO P
;
ˆˆP Q
if
˙˙ 
(
˙˙ 
block
˙˙ 
.
˙˙ 
Range
˙˙ 
.
˙˙ 
	Allocator
˙˙ $
.
˙˙$ %
Version
˙˙% ,
==
˙˙- /
$num
˙˙0 1
)
˙˙1 2
block
˚˚ 
.
˚˚ 
Range
˚˚ 
.
˚˚ 
	Allocator
˚˚ %
.
˚˚% &
Version
˚˚& -
=
˚˚. /
block
˚˚0 5
.
˚˚5 6
Range
˚˚6 ;
.
˚˚; <
	Allocator
˚˚< E
.
˚˚E F
OfficialVersion
˚˚F U
;
˚˚U V
if
ˇˇ 
(
ˇˇ 
UseDelegate
ˇˇ 
(
ˇˇ 
)
ˇˇ 
)
ˇˇ 
{
ÄÄ 
int
ÅÅ 
error
ÅÅ 
=
ÅÅ 

kErrorNone
ÅÅ &
;
ÅÅ& ')
forward_mono_allocate_block
ÇÇ +
(
ÇÇ+ ,
ref
ÇÇ, /
block
ÇÇ0 5
,
ÇÇ5 6
ref
ÇÇ7 :
error
ÇÇ; @
)
ÇÇ@ A
;
ÇÇA B
return
ÉÉ 
error
ÉÉ 
;
ÉÉ 
}
ÑÑ 
return
ÜÜ 
allocate_block
ÜÜ !
(
ÜÜ! "
ref
ÜÜ" %
block
ÜÜ& +
)
ÜÜ+ ,
;
ÜÜ, -
}
áá 	
[
åå 	
BurstCompile
åå	 
(
åå "
CompileSynchronously
åå *
=
åå+ ,
true
åå- 1
)
åå1 2
]
åå2 3
internal
çç 
struct
çç 
StackAllocator
çç &
:
çç' (

IAllocator
çç) 3
,
çç3 4
IDisposable
çç5 @
{
éé 	
public
èè 
AllocatorHandle
èè "
Handle
èè# )
{
èè* +
get
èè, /
{
èè0 1
return
èè2 8
m_handle
èè9 A
;
èèA B
}
èèC D
set
èèE H
{
èèI J
m_handle
èèK S
=
èèT U
value
èèV [
;
èè[ \
}
èè] ^
}
èè_ `
public
êê 
	Allocator
êê 
ToAllocator
êê (
{
êê) *
get
êê+ .
{
êê/ 0
return
êê1 7
m_handle
êê8 @
.
êê@ A
ToAllocator
êêA L
;
êêL M
}
êêN O
}
êêP Q
public
ëë 
bool
ëë 
IsCustomAllocator
ëë )
{
ëë* +
get
ëë, /
{
ëë0 1
return
ëë2 8
m_handle
ëë9 A
.
ëëA B
IsCustomAllocator
ëëB S
;
ëëS T
}
ëëU V
}
ëëW X
internal
ìì 
AllocatorHandle
ìì $
m_handle
ìì% -
;
ìì- .
internal
ïï 
Block
ïï 
	m_storage
ïï $
;
ïï$ %
internal
ññ 
long
ññ 
m_top
ññ 
;
ññ  
public
òò 
void
òò 

Initialize
òò "
(
òò" #
Block
òò# (
storage
òò) 0
)
òò0 1
{
ôô 
	m_storage
öö 
=
öö 
storage
öö #
;
öö# $
m_top
õõ 
=
õõ 
$num
õõ 
;
õõ 
	m_storage
ùù 
.
ùù 
Range
ùù 
.
ùù  
	Allocator
ùù  )
.
ùù) *
AddChildAllocator
ùù* ;
(
ùù; <
Handle
ùù< B
)
ùùB C
;
ùùC D
}
üü 
public
°° 
unsafe
°° 
int
°° 
Try
°° !
(
°°! "
ref
°°" %
Block
°°& +
block
°°, 1
)
°°1 2
{
¢¢ 
if
££ 
(
££ 
block
££ 
.
££ 
Range
££ 
.
££  
Pointer
££  '
==
££( *
IntPtr
££+ 1
.
££1 2
Zero
££2 6
)
££6 7
{
§§ 
if
•• 
(
•• 
m_top
•• 
+
•• 
block
••  %
.
••% &
Bytes
••& +
>
••, -
	m_storage
••. 7
.
••7 8
Bytes
••8 =
)
••= >
{
¶¶ 
return
ßß 
-
ßß  
$num
ßß  !
;
ßß! "
}
®® 
block
™™ 
.
™™ 
Range
™™ 
.
™™  
Pointer
™™  '
=
™™( )
(
™™* +
IntPtr
™™+ 1
)
™™1 2
(
™™2 3
(
™™3 4
byte
™™4 8
*
™™8 9
)
™™9 :
	m_storage
™™: C
.
™™C D
Range
™™D I
.
™™I J
Pointer
™™J Q
+
™™R S
m_top
™™T Y
)
™™Y Z
;
™™Z [
block
´´ 
.
´´ 
AllocatedItems
´´ (
=
´´) *
block
´´+ 0
.
´´0 1
Range
´´1 6
.
´´6 7
Items
´´7 <
;
´´< =
m_top
¨¨ 
+=
¨¨ 
block
¨¨ "
.
¨¨" #
Bytes
¨¨# (
;
¨¨( )
return
≠≠ 
$num
≠≠ 
;
≠≠ 
}
ÆÆ 
if
∞∞ 
(
∞∞ 
block
∞∞ 
.
∞∞ 
Bytes
∞∞ 
==
∞∞  "
$num
∞∞# $
)
∞∞$ %
{
±± 
if
≤≤ 
(
≤≤ 
(
≤≤ 
byte
≤≤ 
*
≤≤ 
)
≤≤ 
block
≤≤ $
.
≤≤$ %
Range
≤≤% *
.
≤≤* +
Pointer
≤≤+ 2
-
≤≤3 4
(
≤≤5 6
byte
≤≤6 :
*
≤≤: ;
)
≤≤; <
	m_storage
≤≤< E
.
≤≤E F
Range
≤≤F K
.
≤≤K L
Pointer
≤≤L S
==
≤≤T V
(
≤≤W X
long
≤≤X \
)
≤≤\ ]
(
≤≤] ^
m_top
≤≤^ c
-
≤≤d e
block
≤≤f k
.
≤≤k l
AllocatedBytes
≤≤l z
)
≤≤z {
)
≤≤{ |
{
≥≥ 
m_top
¥¥ 
-=
¥¥  
block
¥¥! &
.
¥¥& '
AllocatedBytes
¥¥' 5
;
¥¥5 6
var
µµ 
blockSizeInBytes
µµ ,
=
µµ- .
block
µµ/ 4
.
µµ4 5
AllocatedItems
µµ5 C
*
µµD E
block
µµF K
.
µµK L
BytesPerItem
µµL X
;
µµX Y
block
∂∂ 
.
∂∂ 
Range
∂∂ #
.
∂∂# $
Pointer
∂∂$ +
=
∂∂, -
IntPtr
∂∂. 4
.
∂∂4 5
Zero
∂∂5 9
;
∂∂9 :
block
∑∑ 
.
∑∑ 
AllocatedItems
∑∑ ,
=
∑∑- .
$num
∑∑/ 0
;
∑∑0 1
return
∏∏ 
$num
∏∏  
;
∏∏  !
}
ππ 
return
ªª 
-
ªª 
$num
ªª 
;
ªª 
}
ºº 
return
øø 
-
øø 
$num
øø 
;
øø 
}
¿¿ 
[
¬¬ 
BurstCompile
¬¬ 
(
¬¬ "
CompileSynchronously
¬¬ .
=
¬¬/ 0
true
¬¬1 5
)
¬¬5 6
]
¬¬6 7
[
√√ !
MonoPInvokeCallback
√√ 
(
√√ 
typeof
√√ 
(
√√ 
TryFunction
√√ *
)
√√* +
)
√√+ ,
]
√√, -
public
ƒƒ 
static
ƒƒ 
unsafe
ƒƒ  
int
ƒƒ! $
Try
ƒƒ% (
(
ƒƒ( )
IntPtr
ƒƒ) /
allocatorState
ƒƒ0 >
,
ƒƒ> ?
ref
ƒƒ@ C
Block
ƒƒD I
block
ƒƒJ O
)
ƒƒO P
{
≈≈ 
return
∆∆ 
(
∆∆ 
(
∆∆ 
StackAllocator
∆∆ '
*
∆∆' (
)
∆∆( )
allocatorState
∆∆) 7
)
∆∆7 8
->
∆∆8 :
Try
∆∆: =
(
∆∆= >
ref
∆∆> A
block
∆∆B G
)
∆∆G H
;
∆∆H I
}
«« 
public
…… 
TryFunction
…… 
Function
…… '
=>
……( *
Try
……+ .
;
……. /
public
ÀÀ 
void
ÀÀ 
Dispose
ÀÀ 
(
ÀÀ  
)
ÀÀ  !
{
ÃÃ 
m_handle
ÕÕ 
.
ÕÕ 
Rewind
ÕÕ 
(
ÕÕ  
)
ÕÕ  !
;
ÕÕ! "
}
ŒŒ 
}
œœ 	
[
‘‘ 	
BurstCompile
‘‘	 
(
‘‘ "
CompileSynchronously
‘‘ *
=
‘‘+ ,
true
‘‘- 1
)
‘‘1 2
]
‘‘2 3
internal
’’ 
struct
’’ 
SlabAllocator
’’ %
:
’’& '

IAllocator
’’( 2
,
’’2 3
IDisposable
’’4 ?
{
÷÷ 	
public
◊◊ 
AllocatorHandle
◊◊ "
Handle
◊◊# )
{
◊◊* +
get
◊◊, /
{
◊◊0 1
return
◊◊2 8
m_handle
◊◊9 A
;
◊◊A B
}
◊◊C D
set
◊◊E H
{
◊◊I J
m_handle
◊◊K S
=
◊◊T U
value
◊◊V [
;
◊◊[ \
}
◊◊] ^
}
◊◊_ `
public
ŸŸ 
	Allocator
ŸŸ 
ToAllocator
ŸŸ (
{
ŸŸ) *
get
ŸŸ+ .
{
ŸŸ/ 0
return
ŸŸ1 7
m_handle
ŸŸ8 @
.
ŸŸ@ A
ToAllocator
ŸŸA L
;
ŸŸL M
}
ŸŸN O
}
ŸŸP Q
public
€€ 
bool
€€ 
IsCustomAllocator
€€ )
{
€€* +
get
€€, /
{
€€0 1
return
€€2 8
m_handle
€€9 A
.
€€A B
IsCustomAllocator
€€B S
;
€€S T
}
€€U V
}
€€W X
internal
›› 
AllocatorHandle
›› $
m_handle
››% -
;
››- .
internal
ﬂﬂ 
Block
ﬂﬂ 
Storage
ﬂﬂ "
;
ﬂﬂ" #
internal
‡‡ 
int
‡‡ !
Log2SlabSizeInBytes
‡‡ ,
;
‡‡, -
internal
··  
FixedList4096Bytes
·· '
<
··' (
int
··( +
>
··+ ,
Occupied
··- 5
;
··5 6
internal
‚‚ 
long
‚‚ 
budgetInBytes
‚‚ '
;
‚‚' (
internal
„„ 
long
„„ 
allocatedBytes
„„ (
;
„„( )
public
ÂÂ 
long
ÂÂ 
BudgetInBytes
ÂÂ %
=>
ÂÂ& (
budgetInBytes
ÂÂ) 6
;
ÂÂ6 7
public
ÁÁ 
long
ÁÁ 
AllocatedBytes
ÁÁ &
=>
ÁÁ' )
allocatedBytes
ÁÁ* 8
;
ÁÁ8 9
internal
ÈÈ 
int
ÈÈ 
SlabSizeInBytes
ÈÈ (
{
ÍÍ 
get
ÎÎ 
=>
ÎÎ 
$num
ÎÎ 
<<
ÎÎ !
Log2SlabSizeInBytes
ÎÎ /
;
ÎÎ/ 0
set
ÏÏ 
=>
ÏÏ !
Log2SlabSizeInBytes
ÏÏ *
=
ÏÏ+ ,
(
ÏÏ- .
byte
ÏÏ. 2
)
ÏÏ2 3
(
ÏÏ3 4
$num
ÏÏ4 6
-
ÏÏ7 8
math
ÏÏ9 =
.
ÏÏ= >
lzcnt
ÏÏ> C
(
ÏÏC D
math
ÏÏD H
.
ÏÏH I
max
ÏÏI L
(
ÏÏL M
$num
ÏÏM N
,
ÏÏN O
value
ÏÏP U
)
ÏÏU V
-
ÏÏW X
$num
ÏÏY Z
)
ÏÏZ [
)
ÏÏ[ \
;
ÏÏ\ ]
}
ÌÌ 
internal
ÔÔ 
int
ÔÔ 
Slabs
ÔÔ 
=>
ÔÔ !
(
ÔÔ" #
int
ÔÔ# &
)
ÔÔ& '
(
ÔÔ' (
Storage
ÔÔ( /
.
ÔÔ/ 0
Bytes
ÔÔ0 5
>>
ÔÔ6 8!
Log2SlabSizeInBytes
ÔÔ9 L
)
ÔÔL M
;
ÔÔM N
internal
ÒÒ 
void
ÒÒ 

Initialize
ÒÒ $
(
ÒÒ$ %
Block
ÒÒ% *
storage
ÒÒ+ 2
,
ÒÒ2 3
int
ÒÒ4 7
slabSizeInBytes
ÒÒ8 G
,
ÒÒG H
long
ÒÒI M
budget
ÒÒN T
)
ÒÒT U
{
ÚÚ 
storage
ÙÙ 
.
ÙÙ 
Range
ÙÙ 
.
ÙÙ 
	Allocator
ÙÙ '
.
ÙÙ' (
AddChildAllocator
ÙÙ( 9
(
ÙÙ9 :
Handle
ÙÙ: @
)
ÙÙ@ A
;
ÙÙA B
Assert
ˆˆ 
.
ˆˆ 
IsTrue
ˆˆ 
(
ˆˆ 
(
ˆˆ 
slabSizeInBytes
ˆˆ .
&
ˆˆ/ 0
(
ˆˆ1 2
slabSizeInBytes
ˆˆ2 A
-
ˆˆB C
$num
ˆˆD E
)
ˆˆE F
)
ˆˆF G
==
ˆˆH J
$num
ˆˆK L
)
ˆˆL M
;
ˆˆM N
Storage
˜˜ 
=
˜˜ 
storage
˜˜ !
;
˜˜! "!
Log2SlabSizeInBytes
¯¯ #
=
¯¯$ %
$num
¯¯& '
;
¯¯' (
Occupied
˘˘ 
=
˘˘ 
default
˘˘ "
;
˘˘" #
budgetInBytes
˙˙ 
=
˙˙ 
budget
˙˙  &
;
˙˙& '
allocatedBytes
˚˚ 
=
˚˚  
$num
˚˚! "
;
˚˚" #
SlabSizeInBytes
¸¸ 
=
¸¸  !
slabSizeInBytes
¸¸" 1
;
¸¸1 2
Occupied
˝˝ 
.
˝˝ 
Length
˝˝ 
=
˝˝  !
(
˝˝" #
Slabs
˝˝# (
+
˝˝) *
$num
˝˝+ -
)
˝˝- .
/
˝˝/ 0
$num
˝˝1 3
;
˝˝3 4
}
˛˛ 
public
ÄÄ 
int
ÄÄ 
Try
ÄÄ 
(
ÄÄ 
ref
ÄÄ 
Block
ÄÄ $
block
ÄÄ% *
)
ÄÄ* +
{
ÅÅ 
if
ÇÇ 
(
ÇÇ 
block
ÇÇ 
.
ÇÇ 
Range
ÇÇ 
.
ÇÇ  
Pointer
ÇÇ  '
==
ÇÇ( *
IntPtr
ÇÇ+ 1
.
ÇÇ1 2
Zero
ÇÇ2 6
)
ÇÇ6 7
{
ÉÉ 
if
ÑÑ 
(
ÑÑ 
block
ÑÑ 
.
ÑÑ 
Bytes
ÑÑ #
+
ÑÑ$ %
allocatedBytes
ÑÑ& 4
>
ÑÑ5 6
budgetInBytes
ÑÑ7 D
)
ÑÑD E
return
ÖÖ 
-
ÖÖ  
$num
ÖÖ  !
;
ÖÖ! "
if
ÜÜ 
(
ÜÜ 
block
ÜÜ 
.
ÜÜ 
Bytes
ÜÜ #
>
ÜÜ$ %
SlabSizeInBytes
ÜÜ& 5
)
ÜÜ5 6
return
áá 
-
áá  
$num
áá  !
;
áá! "
for
àà 
(
àà 
var
àà 
	wordIndex
àà &
=
àà' (
$num
àà) *
;
àà* +
	wordIndex
àà, 5
<
àà6 7
Occupied
àà8 @
.
àà@ A
Length
ààA G
;
ààG H
++
ààI K
	wordIndex
ààK T
)
ààT U
{
ââ 
var
ää 
word
ää  
=
ää! "
Occupied
ää# +
[
ää+ ,
	wordIndex
ää, 5
]
ää5 6
;
ää6 7
if
ãã 
(
ãã 
word
ãã  
==
ãã! #
-
ãã$ %
$num
ãã% &
)
ãã& '
continue
åå $
;
åå$ %
for
çç 
(
çç 
var
çç  
bitIndex
çç! )
=
çç* +
$num
çç, -
;
çç- .
bitIndex
çç/ 7
<
çç8 9
$num
çç: <
;
çç< =
++
çç> @
bitIndex
çç@ H
)
ççH I
if
éé 
(
éé  
(
éé  !
word
éé! %
&
éé& '
(
éé( )
$num
éé) *
<<
éé+ -
bitIndex
éé. 6
)
éé6 7
)
éé7 8
==
éé9 ;
$num
éé< =
)
éé= >
{
èè 
Occupied
êê  (
[
êê( )
	wordIndex
êê) 2
]
êê2 3
|=
êê4 6
$num
êê7 8
<<
êê9 ;
bitIndex
êê< D
;
êêD E
block
ëë  %
.
ëë% &
Range
ëë& +
.
ëë+ ,
Pointer
ëë, 3
=
ëë4 5
Storage
ëë6 =
.
ëë= >
Range
ëë> C
.
ëëC D
Pointer
ëëD K
+
ëëL M
(
íí$ %
int
íí% (
)
íí( )
(
íí) *
SlabSizeInBytes
íí* 9
*
íí: ;
(
íí< =
	wordIndex
íí= F
*
ííG H
$num
ííI L
+
ííM N
bitIndex
ííO W
)
ííW X
)
ííX Y
;
ííY Z
block
ìì  %
.
ìì% &
AllocatedItems
ìì& 4
=
ìì5 6
SlabSizeInBytes
ìì7 F
/
ììG H
block
ììI N
.
ììN O
BytesPerItem
ììO [
;
ìì[ \
allocatedBytes
îî  .
+=
îî/ 1
block
îî2 7
.
îî7 8
Bytes
îî8 =
;
îî= >
return
ïï  &
$num
ïï' (
;
ïï( )
}
ññ 
}
óó 
return
ôô 
-
ôô 
$num
ôô 
;
ôô 
}
öö 
if
úú 
(
úú 
block
úú 
.
úú 
Bytes
úú 
==
úú  "
$num
úú# $
)
úú$ %
{
ùù 
var
ûû 
	slabIndex
ûû !
=
ûû" #
(
ûû$ %
(
ûû% &
ulong
ûû& +
)
ûû+ ,
block
ûû, 1
.
ûû1 2
Range
ûû2 7
.
ûû7 8
Pointer
ûû8 ?
-
ûû@ A
(
ûûB C
ulong
ûûC H
)
ûûH I
Storage
ûûI P
.
ûûP Q
Range
ûûQ V
.
ûûV W
Pointer
ûûW ^
)
ûû^ _
>>
ûû` b!
Log2SlabSizeInBytes
üü +
;
üü+ ,
int
†† 
	wordIndex
†† !
=
††" #
(
††$ %
int
††% (
)
††( )
(
††) *
	slabIndex
††* 3
>>
††4 6
$num
††7 8
)
††8 9
;
††9 :
int
°° 
bitIndex
°°  
=
°°! "
(
°°# $
int
°°$ '
)
°°' (
(
°°( )
	slabIndex
°°) 2
&
°°3 4
$num
°°5 7
)
°°7 8
;
°°8 9
Occupied
¢¢ 
[
¢¢ 
	wordIndex
¢¢ &
]
¢¢& '
&=
¢¢( *
~
¢¢+ ,
(
¢¢, -
$num
¢¢- .
<<
¢¢/ 1
bitIndex
¢¢2 :
)
¢¢: ;
;
¢¢; <
block
££ 
.
££ 
Range
££ 
.
££  
Pointer
££  '
=
££( )
IntPtr
££* 0
.
££0 1
Zero
££1 5
;
££5 6
var
§§ 
blockSizeInBytes
§§ (
=
§§) *
block
§§+ 0
.
§§0 1
AllocatedItems
§§1 ?
*
§§@ A
block
§§B G
.
§§G H
BytesPerItem
§§H T
;
§§T U
allocatedBytes
•• "
-=
••# %
blockSizeInBytes
••& 6
;
••6 7
block
¶¶ 
.
¶¶ 
AllocatedItems
¶¶ (
=
¶¶) *
$num
¶¶+ ,
;
¶¶, -
return
ßß 
$num
ßß 
;
ßß 
}
®® 
return
´´ 
-
´´ 
$num
´´ 
;
´´ 
}
¨¨ 
[
ÆÆ 
BurstCompile
ÆÆ 
(
ÆÆ "
CompileSynchronously
ÆÆ .
=
ÆÆ/ 0
true
ÆÆ1 5
)
ÆÆ5 6
]
ÆÆ6 7
[
ØØ !
MonoPInvokeCallback
ØØ 
(
ØØ 
typeof
ØØ 
(
ØØ 
TryFunction
ØØ *
)
ØØ* +
)
ØØ+ ,
]
ØØ, -
public
∞∞ 
static
∞∞ 
unsafe
∞∞  
int
∞∞! $
Try
∞∞% (
(
∞∞( )
IntPtr
∞∞) /
allocatorState
∞∞0 >
,
∞∞> ?
ref
∞∞@ C
Block
∞∞D I
block
∞∞J O
)
∞∞O P
{
±± 
return
≤≤ 
(
≤≤ 
(
≤≤ 
SlabAllocator
≤≤ &
*
≤≤& '
)
≤≤' (
allocatorState
≤≤( 6
)
≤≤6 7
->
≤≤7 9
Try
≤≤9 <
(
≤≤< =
ref
≤≤= @
block
≤≤A F
)
≤≤F G
;
≤≤G H
}
≥≥ 
public
µµ 
TryFunction
µµ 
Function
µµ '
=>
µµ( *
Try
µµ+ .
;
µµ. /
public
∑∑ 
void
∑∑ 
Dispose
∑∑ 
(
∑∑  
)
∑∑  !
{
∏∏ 
m_handle
ππ 
.
ππ 
Rewind
ππ 
(
ππ  
)
ππ  !
;
ππ! "
}
∫∫ 
}
ªª 	
internal
ΩΩ 
struct
ΩΩ 

TableEntry
ΩΩ "
{
ææ 	
internal
øø 
IntPtr
øø 
function
øø $
;
øø$ %
internal
¿¿ 
IntPtr
¿¿ 
state
¿¿ !
;
¿¿! "
}
¡¡ 	
internal
√√ 
struct
√√ 
Array16
√√ 
<
√√  
T
√√  !
>
√√! "
where
√√# (
T
√√) *
:
√√+ ,
	unmanaged
√√- 6
{
ƒƒ 	
internal
≈≈ 
T
≈≈ 
f0
≈≈ 
,
≈≈ 
f1
≈≈ 
,
≈≈ 
f2
≈≈ !
,
≈≈! "
f3
≈≈# %
,
≈≈% &
f4
≈≈' )
,
≈≈) *
f5
≈≈+ -
,
≈≈- .
f6
≈≈/ 1
,
≈≈1 2
f7
≈≈3 5
,
≈≈5 6
f8
≈≈7 9
,
≈≈9 :
f9
≈≈; =
,
≈≈= >
f10
≈≈? B
,
≈≈B C
f11
≈≈D G
,
≈≈G H
f12
≈≈I L
,
≈≈L M
f13
≈≈N Q
,
≈≈Q R
f14
≈≈S V
,
≈≈V W
f15
≈≈X [
;
≈≈[ \
}
∆∆ 	
internal
«« 
struct
«« 
Array256
««  
<
««  !
T
««! "
>
««" #
where
««$ )
T
««* +
:
««, -
	unmanaged
««. 7
{
»» 	
internal
…… 
Array16
…… 
<
…… 
T
…… 
>
…… 
f0
……  "
,
……" #
f1
……$ &
,
……& '
f2
……( *
,
……* +
f3
……, .
,
……. /
f4
……0 2
,
……2 3
f5
……4 6
,
……6 7
f6
……8 :
,
……: ;
f7
……< >
,
……> ?
f8
……@ B
,
……B C
f9
……D F
,
……F G
f10
……H K
,
……K L
f11
……M P
,
……P Q
f12
……R U
,
……U V
f13
……W Z
,
……Z [
f14
……\ _
,
……_ `
f15
……a d
;
……d e
}
   	
internal
ÀÀ 
struct
ÀÀ 
	Array4096
ÀÀ !
<
ÀÀ! "
T
ÀÀ" #
>
ÀÀ# $
where
ÀÀ% *
T
ÀÀ+ ,
:
ÀÀ- .
	unmanaged
ÀÀ/ 8
{
ÃÃ 	
internal
ÕÕ 
Array256
ÕÕ 
<
ÕÕ 
T
ÕÕ 
>
ÕÕ  
f0
ÕÕ! #
,
ÕÕ# $
f1
ÕÕ% '
,
ÕÕ' (
f2
ÕÕ) +
,
ÕÕ+ ,
f3
ÕÕ- /
,
ÕÕ/ 0
f4
ÕÕ1 3
,
ÕÕ3 4
f5
ÕÕ5 7
,
ÕÕ7 8
f6
ÕÕ9 ;
,
ÕÕ; <
f7
ÕÕ= ?
,
ÕÕ? @
f8
ÕÕA C
,
ÕÕC D
f9
ÕÕE G
,
ÕÕG H
f10
ÕÕI L
,
ÕÕL M
f11
ÕÕN Q
,
ÕÕQ R
f12
ÕÕS V
,
ÕÕV W
f13
ÕÕX [
,
ÕÕ[ \
f14
ÕÕ] `
,
ÕÕ` a
f15
ÕÕb e
;
ÕÕe f
}
ŒŒ 	
internal
œœ 
struct
œœ 

Array32768
œœ "
<
œœ" #
T
œœ# $
>
œœ$ %
:
œœ& '

IIndexable
œœ( 2
<
œœ2 3
T
œœ3 4
>
œœ4 5
where
œœ6 ;
T
œœ< =
:
œœ> ?
	unmanaged
œœ@ I
{
–– 	
internal
—— 
	Array4096
—— 
<
—— 
T
——  
>
——  !
f0
——" $
,
——$ %
f1
——& (
,
——( )
f2
——* ,
,
——, -
f3
——. 0
,
——0 1
f4
——2 4
,
——4 5
f5
——6 8
,
——8 9
f6
——: <
,
——< =
f7
——> @
;
——@ A
public
““ 
int
““ 
Length
““ 
{
““ 
get
““  #
{
““$ %
return
““& ,
$num
““- 2
;
““2 3
}
““4 5
set
““6 9
{
““: ;
}
““; <
}
““= >
public
”” 
ref
”” 
T
”” 
	ElementAt
”” "
(
””" #
int
””# &
index
””' ,
)
””, -
{
‘‘ 
unsafe
’’ 
{
’’ 
fixed
’’ 
(
’’ 
	Array4096
’’ (
<
’’( )
T
’’) *
>
’’* +
*
’’+ ,
p
’’- .
=
’’/ 0
&
’’1 2
f0
’’2 4
)
’’4 5
{
’’6 7
return
’’8 >
ref
’’? B
UnsafeUtility
’’C P
.
’’P Q
AsRef
’’Q V
<
’’V W
T
’’W X
>
’’X Y
(
’’Y Z
(
’’Z [
T
’’[ \
*
’’\ ]
)
’’] ^
p
’’^ _
+
’’` a
index
’’b g
)
’’g h
;
’’h i
}
’’j k
}
’’l m
}
÷÷ 
}
◊◊ 	
internal
‹‹ 
sealed
‹‹ 
class
‹‹ 
SharedStatics
‹‹ +
{
›› 	
internal
ﬁﬁ 
sealed
ﬁﬁ 
class
ﬁﬁ !
IsInstalled
ﬁﬁ" -
{
ﬁﬁ. /
internal
ﬁﬁ0 8
static
ﬁﬁ9 ?
readonly
ﬁﬁ@ H
SharedStatic
ﬁﬁI U
<
ﬁﬁU V
Long1024
ﬁﬁV ^
>
ﬁﬁ^ _
Ref
ﬁﬁ` c
=
ﬁﬁd e
SharedStatic
ﬁﬁf r
<
ﬁﬁr s
Long1024
ﬁﬁs {
>
ﬁﬁ{ |
.
ﬁﬁ| }
GetOrCreateﬁﬁ} à
<ﬁﬁà â
IsInstalledﬁﬁâ î
>ﬁﬁî ï
(ﬁﬁï ñ
)ﬁﬁñ ó
;ﬁﬁó ò
}ﬁﬁô ö
internal
ﬂﬂ 
sealed
ﬂﬂ 
class
ﬂﬂ !

TableEntry
ﬂﬂ" ,
{
ﬂﬂ- .
internal
ﬂﬂ/ 7
static
ﬂﬂ8 >
readonly
ﬂﬂ? G
SharedStatic
ﬂﬂH T
<
ﬂﬂT U

Array32768
ﬂﬂU _
<
ﬂﬂ_ `
AllocatorManager
ﬂﬂ` p
.
ﬂﬂp q

TableEntry
ﬂﬂq {
>
ﬂﬂ{ |
>
ﬂﬂ| }
Refﬂﬂ~ Å
=ﬂﬂÇ É
SharedStaticﬂﬂÑ ê
<ﬂﬂê ë

Array32768ﬂﬂë õ
<ﬂﬂõ ú 
AllocatorManagerﬂﬂú ¨
.ﬂﬂ¨ ≠

TableEntryﬂﬂ≠ ∑
>ﬂﬂ∑ ∏
>ﬂﬂ∏ π
.ﬂﬂπ ∫
GetOrCreateﬂﬂ∫ ≈
<ﬂﬂ≈ ∆

TableEntryﬂﬂ∆ –
>ﬂﬂ– —
(ﬂﬂ— “
)ﬂﬂ“ ”
;ﬂﬂ” ‘
}ﬂﬂ’ ÷
internal
·· 
sealed
·· 
class
·· !
Version
··" )
{
··* +
internal
··, 4
static
··5 ;
readonly
··< D
SharedStatic
··E Q
<
··Q R

Array32768
··R \
<
··\ ]
ushort
··] c
>
··c d
>
··d e
Ref
··f i
=
··j k
SharedStatic
··l x
<
··x y

Array32768··y É
<··É Ñ
ushort··Ñ ä
>··ä ã
>··ã å
.··å ç
GetOrCreate··ç ò
<··ò ô
Version··ô †
>··† °
(··° ¢
)··¢ £
;··£ §
}··• ¶
internal
‚‚ 
sealed
‚‚ 
class
‚‚ ! 
ChildSafetyHandles
‚‚" 4
{
‚‚5 6
internal
‚‚7 ?
static
‚‚@ F
readonly
‚‚G O
SharedStatic
‚‚P \
<
‚‚\ ]

Array32768
‚‚] g
<
‚‚g h

UnsafeList
‚‚h r
<
‚‚r s!
AtomicSafetyHandle‚‚s Ö
>‚‚Ö Ü
>‚‚Ü á
>‚‚á à
Ref‚‚â å
=‚‚ç é
SharedStatic‚‚è õ
<‚‚õ ú

Array32768‚‚ú ¶
<‚‚¶ ß

UnsafeList‚‚ß ±
<‚‚± ≤"
AtomicSafetyHandle‚‚≤ ƒ
>‚‚ƒ ≈
>‚‚≈ ∆
>‚‚∆ «
.‚‚« »
GetOrCreate‚‚» ”
<‚‚” ‘"
ChildSafetyHandles‚‚‘ Ê
>‚‚Ê Á
(‚‚Á Ë
)‚‚Ë È
;‚‚È Í
}‚‚Î Ï
internal
„„ 
sealed
„„ 
class
„„ !
ChildAllocators
„„" 1
{
„„2 3
internal
„„4 <
static
„„= C
readonly
„„D L
SharedStatic
„„M Y
<
„„Y Z

Array32768
„„Z d
<
„„d e

UnsafeList
„„e o
<
„„o p
AllocatorHandle
„„p 
>„„ Ä
>„„Ä Å
>„„Å Ç
Ref„„É Ü
=„„á à
SharedStatic„„â ï
<„„ï ñ

Array32768„„ñ †
<„„† °

UnsafeList„„° ´
<„„´ ¨
AllocatorHandle„„¨ ª
>„„ª º
>„„º Ω
>„„Ω æ
.„„æ ø
GetOrCreate„„ø  
<„„  À
ChildAllocators„„À ⁄
>„„⁄ €
(„„€ ‹
)„„‹ ›
;„„› ﬁ
}„„ﬂ ‡
internal
‰‰ 
sealed
‰‰ 
class
‰‰ !
Parent
‰‰" (
{
‰‰) *
internal
‰‰+ 3
static
‰‰4 :
readonly
‰‰; C
SharedStatic
‰‰D P
<
‰‰P Q

Array32768
‰‰Q [
<
‰‰[ \
AllocatorHandle
‰‰\ k
>
‰‰k l
>
‰‰l m
Ref
‰‰n q
=
‰‰r s
SharedStatic‰‰t Ä
<‰‰Ä Å

Array32768‰‰Å ã
<‰‰ã å
AllocatorHandle‰‰å õ
>‰‰õ ú
>‰‰ú ù
.‰‰ù û
GetOrCreate‰‰û ©
<‰‰© ™
Parent‰‰™ ∞
>‰‰∞ ±
(‰‰± ≤
)‰‰≤ ≥
;‰‰≥ ¥
}‰‰µ ∂
internal
ÂÂ 
sealed
ÂÂ 
class
ÂÂ !
IndexInParent
ÂÂ" /
{
ÂÂ0 1
internal
ÂÂ2 :
static
ÂÂ; A
readonly
ÂÂB J
SharedStatic
ÂÂK W
<
ÂÂW X

Array32768
ÂÂX b
<
ÂÂb c
int
ÂÂc f
>
ÂÂf g
>
ÂÂg h
Ref
ÂÂi l
=
ÂÂm n
SharedStatic
ÂÂo {
<
ÂÂ{ |

Array32768ÂÂ| Ü
<ÂÂÜ á
intÂÂá ä
>ÂÂä ã
>ÂÂã å
.ÂÂå ç
GetOrCreateÂÂç ò
<ÂÂò ô
IndexInParentÂÂô ¶
>ÂÂ¶ ß
(ÂÂß ®
)ÂÂ® ©
;ÂÂ© ™
}ÂÂ´ ¨
}
ÁÁ 	
internal
ÈÈ 
static
ÈÈ 
class
ÈÈ 
Managed
ÈÈ %
{
ÍÍ 	
internal
ÔÔ 
const
ÔÔ 
int
ÔÔ $
kMaxNumCustomAllocator
ÔÔ 5
=
ÔÔ6 7
$num
ÔÔ8 =
;
ÔÔ= >
internal
 
static
 
TryFunction
 '
[
' (
]
( )"
TryFunctionDelegates
* >
=
? @
new
A D
TryFunction
E P
[
P Q$
kMaxNumCustomAllocator
Q g
]
g h
;
h i
[
¯¯  
NotBurstCompatible
¯¯ 
]
¯¯  
public
˘˘ 
static
˘˘ 
void
˘˘ 
RegisterDelegate
˘˘ /
(
˘˘/ 0
int
˘˘0 3
index
˘˘4 9
,
˘˘9 :
TryFunction
˘˘; F
function
˘˘G O
)
˘˘O P
{
˙˙ 
if
¸¸ 
(
¸¸ 
index
¸¸ 
>=
¸¸ $
kMaxNumCustomAllocator
¸¸ 2
)
¸¸2 3
{
˝˝ 
throw
˛˛ 
new
˛˛ 
ArgumentException
˛˛ /
(
˛˛/ 0
$str
˛˛0 w
)
˛˛w x
;
˛˛x y
}
ˇˇ 
Managed
Å	Å	 
.
Å	Å	 "
TryFunctionDelegates
Å	Å	 ,
[
Å	Å	, -
index
Å	Å	- 2
]
Å	Å	2 3
=
Å	Å	4 5
function
Å	Å	6 >
;
Å	Å	> ?
}
É	É	 
[
â	â	  
NotBurstCompatible
â	â	 
]
â	â	  
public
ä	ä	 
static
ä	ä	 
void
ä	ä	  
UnregisterDelegate
ä	ä	 1
(
ä	ä	1 2
int
ä	ä	2 5
index
ä	ä	6 ;
)
ä	ä	; <
{
ã	ã	 
if
ç	ç	 
(
ç	ç	 
index
ç	ç	 
>=
ç	ç	 $
kMaxNumCustomAllocator
ç	ç	 3
)
ç	ç	3 4
{
é	é	 
throw
è	è	 
new
è	è	 
ArgumentException
è	è	 /
(
è	è	/ 0
$str
è	è	0 y
)
è	è	y z
;
è	è	z {
}
ê	ê	 
Managed
ë	ë	 
.
ë	ë	 "
TryFunctionDelegates
ë	ë	 ,
[
ë	ë	, -
index
ë	ë	- 2
]
ë	ë	2 3
=
ë	ë	4 5
default
ë	ë	6 =
;
ë	ë	= >
}
ì	ì	 
}
î	î	 	
public
ô	ô	 
static
ô	ô	 
void
ô	ô	 

Initialize
ô	ô	 %
(
ô	ô	% &
)
ô	ô	& '
{
ö	ö	 	
}
õ	õ	 	
internal
§	§	 
static
§	§	 
void
§	§	 
Install
§	§	 $
(
§	§	$ %
AllocatorHandle
§	§	% 4
handle
§	§	5 ;
,
§	§	; <
IntPtr
•	•	( .
allocatorState
•	•	/ =
,
•	•	= >
FunctionPointer
¶	¶	( 7
<
¶	¶	7 8
TryFunction
¶	¶	8 C
>
¶	¶	C D
functionPointer
¶	¶	E T
,
¶	¶	T U
TryFunction
ß	ß	( 3
function
ß	ß	4 <
)
ß	ß	< =
{
®	®	 	
if
©	©	 
(
©	©	 
functionPointer
©	©	 
.
©	©	 
Value
©	©	 $
==
©	©	% '
IntPtr
©	©	( .
.
©	©	. /
Zero
©	©	/ 3
)
©	©	3 4
handle
™	™	 
.
™	™	 

Unregister
™	™	 !
(
™	™	! "
)
™	™	" #
;
™	™	# $
else
´	´	 
{
¨	¨	 
int
≠	≠	 
error
≠	≠	 
=
≠	≠	 
ConcurrentMask
≠	≠	 *
.
≠	≠	* +
TryAllocate
≠	≠	+ 6
(
≠	≠	6 7
ref
≠	≠	7 :
SharedStatics
≠	≠	; H
.
≠	≠	H I
IsInstalled
≠	≠	I T
.
≠	≠	T U
Ref
≠	≠	U X
.
≠	≠	X Y
Data
≠	≠	Y ]
,
≠	≠	] ^
handle
≠	≠	_ e
.
≠	≠	e f
Value
≠	≠	f k
,
≠	≠	k l
$num
≠	≠	m n
)
≠	≠	n o
;
≠	≠	o p
if
Æ	Æ	 
(
Æ	Æ	 
ConcurrentMask
Æ	Æ	 "
.
Æ	Æ	" #
	Succeeded
Æ	Æ	# ,
(
Æ	Æ	, -
error
Æ	Æ	- 2
)
Æ	Æ	2 3
)
Æ	Æ	3 4
{
Ø	Ø	 
handle
∞	∞	 
.
∞	∞	 
Install
∞	∞	 "
(
∞	∞	" #
new
∞	∞	# &

TableEntry
∞	∞	' 1
{
∞	∞	2 3
state
∞	∞	4 9
=
∞	∞	: ;
allocatorState
∞	∞	< J
,
∞	∞	J K
function
∞	∞	L T
=
∞	∞	U V
functionPointer
∞	∞	W f
.
∞	∞	f g
Value
∞	∞	g l
}
∞	∞	m n
)
∞	∞	n o
;
∞	∞	o p
Managed
±	±	 
.
±	±	 
RegisterDelegate
±	±	 ,
(
±	±	, -
handle
±	±	- 3
.
±	±	3 4
Index
±	±	4 9
,
±	±	9 :
function
±	±	; C
)
±	±	C D
;
±	±	D E
}
≤	≤	 
}
≥	≥	 
}
¥	¥	 	
internal
º	º	 
static
º	º	 
void
º	º	 
Install
º	º	 $
(
º	º	$ %
AllocatorHandle
º	º	% 4
handle
º	º	5 ;
,
º	º	; <
IntPtr
º	º	= C
allocatorState
º	º	D R
,
º	º	R S
TryFunction
º	º	T _
function
º	º	` h
)
º	º	h i
{
Ω	Ω	 	
var
æ	æ	 
functionPointer
æ	æ	 
=
æ	æ	  !
(
æ	æ	" #
function
æ	æ	# +
==
æ	æ	, .
null
æ	æ	/ 3
)
æ	æ	3 4
?
ø	ø	 
new
ø	ø	 
FunctionPointer
ø	ø	 %
<
ø	ø	% &
TryFunction
ø	ø	& 1
>
ø	ø	1 2
(
ø	ø	2 3
IntPtr
ø	ø	3 9
.
ø	ø	9 :
Zero
ø	ø	: >
)
ø	ø	> ?
:
¿	¿	 
BurstCompiler
¿	¿	 
.
¿	¿	  $
CompileFunctionPointer
¿	¿	  6
(
¿	¿	6 7
function
¿	¿	7 ?
)
¿	¿	? @
;
¿	¿	@ A
Install
¡	¡	 
(
¡	¡	 
handle
¡	¡	 
,
¡	¡	 
allocatorState
¡	¡	 *
,
¡	¡	* +
functionPointer
¡	¡	, ;
,
¡	¡	; <
function
¡	¡	= E
)
¡	¡	E F
;
¡	¡	F G
}
¬	¬	 	
internal
 	 	 
static
 	 	 
AllocatorHandle
 	 	 '
Register
 	 	( 0
(
 	 	0 1
IntPtr
 	 	1 7
allocatorState
 	 	8 F
,
 	 	F G
FunctionPointer
 	 	H W
<
 	 	W X
TryFunction
 	 	X c
>
 	 	c d
functionPointer
 	 	e t
)
 	 	t u
{
À	À	 	
var
Ã	Ã	 

tableEntry
Ã	Ã	 
=
Ã	Ã	 
new
Ã	Ã	  

TableEntry
Ã	Ã	! +
{
Ã	Ã	, -
state
Ã	Ã	. 3
=
Ã	Ã	4 5
allocatorState
Ã	Ã	6 D
,
Ã	Ã	D E
function
Ã	Ã	F N
=
Ã	Ã	O P
functionPointer
Ã	Ã	Q `
.
Ã	Ã	` a
Value
Ã	Ã	a f
}
Ã	Ã	g h
;
Ã	Ã	h i
var
Õ	Õ	 
error
Õ	Õ	 
=
Õ	Õ	 
ConcurrentMask
Õ	Õ	 &
.
Õ	Õ	& '
TryAllocate
Õ	Õ	' 2
(
Õ	Õ	2 3
ref
Õ	Õ	3 6
SharedStatics
Õ	Õ	7 D
.
Õ	Õ	D E
IsInstalled
Õ	Õ	E P
.
Õ	Õ	P Q
Ref
Õ	Õ	Q T
.
Õ	Õ	T U
Data
Õ	Õ	U Y
,
Õ	Õ	Y Z
out
Õ	Õ	[ ^
int
Õ	Õ	_ b
offset
Õ	Õ	c i
,
Õ	Õ	i j
(
Õ	Õ	k l
FirstUserIndex
Õ	Õ	l z
+
Õ	Õ	z {
$num
Õ	Õ	{ }
)
Õ	Õ	} ~
>>Õ	Õ	~ Ä
$numÕ	Õ	Ä Å
,Õ	Õ	Å Ç
SharedStaticsÕ	Õ	É ê
.Õ	Õ	ê ë
IsInstalledÕ	Õ	ë ú
.Õ	Õ	ú ù
RefÕ	Õ	ù †
.Õ	Õ	† °
DataÕ	Õ	° •
.Õ	Õ	• ¶
LengthÕ	Õ	¶ ¨
,Õ	Õ	¨ ≠
$numÕ	Õ	Æ Ø
)Õ	Õ	Ø ∞
;Õ	Õ	∞ ±
AllocatorHandle
Œ	Œ	 
handle
Œ	Œ	 "
=
Œ	Œ	# $
default
Œ	Œ	% ,
;
Œ	Œ	, -
if
œ	œ	 
(
œ	œ	 
ConcurrentMask
œ	œ	 
.
œ	œ	 
	Succeeded
œ	œ	 '
(
œ	œ	' (
error
œ	œ	( -
)
œ	œ	- .
)
œ	œ	. /
{
–	–	 
handle
—	—	 
.
—	—	 
Index
—	—	 
=
—	—	 
(
—	—	  
ushort
—	—	  &
)
—	—	& '
offset
—	—	' -
;
—	—	- .
handle
“	“	 
.
“	“	 
Install
“	“	 
(
“	“	 

tableEntry
“	“	 )
)
“	“	) *
;
“	“	* +
handle
‘	‘	 
.
‘	‘	 
Version
‘	‘	 
=
‘	‘	  
handle
‘	‘	! '
.
‘	‘	' (
OfficialVersion
‘	‘	( 7
;
‘	‘	7 8
}
÷	÷	 
return
◊	◊	 
handle
◊	◊	 
;
◊	◊	 
}
ÿ	ÿ	 	
[
ﬂ	ﬂ	 	 
NotBurstCompatible
ﬂ	ﬂ		 
]
ﬂ	ﬂ	 
public
‡	‡	 
static
‡	‡	 
unsafe
‡	‡	 
void
‡	‡	 !
Register
‡	‡	" *
<
‡	‡	* +
T
‡	‡	+ ,
>
‡	‡	, -
(
‡	‡	- .
ref
‡	‡	. 1
this
‡	‡	2 6
T
‡	‡	7 8
t
‡	‡	9 :
)
‡	‡	: ;
where
‡	‡	< A
T
‡	‡	B C
:
‡	‡	D E
	unmanaged
‡	‡	F O
,
‡	‡	O P

IAllocator
‡	‡	Q [
{
·	·	 	
var
‚	‚	 
functionPointer
‚	‚	 
=
‚	‚	  !
(
‚	‚	" #
t
‚	‚	# $
.
‚	‚	$ %
Function
‚	‚	% -
==
‚	‚	. 0
null
‚	‚	1 5
)
‚	‚	5 6
?
„	„	 
new
„	„	 
FunctionPointer
„	„	 %
<
„	„	% &
TryFunction
„	„	& 1
>
„	„	1 2
(
„	„	2 3
IntPtr
„	„	3 9
.
„	„	9 :
Zero
„	„	: >
)
„	„	> ?
:
‰	‰	 
BurstCompiler
‰	‰	 
.
‰	‰	  $
CompileFunctionPointer
‰	‰	  6
(
‰	‰	6 7
t
‰	‰	7 8
.
‰	‰	8 9
Function
‰	‰	9 A
)
‰	‰	A B
;
‰	‰	B C
t
Â	Â	 
.
Â	Â	 
Handle
Â	Â	 
=
Â	Â	 
Register
Â	Â	 
(
Â	Â	  
(
Â	Â	  !
IntPtr
Â	Â	! '
)
Â	Â	' (
UnsafeUtility
Â	Â	( 5
.
Â	Â	5 6
	AddressOf
Â	Â	6 ?
(
Â	Â	? @
ref
Â	Â	@ C
t
Â	Â	D E
)
Â	Â	E F
,
Â	Â	F G
functionPointer
Â	Â	H W
)
Â	Â	W X
;
Â	Â	X Y
Managed
Á	Á	 
.
Á	Á	 
RegisterDelegate
Á	Á	 $
(
Á	Á	$ %
t
Á	Á	% &
.
Á	Á	& '
Handle
Á	Á	' -
.
Á	Á	- .
Index
Á	Á	. 3
,
Á	Á	3 4
t
Á	Á	5 6
.
Á	Á	6 7
Function
Á	Á	7 ?
)
Á	Á	? @
;
Á	Á	@ A
if
Í	Í	 
(
Í	Í	 
!
Í	Í	 
t
Í	Í	 
.
Í	Í	 
Handle
Í	Í	 
.
Í	Í	 
IsValid
Í	Í	 !
)
Í	Í	! "
throw
Î	Î	 
new
Î	Î	 '
InvalidOperationException
Î	Î	 3
(
Î	Î	3 4
$str
Î	Î	4 {
)
Î	Î	{ |
;
Î	Î	| }
}
Ì	Ì	 	
public
Ù	Ù	 
static
Ù	Ù	 
void
Ù	Ù	 !
UnmanagedUnregister
Ù	Ù	 .
<
Ù	Ù	. /
T
Ù	Ù	/ 0
>
Ù	Ù	0 1
(
Ù	Ù	1 2
ref
Ù	Ù	2 5
this
Ù	Ù	6 :
T
Ù	Ù	; <
t
Ù	Ù	= >
)
Ù	Ù	> ?
where
Ù	Ù	@ E
T
Ù	Ù	F G
:
Ù	Ù	H I
	unmanaged
Ù	Ù	J S
,
Ù	Ù	S T

IAllocator
Ù	Ù	U _
{
ı	ı	 	
if
ˆ	ˆ	 
(
ˆ	ˆ	 
t
ˆ	ˆ	 
.
ˆ	ˆ	 
Handle
ˆ	ˆ	 
.
ˆ	ˆ	 
IsInstalled
ˆ	ˆ	 #
)
ˆ	ˆ	# $
{
˜	˜	 
t
¯	¯	 
.
¯	¯	 
Handle
¯	¯	 
.
¯	¯	 
Install
¯	¯	  
(
¯	¯	  !
default
¯	¯	! (
)
¯	¯	( )
;
¯	¯	) *
ConcurrentMask
˘	˘	 
.
˘	˘	 
TryFree
˘	˘	 &
(
˘	˘	& '
ref
˘	˘	' *
SharedStatics
˘	˘	+ 8
.
˘	˘	8 9
IsInstalled
˘	˘	9 D
.
˘	˘	D E
Ref
˘	˘	E H
.
˘	˘	H I
Data
˘	˘	I M
,
˘	˘	M N
t
˘	˘	O P
.
˘	˘	P Q
Handle
˘	˘	Q W
.
˘	˘	W X
Value
˘	˘	X ]
,
˘	˘	] ^
$num
˘	˘	_ `
)
˘	˘	` a
;
˘	˘	a b
}
˙	˙	 
}
˚	˚	 	
[
Ç
Ç
 	 
NotBurstCompatible
Ç
Ç
	 
]
Ç
Ç
 
public
É
É
 
static
É
É
 
void
É
É
 

Unregister
É
É
 %
<
É
É
% &
T
É
É
& '
>
É
É
' (
(
É
É
( )
ref
É
É
) ,
this
É
É
- 1
T
É
É
2 3
t
É
É
4 5
)
É
É
5 6
where
É
É
7 <
T
É
É
= >
:
É
É
? @
	unmanaged
É
É
A J
,
É
É
J K

IAllocator
É
É
L V
{
Ñ
Ñ
 	
if
Ö
Ö
 
(
Ö
Ö
 
t
Ö
Ö
 
.
Ö
Ö
 
Handle
Ö
Ö
 
.
Ö
Ö
 
IsInstalled
Ö
Ö
 #
)
Ö
Ö
# $
{
Ü
Ü
 
t
á
á
 
.
á
á
 
Handle
á
á
 
.
á
á
 
Install
á
á
  
(
á
á
  !
default
á
á
! (
)
á
á
( )
;
á
á
) *
ConcurrentMask
à
à
 
.
à
à
 
TryFree
à
à
 &
(
à
à
& '
ref
à
à
' *
SharedStatics
à
à
+ 8
.
à
à
8 9
IsInstalled
à
à
9 D
.
à
à
D E
Ref
à
à
E H
.
à
à
H I
Data
à
à
I M
,
à
à
M N
t
à
à
O P
.
à
à
P Q
Handle
à
à
Q W
.
à
à
W X
Value
à
à
X ]
,
à
à
] ^
$num
à
à
_ `
)
à
à
` a
;
à
à
a b
Managed
â
â
 
.
â
â
  
UnregisterDelegate
â
â
 *
(
â
â
* +
t
â
â
+ ,
.
â
â
, -
Handle
â
â
- 3
.
â
â
3 4
Index
â
â
4 9
)
â
â
9 :
;
â
â
: ;
}
ä
ä
 
}
ã
ã
 	
[
ì
ì
 	 
NotBurstCompatible
ì
ì
	 
]
ì
ì
 
internal
î
î
 
static
î
î
 
ref
î
î
 
T
î
î
 
CreateAllocator
î
î
 -
<
î
î
- .
T
î
î
. /
>
î
î
/ 0
(
î
î
0 1
AllocatorHandle
î
î
1 @
backingAllocator
î
î
A Q
)
î
î
Q R
where
ï
ï
 
T
ï
ï
 
:
ï
ï
 
	unmanaged
ï
ï
 
,
ï
ï
  

IAllocator
ï
ï
! +
{
ñ
ñ
 	
unsafe
ó
ó
 
{
ò
ò
 
var
ô
ô
 
allocatorPtr
ô
ô
  
=
ô
ô
! "
(
ô
ô
# $
T
ô
ô
$ %
*
ô
ô
% &
)
ô
ô
& '
Memory
ô
ô
' -
.
ô
ô
- .
	Unmanaged
ô
ô
. 7
.
ô
ô
7 8
Allocate
ô
ô
8 @
(
ô
ô
@ A
UnsafeUtility
ô
ô
A N
.
ô
ô
N O
SizeOf
ô
ô
O U
<
ô
ô
U V
T
ô
ô
V W
>
ô
ô
W X
(
ô
ô
X Y
)
ô
ô
Y Z
,
ô
ô
Z [
$num
ô
ô
\ ^
,
ô
ô
^ _
backingAllocator
ô
ô
` p
)
ô
ô
p q
;
ô
ô
q r
*
ö
ö
 
allocatorPtr
ö
ö
 
=
ö
ö
 
default
ö
ö
  '
;
ö
ö
' (
ref
õ
õ
 
T
õ
õ
 
	allocator
õ
õ
 
=
õ
õ
  !
ref
õ
õ
" %
UnsafeUtility
õ
õ
& 3
.
õ
õ
3 4
AsRef
õ
õ
4 9
<
õ
õ
9 :
T
õ
õ
: ;
>
õ
õ
; <
(
õ
õ
< =
allocatorPtr
õ
õ
= I
)
õ
õ
I J
;
õ
õ
J K
Register
ú
ú
 
(
ú
ú
 
ref
ú
ú
 
	allocator
ú
ú
 &
)
ú
ú
& '
;
ú
ú
' (
return
ù
ù
 
ref
ù
ù
 
	allocator
ù
ù
 $
;
ù
ù
$ %
}
û
û
 
}
ü
ü
 	
[
ß
ß
 	 
NotBurstCompatible
ß
ß
	 
]
ß
ß
 
internal
®
®
 
static
®
®
 
void
®
®
 
DestroyAllocator
®
®
 -
<
®
®
- .
T
®
®
. /
>
®
®
/ 0
(
®
®
0 1
ref
®
®
1 4
this
®
®
5 9
T
®
®
: ;
t
®
®
< =
,
®
®
= >
AllocatorHandle
®
®
? N
backingAllocator
®
®
O _
)
®
®
_ `
where
©
©
 
T
©
©
 
:
©
©
 
	unmanaged
©
©
 
,
©
©
  

IAllocator
©
©
! +
{
™
™
 	

Unregister
´
´
 
(
´
´
 
ref
´
´
 
t
´
´
 
)
´
´
 
;
´
´
 
unsafe
≠
≠
 
{
Æ
Æ
 
var
Ø
Ø
 
allocatorPtr
Ø
Ø
  
=
Ø
Ø
! "
UnsafeUtility
Ø
Ø
# 0
.
Ø
Ø
0 1
	AddressOf
Ø
Ø
1 :
<
Ø
Ø
: ;
T
Ø
Ø
; <
>
Ø
Ø
< =
(
Ø
Ø
= >
ref
Ø
Ø
> A
t
Ø
Ø
B C
)
Ø
Ø
C D
;
Ø
Ø
D E
Memory
∞
∞
 
.
∞
∞
 
	Unmanaged
∞
∞
  
.
∞
∞
  !
Free
∞
∞
! %
(
∞
∞
% &
allocatorPtr
∞
∞
& 2
,
∞
∞
2 3
backingAllocator
∞
∞
4 D
)
∞
∞
D E
;
∞
∞
E F
}
±
±
 
}
≤
≤
 	
public
∑
∑
 
static
∑
∑
 
void
∑
∑
 
Shutdown
∑
∑
 #
(
∑
∑
# $
)
∑
∑
$ %
{
∏
∏
 	
}
π
π
 	
public
¿
¿
 
const
¿
¿
 
ushort
¿
¿
 
FirstUserIndex
¿
¿
 *
=
¿
¿
+ ,
$num
¿
¿
- /
;
¿
¿
/ 0
internal
¬
¬
 
static
¬
¬
 
bool
¬
¬
 
IsCustomAllocator
¬
¬
 .
(
¬
¬
. /
AllocatorHandle
¬
¬
/ >
	allocator
¬
¬
? H
)
¬
¬
H I
{
√
√
 	
return
ƒ
ƒ
 
	allocator
ƒ
ƒ
 
.
ƒ
ƒ
 
Index
ƒ
ƒ
 "
>=
ƒ
ƒ
# %
FirstUserIndex
ƒ
ƒ
& 4
;
ƒ
ƒ
4 5
}
≈
≈
 	
[
«
«
 	
Conditional
«
«
	 
(
«
«
 
$str
«
«
 5
)
«
«
5 6
]
«
«
6 7
internal
»
»
 
static
»
»
 
void
»
»
 #
CheckFailedToAllocate
»
»
 2
(
»
»
2 3
int
»
»
3 6
error
»
»
7 <
)
»
»
< =
{
…
…
 	
if
 
 
 
(
 
 
 
error
 
 
 
!=
 
 
 
$num
 
 
 
)
 
 
 
throw
À
À
 
new
À
À
 
ArgumentException
À
À
 +
(
À
À
+ ,
$str
À
À
, @
)
À
À
@ A
;
À
À
A B
}
Ã
Ã
 	
[
Œ
Œ
 	
Conditional
Œ
Œ
	 
(
Œ
Œ
 
$str
Œ
Œ
 5
)
Œ
Œ
5 6
]
Œ
Œ
6 7
internal
œ
œ
 
static
œ
œ
 
void
œ
œ
 
CheckFailedToFree
œ
œ
 .
(
œ
œ
. /
int
œ
œ
/ 2
error
œ
œ
3 8
)
œ
œ
8 9
{
–
–
 	
if
—
—
 
(
—
—
 
error
—
—
 
!=
—
—
 
$num
—
—
 
)
—
—
 
throw
“
“
 
new
“
“
 
ArgumentException
“
“
 +
(
“
“
+ ,
$str
“
“
, <
)
“
“
< =
;
“
“
= >
}
”
”
 	
[
’
’
 	
Conditional
’
’
	 
(
’
’
 
$str
’
’
 5
)
’
’
5 6
]
’
’
6 7
internal
÷
÷
 
static
÷
÷
 
void
÷
÷
 

CheckValid
÷
÷
 '
(
÷
÷
' (
AllocatorHandle
÷
÷
( 7
handle
÷
÷
8 >
)
÷
÷
> ?
{
◊
◊
 	
if
Ÿ
Ÿ
 
(
Ÿ
Ÿ
 
handle
Ÿ
Ÿ
 
.
Ÿ
Ÿ
 
IsValid
Ÿ
Ÿ
 
==
Ÿ
Ÿ
  
false
Ÿ
Ÿ
! &
)
Ÿ
Ÿ
& '
throw
⁄
⁄
 
new
⁄
⁄
 
ArgumentException
⁄
⁄
 +
(
⁄
⁄
+ ,
$str
⁄
⁄
, L
)
⁄
⁄
L M
;
⁄
⁄
M N
}
‹
‹
 	
}
›
›
 
[
‚
‚
 
BurstCompatible
‚
‚
 
(
‚
‚
 "
GenericTypeArguments
‚
‚
 )
=
‚
‚
* +
new
‚
‚
, /
[
‚
‚
/ 0
]
‚
‚
0 1
{
‚
‚
2 3
typeof
‚
‚
4 :
(
‚
‚
: ;
AllocatorManager
‚
‚
; K
.
‚
‚
K L
AllocatorHandle
‚
‚
L [
)
‚
‚
[ \
}
‚
‚
] ^
)
‚
‚
^ _
]
‚
‚
_ `
public
„
„
 

unsafe
„
„
 
struct
„
„
 
AllocatorHelper
„
„
 (
<
„
„
( )
T
„
„
) *
>
„
„
* +
:
„
„
, -
IDisposable
„
„
. 9
where
‰
‰
 
T
‰
‰
 
:
‰
‰
 
	unmanaged
‰
‰
 
,
‰
‰
 
AllocatorManager
‰
‰
 -
.
‰
‰
- .

IAllocator
‰
‰
. 8
{
Â
Â
 
readonly
È
È
 
T
È
È
 
*
È
È
 
m_allocator
È
È
 
;
È
È
  
AllocatorManager
Ó
Ó
 
.
Ó
Ó
 
AllocatorHandle
Ó
Ó
 ( 
m_backingAllocator
Ó
Ó
) ;
;
Ó
Ó
; <
public
Û
Û
 
ref
Û
Û
 
T
Û
Û
 
	Allocator
Û
Û
 
=>
Û
Û
 !
ref
Û
Û
" %
UnsafeUtility
Û
Û
& 3
.
Û
Û
3 4
AsRef
Û
Û
4 9
<
Û
Û
9 :
T
Û
Û
: ;
>
Û
Û
; <
(
Û
Û
< =
m_allocator
Û
Û
= H
)
Û
Û
H I
;
Û
Û
I J
[
˘
˘
 	 
NotBurstCompatible
˘
˘
	 
]
˘
˘
 
public
˙
˙
 
AllocatorHelper
˙
˙
 
(
˙
˙
 
AllocatorManager
˙
˙
 /
.
˙
˙
/ 0
AllocatorHandle
˙
˙
0 ?
backingAllocator
˙
˙
@ P
)
˙
˙
P Q
{
˚
˚
 	
ref
¸
¸
 
var
¸
¸
 
	allocator
¸
¸
 
=
¸
¸
 
ref
¸
¸
  #
AllocatorManager
¸
¸
$ 4
.
¸
¸
4 5
CreateAllocator
¸
¸
5 D
<
¸
¸
D E
T
¸
¸
E F
>
¸
¸
F G
(
¸
¸
G H
backingAllocator
¸
¸
H X
)
¸
¸
X Y
;
¸
¸
Y Z
m_allocator
˝
˝
 
=
˝
˝
 
(
˝
˝
 
T
˝
˝
 
*
˝
˝
 
)
˝
˝
 
UnsafeUtility
˝
˝
 +
.
˝
˝
+ ,
	AddressOf
˝
˝
, 5
<
˝
˝
5 6
T
˝
˝
6 7
>
˝
˝
7 8
(
˝
˝
8 9
ref
˝
˝
9 <
	allocator
˝
˝
= F
)
˝
˝
F G
;
˝
˝
G H 
m_backingAllocator
˛
˛
 
=
˛
˛
  
backingAllocator
˛
˛
! 1
;
˛
˛
1 2
}
ˇ
ˇ
 	
[
ÑÑ 	 
NotBurstCompatible
ÑÑ	 
]
ÑÑ 
public
ÖÖ 
void
ÖÖ 
Dispose
ÖÖ 
(
ÖÖ 
)
ÖÖ 
{
ÜÜ 	
ref
áá 
var
áá 
	allocator
áá 
=
áá 
ref
áá  #
UnsafeUtility
áá$ 1
.
áá1 2
AsRef
áá2 7
<
áá7 8
T
áá8 9
>
áá9 :
(
áá: ;
m_allocator
áá; F
)
ááF G
;
ááG H
AllocatorManager
àà 
.
àà 
DestroyAllocator
àà -
(
àà- .
ref
àà. 1
	allocator
àà2 ;
,
àà; < 
m_backingAllocator
àà= O
)
ààO P
;
ààP Q
}
ââ 	
}
ää 
}ãã Í)
oC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeNotBurstCompatible.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
.+ ,
NotBurstCompatible, >
{ 
public 

static 
class 

Extensions "
{		 
public 
static 
T 
[ 
] 
ToArray !
<! "
T" #
># $
($ %
this% )
UnsafeHashSet* 7
<7 8
T8 9
>9 :
set; >
)> ?
where 
T 
: 
	unmanaged 
,  

IEquatable! +
<+ ,
T, -
>- .
{ 	
var 
array 
= 
set 
. 
ToNativeArray )
() *
	Allocator* 3
.3 4
TempJob4 ;
); <
;< =
var 
managed 
= 
array 
.  
ToArray  '
(' (
)( )
;) *
array 
. 
Dispose 
( 
) 
; 
return 
managed 
; 
} 	
[ 	
NotBurstCompatible	 
] 
public   
static   
unsafe   
void   !
AddNBC  " (
(  ( )
ref  ) ,
this  - 1
UnsafeAppendBuffer  2 D
buffer  E K
,  K L
string  M S
value  T Y
)  Y Z
{!! 	
if"" 
("" 
value"" 
!="" 
null"" 
)"" 
{## 
buffer$$ 
.$$ 
Add$$ 
($$ 
value$$  
.$$  !
Length$$! '
)$$' (
;$$( )
fixed%% 
(%% 
char%% 
*%% 
ptr%%  
=%%! "
value%%# (
)%%( )
{&& 
buffer'' 
.'' 
Add'' 
('' 
ptr'' "
,''" #
sizeof''$ *
(''* +
char''+ /
)''/ 0
*''1 2
value''3 8
.''8 9
Length''9 ?
)''? @
;''@ A
}(( 
})) 
else** 
{++ 
buffer,, 
.,, 
Add,, 
(,, 
-,, 
$num,, 
),, 
;,, 
}-- 
}.. 	
[55 	
NotBurstCompatible55	 
]55 
public66 
static66 
unsafe66 
byte66 !
[66! "
]66" #

ToBytesNBC66$ .
(66. /
ref66/ 2
this663 7
UnsafeAppendBuffer668 J
buffer66K Q
)66Q R
{77 	
var88 
dst88 
=88 
new88 
byte88 
[88 
buffer88 %
.88% &
Length88& ,
]88, -
;88- .
fixed99 
(99 
byte99 
*99 
dstPtr99 
=99  !
dst99" %
)99% &
{:: 
UnsafeUtility;; 
.;; 
MemCpy;; $
(;;$ %
dstPtr;;% +
,;;+ ,
buffer;;- 3
.;;3 4
Ptr;;4 7
,;;7 8
buffer;;9 ?
.;;? @
Length;;@ F
);;F G
;;;G H
}<< 
return== 
dst== 
;== 
}>> 	
[FF 	
NotBurstCompatibleFF	 
]FF 
publicGG 
staticGG 
unsafeGG 
voidGG !
ReadNextNBCGG" -
(GG- .
refGG. 1
thisGG2 6
UnsafeAppendBufferGG7 I
.GGI J
ReaderGGJ P
readerGGQ W
,GGW X
outGGY \
stringGG] c
valueGGd i
)GGi j
{HH 	
intII 
lengthII 
;II 
readerJJ 
.JJ 
ReadNextJJ 
(JJ 
outJJ 
lengthJJ  &
)JJ& '
;JJ' (
ifLL 
(LL 
lengthLL 
!=LL 
-LL 
$numLL 
)LL 
{MM 
valueNN 
=NN 
newNN 
stringNN "
(NN" #
$charNN# &
,NN& '
lengthNN( .
)NN. /
;NN/ 0
fixedPP 
(PP 
charPP 
*PP 
bufPP  
=PP! "
valuePP# (
)PP( )
{QQ 
intRR 
bufLenRR 
=RR  
lengthRR! '
*RR( )
sizeofRR* 0
(RR0 1
charRR1 5
)RR5 6
;RR6 7
UnsafeUtilitySS !
.SS! "
MemCpySS" (
(SS( )
bufSS) ,
,SS, -
readerSS. 4
.SS4 5
ReadNextSS5 =
(SS= >
bufLenSS> D
)SSD E
,SSE F
bufLenSSG M
)SSM N
;SSN O
}TT 
}UU 
elseVV 
{WW 
valueXX 
=XX 
nullXX 
;XX 
}YY 
}ZZ 	
}\\ 
}]] ﬁ§
nC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\FixedStringParseMethods.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[		 
BurstCompatible		 
]		 
public

 

unsafe

 
static

 
partial

  
class

! &
FixedStringMethods

' 9
{ 
[ 	

MethodImpl	 
( 
MethodImplOptions %
.% &
AggressiveInlining& 8
)8 9
]9 :
[ 	
BurstCompatible	 
(  
GenericTypeArguments -
=. /
new0 3
[3 4
]4 5
{6 7
typeof8 >
(> ?
FixedString128Bytes? R
)R S
}T U
)U V
]V W
internal 
static 
bool 
ParseLongInternal .
<. /
T/ 0
>0 1
(1 2
ref2 5
T6 7
fs8 :
,: ;
ref< ?
int@ C
offsetD J
,J K
outL O
longP T
valueU Z
)Z [
where 
T 
: 
struct 
, 
INativeList )
<) *
byte* .
>. /
,/ 0

IUTF8Bytes1 ;
{ 	
int 
resetOffset 
= 
offset $
;$ %
int 
sign 
= 
$num 
; 
if 
( 
offset 
< 
fs 
. 
Length "
)" #
{ 
if 
( 
fs 
. 
Peek 
( 
offset "
)" #
.# $
value$ )
==* ,
$char- 0
)0 1
fs 
. 
Read 
( 
ref 
offset  &
)& '
;' (
else 
if 
( 
fs 
. 
Peek  
(  !
offset! '
)' (
.( )
value) .
==/ 1
$char2 5
)5 6
{ 
sign 
= 
- 
$num 
; 
fs 
. 
Read 
( 
ref 
offset  &
)& '
;' (
} 
} 
int 
digitOffset 
= 
offset $
;$ %
value 
= 
$num 
; 
while   
(   
offset   
<   
fs   
.   
Length   %
&&  & (
Unicode  ) 0
.  0 1
Rune  1 5
.  5 6
IsDigit  6 =
(  = >
fs  > @
.  @ A
Peek  A E
(  E F
offset  F L
)  L M
)  M N
)  N O
{!! 
value"" 
*="" 
$num"" 
;"" 
value## 
+=## 
fs## 
.## 
Read##  
(##  !
ref##! $
offset##% +
)##+ ,
.##, -
value##- 2
-##3 4
$char##5 8
;##8 9
}$$ 
value%% 
=%% 
sign%% 
*%% 
value%%  
;%%  !
if)) 
()) 
offset)) 
==)) 
digitOffset)) %
)))% &
{** 
offset++ 
=++ 
resetOffset++ $
;++$ %
return,, 
false,, 
;,, 
}-- 
return// 
true// 
;// 
}00 	
[?? 	
BurstCompatible??	 
(??  
GenericTypeArguments?? -
=??. /
new??0 3
[??3 4
]??4 5
{??6 7
typeof??8 >
(??> ?
FixedString128Bytes??? R
)??R S
}??T U
)??U V
]??V W
public@@ 
static@@ 

ParseError@@  
Parse@@! &
<@@& '
T@@' (
>@@( )
(@@) *
ref@@* -
this@@. 2
T@@3 4
fs@@5 7
,@@7 8
ref@@9 <
int@@= @
offset@@A G
,@@G H
ref@@I L
int@@M P
output@@Q W
)@@W X
whereAA 
TAA 
:AA 
structAA 
,AA 
INativeListAA )
<AA) *
byteAA* .
>AA. /
,AA/ 0

IUTF8BytesAA1 ;
{BB 	
ifCC 
(CC 
!CC 
ParseLongInternalCC "
(CC" #
refCC# &
fsCC' )
,CC) *
refCC+ .
offsetCC/ 5
,CC5 6
outCC7 :
longCC; ?
valueCC@ E
)CCE F
)CCF G
returnDD 

ParseErrorDD !
.DD! "
SyntaxDD" (
;DD( )
ifEE 
(EE 
valueEE 
>EE 
intEE 
.EE 
MaxValueEE $
)EE$ %
returnFF 

ParseErrorFF !
.FF! "
OverflowFF" *
;FF* +
ifGG 
(GG 
valueGG 
<GG 
intGG 
.GG 
MinValueGG $
)GG$ %
returnHH 

ParseErrorHH !
.HH! "
OverflowHH" *
;HH* +
outputII 
=II 
(II 
intII 
)II 
valueII 
;II  
returnJJ 

ParseErrorJJ 
.JJ 
NoneJJ "
;JJ" #
}KK 	
[ZZ 	
BurstCompatibleZZ	 
(ZZ  
GenericTypeArgumentsZZ -
=ZZ. /
newZZ0 3
[ZZ3 4
]ZZ4 5
{ZZ6 7
typeofZZ8 >
(ZZ> ?
FixedString128BytesZZ? R
)ZZR S
}ZZT U
)ZZU V
]ZZV W
public[[ 
static[[ 

ParseError[[  
Parse[[! &
<[[& '
T[[' (
>[[( )
([[) *
ref[[* -
this[[. 2
T[[3 4
fs[[5 7
,[[7 8
ref[[9 <
int[[= @
offset[[A G
,[[G H
ref[[I L
uint[[M Q
output[[R X
)[[X Y
where\\ 
T\\ 
:\\ 
struct\\ 
,\\ 
INativeList\\ )
<\\) *
byte\\* .
>\\. /
,\\/ 0

IUTF8Bytes\\1 ;
{]] 	
if^^ 
(^^ 
!^^ 
ParseLongInternal^^ "
(^^" #
ref^^# &
fs^^' )
,^^) *
ref^^+ .
offset^^/ 5
,^^5 6
out^^7 :
long^^; ?
value^^@ E
)^^E F
)^^F G
return__ 

ParseError__ !
.__! "
Syntax__" (
;__( )
if`` 
(`` 
value`` 
>`` 
uint`` 
.`` 
MaxValue`` %
)``% &
returnaa 

ParseErroraa !
.aa! "
Overflowaa" *
;aa* +
ifbb 
(bb 
valuebb 
<bb 
uintbb 
.bb 
MinValuebb %
)bb% &
returncc 

ParseErrorcc !
.cc! "
Overflowcc" *
;cc* +
outputdd 
=dd 
(dd 
uintdd 
)dd 
valuedd  
;dd  !
returnee 

ParseErroree 
.ee 
Noneee "
;ee" #
}ff 	
[tt 	
BurstCompatiblett	 
(tt  
GenericTypeArgumentstt -
=tt. /
newtt0 3
[tt3 4
]tt4 5
{tt6 7
typeoftt8 >
(tt> ?
FixedString128Bytestt? R
)ttR S
}ttT U
)ttU V
]ttV W
publicuu 
staticuu 

ParseErroruu  
Parseuu! &
<uu& '
Tuu' (
>uu( )
(uu) *
refuu* -
thisuu. 2
Tuu3 4
fsuu5 7
,uu7 8
refuu9 <
intuu= @
offsetuuA G
,uuG H
refuuI L
floatuuM R
outputuuS Y
,uuY Z
charuu[ _
decimalSeparatoruu` p
=uuq r
$charuus v
)uuv w
wherevv 
Tvv 
:vv 
structvv 
,vv 
INativeListvv )
<vv) *
bytevv* .
>vv. /
,vv/ 0

IUTF8Bytesvv1 ;
{ww 	
intxx 
resetOffsetxx 
=xx 
offsetxx $
;xx$ %
intyy 
signyy 
=yy 
$numyy 
;yy 
ifzz 
(zz 
offsetzz 
<zz 
fszz 
.zz 
Lengthzz "
)zz" #
{{{ 
if|| 
(|| 
fs|| 
.|| 
Peek|| 
(|| 
offset|| "
)||" #
.||# $
value||$ )
==||* ,
$char||- 0
)||0 1
fs}} 
.}} 
Read}} 
(}} 
ref}} 
offset}}  &
)}}& '
;}}' (
else~~ 
if~~ 
(~~ 
fs~~ 
.~~ 
Peek~~  
(~~  !
offset~~! '
)~~' (
.~~( )
value~~) .
==~~/ 1
$char~~2 5
)~~5 6
{ 
sign
ÄÄ 
=
ÄÄ 
-
ÄÄ 
$num
ÄÄ 
;
ÄÄ 
fs
ÅÅ 
.
ÅÅ 
Read
ÅÅ 
(
ÅÅ 
ref
ÅÅ 
offset
ÅÅ  &
)
ÅÅ& '
;
ÅÅ' (
}
ÇÇ 
}
ÉÉ 
if
ÑÑ 
(
ÑÑ 
fs
ÑÑ 
.
ÑÑ 
Found
ÑÑ 
(
ÑÑ 
ref
ÑÑ 
offset
ÑÑ #
,
ÑÑ# $
$char
ÑÑ% (
,
ÑÑ( )
$char
ÑÑ* -
,
ÑÑ- .
$char
ÑÑ/ 2
)
ÑÑ2 3
)
ÑÑ3 4
{
ÖÖ 
FixedStringUtils
ÜÜ  
.
ÜÜ  !
UintFloatUnion
ÜÜ! /
ufu
ÜÜ0 3
=
ÜÜ4 5
new
ÜÜ6 9
FixedStringUtils
ÜÜ: J
.
ÜÜJ K
UintFloatUnion
ÜÜK Y
(
ÜÜY Z
)
ÜÜZ [
;
ÜÜ[ \
ufu
áá 
.
áá 
	uintValue
áá 
=
áá 
$num
áá  +
;
áá+ ,
output
àà 
=
àà 
ufu
àà 
.
àà 

floatValue
àà '
;
àà' (
return
ââ 

ParseError
ââ !
.
ââ! "
None
ââ" &
;
ââ& '
}
ää 
if
ãã 
(
ãã 
fs
ãã 
.
ãã 
Found
ãã 
(
ãã 
ref
ãã 
offset
ãã #
,
ãã# $
$char
ãã% (
,
ãã( )
$char
ãã* -
,
ãã- .
$char
ãã/ 2
,
ãã2 3
$char
ãã4 7
,
ãã7 8
$char
ãã9 <
,
ãã< =
$char
ãã> A
,
ããA B
$char
ããC F
,
ããF G
$char
ããH K
)
ããK L
)
ããL M
{
åå 
output
çç 
=
çç 
(
çç 
sign
çç 
==
çç !
$num
çç" #
)
çç# $
?
çç% &
Single
çç' -
.
çç- .
PositiveInfinity
çç. >
:
çç? @
Single
ççA G
.
ççG H
NegativeInfinity
ççH X
;
ççX Y
return
éé 

ParseError
éé !
.
éé! "
None
éé" &
;
éé& '
}
èè 
ulong
ëë 
decimalMantissa
ëë !
=
ëë" #
$num
ëë$ %
;
ëë% &
int
íí 
significantDigits
íí !
=
íí" #
$num
íí$ %
;
íí% &
int
ìì 
digitsAfterDot
ìì 
=
ìì  
$num
ìì! "
;
ìì" #
int
îî 
mantissaDigits
îî 
=
îî  
$num
îî! "
;
îî" #
while
ïï 
(
ïï 
offset
ïï 
<
ïï 
fs
ïï 
.
ïï 
Length
ïï %
&&
ïï& (
Unicode
ïï) 0
.
ïï0 1
Rune
ïï1 5
.
ïï5 6
IsDigit
ïï6 =
(
ïï= >
fs
ïï> @
.
ïï@ A
Peek
ïïA E
(
ïïE F
offset
ïïF L
)
ïïL M
)
ïïM N
)
ïïN O
{
ññ 
++
óó 
mantissaDigits
óó  
;
óó  !
if
òò 
(
òò 
significantDigits
òò %
<
òò& '
$num
òò( )
)
òò) *
{
ôô 
var
öö 
temp
öö 
=
öö 
decimalMantissa
öö .
*
öö/ 0
$num
öö1 3
+
öö4 5
(
öö6 7
ulong
öö7 <
)
öö< =
(
öö= >
fs
öö> @
.
öö@ A
Peek
ööA E
(
ööE F
offset
ööF L
)
ööL M
.
ööM N
value
ööN S
-
ööT U
$char
ööV Y
)
ööY Z
;
ööZ [
if
õõ 
(
õõ 
temp
õõ 
>
õõ 
decimalMantissa
õõ .
)
õõ. /
++
úú 
significantDigits
úú +
;
úú+ ,
decimalMantissa
ùù #
=
ùù$ %
temp
ùù& *
;
ùù* +
}
ûû 
else
üü 
--
†† 
digitsAfterDot
†† $
;
††$ %
fs
°° 
.
°° 
Read
°° 
(
°° 
ref
°° 
offset
°° "
)
°°" #
;
°°# $
}
¢¢ 
if
££ 
(
££ 
offset
££ 
<
££ 
fs
££ 
.
££ 
Length
££ "
&&
££# %
fs
££& (
.
££( )
Peek
££) -
(
££- .
offset
££. 4
)
££4 5
.
££5 6
value
££6 ;
==
££< >
decimalSeparator
££? O
)
££O P
{
§§ 
fs
•• 
.
•• 
Read
•• 
(
•• 
ref
•• 
offset
•• "
)
••" #
;
••# $
while
¶¶ 
(
¶¶ 
offset
¶¶ 
<
¶¶ 
fs
¶¶  "
.
¶¶" #
Length
¶¶# )
&&
¶¶* ,
Unicode
¶¶- 4
.
¶¶4 5
Rune
¶¶5 9
.
¶¶9 :
IsDigit
¶¶: A
(
¶¶A B
fs
¶¶B D
.
¶¶D E
Peek
¶¶E I
(
¶¶I J
offset
¶¶J P
)
¶¶P Q
)
¶¶Q R
)
¶¶R S
{
ßß 
++
®® 
mantissaDigits
®® $
;
®®$ %
if
©© 
(
©© 
significantDigits
©© )
<
©©* +
$num
©©, -
)
©©- .
{
™™ 
var
´´ 
temp
´´  
=
´´! "
decimalMantissa
´´# 2
*
´´3 4
$num
´´5 7
+
´´8 9
(
´´: ;
ulong
´´; @
)
´´@ A
(
´´A B
fs
´´B D
.
´´D E
Peek
´´E I
(
´´I J
offset
´´J P
)
´´P Q
.
´´Q R
value
´´R W
-
´´X Y
$char
´´Z ]
)
´´] ^
;
´´^ _
if
¨¨ 
(
¨¨ 
temp
¨¨  
>
¨¨! "
decimalMantissa
¨¨# 2
)
¨¨2 3
++
≠≠ 
significantDigits
≠≠ /
;
≠≠/ 0
decimalMantissa
ÆÆ '
=
ÆÆ( )
temp
ÆÆ* .
;
ÆÆ. /
++
ØØ 
digitsAfterDot
ØØ (
;
ØØ( )
}
∞∞ 
fs
±± 
.
±± 
Read
±± 
(
±± 
ref
±± 
offset
±±  &
)
±±& '
;
±±' (
}
≤≤ 
}
≥≥ 
if
¥¥ 
(
¥¥ 
mantissaDigits
¥¥ 
==
¥¥ !
$num
¥¥" #
)
¥¥# $
{
µµ 
offset
∑∑ 
=
∑∑ 
resetOffset
∑∑ $
;
∑∑$ %
return
∏∏ 

ParseError
∏∏ !
.
∏∏! "
Syntax
∏∏" (
;
∏∏( )
}
ππ 
int
∫∫ 
decimalExponent
∫∫ 
=
∫∫  !
$num
∫∫" #
;
∫∫# $
int
ªª !
decimalExponentSign
ªª #
=
ªª$ %
$num
ªª& '
;
ªª' (
if
ºº 
(
ºº 
offset
ºº 
<
ºº 
fs
ºº 
.
ºº 
Length
ºº "
&&
ºº# %
(
ºº& '
fs
ºº' )
.
ºº) *
Peek
ºº* .
(
ºº. /
offset
ºº/ 5
)
ºº5 6
.
ºº6 7
value
ºº7 <
|
ºº= >
$num
ºº? A
)
ººA B
==
ººC E
$char
ººF I
)
ººI J
{
ΩΩ 
fs
ææ 
.
ææ 
Read
ææ 
(
ææ 
ref
ææ 
offset
ææ "
)
ææ" #
;
ææ# $
if
øø 
(
øø 
offset
øø 
<
øø 
fs
øø 
.
øø  
Length
øø  &
)
øø& '
{
¿¿ 
if
¡¡ 
(
¡¡ 
fs
¡¡ 
.
¡¡ 
Peek
¡¡ 
(
¡¡  
offset
¡¡  &
)
¡¡& '
.
¡¡' (
value
¡¡( -
==
¡¡. 0
$char
¡¡1 4
)
¡¡4 5
fs
¬¬ 
.
¬¬ 
Read
¬¬ 
(
¬¬  
ref
¬¬  #
offset
¬¬$ *
)
¬¬* +
;
¬¬+ ,
else
√√ 
if
√√ 
(
√√ 
fs
√√ 
.
√√  
Peek
√√  $
(
√√$ %
offset
√√% +
)
√√+ ,
.
√√, -
value
√√- 2
==
√√3 5
$char
√√6 9
)
√√9 :
{
ƒƒ !
decimalExponentSign
≈≈ +
=
≈≈, -
-
≈≈. /
$num
≈≈/ 0
;
≈≈0 1
fs
∆∆ 
.
∆∆ 
Read
∆∆ 
(
∆∆  
ref
∆∆  #
offset
∆∆$ *
)
∆∆* +
;
∆∆+ ,
}
«« 
}
»» 
int
…… 
digitOffset
…… 
=
……  !
offset
……" (
;
……( )
while
   
(
   
offset
   
<
   
fs
    "
.
  " #
Length
  # )
&&
  * ,
Unicode
  - 4
.
  4 5
Rune
  5 9
.
  9 :
IsDigit
  : A
(
  A B
fs
  B D
.
  D E
Peek
  E I
(
  I J
offset
  J P
)
  P Q
)
  Q R
)
  R S
{
ÀÀ 
decimalExponent
ÃÃ #
=
ÃÃ$ %
decimalExponent
ÃÃ& 5
*
ÃÃ6 7
$num
ÃÃ8 :
+
ÃÃ; <
(
ÃÃ= >
fs
ÃÃ> @
.
ÃÃ@ A
Peek
ÃÃA E
(
ÃÃE F
offset
ÃÃF L
)
ÃÃL M
.
ÃÃM N
value
ÃÃN S
-
ÃÃT U
$char
ÃÃV Y
)
ÃÃY Z
;
ÃÃZ [
fs
ÕÕ 
.
ÕÕ 
Read
ÕÕ 
(
ÕÕ 
ref
ÕÕ 
offset
ÕÕ  &
)
ÕÕ& '
;
ÕÕ' (
}
ŒŒ 
if
œœ 
(
œœ 
offset
œœ 
==
œœ 
digitOffset
œœ )
)
œœ) *
{
–– 
offset
““ 
=
““ 
resetOffset
““ (
;
““( )
return
”” 

ParseError
”” %
.
””% &
Syntax
””& ,
;
””, -
}
‘‘ 
if
’’ 
(
’’ 
decimalExponent
’’ #
>
’’$ %
$num
’’& (
)
’’( )
{
÷÷ 
if
◊◊ 
(
◊◊ !
decimalExponentSign
◊◊ +
==
◊◊, .
$num
◊◊/ 0
)
◊◊0 1
return
ÿÿ 

ParseError
ÿÿ )
.
ÿÿ) *
Overflow
ÿÿ* 2
;
ÿÿ2 3
else
ŸŸ 
return
⁄⁄ 

ParseError
⁄⁄ )
.
⁄⁄) *
	Underflow
⁄⁄* 3
;
⁄⁄3 4
}
€€ 
}
‹‹ 
decimalExponent
›› 
=
›› 
decimalExponent
›› -
*
››. /!
decimalExponentSign
››0 C
-
››D E
digitsAfterDot
››F T
;
››T U
var
ﬁﬁ 
error
ﬁﬁ 
=
ﬁﬁ 
FixedStringUtils
ﬁﬁ (
.
ﬁﬁ( )
Base10ToBase2
ﬁﬁ) 6
(
ﬁﬁ6 7
ref
ﬁﬁ7 :
output
ﬁﬁ; A
,
ﬁﬁA B
decimalMantissa
ﬁﬁC R
,
ﬁﬁR S
decimalExponent
ﬁﬁT c
)
ﬁﬁc d
;
ﬁﬁd e
if
ﬂﬂ 
(
ﬂﬂ 
error
ﬂﬂ 
!=
ﬂﬂ 

ParseError
ﬂﬂ #
.
ﬂﬂ# $
None
ﬂﬂ$ (
)
ﬂﬂ( )
return
‡‡ 
error
‡‡ 
;
‡‡ 
output
·· 
*=
·· 
sign
·· 
;
·· 
return
‚‚ 

ParseError
‚‚ 
.
‚‚ 
None
‚‚ "
;
‚‚" #
}
„„ 	
}
‰‰ 
}ÂÂ ÿ&
mC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeScratchAllocator.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{ 
[ 
BurstCompatible 
] 
public 

unsafe 
struct "
UnsafeScratchAllocator /
{ 
void 
* 
	m_Pointer 
; 
int 
m_LengthInBytes 
; 
readonly 
int 
m_CapacityInBytes &
;& '
public "
UnsafeScratchAllocator %
(% &
void& *
** +
ptr, /
,/ 0
int1 4
capacityInBytes5 D
)D E
{ 	
	m_Pointer 
= 
ptr 
; 
m_LengthInBytes 
= 
$num 
;  
m_CapacityInBytes 
= 
capacityInBytes  /
;/ 0
} 	
[ 	
Conditional	 
( 
$str 6
)6 7
]7 8
void 0
$CheckAllocationDoesNotExceedCapacity 1
(1 2
ulong2 7
requestedSize8 E
)E F
{   	
if!! 
(!! 
requestedSize!! 
>!! 
(!!  !
ulong!!! &
)!!& '
m_CapacityInBytes!!' 8
)!!8 9
throw"" 
new"" 
ArgumentException"" +
(""+ ,
$""", .
$str"". |
{""| }
requestedSize	""} ä
}
""ä ã
$str
""ã í
{
""í ì
m_LengthInBytes
""ì ¢
}
""¢ £
$str
""£ Æ
{
""Æ Ø
m_CapacityInBytes
""Ø ¿
}
""¿ ¡
"
""¡ ¬
)
""¬ √
;
""√ ƒ
}## 	
public,, 
void,, 
*,, 
Allocate,, 
(,, 
int,, !
sizeInBytes,," -
,,,- .
int,,/ 2
alignmentInBytes,,3 C
),,C D
{-- 	
if.. 
(.. 
sizeInBytes.. 
==.. 
$num..  
)..  !
return// 
null// 
;// 
var00 
alignmentMask00 
=00 
(00  !
ulong00! &
)00& '
(00' (
alignmentInBytes00( 8
-009 :
$num00; <
)00< =
;00= >
var11 
end11 
=11 
(11 
ulong11 
)11 
(11 
IntPtr11 $
)11$ %
	m_Pointer11% .
+11/ 0
(111 2
ulong112 7
)117 8
m_LengthInBytes118 G
;11G H
end22 
=22 
(22 
end22 
+22 
alignmentMask22 &
)22& '
&22( )
~22* +
alignmentMask22+ 8
;228 9
var33 
lengthInBytes33 
=33 
(33  !
byte33! %
*33% &
)33& '
(33' (
IntPtr33( .
)33. /
end33/ 2
-333 4
(335 6
byte336 :
*33: ;
)33; <
	m_Pointer33< E
;33E F
lengthInBytes44 
+=44 
sizeInBytes44 (
;44( )0
$CheckAllocationDoesNotExceedCapacity55 0
(550 1
(551 2
ulong552 7
)557 8
lengthInBytes558 E
)55E F
;55F G
m_LengthInBytes66 
=66 
(66 
int66 "
)66" #
lengthInBytes66# 0
;660 1
return77 
(77 
void77 
*77 
)77 
(77 
IntPtr77 !
)77! "
end77" %
;77% &
}88 	
[BB 	
BurstCompatibleBB	 
(BB  
GenericTypeArgumentsBB -
=BB. /
newBB0 3
[BB4 5
]BB5 6
{BB7 8
typeofBB9 ?
(BB? @
intBB@ C
)BBC D
}BBE F
)BBF G
]BBG H
publicCC 
voidCC 
*CC 
AllocateCC 
<CC 
TCC 
>CC  
(CC  !
intCC! $
countCC% *
=CC+ ,
$numCC- .
)CC. /
whereCC0 5
TCC6 7
:CC8 9
structCC: @
{DD 	
returnEE 
AllocateEE 
(EE 
UnsafeUtilityEE )
.EE) *
SizeOfEE* 0
<EE0 1
TEE1 2
>EE2 3
(EE3 4
)EE4 5
*EE6 7
countEE8 =
,EE= >
UnsafeUtilityEE? L
.EEL M
AlignOfEEM T
<EET U
TEEU V
>EEV W
(EEW X
)EEX Y
)EEY Z
;EEZ [
}FF 	
}GG 
}HH Ã\
nC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeHashMapExtensions.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[		 
BurstCompatible		 
]		 
public

 

static

 
class

 #
NativeHashMapExtensions

 /
{ 
[ 	
BurstCompatible	 
(  
GenericTypeArguments -
=. /
new0 3
[4 5
]5 6
{7 8
typeof9 ?
(? @
int@ C
)C D
}E F
)F G
]G H
public 
static 
int 
Unique  
<  !
T! "
>" #
(# $
this$ (
NativeArray) 4
<4 5
T5 6
>6 7
array8 =
)= >
where 
T 
: 
struct 
, 

IEquatable (
<( )
T) *
>* +
{ 	
if 
( 
array 
. 
Length 
== 
$num  !
)! "
{ 
return 
$num 
; 
}   
int"" 
first"" 
="" 
$num"" 
;"" 
int## 
last## 
=## 
array## 
.## 
Length## #
;### $
var$$ 
result$$ 
=$$ 
first$$ 
;$$ 
while%% 
(%% 
++%% 
first%% 
!=%% 
last%% "
)%%" #
{&& 
if'' 
('' 
!'' 
array'' 
['' 
result'' !
]''! "
.''" #
Equals''# )
('') *
array''* /
[''/ 0
first''0 5
]''5 6
)''6 7
)''7 8
{(( 
array)) 
[)) 
++)) 
result)) "
]))" #
=))$ %
array))& +
[))+ ,
first)), 1
]))1 2
;))2 3
}** 
}++ 
return-- 
++-- 
result-- 
;-- 
}.. 	
[99 	
BurstCompatible99	 
(99  
GenericTypeArguments99 -
=99. /
new990 3
[993 4
]994 5
{996 7
typeof998 >
(99> ?
int99? B
)99B C
,99C D
typeof99E K
(99K L
int99L O
)99O P
}99Q R
)99R S
]99S T
public:: 
static:: 
(:: 
NativeArray:: "
<::" #
TKey::# '
>::' (
,::( )
int::* -
)::- .
GetUniqueKeyArray::/ @
<::@ A
TKey::A E
,::E F
TValue::G M
>::M N
(::N O
this::O S
UnsafeMultiHashMap::T f
<::f g
TKey::g k
,::k l
TValue::m s
>::s t
	container::u ~
,::~ 
AllocatorManager
::Ä ê
.
::ê ë
AllocatorHandle
::ë †
	allocator
::° ™
)
::™ ´
where;; 
TKey;; 
:;; 
struct;; 
,;;  

IEquatable;;! +
<;;+ ,
TKey;;, 0
>;;0 1
,;;1 2
IComparable;;3 >
<;;> ?
TKey;;? C
>;;C D
where<< 
TValue<< 
:<< 
struct<< !
{== 	
var>> 
result>> 
=>> 
	container>> "
.>>" #
GetKeyArray>># .
(>>. /
	allocator>>/ 8
)>>8 9
;>>9 :
result?? 
.?? 
Sort?? 
(?? 
)?? 
;?? 
int@@ 
uniques@@ 
=@@ 
result@@  
.@@  !
Unique@@! '
(@@' (
)@@( )
;@@) *
returnAA 
(AA 
resultAA 
,AA 
uniquesAA #
)AA# $
;AA$ %
}BB 	
[LL 	
BurstCompatibleLL	 
(LL  
GenericTypeArgumentsLL -
=LL. /
newLL0 3
[LL3 4
]LL4 5
{LL6 7
typeofLL8 >
(LL> ?
intLL? B
)LLB C
,LLC D
typeofLLE K
(LLK L
intLLL O
)LLO P
}LLQ R
)LLR S
]LLS T
publicMM 
staticMM 
(MM 
NativeArrayMM "
<MM" #
TKeyMM# '
>MM' (
,MM( )
intMM* -
)MM- .
GetUniqueKeyArrayMM/ @
<MM@ A
TKeyMMA E
,MME F
TValueMMG M
>MMM N
(MMN O
thisMMO S
NativeMultiHashMapMMT f
<MMf g
TKeyMMg k
,MMk l
TValueMMm s
>MMs t
	containerMMu ~
,MM~ 
AllocatorManager
MMÄ ê
.
MMê ë
AllocatorHandle
MMë †
	allocator
MM° ™
)
MM™ ´
whereNN 
TKeyNN 
:NN 
structNN 
,NN  

IEquatableNN! +
<NN+ ,
TKeyNN, 0
>NN0 1
,NN1 2
IComparableNN3 >
<NN> ?
TKeyNN? C
>NNC D
whereOO 
TValueOO 
:OO 
structOO !
{PP 	
varQQ 
resultQQ 
=QQ 
	containerQQ "
.QQ" #
GetKeyArrayQQ# .
(QQ. /
	allocatorQQ/ 8
)QQ8 9
;QQ9 :
resultRR 
.RR 
SortRR 
(RR 
)RR 
;RR 
intSS 
uniquesSS 
=SS 
resultSS  
.SS  !
UniqueSS! '
(SS' (
)SS( )
;SS) *
returnTT 
(TT 
resultTT 
,TT 
uniquesTT #
)TT# $
;TT$ %
}UU 	
[ff 	
Obsoleteff	 
(ff 
$str	ff ´
,
ff´ ¨
false
ff≠ ≤
)
ff≤ ≥
]
ff≥ ¥
[gg 	
BurstCompatiblegg	 
(gg  
GenericTypeArgumentsgg -
=gg. /
newgg0 3
[gg4 5
]gg5 6
{gg7 8
typeofgg9 ?
(gg? @
intgg@ C
)ggC D
,ggD E
typeofggF L
(ggL M
intggM P
)ggP Q
}ggR S
)ggS T
]ggT U
publichh 
statichh 
unsafehh #
UnsafeHashMapBucketDatahh 4
GetBucketDatahh5 B
<hhB C
TKeyhhC G
,hhG H
TValuehhI O
>hhO P
(hhP Q
thishhQ U
NativeHashMaphhV c
<hhc d
TKeyhhd h
,hhh i
TValuehhj p
>hhp q
	containerhhr {
)hh{ |
whereii 
TKeyii 
:ii 
structii 
,ii  

IEquatableii! +
<ii+ ,
TKeyii, 0
>ii0 1
wherejj 
TValuejj 
:jj 
structjj !
{kk 	
returnll 
	containerll 
.ll 
m_HashMapDatall *
.ll* +
m_Bufferll+ 3
->ll3 5
GetBucketDatall5 B
(llB C
)llC D
;llD E
}mm 	
[}} 	
BurstCompatible}}	 
(}}  
GenericTypeArguments}} -
=}}. /
new}}0 3
[}}3 4
]}}4 5
{}}6 7
typeof}}8 >
(}}> ?
int}}? B
)}}B C
,}}C D
typeof}}E K
(}}K L
int}}L O
)}}O P
}}}Q R
)}}R S
]}}S T
public~~ 
static~~ 
unsafe~~ #
UnsafeHashMapBucketData~~ 4
GetUnsafeBucketData~~5 H
<~~H I
TKey~~I M
,~~M N
TValue~~O U
>~~U V
(~~V W
this~~W [
NativeHashMap~~\ i
<~~i j
TKey~~j n
,~~n o
TValue~~p v
>~~v w
	container	~~x Å
)
~~Å Ç
where 
TKey 
: 
struct 
,  

IEquatable! +
<+ ,
TKey, 0
>0 1
where
ÄÄ 
TValue
ÄÄ 
:
ÄÄ 
struct
ÄÄ !
{
ÅÅ 	
return
ÇÇ 
	container
ÇÇ 
.
ÇÇ 
m_HashMapData
ÇÇ *
.
ÇÇ* +
m_Buffer
ÇÇ+ 3
->
ÇÇ3 5
GetBucketData
ÇÇ5 B
(
ÇÇB C
)
ÇÇC D
;
ÇÇD E
}
ÉÉ 	
[
ìì 	
BurstCompatible
ìì	 
(
ìì "
GenericTypeArguments
ìì -
=
ìì. /
new
ìì0 3
[
ìì4 5
]
ìì5 6
{
ìì7 8
typeof
ìì9 ?
(
ìì? @
int
ìì@ C
)
ììC D
,
ììD E
typeof
ììF L
(
ììL M
int
ììM P
)
ììP Q
}
ììR S
)
ììS T
]
ììT U
public
îî 
static
îî 
unsafe
îî %
UnsafeHashMapBucketData
îî 4!
GetUnsafeBucketData
îî5 H
<
îîH I
TKey
îîI M
,
îîM N
TValue
îîO U
>
îîU V
(
îîV W
this
îîW [ 
NativeMultiHashMap
îî\ n
<
îîn o
TKey
îîo s
,
îîs t
TValue
îîu {
>
îî{ |
	containerîî} Ü
)îîÜ á
where
ïï 
TKey
ïï 
:
ïï 
struct
ïï 
,
ïï  

IEquatable
ïï! +
<
ïï+ ,
TKey
ïï, 0
>
ïï0 1
where
ññ 
TValue
ññ 
:
ññ 
struct
ññ !
{
óó 	
return
òò 
	container
òò 
.
òò  
m_MultiHashMapData
òò /
.
òò/ 0
m_Buffer
òò0 8
->
òò8 :
GetBucketData
òò: G
(
òòG H
)
òòH I
;
òòI J
}
ôô 	
[
•• 	
BurstCompatible
••	 
(
•• "
GenericTypeArguments
•• -
=
••. /
new
••0 3
[
••4 5
]
••5 6
{
••7 8
typeof
••9 ?
(
••? @
int
••@ C
)
••C D
,
••D E
typeof
••F L
(
••L M
int
••M P
)
••P Q
}
••R S
)
••S T
]
••T U
public
¶¶ 
static
¶¶ 
void
¶¶ 
Remove
¶¶ !
<
¶¶! "
TKey
¶¶" &
,
¶¶& '
TValue
¶¶( .
>
¶¶. /
(
¶¶/ 0
this
¶¶0 4 
NativeMultiHashMap
¶¶5 G
<
¶¶G H
TKey
¶¶H L
,
¶¶L M
TValue
¶¶N T
>
¶¶T U
	container
¶¶V _
,
¶¶_ `
TKey
¶¶a e
key
¶¶f i
,
¶¶i j
TValue
¶¶k q
value
¶¶r w
)
¶¶w x
where
¶¶y ~
TKey¶¶ É
:¶¶Ñ Ö
struct¶¶Ü å
,¶¶å ç

IEquatable¶¶é ò
<¶¶ò ô
TKey¶¶ô ù
>¶¶ù û
where¶¶ü §
TValue¶¶• ´
:¶¶¨ ≠
struct¶¶Æ ¥
,¶¶¥ µ

IEquatable¶¶∂ ¿
<¶¶¿ ¡
TValue¶¶¡ «
>¶¶« »
{
ßß 	 
AtomicSafetyHandle
©© 
.
©© /
!CheckWriteAndBumpSecondaryVersion
©© @
(
©©@ A
	container
©©A J
.
©©J K
m_Safety
©©K S
)
©©S T
;
©©T U
	container
´´ 
.
´´  
m_MultiHashMapData
´´ (
.
´´( )
Remove
´´) /
(
´´/ 0
key
´´0 3
,
´´3 4
value
´´5 :
)
´´: ;
;
´´; <
}
¨¨ 	
}
≠≠ 
}ÆÆ ÿÆ
^C:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\xxHash3.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[ 
BurstCompile 
] 
[   
BurstCompatible   
]   
public!! 

static!! 
partial!! 
class!! 
xxHash3!!  '
{"" 
public++ 
static++ 
unsafe++ 
uint2++ "
Hash64++# )
(++) *
void++* .
*++. /
input++0 5
,++5 6
long++7 ;
length++< B
)++B C
{,, 	
fixed-- 
(-- 
void-- 
*-- 
secret-- 
=--  !
xxHashDefaultKey--" 2
.--2 3
kSecret--3 :
)--: ;
{.. 
return// 
ToUint2// 
(// 
Hash64Internal// -
(//- .
(//. /
byte/// 3
*//3 4
)//4 5
input//6 ;
,//; <
null//= A
,//A B
length//C I
,//I J
(//K L
byte//L P
*//P Q
)//Q R
secret//S Y
,//Y Z
$num//[ \
)//\ ]
)//] ^
;//^ _
}00 
}11 	
[:: 	
BurstCompatible::	 
(::  
GenericTypeArguments:: -
=::. /
new::0 3
[::4 5
]::5 6
{::7 8
typeof::9 ?
(::? @
int::@ C
)::C D
}::E F
)::F G
]::G H
public;; 
static;; 
unsafe;; 
uint2;; "
Hash64;;# )
<;;) *
T;;* +
>;;+ ,
(;;, -
in;;- /
T;;0 1
input;;2 7
);;7 8
where;;9 >
T;;? @
:;;A B
	unmanaged;;C L
{<< 	
return== 
Hash64== 
(== #
UnsafeUtilityExtensions== 1
.==1 2
	AddressOf==2 ;
(==; <
input==< A
)==A B
,==B C
UnsafeUtility==D Q
.==Q R
SizeOf==R X
<==X Y
T==Y Z
>==Z [
(==[ \
)==\ ]
)==] ^
;==^ _
}>> 	
publicGG 
staticGG 
unsafeGG 
uint2GG "
Hash64GG# )
(GG) *
voidGG* .
*GG. /
inputGG0 5
,GG5 6
longGG7 ;
lengthGG< B
,GGB C
ulongGGD I
seedGGJ N
)GGN O
{HH 	
fixedII 
(II 
byteII 
*II 
secretII 
=II  !
xxHashDefaultKeyII" 2
.II2 3
kSecretII3 :
)II: ;
{JJ 
returnKK 
ToUint2KK 
(KK 
Hash64InternalKK -
(KK- .
(KK. /
byteKK/ 3
*KK3 4
)KK4 5
inputKK6 ;
,KK; <
nullKK= A
,KKA B
lengthKKC I
,KKI J
secretKKK Q
,KKQ R
seedKKS W
)KKW X
)KKX Y
;KKY Z
}LL 
}MM 	
publicUU 
staticUU 
unsafeUU 
uint4UU "
Hash128UU# *
(UU* +
voidUU+ /
*UU/ 0
inputUU1 6
,UU6 7
longUU8 <
lengthUU= C
)UUC D
{VV 	
fixedWW 
(WW 
voidWW 
*WW 
secretWW 
=WW  !
xxHashDefaultKeyWW" 2
.WW2 3
kSecretWW3 :
)WW: ;
{XX 
Hash128InternalYY 
(YY  
(YY  !
byteYY! %
*YY% &
)YY& '
inputYY( -
,YY- .
nullYY/ 3
,YY3 4
lengthYY5 ;
,YY; <
(YY= >
byteYY> B
*YYB C
)YYC D
secretYYE K
,YYK L
$numYYM N
,YYN O
outYYP S
varYYT W
resultYYX ^
)YY^ _
;YY_ `
returnZZ 
resultZZ 
;ZZ 
}[[ 
}\\ 	
[dd 	
BurstCompatibledd	 
(dd  
GenericTypeArgumentsdd -
=dd. /
newdd0 3
[dd4 5
]dd5 6
{dd7 8
typeofdd9 ?
(dd? @
intdd@ C
)ddC D
}ddE F
)ddF G
]ddG H
publicee 
staticee 
unsafeee 
uint4ee "
Hash128ee# *
<ee* +
Tee+ ,
>ee, -
(ee- .
inee. 0
Tee1 2
inputee3 8
)ee8 9
whereee: ?
Tee@ A
:eeB C
	unmanagedeeD M
{ff 	
returngg 
Hash128gg 
(gg #
UnsafeUtilityExtensionsgg 2
.gg2 3
	AddressOfgg3 <
(gg< =
inputgg= B
)ggB C
,ggC D
UnsafeUtilityggE R
.ggR S
SizeOfggS Y
<ggY Z
TggZ [
>gg[ \
(gg\ ]
)gg] ^
)gg^ _
;gg_ `
}hh 	
publicss 
staticss 
unsafess 
uint4ss "
Hash128ss# *
(ss* +
voidss+ /
*ss/ 0
inputss1 6
,ss6 7
voidss8 <
*ss< =
destinationss> I
,ssI J
longssK O
lengthssP V
)ssV W
{tt 	
fixeduu 
(uu 
byteuu 
*uu 
secretuu 
=uu  !
xxHashDefaultKeyuu" 2
.uu2 3
kSecretuu3 :
)uu: ;
{vv 
Hash128Internalww 
(ww  
(ww  !
byteww! %
*ww% &
)ww& '
inputww( -
,ww- .
(ww/ 0
byteww0 4
*ww4 5
)ww5 6
destinationww7 B
,wwB C
lengthwwD J
,wwJ K
secretwwL R
,wwR S
$numwwT U
,wwU V
outwwW Z
varww[ ^
resultww_ e
)wwe f
;wwf g
returnyy 
resultyy 
;yy 
}zz 
}{{ 	
public
ÑÑ 
static
ÑÑ 
unsafe
ÑÑ 
uint4
ÑÑ "
Hash128
ÑÑ# *
(
ÑÑ* +
void
ÑÑ+ /
*
ÑÑ/ 0
input
ÑÑ1 6
,
ÑÑ6 7
long
ÑÑ8 <
length
ÑÑ= C
,
ÑÑC D
ulong
ÑÑE J
seed
ÑÑK O
)
ÑÑO P
{
ÖÖ 	
fixed
ÜÜ 
(
ÜÜ 
byte
ÜÜ 
*
ÜÜ 
secret
ÜÜ 
=
ÜÜ  !
xxHashDefaultKey
ÜÜ" 2
.
ÜÜ2 3
kSecret
ÜÜ3 :
)
ÜÜ: ;
{
áá 
Hash128Internal
àà 
(
àà  
(
àà  !
byte
àà! %
*
àà% &
)
àà& '
input
àà( -
,
àà- .
null
àà/ 3
,
àà3 4
length
àà5 ;
,
àà; <
secret
àà= C
,
ààC D
seed
ààE I
,
ààI J
out
ààK N
var
ààO R
result
ààS Y
)
ààY Z
;
ààZ [
return
ää 
result
ää 
;
ää 
}
ãã 
}
åå 	
public
ññ 
static
ññ 
unsafe
ññ 
uint4
ññ "
Hash128
ññ# *
(
ññ* +
void
ññ+ /
*
ññ/ 0
input
ññ1 6
,
ññ6 7
void
ññ8 <
*
ññ< =
destination
ññ> I
,
ññI J
long
ññK O
length
ññP V
,
ññV W
ulong
ññX ]
seed
ññ^ b
)
ññb c
{
óó 	
fixed
òò 
(
òò 
byte
òò 
*
òò 
secret
òò 
=
òò  !
xxHashDefaultKey
òò" 2
.
òò2 3
kSecret
òò3 :
)
òò: ;
{
ôô 
Hash128Internal
öö 
(
öö  
(
öö  !
byte
öö! %
*
öö% &
)
öö& '
input
öö( -
,
öö- .
(
öö/ 0
byte
öö0 4
*
öö4 5
)
öö5 6
destination
öö7 B
,
ööB C
length
ööD J
,
ööJ K
secret
ööL R
,
ööR S
seed
ööT X
,
ööX Y
out
ööZ ]
var
öö^ a
result
ööb h
)
ööh i
;
ööi j
return
úú 
result
úú 
;
úú 
}
ùù 
}
ûû 	
private
§§ 
const
§§ 
int
§§ 

STRIPE_LEN
§§ $
=
§§% &
$num
§§' )
;
§§) *
private
•• 
const
•• 
int
•• 
ACC_NB
••  
=
••! "

STRIPE_LEN
••# -
/
••. /
$num
••0 1
;
••1 2
private
¶¶ 
const
¶¶ 
int
¶¶ !
SECRET_CONSUME_RATE
¶¶ -
=
¶¶. /
$num
¶¶0 1
;
¶¶1 2
private
ßß 
const
ßß 
int
ßß 
SECRET_KEY_SIZE
ßß )
=
ßß* +
$num
ßß, /
;
ßß/ 0
private
®® 
const
®® 
int
®® !
SECRET_KEY_MIN_SIZE
®® -
=
®®. /
$num
®®0 3
;
®®3 4
private
©© 
const
©© 
int
©© "
SECRET_LASTACC_START
©© .
=
©©/ 0
$num
©©1 2
;
©©2 3
private
™™ 
const
™™ 
int
™™ 
	NB_ROUNDS
™™ #
=
™™$ %
(
™™& '
SECRET_KEY_SIZE
™™' 6
-
™™7 8

STRIPE_LEN
™™9 C
)
™™C D
/
™™E F!
SECRET_CONSUME_RATE
™™G Z
;
™™Z [
private
´´ 
const
´´ 
int
´´ 
	BLOCK_LEN
´´ #
=
´´$ %

STRIPE_LEN
´´& 0
*
´´1 2
	NB_ROUNDS
´´3 <
;
´´< =
private
≠≠ 
const
≠≠ 
uint
≠≠ 
	PRIME32_1
≠≠ $
=
≠≠% &
$num
≠≠' 2
;
≠≠2 3
private
ÆÆ 
const
ÆÆ 
uint
ÆÆ 
	PRIME32_2
ÆÆ $
=
ÆÆ% &
$num
ÆÆ' 2
;
ÆÆ2 3
private
∞∞ 
const
∞∞ 
uint
∞∞ 
	PRIME32_3
∞∞ $
=
∞∞% &
$num
∞∞' 2
;
∞∞2 3
private
≥≥ 
const
≥≥ 
uint
≥≥ 
	PRIME32_5
≥≥ $
=
≥≥% &
$num
≥≥' 2
;
≥≥2 3
private
¥¥ 
const
¥¥ 
ulong
¥¥ 
	PRIME64_1
¥¥ %
=
¥¥& '
$num
¥¥( <
;
¥¥< =
private
µµ 
const
µµ 
ulong
µµ 
	PRIME64_2
µµ %
=
µµ& '
$num
µµ( <
;
µµ< =
private
∂∂ 
const
∂∂ 
ulong
∂∂ 
	PRIME64_3
∂∂ %
=
∂∂& '
$num
∂∂( <
;
∂∂< =
private
∑∑ 
const
∑∑ 
ulong
∑∑ 
	PRIME64_4
∑∑ %
=
∑∑& '
$num
∑∑( <
;
∑∑< =
private
∏∏ 
const
∏∏ 
ulong
∏∏ 
	PRIME64_5
∏∏ %
=
∏∏& '
$num
∏∏( <
;
∏∏< =
private
∫∫ 
const
∫∫ 
int
∫∫ 
MIDSIZE_MAX
∫∫ %
=
∫∫& '
$num
∫∫( +
;
∫∫+ ,
private
ªª 
const
ªª 
int
ªª !
MIDSIZE_STARTOFFSET
ªª -
=
ªª. /
$num
ªª0 1
;
ªª1 2
private
ºº 
const
ºº 
int
ºº  
MIDSIZE_LASTOFFSET
ºº ,
=
ºº- .
$num
ºº/ 1
;
ºº1 2
private
ææ 
const
ææ 
int
ææ $
SECRET_MERGEACCS_START
ææ 0
=
ææ1 2
$num
ææ3 5
;
ææ5 6
private
¬¬ 
struct
¬¬ 
ulong2
¬¬ 
{
√√ 	
public
ƒƒ 
ulong
ƒƒ 
x
ƒƒ 
;
ƒƒ 
public
≈≈ 
ulong
≈≈ 
y
≈≈ 
;
≈≈ 
public
«« 
ulong2
«« 
(
«« 
ulong
«« 
x
««  !
,
««! "
ulong
««# (
y
««) *
)
««* +
{
»» 
this
…… 
.
…… 
x
…… 
=
…… 
x
…… 
;
…… 
this
   
.
   
y
   
=
   
y
   
;
   
}
ÀÀ 
}
ÃÃ 	
internal
ŒŒ 
static
ŒŒ 
unsafe
ŒŒ 
ulong
ŒŒ $
Hash64Internal
ŒŒ% 3
(
ŒŒ3 4
byte
ŒŒ4 8
*
ŒŒ8 9
input
ŒŒ: ?
,
ŒŒ? @
byte
ŒŒA E
*
ŒŒE F
dest
ŒŒG K
,
ŒŒK L
long
ŒŒM Q
length
ŒŒR X
,
ŒŒX Y
byte
ŒŒZ ^
*
ŒŒ^ _
secret
ŒŒ` f
,
ŒŒf g
ulong
ŒŒh m
seed
ŒŒn r
)
ŒŒr s
{
œœ 	
if
–– 
(
–– 
length
–– 
<
–– 
$num
–– 
)
–– 
{
—— 
return
““ 
Hash64Len0To16
““ %
(
““% &
input
““& +
,
““+ ,
length
““- 3
,
““3 4
secret
““5 ;
,
““; <
seed
““= A
)
““A B
;
““B C
}
”” 
if
’’ 
(
’’ 
length
’’ 
<
’’ 
$num
’’ 
)
’’ 
{
÷÷ 
return
◊◊ 
Hash64Len17To128
◊◊ '
(
◊◊' (
input
◊◊( -
,
◊◊- .
length
◊◊/ 5
,
◊◊5 6
secret
◊◊7 =
,
◊◊= >
seed
◊◊? C
)
◊◊C D
;
◊◊D E
}
ÿÿ 
if
⁄⁄ 
(
⁄⁄ 
length
⁄⁄ 
<
⁄⁄ 
MIDSIZE_MAX
⁄⁄ $
)
⁄⁄$ %
{
€€ 
return
‹‹ 
Hash64Len129To240
‹‹ (
(
‹‹( )
input
‹‹) .
,
‹‹. /
length
‹‹0 6
,
‹‹6 7
secret
‹‹8 >
,
‹‹> ?
seed
‹‹@ D
)
‹‹D E
;
‹‹E F
}
›› 
if
ﬂﬂ 
(
ﬂﬂ 
seed
ﬂﬂ 
!=
ﬂﬂ 
$num
ﬂﬂ 
)
ﬂﬂ 
{
‡‡ 
var
·· 
	newSecret
·· 
=
·· 
(
··  !
byte
··! %
*
··% &
)
··& '
Memory
··( .
.
··. /
	Unmanaged
··/ 8
.
··8 9
Allocate
··9 A
(
··A B
SECRET_KEY_SIZE
··B Q
,
··Q R
$num
··S U
,
··U V
	Allocator
··W `
.
··` a
Temp
··a e
)
··e f
;
··f g
EncodeSecretKey
„„ 
(
„„  
	newSecret
„„  )
,
„„) *
secret
„„+ 1
,
„„1 2
seed
„„3 7
)
„„7 8
;
„„8 9
var
‰‰ 
result
‰‰ 
=
‰‰ 

Hash64Long
‰‰ '
(
‰‰' (
input
‰‰( -
,
‰‰- .
dest
‰‰/ 3
,
‰‰3 4
length
‰‰5 ;
,
‰‰; <
	newSecret
‰‰= F
)
‰‰F G
;
‰‰G H
Memory
ÊÊ 
.
ÊÊ 
	Unmanaged
ÊÊ  
.
ÊÊ  !
Free
ÊÊ! %
(
ÊÊ% &
	newSecret
ÊÊ& /
,
ÊÊ/ 0
	Allocator
ÊÊ1 :
.
ÊÊ: ;
Temp
ÊÊ; ?
)
ÊÊ? @
;
ÊÊ@ A
return
ËË 
result
ËË 
;
ËË 
}
ÈÈ 
else
ÎÎ 
{
ÏÏ 
return
ÌÌ 

Hash64Long
ÌÌ !
(
ÌÌ! "
input
ÌÌ" '
,
ÌÌ' (
dest
ÌÌ) -
,
ÌÌ- .
length
ÌÌ/ 5
,
ÌÌ5 6
secret
ÌÌ7 =
)
ÌÌ= >
;
ÌÌ> ?
}
ÓÓ 
}
ÔÔ 	
internal
ÒÒ 
static
ÒÒ 
unsafe
ÒÒ 
void
ÒÒ #
Hash128Internal
ÒÒ$ 3
(
ÒÒ3 4
byte
ÒÒ4 8
*
ÒÒ8 9
input
ÒÒ: ?
,
ÒÒ? @
byte
ÒÒA E
*
ÒÒE F
dest
ÒÒG K
,
ÒÒK L
long
ÒÒM Q
length
ÒÒR X
,
ÒÒX Y
byte
ÒÒZ ^
*
ÒÒ^ _
secret
ÒÒ` f
,
ÒÒf g
ulong
ÒÒh m
seed
ÒÒn r
,
ÒÒr s
out
ÚÚ 
uint4
ÚÚ 
result
ÚÚ 
)
ÚÚ 
{
ÛÛ 	
if
ÙÙ 
(
ÙÙ 
dest
ÙÙ 
!=
ÙÙ 
null
ÙÙ 
&&
ÙÙ 
length
ÙÙ  &
<
ÙÙ' (
MIDSIZE_MAX
ÙÙ) 4
)
ÙÙ4 5
{
ıı 
UnsafeUtility
ˆˆ 
.
ˆˆ 
MemCpy
ˆˆ $
(
ˆˆ$ %
dest
ˆˆ% )
,
ˆˆ) *
input
ˆˆ+ 0
,
ˆˆ0 1
length
ˆˆ2 8
)
ˆˆ8 9
;
ˆˆ9 :
}
˜˜ 
if
˘˘ 
(
˘˘ 
length
˘˘ 
<
˘˘ 
$num
˘˘ 
)
˘˘ 
{
˙˙ 
Hash128Len0To16
˚˚ 
(
˚˚  
input
˚˚  %
,
˚˚% &
length
˚˚' -
,
˚˚- .
secret
˚˚/ 5
,
˚˚5 6
seed
˚˚7 ;
,
˚˚; <
out
˚˚= @
result
˚˚A G
)
˚˚G H
;
˚˚H I
return
¸¸ 
;
¸¸ 
}
˝˝ 
if
ˇˇ 
(
ˇˇ 
length
ˇˇ 
<
ˇˇ 
$num
ˇˇ 
)
ˇˇ 
{
ÄÄ 
Hash128Len17To128
ÅÅ !
(
ÅÅ! "
input
ÅÅ" '
,
ÅÅ' (
length
ÅÅ) /
,
ÅÅ/ 0
secret
ÅÅ1 7
,
ÅÅ7 8
seed
ÅÅ9 =
,
ÅÅ= >
out
ÅÅ? B
result
ÅÅC I
)
ÅÅI J
;
ÅÅJ K
return
ÇÇ 
;
ÇÇ 
}
ÉÉ 
if
ÖÖ 
(
ÖÖ 
length
ÖÖ 
<
ÖÖ 
MIDSIZE_MAX
ÖÖ $
)
ÖÖ$ %
{
ÜÜ  
Hash128Len129To240
áá "
(
áá" #
input
áá# (
,
áá( )
length
áá* 0
,
áá0 1
secret
áá2 8
,
áá8 9
seed
áá: >
,
áá> ?
out
áá@ C
result
ááD J
)
ááJ K
;
ááK L
return
àà 
;
àà 
}
ââ 
if
ãã 
(
ãã 
seed
ãã 
!=
ãã 
$num
ãã 
)
ãã 
{
åå 
var
çç 
addr
çç 
=
çç 

stackalloc
çç %
byte
çç& *
[
çç* +
SECRET_KEY_SIZE
çç+ :
+
çç; <
$num
çç= ?
]
çç? @
;
çç@ A
var
êê 
	newSecret
êê 
=
êê 
(
êê  !
byte
êê! %
*
êê% &
)
êê& '
(
êê( )
(
êê) *
ulong
êê* /
)
êê/ 0
addr
êê1 5
+
êê6 7
$num
êê8 :
&
êê; <
$num
êê= O
)
êêO P
;
êêP Q
EncodeSecretKey
íí 
(
íí  
	newSecret
íí  )
,
íí) *
secret
íí+ 1
,
íí1 2
seed
íí3 7
)
íí7 8
;
íí8 9
Hash128Long
ìì 
(
ìì 
input
ìì !
,
ìì! "
dest
ìì# '
,
ìì' (
length
ìì) /
,
ìì/ 0
	newSecret
ìì1 :
,
ìì: ;
out
ìì< ?
result
ìì@ F
)
ììF G
;
ììG H
}
îî 
else
ññ 
{
óó 
Hash128Long
òò 
(
òò 
input
òò !
,
òò! "
dest
òò# '
,
òò' (
length
òò) /
,
òò/ 0
secret
òò1 7
,
òò7 8
out
òò9 <
result
òò= C
)
òòC D
;
òòD E
}
ôô 
}
öö 	
private
ûû 
static
ûû 
unsafe
ûû 
ulong
ûû #
Hash64Len1To3
ûû$ 1
(
ûû1 2
byte
ûû2 6
*
ûû6 7
input
ûû8 =
,
ûû= >
long
ûû? C
len
ûûD G
,
ûûG H
byte
ûûI M
*
ûûM N
secret
ûûO U
,
ûûU V
ulong
ûûW \
seed
ûû] a
)
ûûa b
{
üü 	
	unchecked
†† 
{
°° 
var
¢¢ 
c1
¢¢ 
=
¢¢ 
input
¢¢ 
[
¢¢ 
$num
¢¢  
]
¢¢  !
;
¢¢! "
var
££ 
c2
££ 
=
££ 
input
££ 
[
££ 
len
££ "
>>
££# %
$num
££& '
]
££' (
;
££( )
var
§§ 
c3
§§ 
=
§§ 
input
§§ 
[
§§ 
len
§§ "
-
§§# $
$num
§§% &
]
§§& '
;
§§' (
var
•• 
combined
•• 
=
•• 
(
••  
(
••  !
uint
••! %
)
••% &
c1
••& (
<<
••) +
$num
••, .
)
••. /
|
••0 1
(
••2 3
(
••3 4
uint
••4 8
)
••8 9
c2
••9 ;
<<
••= ?
$num
••@ B
)
••B C
|
••D E
(
••F G
(
••G H
uint
••H L
)
••L M
c3
••M O
<<
••P R
$num
••T U
)
••U V
|
••W X
(
••Y Z
(
••Z [
uint
••[ _
)
••_ `
len
••` c
<<
••d f
$num
••g h
)
••h i
;
••i j
ulong
¶¶ 
bitflip
¶¶ 
=
¶¶ 
(
¶¶  !
Read32LE
¶¶! )
(
¶¶) *
secret
¶¶* 0
)
¶¶0 1
^
¶¶2 3
Read32LE
¶¶4 <
(
¶¶< =
secret
¶¶= C
+
¶¶C D
$num
¶¶D E
)
¶¶E F
)
¶¶F G
+
¶¶H I
seed
¶¶J N
;
¶¶N O
ulong
ßß 
keyed
ßß 
=
ßß 
(
ßß 
ulong
ßß $
)
ßß$ %
combined
ßß% -
^
ßß. /
bitflip
ßß0 7
;
ßß7 8
return
®® 
AvalancheH64
®® #
(
®®# $
keyed
®®$ )
)
®®) *
;
®®* +
}
©© 
}
™™ 	
private
¨¨ 
static
¨¨ 
unsafe
¨¨ 
ulong
¨¨ #
Hash64Len4To8
¨¨$ 1
(
¨¨1 2
byte
¨¨2 6
*
¨¨6 7
input
¨¨8 =
,
¨¨= >
long
¨¨? C
length
¨¨D J
,
¨¨J K
byte
¨¨L P
*
¨¨P Q
secret
¨¨R X
,
¨¨X Y
ulong
¨¨Z _
seed
¨¨` d
)
¨¨d e
{
≠≠ 	
	unchecked
ÆÆ 
{
ØØ 
seed
∞∞ 
^=
∞∞ 
(
∞∞ 
ulong
∞∞ 
)
∞∞ 
Swap32
∞∞ %
(
∞∞% &
(
∞∞& '
uint
∞∞' +
)
∞∞+ ,
seed
∞∞, 0
)
∞∞0 1
<<
∞∞2 4
$num
∞∞5 7
;
∞∞7 8
var
±± 
input1
±± 
=
±± 
Read32LE
±± %
(
±±% &
input
±±& +
)
±±+ ,
;
±±, -
var
≤≤ 
input2
≤≤ 
=
≤≤ 
Read32LE
≤≤ %
(
≤≤% &
input
≤≤& +
+
≤≤, -
length
≤≤. 4
-
≤≤5 6
$num
≤≤7 8
)
≤≤8 9
;
≤≤9 :
var
≥≥ 
bitflip
≥≥ 
=
≥≥ 
(
≥≥ 
Read64LE
≥≥ '
(
≥≥' (
secret
≥≥( .
+
≥≥. /
$num
≥≥/ 0
)
≥≥0 1
^
≥≥2 3
Read64LE
≥≥4 <
(
≥≥< =
secret
≥≥= C
+
≥≥C D
$num
≥≥D F
)
≥≥F G
)
≥≥G H
-
≥≥I J
seed
≥≥K O
;
≥≥O P
var
¥¥ 
input64
¥¥ 
=
¥¥ 
input2
¥¥ $
+
¥¥% &
(
¥¥' (
(
¥¥( )
(
¥¥) *
ulong
¥¥* /
)
¥¥/ 0
input1
¥¥0 6
)
¥¥6 7
<<
¥¥8 :
$num
¥¥; =
)
¥¥= >
;
¥¥> ?
var
µµ 
keyed
µµ 
=
µµ 
input64
µµ #
^
µµ$ %
bitflip
µµ& -
;
µµ- .
return
∂∂ 
rrmxmx
∂∂ 
(
∂∂ 
keyed
∂∂ #
,
∂∂# $
(
∂∂% &
ulong
∂∂& +
)
∂∂+ ,
length
∂∂, 2
)
∂∂2 3
;
∂∂3 4
}
∑∑ 
}
∏∏ 	
private
∫∫ 
static
∫∫ 
unsafe
∫∫ 
ulong
∫∫ #
Hash64Len9To16
∫∫$ 2
(
∫∫2 3
byte
∫∫3 7
*
∫∫7 8
input
∫∫9 >
,
∫∫> ?
long
∫∫@ D
length
∫∫E K
,
∫∫K L
byte
∫∫M Q
*
∫∫Q R
secret
∫∫S Y
,
∫∫Y Z
ulong
∫∫[ `
seed
∫∫a e
)
∫∫e f
{
ªª 	
	unchecked
ºº 
{
ΩΩ 
var
ææ 
bitflip1
ææ 
=
ææ 
(
ææ  
Read64LE
ææ  (
(
ææ( )
secret
ææ) /
+
ææ/ 0
$num
ææ0 2
)
ææ2 3
^
ææ4 5
Read64LE
ææ6 >
(
ææ> ?
secret
ææ? E
+
ææE F
$num
ææF H
)
ææH I
)
ææI J
+
ææK L
seed
ææM Q
;
ææQ R
var
øø 
bitflip2
øø 
=
øø 
(
øø  
Read64LE
øø  (
(
øø( )
secret
øø) /
+
øø/ 0
$num
øø0 2
)
øø2 3
^
øø4 5
Read64LE
øø6 >
(
øø> ?
secret
øø? E
+
øøE F
$num
øøF H
)
øøH I
)
øøI J
-
øøK L
seed
øøM Q
;
øøQ R
var
¿¿ 
input_lo
¿¿ 
=
¿¿ 
Read64LE
¿¿ '
(
¿¿' (
input
¿¿( -
)
¿¿- .
^
¿¿/ 0
bitflip1
¿¿1 9
;
¿¿9 :
var
¡¡ 
input_hi
¡¡ 
=
¡¡ 
Read64LE
¡¡ '
(
¡¡' (
input
¡¡( -
+
¡¡. /
length
¡¡0 6
-
¡¡7 8
$num
¡¡9 :
)
¡¡: ;
^
¡¡< =
bitflip2
¡¡> F
;
¡¡F G
var
¬¬ 
acc
¬¬ 
=
¬¬ 
(
¬¬ 
ulong
¬¬  
)
¬¬  !
length
¬¬! '
+
¬¬( )
Swap64
¬¬* 0
(
¬¬0 1
input_lo
¬¬1 9
)
¬¬9 :
+
¬¬; <
input_hi
¬¬= E
+
¬¬F G
Mul128Fold64
¬¬H T
(
¬¬T U
input_lo
¬¬U ]
,
¬¬] ^
input_hi
¬¬_ g
)
¬¬g h
;
¬¬h i
return
√√ 
	Avalanche
√√  
(
√√  !
acc
√√! $
)
√√$ %
;
√√% &
}
ƒƒ 
}
≈≈ 	
private
«« 
static
«« 
unsafe
«« 
ulong
«« #
Hash64Len0To16
««$ 2
(
««2 3
byte
««3 7
*
««7 8
input
««9 >
,
««> ?
long
««@ D
length
««E K
,
««K L
byte
««M Q
*
««Q R
secret
««S Y
,
««Y Z
ulong
««[ `
seed
««a e
)
««e f
{
»» 	
if
…… 
(
…… 
length
…… 
>
…… 
$num
…… 
)
…… 
{
   
return
ÀÀ 
Hash64Len9To16
ÀÀ %
(
ÀÀ% &
input
ÀÀ& +
,
ÀÀ+ ,
length
ÀÀ- 3
,
ÀÀ3 4
secret
ÀÀ5 ;
,
ÀÀ; <
seed
ÀÀ= A
)
ÀÀA B
;
ÀÀB C
}
ÃÃ 
if
ŒŒ 
(
ŒŒ 
length
ŒŒ 
>=
ŒŒ 
$num
ŒŒ 
)
ŒŒ 
{
œœ 
return
–– 
Hash64Len4To8
–– $
(
––$ %
input
––% *
,
––* +
length
––, 2
,
––2 3
secret
––4 :
,
––: ;
seed
––< @
)
––@ A
;
––A B
}
—— 
if
”” 
(
”” 
length
”” 
>
”” 
$num
”” 
)
”” 
{
‘‘ 
return
’’ 
Hash64Len1To3
’’ $
(
’’$ %
input
’’% *
,
’’* +
length
’’, 2
,
’’2 3
secret
’’4 :
,
’’: ;
seed
’’< @
)
’’@ A
;
’’A B
}
÷÷ 
return
ÿÿ 
AvalancheH64
ÿÿ 
(
ÿÿ  
seed
ÿÿ  $
^
ÿÿ% &
(
ÿÿ' (
Read64LE
ÿÿ( 0
(
ÿÿ0 1
secret
ÿÿ1 7
+
ÿÿ7 8
$num
ÿÿ8 :
)
ÿÿ: ;
^
ÿÿ< =
Read64LE
ÿÿ> F
(
ÿÿF G
secret
ÿÿG M
+
ÿÿM N
$num
ÿÿN P
)
ÿÿP Q
)
ÿÿQ R
)
ÿÿR S
;
ÿÿS T
}
ŸŸ 	
private
€€ 
static
€€ 
unsafe
€€ 
ulong
€€ #
Hash64Len17To128
€€$ 4
(
€€4 5
byte
€€5 9
*
€€9 :
input
€€; @
,
€€@ A
long
€€B F
length
€€G M
,
€€M N
byte
€€O S
*
€€S T
secret
€€U [
,
€€[ \
ulong
€€] b
seed
€€c g
)
€€g h
{
‹‹ 	
	unchecked
›› 
{
ﬁﬁ 
var
ﬂﬂ 
acc
ﬂﬂ 
=
ﬂﬂ 
(
ﬂﬂ 
ulong
ﬂﬂ  
)
ﬂﬂ  !
length
ﬂﬂ" (
*
ﬂﬂ) *
	PRIME64_1
ﬂﬂ+ 4
;
ﬂﬂ4 5
if
‡‡ 
(
‡‡ 
length
‡‡ 
>
‡‡ 
$num
‡‡ 
)
‡‡  
{
·· 
if
‚‚ 
(
‚‚ 
length
‚‚ 
>
‚‚  
$num
‚‚! #
)
‚‚# $
{
„„ 
if
‰‰ 
(
‰‰ 
length
‰‰ "
>
‰‰# $
$num
‰‰% '
)
‰‰' (
{
ÂÂ 
acc
ÊÊ 
+=
ÊÊ  "
Mix16
ÊÊ# (
(
ÊÊ( )
input
ÊÊ) .
+
ÊÊ/ 0
$num
ÊÊ1 3
,
ÊÊ3 4
secret
ÊÊ5 ;
+
ÊÊ< =
$num
ÊÊ> @
,
ÊÊ@ A
seed
ÊÊB F
)
ÊÊF G
;
ÊÊG H
acc
ÁÁ 
+=
ÁÁ  "
Mix16
ÁÁ# (
(
ÁÁ( )
input
ÁÁ) .
+
ÁÁ/ 0
length
ÁÁ1 7
-
ÁÁ8 9
$num
ÁÁ: <
,
ÁÁ< =
secret
ÁÁ> D
+
ÁÁE F
$num
ÁÁG J
,
ÁÁJ K
seed
ÁÁL P
)
ÁÁP Q
;
ÁÁQ R
}
ËË 
acc
ÍÍ 
+=
ÍÍ 
Mix16
ÍÍ $
(
ÍÍ$ %
input
ÍÍ% *
+
ÍÍ+ ,
$num
ÍÍ- /
,
ÍÍ/ 0
secret
ÍÍ1 7
+
ÍÍ8 9
$num
ÍÍ: <
,
ÍÍ< =
seed
ÍÍ> B
)
ÍÍB C
;
ÍÍC D
acc
ÎÎ 
+=
ÎÎ 
Mix16
ÎÎ $
(
ÎÎ$ %
input
ÎÎ% *
+
ÎÎ+ ,
length
ÎÎ- 3
-
ÎÎ4 5
$num
ÎÎ6 8
,
ÎÎ8 9
secret
ÎÎ: @
+
ÎÎA B
$num
ÎÎC E
,
ÎÎE F
seed
ÎÎG K
)
ÎÎK L
;
ÎÎL M
}
ÏÏ 
acc
ÓÓ 
+=
ÓÓ 
Mix16
ÓÓ  
(
ÓÓ  !
input
ÓÓ! &
+
ÓÓ' (
$num
ÓÓ) +
,
ÓÓ+ ,
secret
ÓÓ- 3
+
ÓÓ4 5
$num
ÓÓ6 8
,
ÓÓ8 9
seed
ÓÓ: >
)
ÓÓ> ?
;
ÓÓ? @
acc
ÔÔ 
+=
ÔÔ 
Mix16
ÔÔ  
(
ÔÔ  !
input
ÔÔ! &
+
ÔÔ' (
length
ÔÔ) /
-
ÔÔ0 1
$num
ÔÔ2 4
,
ÔÔ4 5
secret
ÔÔ6 <
+
ÔÔ= >
$num
ÔÔ? A
,
ÔÔA B
seed
ÔÔC G
)
ÔÔG H
;
ÔÔH I
}
 
acc
ÚÚ 
+=
ÚÚ 
Mix16
ÚÚ 
(
ÚÚ 
input
ÚÚ "
+
ÚÚ# $
$num
ÚÚ% &
,
ÚÚ& '
secret
ÚÚ( .
+
ÚÚ/ 0
$num
ÚÚ1 2
,
ÚÚ2 3
seed
ÚÚ4 8
)
ÚÚ8 9
;
ÚÚ9 :
acc
ÛÛ 
+=
ÛÛ 
Mix16
ÛÛ 
(
ÛÛ 
input
ÛÛ "
+
ÛÛ# $
length
ÛÛ% +
-
ÛÛ, -
$num
ÛÛ. 0
,
ÛÛ0 1
secret
ÛÛ2 8
+
ÛÛ9 :
$num
ÛÛ; =
,
ÛÛ= >
seed
ÛÛ? C
)
ÛÛC D
;
ÛÛD E
return
ıı 
	Avalanche
ıı  
(
ıı  !
acc
ıı! $
)
ıı$ %
;
ıı% &
}
ˆˆ 
}
˜˜ 	
private
˘˘ 
static
˘˘ 
unsafe
˘˘ 
ulong
˘˘ #
Hash64Len129To240
˘˘$ 5
(
˘˘5 6
byte
˘˘6 :
*
˘˘: ;
input
˘˘< A
,
˘˘A B
long
˘˘C G
length
˘˘H N
,
˘˘N O
byte
˘˘P T
*
˘˘T U
secret
˘˘V \
,
˘˘\ ]
ulong
˘˘^ c
seed
˘˘d h
)
˘˘h i
{
˙˙ 	
	unchecked
˚˚ 
{
¸¸ 
var
˝˝ 
acc
˝˝ 
=
˝˝ 
(
˝˝ 
ulong
˝˝  
)
˝˝  !
length
˝˝" (
*
˝˝) *
	PRIME64_1
˝˝+ 4
;
˝˝4 5
var
˛˛ 
nbRounds
˛˛ 
=
˛˛ 
(
˛˛  
int
˛˛  #
)
˛˛# $
length
˛˛% +
/
˛˛, -
$num
˛˛. 0
;
˛˛0 1
for
ˇˇ 
(
ˇˇ 
var
ˇˇ 
i
ˇˇ 
=
ˇˇ 
$num
ˇˇ 
;
ˇˇ 
i
ˇˇ  !
<
ˇˇ" #
$num
ˇˇ$ %
;
ˇˇ% &
i
ˇˇ' (
++
ˇˇ( *
)
ˇˇ* +
{
ÄÄ 
acc
ÅÅ 
+=
ÅÅ 
Mix16
ÅÅ  
(
ÅÅ  !
input
ÅÅ! &
+
ÅÅ' (
(
ÅÅ) *
$num
ÅÅ* ,
*
ÅÅ- .
i
ÅÅ/ 0
)
ÅÅ0 1
,
ÅÅ1 2
secret
ÅÅ3 9
+
ÅÅ: ;
(
ÅÅ< =
$num
ÅÅ= ?
*
ÅÅ@ A
i
ÅÅB C
)
ÅÅC D
,
ÅÅD E
seed
ÅÅF J
)
ÅÅJ K
;
ÅÅK L
}
ÇÇ 
acc
ÑÑ 
=
ÑÑ 
	Avalanche
ÑÑ 
(
ÑÑ  
acc
ÑÑ  #
)
ÑÑ# $
;
ÑÑ$ %
for
ÜÜ 
(
ÜÜ 
var
ÜÜ 
i
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
;
ÜÜ 
i
ÜÜ  !
<
ÜÜ" #
nbRounds
ÜÜ$ ,
;
ÜÜ, -
i
ÜÜ. /
++
ÜÜ/ 1
)
ÜÜ1 2
{
áá 
acc
àà 
+=
àà 
Mix16
àà  
(
àà  !
input
àà! &
+
àà' (
(
àà) *
$num
àà* ,
*
àà- .
i
àà/ 0
)
àà0 1
,
àà1 2
secret
àà3 9
+
àà: ;
(
àà< =
$num
àà= ?
*
àà@ A
(
ààB C
i
ààC D
-
ààE F
$num
ààG H
)
ààH I
)
ààI J
+
ààK L!
MIDSIZE_STARTOFFSET
ààM `
,
àà` a
seed
ààb f
)
ààf g
;
ààg h
}
ââ 
acc
ãã 
+=
ãã 
Mix16
ãã 
(
ãã 
input
ãã "
+
ãã# $
length
ãã% +
-
ãã, -
$num
ãã. 0
,
ãã0 1
secret
ãã2 8
+
ãã9 :!
SECRET_KEY_MIN_SIZE
ãã; N
-
ããO P 
MIDSIZE_LASTOFFSET
ããQ c
,
ããc d
seed
ããe i
)
ããi j
;
ããj k
return
åå 
	Avalanche
åå  
(
åå  !
acc
åå! $
)
åå$ %
;
åå% &
}
çç 
}
éé 	
[
êê 	
BurstCompile
êê	 
]
êê 
private
ëë 
static
ëë 
unsafe
ëë 
ulong
ëë #

Hash64Long
ëë$ .
(
ëë. /
byte
ëë/ 3
*
ëë3 4
input
ëë5 :
,
ëë: ;
byte
ëë< @
*
ëë@ A
dest
ëëB F
,
ëëF G
long
ëëH L
length
ëëM S
,
ëëS T
byte
ëëU Y
*
ëëY Z
secret
ëë[ a
)
ëëa b
{
íí 	
var
ìì 
addr
ìì 
=
ìì 

stackalloc
ìì !
byte
ìì" &
[
ìì& '

STRIPE_LEN
ìì' 1
+
ìì2 3
$num
ìì4 6
]
ìì6 7
;
ìì7 8
var
îî 
acc
îî 
=
îî 
(
îî 
ulong
îî 
*
îî 
)
îî 
(
îî  
(
îî  !
ulong
îî! &
)
îî& '
addr
îî( ,
+
îî- .
$num
îî/ 1
&
îî2 3
$num
îî4 F
)
îîF G
;
îîG H
acc
ïï 
[
ïï 
$num
ïï 
]
ïï 
=
ïï 
	PRIME32_3
ïï 
;
ïï 
acc
ññ 
[
ññ 
$num
ññ 
]
ññ 
=
ññ 
	PRIME64_1
ññ 
;
ññ 
acc
óó 
[
óó 
$num
óó 
]
óó 
=
óó 
	PRIME64_2
óó 
;
óó 
acc
òò 
[
òò 
$num
òò 
]
òò 
=
òò 
	PRIME64_3
òò 
;
òò 
acc
ôô 
[
ôô 
$num
ôô 
]
ôô 
=
ôô 
	PRIME64_4
ôô 
;
ôô 
acc
öö 
[
öö 
$num
öö 
]
öö 
=
öö 
	PRIME32_2
öö 
;
öö 
acc
õõ 
[
õõ 
$num
õõ 
]
õõ 
=
õõ 
	PRIME64_5
õõ 
;
õõ 
acc
úú 
[
úú 
$num
úú 
]
úú 
=
úú 
	PRIME32_1
úú 
;
úú 
	unchecked
ûû 
{
üü 
if
°° 
(
°° 
X86
°° 
.
°° 
Avx2
°° 
.
°° 
IsAvx2Supported
°° ,
)
°°, -
{
¢¢ &
Avx2HashLongInternalLoop
££ ,
(
££, -
acc
££- 0
,
££0 1
input
££2 7
,
££7 8
dest
££9 =
,
££= >
length
££? E
,
££E F
secret
££G M
,
££M N
$num
££O P
)
££P Q
;
££Q R
}
§§ 
else
•• 
{
ßß )
DefaultHashLongInternalLoop
®® /
(
®®/ 0
acc
®®0 3
,
®®3 4
input
®®5 :
,
®®: ;
dest
®®< @
,
®®@ A
length
®®B H
,
®®H I
secret
®®J P
,
®®P Q
$num
®®R S
)
®®S T
;
®®T U
}
©© 
return
™™ 
MergeAcc
™™ 
(
™™  
acc
™™  #
,
™™# $
secret
™™% +
+
™™, -$
SECRET_MERGEACCS_START
™™. D
,
™™D E
(
™™F G
ulong
™™G L
)
™™L M
length
™™N T
*
™™U V
	PRIME64_1
™™W `
)
™™` a
;
™™a b
}
´´ 
}
¨¨ 	
private
≤≤ 
static
≤≤ 
unsafe
≤≤ 
void
≤≤ "
Hash128Len1To3
≤≤# 1
(
≤≤1 2
byte
≤≤2 6
*
≤≤6 7
input
≤≤8 =
,
≤≤= >
long
≤≤? C
length
≤≤D J
,
≤≤J K
byte
≤≤L P
*
≤≤P Q
secret
≤≤R X
,
≤≤X Y
ulong
≤≤Z _
seed
≤≤` d
,
≤≤d e
out
≥≥ 
uint4
≥≥ 
result
≥≥ 
)
≥≥ 
{
¥¥ 	
	unchecked
µµ 
{
∂∂ 
var
∑∑ 
c1
∑∑ 
=
∑∑ 
input
∑∑ 
[
∑∑ 
$num
∑∑  
]
∑∑  !
;
∑∑! "
var
∏∏ 
c2
∏∏ 
=
∏∏ 
input
∏∏ 
[
∏∏ 
length
∏∏ %
>>
∏∏& (
$num
∏∏) *
]
∏∏* +
;
∏∏+ ,
var
ππ 
c3
ππ 
=
ππ 
input
ππ 
[
ππ 
length
ππ %
-
ππ& '
$num
ππ( )
]
ππ) *
;
ππ* +
var
∫∫ 
	combinedl
∫∫ 
=
∫∫ 
(
∫∫  !
(
∫∫! "
uint
∫∫" &
)
∫∫& '
c1
∫∫( *
<<
∫∫+ -
$num
∫∫. 0
)
∫∫0 1
+
∫∫2 3
(
∫∫4 5
(
∫∫5 6
(
∫∫6 7
uint
∫∫7 ;
)
∫∫; <
c2
∫∫= ?
)
∫∫? @
<<
∫∫A C
$num
∫∫D F
)
∫∫F G
+
∫∫H I
(
∫∫J K
(
∫∫K L
(
∫∫L M
uint
∫∫M Q
)
∫∫Q R
c3
∫∫S U
)
∫∫U V
<<
∫∫W Y
$num
∫∫Z [
)
∫∫[ \
+
∫∫] ^
(
∫∫_ `
(
∫∫` a
(
∫∫a b
uint
∫∫b f
)
∫∫f g
length
∫∫h n
)
∫∫n o
<<
∫∫p r
$num
∫∫s t
)
∫∫t u
;
∫∫u v
var
ªª 
	combinedh
ªª 
=
ªª 
RotL32
ªª  &
(
ªª& '
Swap32
ªª' -
(
ªª- .
	combinedl
ªª. 7
)
ªª7 8
,
ªª8 9
$num
ªª: <
)
ªª< =
;
ªª= >
var
ºº 
bitflipl
ºº 
=
ºº 
(
ºº  
Read32LE
ºº  (
(
ºº( )
secret
ºº) /
)
ºº/ 0
^
ºº1 2
Read32LE
ºº3 ;
(
ºº; <
secret
ºº< B
+
ººB C
$num
ººC D
)
ººD E
)
ººE F
+
ººG H
seed
ººI M
;
ººM N
var
ΩΩ 
bitfliph
ΩΩ 
=
ΩΩ 
(
ΩΩ  
Read32LE
ΩΩ  (
(
ΩΩ( )
secret
ΩΩ) /
+
ΩΩ/ 0
$num
ΩΩ0 1
)
ΩΩ1 2
^
ΩΩ3 4
Read32LE
ΩΩ5 =
(
ΩΩ= >
secret
ΩΩ> D
+
ΩΩD E
$num
ΩΩE G
)
ΩΩG H
)
ΩΩH I
-
ΩΩJ K
seed
ΩΩL P
;
ΩΩP Q
var
ææ 
keyed_lo
ææ 
=
ææ 
	combinedl
ææ (
^
ææ) *
bitflipl
ææ+ 3
;
ææ3 4
var
øø 
keyed_hi
øø 
=
øø 
	combinedh
øø (
^
øø) *
bitfliph
øø+ 3
;
øø3 4
result
¡¡ 
=
¡¡ 
ToUint4
¡¡  
(
¡¡  !
AvalancheH64
¡¡! -
(
¡¡- .
keyed_lo
¡¡. 6
)
¡¡6 7
,
¡¡7 8
AvalancheH64
¡¡9 E
(
¡¡E F
keyed_hi
¡¡F N
)
¡¡N O
)
¡¡O P
;
¡¡P Q
}
¬¬ 
}
√√ 	
private
≈≈ 
static
≈≈ 
unsafe
≈≈ 
void
≈≈ "
Hash128Len4To8
≈≈# 1
(
≈≈1 2
byte
≈≈2 6
*
≈≈6 7
input
≈≈8 =
,
≈≈= >
long
≈≈? C
len
≈≈D G
,
≈≈G H
byte
≈≈I M
*
≈≈M N
secret
≈≈O U
,
≈≈U V
ulong
≈≈W \
seed
≈≈] a
,
≈≈a b
out
∆∆ 
uint4
∆∆ 
result
∆∆ 
)
∆∆ 
{
«« 	
	unchecked
»» 
{
…… 
seed
   
^=
   
(
   
ulong
   
)
   
Swap32
   %
(
  % &
(
  & '
uint
  ' +
)
  + ,
seed
  , 0
)
  0 1
<<
  2 4
$num
  5 7
;
  7 8
var
ÀÀ 
input_lo
ÀÀ 
=
ÀÀ 
Read32LE
ÀÀ '
(
ÀÀ' (
input
ÀÀ( -
)
ÀÀ- .
;
ÀÀ. /
var
ÃÃ 
input_hi
ÃÃ 
=
ÃÃ 
Read32LE
ÃÃ '
(
ÃÃ' (
input
ÃÃ( -
+
ÃÃ. /
len
ÃÃ0 3
-
ÃÃ4 5
$num
ÃÃ6 7
)
ÃÃ7 8
;
ÃÃ8 9
var
ÕÕ 
input_64
ÕÕ 
=
ÕÕ 
input_lo
ÕÕ '
+
ÕÕ( )
(
ÕÕ* +
(
ÕÕ+ ,
ulong
ÕÕ, 1
)
ÕÕ1 2
input_hi
ÕÕ2 :
<<
ÕÕ; =
$num
ÕÕ> @
)
ÕÕ@ A
;
ÕÕA B
var
ŒŒ 
bitflip
ŒŒ 
=
ŒŒ 
(
ŒŒ 
Read64LE
ŒŒ '
(
ŒŒ' (
secret
ŒŒ( .
+
ŒŒ. /
$num
ŒŒ/ 1
)
ŒŒ1 2
^
ŒŒ3 4
Read64LE
ŒŒ5 =
(
ŒŒ= >
secret
ŒŒ> D
+
ŒŒD E
$num
ŒŒE G
)
ŒŒG H
)
ŒŒH I
+
ŒŒJ K
seed
ŒŒL P
;
ŒŒP Q
var
œœ 
keyed
œœ 
=
œœ 
input_64
œœ $
^
œœ% &
bitflip
œœ' .
;
œœ. /
var
—— 
low
—— 
=
—— 
Common
——  
.
——  !
umul128
——! (
(
——( )
keyed
——) .
,
——. /
	PRIME64_1
——0 9
+
——: ;
(
——< =
ulong
——= B
)
——B C
(
——C D
len
——D G
<<
——H J
$num
——K L
)
——L M
,
——M N
out
——O R
var
——S V
high
——W [
)
——[ \
;
——\ ]
high
”” 
+=
”” 
(
”” 
low
”” 
<<
”” 
$num
””  !
)
””! "
;
””" #
low
‘‘ 
^=
‘‘ 
(
‘‘ 
high
‘‘ 
>>
‘‘ 
$num
‘‘  !
)
‘‘! "
;
‘‘" #
low
÷÷ 
=
÷÷ 

XorShift64
÷÷  
(
÷÷  !
low
÷÷! $
,
÷÷$ %
$num
÷÷& (
)
÷÷( )
;
÷÷) *
low
◊◊ 
*=
◊◊ 
$num
◊◊ *
;
◊◊* +
low
ÿÿ 
=
ÿÿ 

XorShift64
ÿÿ  
(
ÿÿ  !
low
ÿÿ! $
,
ÿÿ$ %
$num
ÿÿ& (
)
ÿÿ( )
;
ÿÿ) *
high
ŸŸ 
=
ŸŸ 
	Avalanche
ŸŸ  
(
ŸŸ  !
high
ŸŸ! %
)
ŸŸ% &
;
ŸŸ& '
result
⁄⁄ 
=
⁄⁄ 
ToUint4
⁄⁄  
(
⁄⁄  !
low
⁄⁄! $
,
⁄⁄$ %
high
⁄⁄& *
)
⁄⁄* +
;
⁄⁄+ ,
}
€€ 
}
‹‹ 	
private
ﬁﬁ 
static
ﬁﬁ 
unsafe
ﬁﬁ 
void
ﬁﬁ "
Hash128Len9To16
ﬁﬁ# 2
(
ﬁﬁ2 3
byte
ﬁﬁ3 7
*
ﬁﬁ7 8
input
ﬁﬁ9 >
,
ﬁﬁ> ?
long
ﬁﬁ@ D
len
ﬁﬁE H
,
ﬁﬁH I
byte
ﬁﬁJ N
*
ﬁﬁN O
secret
ﬁﬁP V
,
ﬁﬁV W
ulong
ﬁﬁX ]
seed
ﬁﬁ^ b
,
ﬁﬁb c
out
ﬂﬂ 
uint4
ﬂﬂ 
result
ﬂﬂ 
)
ﬂﬂ 
{
‡‡ 	
	unchecked
·· 
{
‚‚ 
var
„„ 
bitflipl
„„ 
=
„„ 
(
„„  
Read64LE
„„  (
(
„„( )
secret
„„) /
+
„„/ 0
$num
„„0 2
)
„„2 3
^
„„4 5
Read64LE
„„6 >
(
„„> ?
secret
„„? E
+
„„E F
$num
„„F H
)
„„H I
)
„„I J
-
„„K L
seed
„„M Q
;
„„Q R
var
‰‰ 
bitfliph
‰‰ 
=
‰‰ 
(
‰‰  
Read64LE
‰‰  (
(
‰‰( )
secret
‰‰) /
+
‰‰/ 0
$num
‰‰0 2
)
‰‰2 3
^
‰‰4 5
Read64LE
‰‰6 >
(
‰‰> ?
secret
‰‰? E
+
‰‰E F
$num
‰‰F H
)
‰‰H I
)
‰‰I J
+
‰‰K L
seed
‰‰M Q
;
‰‰Q R
var
ÂÂ 
input_lo
ÂÂ 
=
ÂÂ 
Read64LE
ÂÂ '
(
ÂÂ' (
input
ÂÂ( -
)
ÂÂ- .
;
ÂÂ. /
var
ÊÊ 
input_hi
ÊÊ 
=
ÊÊ 
Read64LE
ÊÊ '
(
ÊÊ' (
input
ÊÊ( -
+
ÊÊ. /
len
ÊÊ0 3
-
ÊÊ4 5
$num
ÊÊ6 7
)
ÊÊ7 8
;
ÊÊ8 9
var
ÁÁ 
low
ÁÁ 
=
ÁÁ 
Common
ÁÁ  
.
ÁÁ  !
umul128
ÁÁ! (
(
ÁÁ( )
input_lo
ÁÁ) 1
^
ÁÁ2 3
input_hi
ÁÁ4 <
^
ÁÁ= >
bitflipl
ÁÁ? G
,
ÁÁG H
	PRIME64_1
ÁÁI R
,
ÁÁR S
out
ÁÁT W
var
ÁÁX [
high
ÁÁ\ `
)
ÁÁ` a
;
ÁÁa b
low
ÈÈ 
+=
ÈÈ 
(
ÈÈ 
ulong
ÈÈ 
)
ÈÈ 
(
ÈÈ 
len
ÈÈ "
-
ÈÈ# $
$num
ÈÈ% &
)
ÈÈ& '
<<
ÈÈ( *
$num
ÈÈ+ -
;
ÈÈ- .
input_hi
ÍÍ 
^=
ÍÍ 
bitfliph
ÍÍ &
;
ÍÍ& '
high
ÎÎ 
+=
ÎÎ 
input_hi
ÎÎ  
+
ÎÎ! "
	Mul32To64
ÎÎ# ,
(
ÎÎ, -
(
ÎÎ- .
uint
ÎÎ. 2
)
ÎÎ2 3
input_hi
ÎÎ3 ;
,
ÎÎ; <
	PRIME32_2
ÎÎ= F
-
ÎÎG H
$num
ÎÎI J
)
ÎÎJ K
;
ÎÎK L
low
ÏÏ 
^=
ÏÏ 
Swap64
ÏÏ 
(
ÏÏ 
high
ÏÏ #
)
ÏÏ# $
;
ÏÏ$ %
var
ÓÓ 
hlow
ÓÓ 
=
ÓÓ 
Common
ÓÓ !
.
ÓÓ! "
umul128
ÓÓ" )
(
ÓÓ) *
low
ÓÓ* -
,
ÓÓ- .
	PRIME64_2
ÓÓ/ 8
,
ÓÓ8 9
out
ÓÓ: =
var
ÓÓ> A
hhigh
ÓÓB G
)
ÓÓG H
;
ÓÓH I
hhigh
ÔÔ 
+=
ÔÔ 
high
ÔÔ 
*
ÔÔ 
	PRIME64_2
ÔÔ  )
;
ÔÔ) *
result
ÒÒ 
=
ÒÒ 
ToUint4
ÒÒ  
(
ÒÒ  !
	Avalanche
ÒÒ! *
(
ÒÒ* +
hlow
ÒÒ+ /
)
ÒÒ/ 0
,
ÒÒ0 1
	Avalanche
ÒÒ2 ;
(
ÒÒ; <
hhigh
ÒÒ< A
)
ÒÒA B
)
ÒÒB C
;
ÒÒC D
}
ÚÚ 
}
ÛÛ 	
private
ıı 
static
ıı 
unsafe
ıı 
void
ıı "
Hash128Len0To16
ıı# 2
(
ıı2 3
byte
ıı3 7
*
ıı7 8
input
ıı9 >
,
ıı> ?
long
ıı@ D
length
ııE K
,
ııK L
byte
ııM Q
*
ııQ R
secret
ııS Y
,
ııY Z
ulong
ıı[ `
seed
ııa e
,
ııe f
out
ˆˆ 
uint4
ˆˆ 
result
ˆˆ 
)
ˆˆ 
{
˜˜ 	
if
¯¯ 
(
¯¯ 
length
¯¯ 
>
¯¯ 
$num
¯¯ 
)
¯¯ 
{
˘˘ 
Hash128Len9To16
˙˙ 
(
˙˙  
input
˙˙  %
,
˙˙% &
length
˙˙' -
,
˙˙- .
secret
˙˙/ 5
,
˙˙5 6
seed
˙˙7 ;
,
˙˙; <
out
˙˙= @
result
˙˙A G
)
˙˙G H
;
˙˙H I
return
˚˚ 
;
˚˚ 
}
¸¸ 
if
˛˛ 
(
˛˛ 
length
˛˛ 
>=
˛˛ 
$num
˛˛ 
)
˛˛ 
{
ˇˇ 
Hash128Len4To8
ÄÄ 
(
ÄÄ 
input
ÄÄ $
,
ÄÄ$ %
length
ÄÄ& ,
,
ÄÄ, -
secret
ÄÄ. 4
,
ÄÄ4 5
seed
ÄÄ6 :
,
ÄÄ: ;
out
ÄÄ< ?
result
ÄÄ@ F
)
ÄÄF G
;
ÄÄG H
return
ÅÅ 
;
ÅÅ 
}
ÇÇ 
if
ÑÑ 
(
ÑÑ 
length
ÑÑ 
>
ÑÑ 
$num
ÑÑ 
)
ÑÑ 
{
ÖÖ 
Hash128Len1To3
ÜÜ 
(
ÜÜ 
input
ÜÜ $
,
ÜÜ$ %
length
ÜÜ& ,
,
ÜÜ, -
secret
ÜÜ. 4
,
ÜÜ4 5
seed
ÜÜ6 :
,
ÜÜ: ;
out
ÜÜ< ?
result
ÜÜ@ F
)
ÜÜF G
;
ÜÜG H
return
áá 
;
áá 
}
àà 
var
ää 
bitflipl
ää 
=
ää 
Read64LE
ää #
(
ää# $
secret
ää$ *
+
ää* +
$num
ää+ -
)
ää- .
^
ää/ 0
Read64LE
ää1 9
(
ää9 :
secret
ää: @
+
ää@ A
$num
ääA C
)
ääC D
;
ääD E
var
ãã 
bitfliph
ãã 
=
ãã 
Read64LE
ãã #
(
ãã# $
secret
ãã$ *
+
ãã* +
$num
ãã+ -
)
ãã- .
^
ãã/ 0
Read64LE
ãã1 9
(
ãã9 :
secret
ãã: @
+
ãã@ A
$num
ããA C
)
ããC D
;
ããD E
var
åå 
low
åå 
=
åå 
AvalancheH64
åå "
(
åå" #
seed
åå# '
^
åå( )
bitflipl
åå* 2
)
åå2 3
;
åå3 4
var
çç 
hi
çç 
=
çç 
AvalancheH64
çç !
(
çç! "
seed
çç# '
^
çç( )
bitfliph
çç* 2
)
çç2 3
;
çç3 4
result
éé 
=
éé 
ToUint4
éé 
(
éé 
low
éé  
,
éé  !
hi
éé" $
)
éé$ %
;
éé% &
}
èè 	
private
ëë 
static
ëë 
unsafe
ëë 
void
ëë "
Hash128Len17To128
ëë# 4
(
ëë4 5
byte
ëë5 9
*
ëë9 :
input
ëë; @
,
ëë@ A
long
ëëB F
length
ëëG M
,
ëëM N
byte
ëëO S
*
ëëS T
secret
ëëU [
,
ëë[ \
ulong
ëë] b
seed
ëëc g
,
ëëg h
out
íí 
uint4
íí 
result
íí 
)
íí 
{
ìì 	
	unchecked
îî 
{
ïï 
var
ññ 
acc
ññ 
=
ññ 
new
ññ 
ulong2
ññ $
(
ññ$ %
(
ññ% &
ulong
ññ& +
)
ññ+ ,
length
ññ- 3
*
ññ4 5
	PRIME64_1
ññ6 ?
,
ññ? @
$num
ññA B
)
ññB C
;
ññC D
if
óó 
(
óó 
length
óó 
>
óó 
$num
óó 
)
óó  
{
òò 
if
ôô 
(
ôô 
length
ôô 
>
ôô  
$num
ôô! #
)
ôô# $
{
öö 
if
õõ 
(
õõ 
length
õõ "
>
õõ# $
$num
õõ% '
)
õõ' (
{
úú 
acc
ùù 
=
ùù  !
Mix32
ùù" '
(
ùù' (
acc
ùù( +
,
ùù+ ,
input
ùù- 2
+
ùù3 4
$num
ùù5 7
,
ùù7 8
input
ùù9 >
+
ùù? @
length
ùùA G
-
ùùH I
$num
ùùJ L
,
ùùL M
secret
ùùN T
+
ùùU V
$num
ùùW Y
,
ùùY Z
seed
ùù[ _
)
ùù_ `
;
ùù` a
}
ûû 
acc
†† 
=
†† 
Mix32
†† #
(
††# $
acc
††$ '
,
††' (
input
††) .
+
††/ 0
$num
††1 3
,
††3 4
input
††5 :
+
††; <
length
††= C
-
††D E
$num
††F H
,
††H I
secret
††J P
+
††Q R
$num
††S U
,
††U V
seed
††W [
)
††[ \
;
††\ ]
}
°° 
acc
££ 
=
££ 
Mix32
££ 
(
££  
acc
££  #
,
££# $
input
££% *
+
££+ ,
$num
££- /
,
££/ 0
input
££1 6
+
££7 8
length
££9 ?
-
££@ A
$num
££B D
,
££D E
secret
££F L
+
££M N
$num
££O Q
,
££Q R
seed
££S W
)
££W X
;
££X Y
}
§§ 
acc
¶¶ 
=
¶¶ 
Mix32
¶¶ 
(
¶¶ 
acc
¶¶ 
,
¶¶  
input
¶¶! &
,
¶¶& '
input
¶¶( -
+
¶¶. /
length
¶¶0 6
-
¶¶7 8
$num
¶¶9 ;
,
¶¶; <
secret
¶¶= C
,
¶¶C D
seed
¶¶E I
)
¶¶I J
;
¶¶J K
var
®® 
low64
®® 
=
®® 
acc
®® 
.
®®  
x
®®  !
+
®®" #
acc
®®$ '
.
®®' (
y
®®( )
;
®®) *
var
©© 
high64
©© 
=
©© 
acc
©©  
.
©©  !
x
©©! "
*
©©# $
	PRIME64_1
©©% .
+
©©/ 0
acc
©©1 4
.
©©4 5
y
©©5 6
*
©©7 8
	PRIME64_4
©©9 B
+
©©C D
(
©©E F
(
©©F G
ulong
©©G L
)
©©L M
length
©©N T
-
©©U V
seed
©©W [
)
©©[ \
*
©©] ^
	PRIME64_2
©©_ h
;
©©h i
result
´´ 
=
´´ 
ToUint4
´´  
(
´´  !
	Avalanche
´´! *
(
´´* +
low64
´´+ 0
)
´´0 1
,
´´1 2
$num
´´3 6
-
´´7 8
	Avalanche
´´9 B
(
´´B C
high64
´´C I
)
´´I J
)
´´J K
;
´´K L
}
¨¨ 
}
≠≠ 	
private
ØØ 
static
ØØ 
unsafe
ØØ 
void
ØØ " 
Hash128Len129To240
ØØ# 5
(
ØØ5 6
byte
ØØ6 :
*
ØØ: ;
input
ØØ< A
,
ØØA B
long
ØØC G
length
ØØH N
,
ØØN O
byte
ØØP T
*
ØØT U
secret
ØØV \
,
ØØ\ ]
ulong
ØØ^ c
seed
ØØd h
,
ØØh i
out
∞∞ 
uint4
∞∞ 
result
∞∞ 
)
∞∞ 
{
±± 	
	unchecked
≤≤ 
{
≥≥ 
var
¥¥ 
acc
¥¥ 
=
¥¥ 
new
¥¥ 
ulong2
¥¥ $
(
¥¥$ %
(
¥¥% &
ulong
¥¥& +
)
¥¥+ ,
length
¥¥- 3
*
¥¥4 5
	PRIME64_1
¥¥6 ?
,
¥¥? @
$num
¥¥A B
)
¥¥B C
;
¥¥C D
var
µµ 
nbRounds
µµ 
=
µµ 
length
µµ %
/
µµ& '
$num
µµ( *
;
µµ* +
int
∂∂ 
i
∂∂ 
;
∂∂ 
for
∏∏ 
(
∏∏ 
i
∏∏ 
=
∏∏ 
$num
∏∏ 
;
∏∏ 
i
∏∏ 
<
∏∏ 
$num
∏∏  !
;
∏∏! "
i
∏∏# $
++
∏∏$ &
)
∏∏& '
{
ππ 
acc
∫∫ 
=
∫∫ 
Mix32
∫∫ 
(
∫∫  
acc
∫∫  #
,
∫∫# $
input
∫∫% *
+
∫∫+ ,
$num
∫∫- /
*
∫∫0 1
i
∫∫2 3
,
∫∫3 4
input
∫∫5 :
+
∫∫; <
$num
∫∫= ?
*
∫∫@ A
i
∫∫B C
+
∫∫D E
$num
∫∫F H
,
∫∫H I
secret
∫∫J P
+
∫∫Q R
$num
∫∫S U
*
∫∫V W
i
∫∫X Y
,
∫∫Y Z
seed
∫∫[ _
)
∫∫_ `
;
∫∫` a
}
ªª 
acc
ΩΩ 
.
ΩΩ 
x
ΩΩ 
=
ΩΩ 
	Avalanche
ΩΩ !
(
ΩΩ! "
acc
ΩΩ" %
.
ΩΩ% &
x
ΩΩ& '
)
ΩΩ' (
;
ΩΩ( )
acc
ææ 
.
ææ 
y
ææ 
=
ææ 
	Avalanche
ææ !
(
ææ! "
acc
ææ" %
.
ææ% &
y
ææ& '
)
ææ' (
;
ææ( )
for
¿¿ 
(
¿¿ 
i
¿¿ 
=
¿¿ 
$num
¿¿ 
;
¿¿ 
i
¿¿ 
<
¿¿ 
nbRounds
¿¿  (
;
¿¿( )
i
¿¿* +
++
¿¿+ -
)
¿¿- .
{
¡¡ 
acc
¬¬ 
=
¬¬ 
Mix32
¬¬ 
(
¬¬  
acc
¬¬  #
,
¬¬# $
input
¬¬% *
+
¬¬+ ,
$num
¬¬- /
*
¬¬0 1
i
¬¬2 3
,
¬¬3 4
input
¬¬5 :
+
¬¬; <
$num
¬¬= ?
*
¬¬@ A
i
¬¬B C
+
¬¬D E
$num
¬¬F H
,
¬¬H I
secret
¬¬J P
+
¬¬Q R!
MIDSIZE_STARTOFFSET
¬¬S f
+
¬¬g h
$num
¬¬i k
*
¬¬l m
(
¬¬n o
i
¬¬o p
-
¬¬q r
$num
¬¬s t
)
¬¬t u
,
¬¬u v
seed
√√ 
)
√√ 
;
√√ 
}
ƒƒ 
acc
∆∆ 
=
∆∆ 
Mix32
∆∆ 
(
∆∆ 
acc
∆∆ 
,
∆∆  
input
∆∆! &
+
∆∆' (
length
∆∆) /
-
∆∆0 1
$num
∆∆2 4
,
∆∆4 5
input
∆∆6 ;
+
∆∆< =
length
∆∆> D
-
∆∆E F
$num
∆∆G I
,
∆∆I J
secret
«« 
+
«« !
SECRET_KEY_MIN_SIZE
«« 0
-
««1 2 
MIDSIZE_LASTOFFSET
««3 E
-
««F G
$num
««H J
,
««J K
$num
««L O
-
««P Q
seed
««R V
)
««V W
;
««W X
var
…… 
low64
…… 
=
…… 
acc
…… 
.
……  
x
……  !
+
……" #
acc
……$ '
.
……' (
y
……( )
;
……) *
var
   
high64
   
=
   
acc
    
.
    !
x
  ! "
*
  # $
	PRIME64_1
  % .
+
  / 0
acc
  1 4
.
  4 5
y
  5 6
*
  7 8
	PRIME64_4
  9 B
+
  C D
(
  E F
(
  F G
ulong
  G L
)
  L M
length
  N T
-
  U V
seed
  W [
)
  [ \
*
  ] ^
	PRIME64_2
  _ h
;
  h i
result
ÃÃ 
=
ÃÃ 
ToUint4
ÃÃ  
(
ÃÃ  !
	Avalanche
ÃÃ! *
(
ÃÃ* +
low64
ÃÃ+ 0
)
ÃÃ0 1
,
ÃÃ1 2
$num
ÃÃ3 6
-
ÃÃ7 8
	Avalanche
ÃÃ9 B
(
ÃÃB C
high64
ÃÃC I
)
ÃÃI J
)
ÃÃJ K
;
ÃÃK L
}
ÕÕ 
}
ŒŒ 	
[
–– 	
BurstCompile
––	 
]
–– 
private
—— 
static
—— 
unsafe
—— 
void
—— "
Hash128Long
——# .
(
——. /
byte
——/ 3
*
——3 4
input
——5 :
,
——: ;
byte
——< @
*
——@ A
dest
——B F
,
——F G
long
——H L
length
——M S
,
——S T
byte
——U Y
*
——Y Z
secret
——[ a
,
——a b
out
——c f
uint4
——g l
result
——m s
)
——s t
{
““ 	
var
‘‘ 
addr
‘‘ 
=
‘‘ 

stackalloc
‘‘ !
byte
‘‘" &
[
‘‘& '

STRIPE_LEN
‘‘' 1
+
‘‘2 3
$num
‘‘4 6
]
‘‘6 7
;
‘‘7 8
var
’’ 
acc
’’ 
=
’’ 
(
’’ 
ulong
’’ 
*
’’ 
)
’’ 
(
’’  
(
’’  !
ulong
’’! &
)
’’& '
addr
’’( ,
+
’’- .
$num
’’/ 1
&
’’2 3
$num
’’4 F
)
’’F G
;
’’G H
acc
÷÷ 
[
÷÷ 
$num
÷÷ 
]
÷÷ 
=
÷÷ 
	PRIME32_3
÷÷ 
;
÷÷ 
acc
◊◊ 
[
◊◊ 
$num
◊◊ 
]
◊◊ 
=
◊◊ 
	PRIME64_1
◊◊ 
;
◊◊ 
acc
ÿÿ 
[
ÿÿ 
$num
ÿÿ 
]
ÿÿ 
=
ÿÿ 
	PRIME64_2
ÿÿ 
;
ÿÿ 
acc
ŸŸ 
[
ŸŸ 
$num
ŸŸ 
]
ŸŸ 
=
ŸŸ 
	PRIME64_3
ŸŸ 
;
ŸŸ 
acc
⁄⁄ 
[
⁄⁄ 
$num
⁄⁄ 
]
⁄⁄ 
=
⁄⁄ 
	PRIME64_4
⁄⁄ 
;
⁄⁄ 
acc
€€ 
[
€€ 
$num
€€ 
]
€€ 
=
€€ 
	PRIME32_2
€€ 
;
€€ 
acc
‹‹ 
[
‹‹ 
$num
‹‹ 
]
‹‹ 
=
‹‹ 
	PRIME64_5
‹‹ 
;
‹‹ 
acc
›› 
[
›› 
$num
›› 
]
›› 
=
›› 
	PRIME32_1
›› 
;
›› 
	unchecked
ﬂﬂ 
{
‡‡ 
if
‚‚ 
(
‚‚ 
X86
‚‚ 
.
‚‚ 
Avx2
‚‚ 
.
‚‚ 
IsAvx2Supported
‚‚ ,
)
‚‚, -
{
„„ &
Avx2HashLongInternalLoop
‰‰ ,
(
‰‰, -
acc
‰‰- 0
,
‰‰0 1
input
‰‰2 7
,
‰‰7 8
dest
‰‰9 =
,
‰‰= >
length
‰‰? E
,
‰‰E F
secret
‰‰G M
,
‰‰M N
$num
‰‰O P
)
‰‰P Q
;
‰‰Q R
}
ÂÂ 
else
ÊÊ 
{
ËË )
DefaultHashLongInternalLoop
ÈÈ /
(
ÈÈ/ 0
acc
ÈÈ0 3
,
ÈÈ3 4
input
ÈÈ5 :
,
ÈÈ: ;
dest
ÈÈ< @
,
ÈÈ@ A
length
ÈÈB H
,
ÈÈH I
secret
ÈÈJ P
,
ÈÈP Q
$num
ÈÈR S
)
ÈÈS T
;
ÈÈT U
}
ÍÍ 
var
ÏÏ 
low64
ÏÏ 
=
ÏÏ 
MergeAcc
ÏÏ $
(
ÏÏ$ %
acc
ÏÏ% (
,
ÏÏ( )
secret
ÏÏ* 0
+
ÏÏ1 2$
SECRET_MERGEACCS_START
ÏÏ3 I
,
ÏÏI J
(
ÏÏK L
ulong
ÏÏL Q
)
ÏÏQ R
length
ÏÏS Y
*
ÏÏZ [
	PRIME64_1
ÏÏ\ e
)
ÏÏe f
;
ÏÏf g
var
ÌÌ 
high64
ÌÌ 
=
ÌÌ 
MergeAcc
ÌÌ %
(
ÌÌ% &
acc
ÌÌ& )
,
ÌÌ) *
secret
ÌÌ+ 1
+
ÌÌ2 3
SECRET_KEY_SIZE
ÌÌ4 C
-
ÌÌD E
$num
ÌÌF H
-
ÌÌI J$
SECRET_MERGEACCS_START
ÌÌK a
,
ÌÌa b
~
ÓÓ 
(
ÓÓ 
(
ÓÓ 
ulong
ÓÓ 
)
ÓÓ 
length
ÓÓ $
*
ÓÓ% &
	PRIME64_2
ÓÓ' 0
)
ÓÓ0 1
)
ÓÓ1 2
;
ÓÓ2 3
result
 
=
 
ToUint4
  
(
  !
low64
! &
,
& '
high64
( .
)
. /
;
/ 0
}
ÒÒ 
}
ÚÚ 	
internal
¯¯ 
static
¯¯ 
uint2
¯¯ 
ToUint2
¯¯ %
(
¯¯% &
ulong
¯¯& +
u
¯¯, -
)
¯¯- .
{
˘˘ 	
return
˙˙ 
new
˙˙ 
uint2
˙˙ 
(
˙˙ 
(
˙˙ 
uint
˙˙ "
)
˙˙" #
(
˙˙# $
u
˙˙$ %
&
˙˙& '
$num
˙˙( 2
)
˙˙2 3
,
˙˙3 4
(
˙˙5 6
uint
˙˙6 :
)
˙˙: ;
(
˙˙; <
u
˙˙< =
>>
˙˙> @
$num
˙˙A C
)
˙˙C D
)
˙˙D E
;
˙˙E F
}
˚˚ 	
internal
˝˝ 
static
˝˝ 
uint4
˝˝ 
ToUint4
˝˝ %
(
˝˝% &
ulong
˝˝& +
ul0
˝˝, /
,
˝˝/ 0
ulong
˝˝1 6
ul1
˝˝7 :
)
˝˝: ;
{
˛˛ 	
return
ˇˇ 
new
ˇˇ 
uint4
ˇˇ 
(
ˇˇ 
(
ˇˇ 
uint
ˇˇ "
)
ˇˇ" #
(
ˇˇ# $
ul0
ˇˇ$ '
&
ˇˇ( )
$num
ˇˇ* 4
)
ˇˇ4 5
,
ˇˇ5 6
(
ˇˇ7 8
uint
ˇˇ8 <
)
ˇˇ< =
(
ˇˇ= >
ul0
ˇˇ> A
>>
ˇˇB D
$num
ˇˇE G
)
ˇˇG H
,
ˇˇH I
(
ˇˇJ K
uint
ˇˇK O
)
ˇˇO P
(
ˇˇP Q
ul1
ˇˇQ T
&
ˇˇU V
$num
ˇˇW a
)
ˇˇa b
,
ˇˇb c
(
ˇˇd e
uint
ˇˇe i
)
ˇˇi j
(
ˇˇj k
ul1
ˇˇk n
>>
ˇˇo q
$num
ˇˇr t
)
ˇˇt u
)
ˇˇu v
;
ˇˇv w
}
ÄÄ 	
internal
ÇÇ 
static
ÇÇ 
unsafe
ÇÇ 
void
ÇÇ #
EncodeSecretKey
ÇÇ$ 3
(
ÇÇ3 4
byte
ÇÇ4 8
*
ÇÇ8 9
dst
ÇÇ: =
,
ÇÇ= >
byte
ÇÇ? C
*
ÇÇC D
secret
ÇÇE K
,
ÇÇK L
ulong
ÇÇM R
seed
ÇÇS W
)
ÇÇW X
{
ÉÉ 	
	unchecked
ÑÑ 
{
ÖÖ 
var
ÜÜ 
seedInitCount
ÜÜ !
=
ÜÜ" #
SECRET_KEY_SIZE
ÜÜ$ 3
/
ÜÜ4 5
(
ÜÜ6 7
$num
ÜÜ7 8
*
ÜÜ9 :
$num
ÜÜ; <
)
ÜÜ< =
;
ÜÜ= >
for
áá 
(
áá 
var
áá 
i
áá 
=
áá 
$num
áá 
;
áá 
i
áá  !
<
áá" #
seedInitCount
áá$ 1
;
áá1 2
i
áá3 4
++
áá4 6
)
áá6 7
{
àà 
	Write64LE
ââ 
(
ââ 
dst
ââ !
+
ââ" #
$num
ââ$ &
*
ââ' (
i
ââ) *
+
ââ+ ,
$num
ââ- .
,
ââ. /
Read64LE
ââ0 8
(
ââ8 9
secret
ââ9 ?
+
ââ@ A
$num
ââB D
*
ââE F
i
ââG H
+
ââI J
$num
ââK L
)
ââL M
+
ââN O
seed
ââP T
)
ââT U
;
ââU V
	Write64LE
ää 
(
ää 
dst
ää !
+
ää" #
$num
ää$ &
*
ää' (
i
ää) *
+
ää+ ,
$num
ää- .
,
ää. /
Read64LE
ää0 8
(
ää8 9
secret
ää9 ?
+
ää@ A
$num
ääB D
*
ääE F
i
ääG H
+
ääI J
$num
ääK L
)
ääL M
-
ääN O
seed
ääP T
)
ääT U
;
ääU V
}
ãã 
}
åå 
}
çç 	
[
èè 	

MethodImpl
èè	 
(
èè 
MethodImplOptions
èè %
.
èè% & 
AggressiveInlining
èè& 8
)
èè8 9
]
èè9 :
private
êê 
static
êê 
unsafe
êê 
ulong
êê #
Read64LE
êê$ ,
(
êê, -
void
êê- 1
*
êê1 2
addr
êê3 7
)
êê7 8
=>
êê9 ;
*
êê< =
(
êê= >
ulong
êê> C
*
êêC D
)
êêD E
addr
êêF J
;
êêJ K
[
ëë 	

MethodImpl
ëë	 
(
ëë 
MethodImplOptions
ëë %
.
ëë% & 
AggressiveInlining
ëë& 8
)
ëë8 9
]
ëë9 :
private
íí 
static
íí 
unsafe
íí 
uint
íí "
Read32LE
íí# +
(
íí+ ,
void
íí, 0
*
íí0 1
addr
íí2 6
)
íí6 7
=>
íí8 :
*
íí; <
(
íí< =
uint
íí= A
*
ííA B
)
ííB C
addr
ííD H
;
ííH I
[
îî 	

MethodImpl
îî	 
(
îî 
MethodImplOptions
îî %
.
îî% & 
AggressiveInlining
îî& 8
)
îî8 9
]
îî9 :
private
ïï 
static
ïï 
unsafe
ïï 
void
ïï "
	Write64LE
ïï# ,
(
ïï, -
void
ïï- 1
*
ïï1 2
addr
ïï3 7
,
ïï7 8
ulong
ïï9 >
value
ïï? D
)
ïïD E
=>
ïïF H
*
ïïI J
(
ïïJ K
ulong
ïïK P
*
ïïP Q
)
ïïQ R
addr
ïïS W
=
ïïX Y
value
ïïZ _
;
ïï_ `
[
ññ 	

MethodImpl
ññ	 
(
ññ 
MethodImplOptions
ññ %
.
ññ% & 
AggressiveInlining
ññ& 8
)
ññ8 9
]
ññ9 :
private
óó 
static
óó 
unsafe
óó 
void
óó "
Read32LE
óó# +
(
óó+ ,
void
óó, 0
*
óó0 1
addr
óó2 6
,
óó6 7
uint
óó8 <
value
óó= B
)
óóB C
=>
óóD F
*
óóG H
(
óóH I
uint
óóI M
*
óóM N
)
óóN O
addr
óóP T
=
óóU V
value
óóW \
;
óó\ ]
[
ôô 	

MethodImpl
ôô	 
(
ôô 
MethodImplOptions
ôô %
.
ôô% & 
AggressiveInlining
ôô& 8
)
ôô8 9
]
ôô9 :
private
öö 
static
öö 
ulong
öö 
	Mul32To64
öö &
(
öö& '
uint
öö' +
x
öö, -
,
öö- .
uint
öö/ 3
y
öö4 5
)
öö5 6
=>
öö7 9
(
öö: ;
ulong
öö; @
)
öö@ A
x
ööB C
*
ööD E
y
ööF G
;
ööG H
[
úú 	

MethodImpl
úú	 
(
úú 
MethodImplOptions
úú %
.
úú% & 
AggressiveInlining
úú& 8
)
úú8 9
]
úú9 :
private
ùù 
static
ùù 
ulong
ùù 
Swap64
ùù #
(
ùù# $
ulong
ùù$ )
x
ùù* +
)
ùù+ ,
{
ûû 	
return
üü 
(
üü 
(
üü 
x
üü 
<<
üü 
$num
üü 
)
üü 
&
üü 
$num
üü  4
)
üü4 5
|
üü6 7
(
†† 
(
†† 
x
†† 
<<
†† 
$num
†† 
)
†† 
&
†† 
$num
††  4
)
††4 5
|
††6 7
(
°° 
(
°° 
x
°° 
<<
°° 
$num
°° 
)
°° 
&
°° 
$num
°°  4
)
°°4 5
|
°°6 7
(
¢¢ 
(
¢¢ 
x
¢¢ 
<<
¢¢ 
$num
¢¢ 
)
¢¢ 
&
¢¢ 
$num
¢¢  4
)
¢¢4 5
|
¢¢6 7
(
££ 
(
££ 
x
££ 
>>
££ 
$num
££ 
)
££ 
&
££ 
$num
££  4
)
££4 5
|
££6 7
(
§§ 
(
§§ 
x
§§ 
>>
§§ 
$num
§§ 
)
§§ 
&
§§ 
$num
§§  4
)
§§4 5
|
§§6 7
(
•• 
(
•• 
x
•• 
>>
•• 
$num
•• 
)
•• 
&
•• 
$num
••  4
)
••4 5
|
••6 7
(
¶¶ 
(
¶¶ 
x
¶¶ 
>>
¶¶ 
$num
¶¶ 
)
¶¶ 
&
¶¶ 
$num
¶¶  4
)
¶¶4 5
;
¶¶5 6
}
ßß 	
[
©© 	

MethodImpl
©©	 
(
©© 
MethodImplOptions
©© %
.
©©% & 
AggressiveInlining
©©& 8
)
©©8 9
]
©©9 :
private
™™ 
static
™™ 
uint
™™ 
Swap32
™™ "
(
™™" #
uint
™™# '
x
™™( )
)
™™) *
{
´´ 	
return
¨¨ 
(
¨¨ 
(
¨¨ 
x
¨¨ 
<<
¨¨ 
$num
¨¨ 
)
¨¨ 
&
¨¨ 
$num
¨¨  *
)
¨¨* +
|
¨¨, -
(
≠≠ 
(
≠≠ 
x
≠≠ 
<<
≠≠ 
$num
≠≠ 
)
≠≠ 
&
≠≠ 
$num
≠≠  *
)
≠≠* +
|
≠≠, -
(
ÆÆ 
(
ÆÆ 
x
ÆÆ 
>>
ÆÆ 
$num
ÆÆ 
)
ÆÆ 
&
ÆÆ 
$num
ÆÆ  *
)
ÆÆ* +
|
ÆÆ, -
(
ØØ 
(
ØØ 
x
ØØ 
>>
ØØ 
$num
ØØ 
)
ØØ 
&
ØØ 
$num
ØØ  *
)
ØØ* +
;
ØØ+ ,
}
∞∞ 	
[
≤≤ 	

MethodImpl
≤≤	 
(
≤≤ 
MethodImplOptions
≤≤ %
.
≤≤% & 
AggressiveInlining
≤≤& 8
)
≤≤8 9
]
≤≤9 :
private
≥≥ 
static
≥≥ 
uint
≥≥ 
RotL32
≥≥ "
(
≥≥" #
uint
≥≥# '
x
≥≥( )
,
≥≥) *
int
≥≥+ .
r
≥≥/ 0
)
≥≥0 1
=>
≥≥2 4
(
≥≥5 6
(
≥≥6 7
(
≥≥7 8
x
≥≥8 9
)
≥≥9 :
<<
≥≥; =
(
≥≥> ?
r
≥≥? @
)
≥≥@ A
)
≥≥A B
|
≥≥C D
(
≥≥E F
(
≥≥F G
x
≥≥G H
)
≥≥H I
>>
≥≥J L
(
≥≥M N
$num
≥≥N P
-
≥≥Q R
(
≥≥S T
r
≥≥T U
)
≥≥U V
)
≥≥V W
)
≥≥W X
)
≥≥X Y
;
≥≥Y Z
[
¥¥ 	

MethodImpl
¥¥	 
(
¥¥ 
MethodImplOptions
¥¥ %
.
¥¥% & 
AggressiveInlining
¥¥& 8
)
¥¥8 9
]
¥¥9 :
private
µµ 
static
µµ 
ulong
µµ 
RotL64
µµ #
(
µµ# $
ulong
µµ$ )
x
µµ* +
,
µµ+ ,
int
µµ- 0
r
µµ1 2
)
µµ2 3
=>
µµ4 6
(
µµ7 8
(
µµ8 9
(
µµ9 :
x
µµ: ;
)
µµ; <
<<
µµ= ?
(
µµ@ A
r
µµA B
)
µµB C
)
µµC D
|
µµE F
(
µµG H
(
µµH I
x
µµI J
)
µµJ K
>>
µµL N
(
µµO P
$num
µµP R
-
µµS T
(
µµU V
r
µµV W
)
µµW X
)
µµX Y
)
µµY Z
)
µµZ [
;
µµ[ \
[
∑∑ 	

MethodImpl
∑∑	 
(
∑∑ 
MethodImplOptions
∑∑ %
.
∑∑% & 
AggressiveInlining
∑∑& 8
)
∑∑8 9
]
∑∑9 :
private
∏∏ 
static
∏∏ 
ulong
∏∏ 

XorShift64
∏∏ '
(
∏∏' (
ulong
∏∏( -
v64
∏∏. 1
,
∏∏1 2
int
∏∏3 6
shift
∏∏7 <
)
∏∏< =
{
ππ 	
return
∫∫ 
v64
∫∫ 
^
∫∫ 
(
∫∫ 
v64
∫∫ 
>>
∫∫  
shift
∫∫! &
)
∫∫& '
;
∫∫' (
}
ªª 	
[
ÿÿ 	

MethodImpl
ÿÿ	 
(
ÿÿ 
MethodImplOptions
ÿÿ %
.
ÿÿ% & 
AggressiveInlining
ÿÿ& 8
)
ÿÿ8 9
]
ÿÿ9 :
private
ŸŸ 
static
ŸŸ 
ulong
ŸŸ 
Mul128Fold64
ŸŸ )
(
ŸŸ) *
ulong
ŸŸ* /
lhs
ŸŸ0 3
,
ŸŸ3 4
ulong
ŸŸ5 :
rhs
ŸŸ; >
)
ŸŸ> ?
{
⁄⁄ 	
var
€€ 
lo
€€ 
=
€€ 
Common
€€ 
.
€€ 
umul128
€€ #
(
€€# $
lhs
€€$ '
,
€€' (
rhs
€€) ,
,
€€, -
out
€€. 1
var
€€2 5
hi
€€6 8
)
€€8 9
;
€€9 :
return
‹‹ 
lo
‹‹ 
^
‹‹ 
hi
‹‹ 
;
‹‹ 
}
›› 	
[
ﬂﬂ 	

MethodImpl
ﬂﬂ	 
(
ﬂﬂ 
MethodImplOptions
ﬂﬂ %
.
ﬂﬂ% & 
AggressiveInlining
ﬂﬂ& 8
)
ﬂﬂ8 9
]
ﬂﬂ9 :
private
‡‡ 
static
‡‡ 
unsafe
‡‡ 
ulong
‡‡ #
Mix16
‡‡$ )
(
‡‡) *
byte
‡‡* .
*
‡‡. /
input
‡‡0 5
,
‡‡5 6
byte
‡‡7 ;
*
‡‡; <
secret
‡‡= C
,
‡‡C D
ulong
‡‡E J
seed
‡‡K O
)
‡‡O P
{
·· 	
var
‚‚ 
input_lo
‚‚ 
=
‚‚ 
Read64LE
‚‚ #
(
‚‚# $
input
‚‚$ )
)
‚‚) *
;
‚‚* +
var
„„ 
input_hi
„„ 
=
„„ 
Read64LE
„„ #
(
„„# $
input
„„$ )
+
„„* +
$num
„„, -
)
„„- .
;
„„. /
return
‰‰ 
Mul128Fold64
‰‰ 
(
‰‰  
input_lo
ÂÂ 
^
ÂÂ 
(
ÂÂ 
Read64LE
ÂÂ $
(
ÂÂ$ %
secret
ÂÂ% +
+
ÂÂ, -
$num
ÂÂ. /
)
ÂÂ/ 0
+
ÂÂ1 2
seed
ÂÂ3 7
)
ÂÂ7 8
,
ÂÂ8 9
input_hi
ÊÊ 
^
ÊÊ 
(
ÊÊ 
Read64LE
ÊÊ $
(
ÊÊ$ %
secret
ÊÊ% +
+
ÊÊ, -
$num
ÊÊ. /
)
ÊÊ/ 0
-
ÊÊ1 2
seed
ÊÊ3 7
)
ÊÊ7 8
)
ÊÊ8 9
;
ÊÊ9 :
}
ÁÁ 	
[
ÈÈ 	

MethodImpl
ÈÈ	 
(
ÈÈ 
MethodImplOptions
ÈÈ %
.
ÈÈ% & 
AggressiveInlining
ÈÈ& 8
)
ÈÈ8 9
]
ÈÈ9 :
private
ÍÍ 
static
ÍÍ 
unsafe
ÍÍ 
ulong2
ÍÍ $
Mix32
ÍÍ% *
(
ÍÍ* +
ulong2
ÍÍ+ 1
acc
ÍÍ2 5
,
ÍÍ5 6
byte
ÍÍ7 ;
*
ÍÍ; <
input_1
ÍÍ= D
,
ÍÍD E
byte
ÍÍF J
*
ÍÍJ K
input_2
ÍÍL S
,
ÍÍS T
byte
ÍÍU Y
*
ÍÍY Z
secret
ÍÍ[ a
,
ÍÍa b
ulong
ÍÍc h
seed
ÍÍi m
)
ÍÍm n
{
ÎÎ 	
	unchecked
ÏÏ 
{
ÌÌ 
var
ÓÓ 
l0
ÓÓ 
=
ÓÓ 
acc
ÓÓ 
.
ÓÓ 
x
ÓÓ 
+
ÓÓ  
Mix16
ÓÓ! &
(
ÓÓ& '
input_1
ÓÓ' .
,
ÓÓ. /
secret
ÓÓ0 6
+
ÓÓ7 8
$num
ÓÓ9 :
,
ÓÓ: ;
seed
ÓÓ< @
)
ÓÓ@ A
;
ÓÓA B
l0
ÔÔ 
^=
ÔÔ 
Read64LE
ÔÔ 
(
ÔÔ 
input_2
ÔÔ &
)
ÔÔ& '
+
ÔÔ( )
Read64LE
ÔÔ* 2
(
ÔÔ2 3
input_2
ÔÔ3 :
+
ÔÔ; <
$num
ÔÔ= >
)
ÔÔ> ?
;
ÔÔ? @
var
ÒÒ 
l1
ÒÒ 
=
ÒÒ 
acc
ÒÒ 
.
ÒÒ 
y
ÒÒ 
+
ÒÒ  
Mix16
ÒÒ! &
(
ÒÒ& '
input_2
ÒÒ' .
,
ÒÒ. /
secret
ÒÒ0 6
+
ÒÒ7 8
$num
ÒÒ9 ;
,
ÒÒ; <
seed
ÒÒ= A
)
ÒÒA B
;
ÒÒB C
l1
ÚÚ 
^=
ÚÚ 
Read64LE
ÚÚ 
(
ÚÚ 
input_1
ÚÚ &
)
ÚÚ& '
+
ÚÚ( )
Read64LE
ÚÚ* 2
(
ÚÚ2 3
input_1
ÚÚ3 :
+
ÚÚ; <
$num
ÚÚ= >
)
ÚÚ> ?
;
ÚÚ? @
return
ÙÙ 
new
ÙÙ 
ulong2
ÙÙ !
(
ÙÙ! "
l0
ÙÙ" $
,
ÙÙ$ %
l1
ÙÙ& (
)
ÙÙ( )
;
ÙÙ) *
}
ıı 
}
ˆˆ 	
[
¯¯ 	

MethodImpl
¯¯	 
(
¯¯ 
MethodImplOptions
¯¯ %
.
¯¯% & 
AggressiveInlining
¯¯& 8
)
¯¯8 9
]
¯¯9 :
private
˘˘ 
static
˘˘ 
ulong
˘˘ 
	Avalanche
˘˘ &
(
˘˘& '
ulong
˘˘' ,
h64
˘˘- 0
)
˘˘0 1
{
˙˙ 	
	unchecked
˚˚ 
{
¸¸ 
h64
˝˝ 
=
˝˝ 

XorShift64
˝˝  
(
˝˝  !
h64
˝˝! $
,
˝˝$ %
$num
˝˝& (
)
˝˝( )
;
˝˝) *
h64
˛˛ 
*=
˛˛ 
$num
˛˛ +
;
˛˛+ ,
h64
ˇˇ 
=
ˇˇ 

XorShift64
ˇˇ  
(
ˇˇ  !
h64
ˇˇ! $
,
ˇˇ$ %
$num
ˇˇ& (
)
ˇˇ( )
;
ˇˇ) *
return
ÄÄ 
h64
ÄÄ 
;
ÄÄ 
}
ÅÅ 
}
ÇÇ 	
[
ÑÑ 	

MethodImpl
ÑÑ	 
(
ÑÑ 
MethodImplOptions
ÑÑ %
.
ÑÑ% & 
AggressiveInlining
ÑÑ& 8
)
ÑÑ8 9
]
ÑÑ9 :
private
ÖÖ 
static
ÖÖ 
ulong
ÖÖ 
AvalancheH64
ÖÖ )
(
ÖÖ) *
ulong
ÖÖ* /
h64
ÖÖ0 3
)
ÖÖ3 4
{
ÜÜ 	
	unchecked
áá 
{
àà 
h64
ââ 
^=
ââ 
h64
ââ 
>>
ââ 
$num
ââ  
;
ââ  !
h64
ää 
*=
ää 
	PRIME64_2
ää  
;
ää  !
h64
ãã 
^=
ãã 
h64
ãã 
>>
ãã 
$num
ãã  
;
ãã  !
h64
åå 
*=
åå 
	PRIME64_3
åå  
;
åå  !
h64
çç 
^=
çç 
h64
çç 
>>
çç 
$num
çç  
;
çç  !
return
éé 
h64
éé 
;
éé 
}
èè 
}
êê 	
[
íí 	

MethodImpl
íí	 
(
íí 
MethodImplOptions
íí %
.
íí% & 
AggressiveInlining
íí& 8
)
íí8 9
]
íí9 :
private
ìì 
static
ìì 
ulong
ìì 
rrmxmx
ìì #
(
ìì# $
ulong
ìì$ )
h64
ìì* -
,
ìì- .
ulong
ìì/ 4
length
ìì5 ;
)
ìì; <
{
îî 	
h64
ïï 
^=
ïï 
RotL64
ïï 
(
ïï 
h64
ïï 
,
ïï 
$num
ïï !
)
ïï! "
^
ïï# $
RotL64
ïï% +
(
ïï+ ,
h64
ïï, /
,
ïï/ 0
$num
ïï1 3
)
ïï3 4
;
ïï4 5
h64
ññ 
*=
ññ 
$num
ññ '
;
ññ' (
h64
óó 
^=
óó 
(
óó 
h64
óó 
>>
óó 
$num
óó 
)
óó 
+
óó  
length
óó! '
;
óó( )
h64
òò 
*=
òò 
$num
òò '
;
òò' (
return
ôô 

XorShift64
ôô 
(
ôô 
h64
ôô !
,
ôô! "
$num
ôô# %
)
ôô% &
;
ôô& '
}
öö 	
[
úú 	

MethodImpl
úú	 
(
úú 
MethodImplOptions
úú %
.
úú% & 
AggressiveInlining
úú& 8
)
úú8 9
]
úú9 :
private
ùù 
static
ùù 
unsafe
ùù 
ulong
ùù #
Mix2Acc
ùù$ +
(
ùù+ ,
ulong
ùù, 1
acc0
ùù2 6
,
ùù6 7
ulong
ùù8 =
acc1
ùù> B
,
ùùB C
byte
ùùD H
*
ùùH I
secret
ùùJ P
)
ùùP Q
{
ûû 	
return
üü 
Mul128Fold64
üü 
(
üü  
acc0
üü  $
^
üü% &
Read64LE
üü' /
(
üü/ 0
secret
üü0 6
)
üü6 7
,
üü7 8
acc1
üü9 =
^
üü> ?
Read64LE
üü@ H
(
üüH I
secret
üüI O
+
üüO P
$num
üüP Q
)
üüQ R
)
üüR S
;
üüS T
}
†† 	
internal
¢¢ 
static
¢¢ 
unsafe
¢¢ 
ulong
¢¢ $
MergeAcc
¢¢% -
(
¢¢- .
ulong
¢¢. 3
*
¢¢3 4
acc
¢¢5 8
,
¢¢8 9
byte
¢¢: >
*
¢¢> ?
secret
¢¢@ F
,
¢¢F G
ulong
¢¢H M
start
¢¢N S
)
¢¢S T
{
££ 	
	unchecked
§§ 
{
•• 
var
¶¶ 
result64
¶¶ 
=
¶¶ 
start
¶¶ $
;
¶¶$ %
result64
®® 
+=
®® 
Mix2Acc
®® #
(
®®# $
acc
®®$ '
[
®®' (
$num
®®( )
]
®®) *
,
®®* +
acc
®®, /
[
®®/ 0
$num
®®0 1
]
®®1 2
,
®®2 3
secret
®®4 :
+
®®; <
$num
®®= >
)
®®> ?
;
®®? @
result64
©© 
+=
©© 
Mix2Acc
©© #
(
©©# $
acc
©©$ '
[
©©' (
$num
©©( )
]
©©) *
,
©©* +
acc
©©, /
[
©©/ 0
$num
©©0 1
]
©©1 2
,
©©2 3
secret
©©4 :
+
©©; <
$num
©©= ?
)
©©? @
;
©©@ A
result64
™™ 
+=
™™ 
Mix2Acc
™™ #
(
™™# $
acc
™™$ '
[
™™' (
$num
™™( )
]
™™) *
,
™™* +
acc
™™, /
[
™™/ 0
$num
™™0 1
]
™™1 2
,
™™2 3
secret
™™4 :
+
™™; <
$num
™™= ?
)
™™? @
;
™™@ A
result64
´´ 
+=
´´ 
Mix2Acc
´´ #
(
´´# $
acc
´´$ '
[
´´' (
$num
´´( )
]
´´) *
,
´´* +
acc
´´, /
[
´´/ 0
$num
´´0 1
]
´´1 2
,
´´2 3
secret
´´4 :
+
´´; <
$num
´´= ?
)
´´? @
;
´´@ A
return
≠≠ 
	Avalanche
≠≠  
(
≠≠  !
result64
≠≠! )
)
≠≠) *
;
≠≠* +
}
ÆÆ 
}
ØØ 	
private
µµ 
static
µµ 
unsafe
µµ 
void
µµ ")
DefaultHashLongInternalLoop
µµ# >
(
µµ> ?
ulong
µµ? D
*
µµD E
acc
µµF I
,
µµI J
byte
µµK O
*
µµO P
input
µµQ V
,
µµV W
byte
µµX \
*
µµ\ ]
dest
µµ^ b
,
µµb c
long
µµd h
length
µµi o
,
µµo p
byte
µµq u
*
µµu v
secret
µµw }
,
µµ} ~
intµµ Ç
isHash64µµÉ ã
)µµã å
{
∂∂ 	
var
∏∏ 
	nb_blocks
∏∏ 
=
∏∏ 
(
∏∏ 
length
∏∏ #
-
∏∏# $
$num
∏∏$ %
)
∏∏% &
/
∏∏' (
	BLOCK_LEN
∏∏) 2
;
∏∏2 3
for
ππ 
(
ππ 
int
ππ 
n
ππ 
=
ππ 
$num
ππ 
;
ππ 
n
ππ 
<
ππ 
	nb_blocks
ππ  )
;
ππ) *
n
ππ+ ,
++
ππ, .
)
ππ. /
{
∫∫ 
DefaultAccumulate
ªª !
(
ªª! "
acc
ªª" %
,
ªª% &
input
ªª' ,
+
ªª- .
n
ªª/ 0
*
ªª1 2
	BLOCK_LEN
ªª3 <
,
ªª< =
dest
ªª> B
==
ªªC E
null
ªªF J
?
ªªK L
null
ªªM Q
:
ªªR S
dest
ªªT X
+
ªªY Z
n
ªª[ \
*
ªª] ^
	BLOCK_LEN
ªª_ h
,
ªªh i
secret
ªªj p
,
ªªp q
	NB_ROUNDS
ºº 
,
ºº 
isHash64
ºº '
)
ºº' (
;
ºº( ) 
DefaultScrambleAcc
ΩΩ "
(
ΩΩ" #
acc
ΩΩ# &
,
ΩΩ& '
secret
ΩΩ( .
+
ΩΩ/ 0
SECRET_KEY_SIZE
ΩΩ1 @
-
ΩΩA B

STRIPE_LEN
ΩΩC M
)
ΩΩM N
;
ΩΩN O
}
ææ 
var
¿¿ 
	nbStripes
¿¿ 
=
¿¿ 
(
¿¿ 
(
¿¿ 
length
¿¿ $
-
¿¿$ %
$num
¿¿% &
)
¿¿& '
-
¿¿( )
(
¿¿* +
	BLOCK_LEN
¿¿+ 4
*
¿¿5 6
	nb_blocks
¿¿7 @
)
¿¿@ A
)
¿¿A B
/
¿¿C D

STRIPE_LEN
¿¿E O
;
¿¿O P
DefaultAccumulate
¡¡ 
(
¡¡ 
acc
¡¡ !
,
¡¡! "
input
¡¡# (
+
¡¡) *
	nb_blocks
¡¡+ 4
*
¡¡5 6
	BLOCK_LEN
¡¡7 @
,
¡¡@ A
dest
¡¡B F
==
¡¡G I
null
¡¡J N
?
¡¡O P
null
¡¡Q U
:
¡¡V W
dest
¡¡X \
+
¡¡] ^
	nb_blocks
¡¡_ h
*
¡¡i j
	BLOCK_LEN
¡¡k t
,
¡¡t u
secret
¬¬ 
,
¬¬ 
	nbStripes
¬¬ !
,
¬¬! "
isHash64
¬¬# +
)
¬¬+ ,
;
¬¬, -
var
ƒƒ 
p
ƒƒ 
=
ƒƒ 
input
ƒƒ 
+
ƒƒ 
length
ƒƒ "
-
ƒƒ# $

STRIPE_LEN
ƒƒ% /
;
ƒƒ/ 0"
DefaultAccumulate512
≈≈  
(
≈≈  !
acc
≈≈! $
,
≈≈$ %
p
≈≈& '
,
≈≈' (
null
≈≈) -
,
≈≈- .
secret
≈≈/ 5
+
≈≈6 7
SECRET_KEY_SIZE
≈≈8 G
-
≈≈H I

STRIPE_LEN
≈≈J T
-
≈≈U V"
SECRET_LASTACC_START
≈≈W k
,
≈≈k l
isHash64
∆∆ 
)
∆∆ 
;
∆∆ 
if
»» 
(
»» 
dest
»» 
!=
»» 
null
»» 
)
»» 
{
…… 
var
   
	remaining
   
=
   
length
    &
%
  ' (

STRIPE_LEN
  ) 3
;
  3 4
if
ÀÀ 
(
ÀÀ 
	remaining
ÀÀ 
!=
ÀÀ  
$num
ÀÀ! "
)
ÀÀ" #
{
ÃÃ 
UnsafeUtility
ÕÕ !
.
ÕÕ! "
MemCpy
ÕÕ" (
(
ÕÕ( )
dest
ÕÕ) -
+
ÕÕ. /
length
ÕÕ0 6
-
ÕÕ7 8
	remaining
ÕÕ9 B
,
ÕÕB C
input
ÕÕD I
+
ÕÕJ K
length
ÕÕL R
-
ÕÕS T
	remaining
ÕÕU ^
,
ÕÕ^ _
	remaining
ÕÕ` i
)
ÕÕi j
;
ÕÕj k
}
ŒŒ 
}
œœ 
}
–– 	
internal
““ 
static
““ 
unsafe
““ 
void
““ #
DefaultAccumulate
““$ 5
(
““5 6
ulong
““6 ;
*
““; <
acc
““= @
,
““@ A
byte
““B F
*
““F G
input
““H M
,
““M N
byte
““O S
*
““S T
dest
““U Y
,
““Y Z
byte
““[ _
*
““_ `
secret
““a g
,
““g h
long
““i m
	nbStripes
““n w
,
““w x
int
““y |
isHash64““} Ö
)““Ö Ü
{
”” 	
for
‘‘ 
(
‘‘ 
int
‘‘ 
n
‘‘ 
=
‘‘ 
$num
‘‘ 
;
‘‘ 
n
‘‘ 
<
‘‘ 
	nbStripes
‘‘  )
;
‘‘) *
n
‘‘+ ,
++
‘‘, .
)
‘‘. /
{
’’ "
DefaultAccumulate512
÷÷ $
(
÷÷$ %
acc
÷÷% (
,
÷÷( )
input
÷÷* /
+
÷÷0 1
n
÷÷2 3
*
÷÷4 5

STRIPE_LEN
÷÷6 @
,
÷÷@ A
dest
÷÷B F
==
÷÷G I
null
÷÷J N
?
÷÷O P
null
÷÷Q U
:
÷÷V W
dest
÷÷X \
+
÷÷] ^
n
÷÷_ `
*
÷÷a b

STRIPE_LEN
÷÷c m
,
÷÷m n
secret
◊◊ 
+
◊◊ 
n
◊◊ 
*
◊◊  !
SECRET_CONSUME_RATE
◊◊! 4
,
◊◊4 5
isHash64
◊◊6 >
)
◊◊> ?
;
◊◊? @
}
ÿÿ 
}
ŸŸ 	
internal
€€ 
static
€€ 
unsafe
€€ 
void
€€ #"
DefaultAccumulate512
€€$ 8
(
€€8 9
ulong
€€9 >
*
€€> ?
acc
€€@ C
,
€€C D
byte
€€E I
*
€€I J
input
€€K P
,
€€P Q
byte
€€R V
*
€€V W
dest
€€X \
,
€€\ ]
byte
€€^ b
*
€€b c
secret
€€d j
,
€€j k
int
€€l o
isHash64
€€p x
)
€€x y
{
‹‹ 	
var
›› 
count
›› 
=
›› 
ACC_NB
›› 
;
›› 
for
ﬁﬁ 
(
ﬁﬁ 
var
ﬁﬁ 
i
ﬁﬁ 
=
ﬁﬁ 
$num
ﬁﬁ 
;
ﬁﬁ 
i
ﬁﬁ 
<
ﬁﬁ 
count
ﬁﬁ  %
;
ﬁﬁ% &
i
ﬁﬁ' (
++
ﬁﬁ( *
)
ﬁﬁ* +
{
ﬂﬂ 
var
‡‡ 
data_val
‡‡ 
=
‡‡ 
Read64LE
‡‡ '
(
‡‡' (
input
‡‡( -
+
‡‡. /
$num
‡‡0 1
*
‡‡2 3
i
‡‡4 5
)
‡‡5 6
;
‡‡6 7
var
·· 
data_key
·· 
=
·· 
data_val
·· '
^
··( )
Read64LE
··* 2
(
··2 3
secret
··3 9
+
··: ;
i
··< =
*
··> ?
$num
··@ A
)
··A B
;
··B C
if
„„ 
(
„„ 
dest
„„ 
!=
„„ 
null
„„  
)
„„  !
{
‰‰ 
	Write64LE
ÂÂ 
(
ÂÂ 
dest
ÂÂ "
+
ÂÂ# $
$num
ÂÂ% &
*
ÂÂ' (
i
ÂÂ) *
,
ÂÂ* +
data_val
ÂÂ, 4
)
ÂÂ4 5
;
ÂÂ5 6
}
ÊÊ 
acc
ËË 
[
ËË 
i
ËË 
^
ËË 
$num
ËË 
]
ËË 
+=
ËË 
data_val
ËË &
;
ËË& '
acc
ÈÈ 
[
ÈÈ 
i
ÈÈ 
]
ÈÈ 
+=
ÈÈ 
	Mul32To64
ÈÈ #
(
ÈÈ# $
(
ÈÈ$ %
uint
ÈÈ% )
)
ÈÈ) *
(
ÈÈ+ ,
data_key
ÈÈ, 4
&
ÈÈ5 6
$num
ÈÈ7 A
)
ÈÈA B
,
ÈÈB C
(
ÈÈD E
uint
ÈÈE I
)
ÈÈI J
(
ÈÈK L
data_key
ÈÈL T
>>
ÈÈU W
$num
ÈÈX Z
)
ÈÈZ [
)
ÈÈ[ \
;
ÈÈ\ ]
}
ÍÍ 
}
ÎÎ 	
internal
ÌÌ 
static
ÌÌ 
unsafe
ÌÌ 
void
ÌÌ # 
DefaultScrambleAcc
ÌÌ$ 6
(
ÌÌ6 7
ulong
ÌÌ7 <
*
ÌÌ< =
acc
ÌÌ> A
,
ÌÌA B
byte
ÌÌC G
*
ÌÌG H
secret
ÌÌI O
)
ÌÌO P
{
ÓÓ 	
for
ÔÔ 
(
ÔÔ 
var
ÔÔ 
i
ÔÔ 
=
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
i
ÔÔ 
<
ÔÔ 
ACC_NB
ÔÔ  &
;
ÔÔ& '
i
ÔÔ( )
++
ÔÔ) +
)
ÔÔ+ ,
{
 
var
ÒÒ 
key64
ÒÒ 
=
ÒÒ 
Read64LE
ÒÒ $
(
ÒÒ$ %
secret
ÒÒ% +
+
ÒÒ, -
$num
ÒÒ. /
*
ÒÒ0 1
i
ÒÒ2 3
)
ÒÒ3 4
;
ÒÒ4 5
var
ÚÚ 
acc64
ÚÚ 
=
ÚÚ 
acc
ÚÚ 
[
ÚÚ  
i
ÚÚ  !
]
ÚÚ! "
;
ÚÚ" #
acc64
ÛÛ 
=
ÛÛ 

XorShift64
ÛÛ "
(
ÛÛ" #
acc64
ÛÛ# (
,
ÛÛ( )
$num
ÛÛ* ,
)
ÛÛ, -
;
ÛÛ- .
acc64
ÙÙ 
^=
ÙÙ 
key64
ÙÙ 
;
ÙÙ 
acc64
ıı 
*=
ıı 
	PRIME32_1
ıı "
;
ıı" #
acc
ˆˆ 
[
ˆˆ 
i
ˆˆ 
]
ˆˆ 
=
ˆˆ 
acc64
ˆˆ 
;
ˆˆ 
}
˜˜ 
}
¯¯ 	
}
˚˚ 
static
˝˝ 

class
˝˝ 
xxHashDefaultKey
˝˝ !
{
˛˛ 
public
ÄÄ 
static
ÄÄ 
readonly
ÄÄ 
byte
ÄÄ #
[
ÄÄ# $
]
ÄÄ$ %
kSecret
ÄÄ& -
=
ÄÄ. /
{
ÅÅ 	
$num
ÇÇ 
,
ÇÇ 
$num
ÇÇ 
,
ÇÇ 
$num
ÇÇ 
,
ÇÇ 
$num
ÇÇ "
,
ÇÇ" #
$num
ÇÇ$ (
,
ÇÇ( )
$num
ÇÇ* .
,
ÇÇ. /
$num
ÇÇ0 4
,
ÇÇ4 5
$num
ÇÇ6 :
,
ÇÇ: ;
$num
ÇÇ< @
,
ÇÇ@ A
$num
ÇÇB F
,
ÇÇF G
$num
ÇÇH L
,
ÇÇL M
$num
ÇÇN R
,
ÇÇR S
$num
ÇÇT X
,
ÇÇX Y
$num
ÇÇZ ^
,
ÇÇ^ _
$num
ÇÇ` d
,
ÇÇd e
$num
ÇÇf j
,
ÇÇj k
$num
ÉÉ 
,
ÉÉ 
$num
ÉÉ 
,
ÉÉ 
$num
ÉÉ 
,
ÉÉ 
$num
ÉÉ "
,
ÉÉ" #
$num
ÉÉ$ (
,
ÉÉ( )
$num
ÉÉ* .
,
ÉÉ. /
$num
ÉÉ0 4
,
ÉÉ4 5
$num
ÉÉ6 :
,
ÉÉ: ;
$num
ÉÉ< @
,
ÉÉ@ A
$num
ÉÉB F
,
ÉÉF G
$num
ÉÉH L
,
ÉÉL M
$num
ÉÉN R
,
ÉÉR S
$num
ÉÉT X
,
ÉÉX Y
$num
ÉÉZ ^
,
ÉÉ^ _
$num
ÉÉ` d
,
ÉÉd e
$num
ÉÉf j
,
ÉÉj k
$num
ÑÑ 
,
ÑÑ 
$num
ÑÑ 
,
ÑÑ 
$num
ÑÑ 
,
ÑÑ 
$num
ÑÑ "
,
ÑÑ" #
$num
ÑÑ$ (
,
ÑÑ( )
$num
ÑÑ* .
,
ÑÑ. /
$num
ÑÑ0 4
,
ÑÑ4 5
$num
ÑÑ6 :
,
ÑÑ: ;
$num
ÑÑ< @
,
ÑÑ@ A
$num
ÑÑB F
,
ÑÑF G
$num
ÑÑH L
,
ÑÑL M
$num
ÑÑN R
,
ÑÑR S
$num
ÑÑT X
,
ÑÑX Y
$num
ÑÑZ ^
,
ÑÑ^ _
$num
ÑÑ` d
,
ÑÑd e
$num
ÑÑf j
,
ÑÑj k
$num
ÖÖ 
,
ÖÖ 
$num
ÖÖ 
,
ÖÖ 
$num
ÖÖ 
,
ÖÖ 
$num
ÖÖ "
,
ÖÖ" #
$num
ÖÖ$ (
,
ÖÖ( )
$num
ÖÖ* .
,
ÖÖ. /
$num
ÖÖ0 4
,
ÖÖ4 5
$num
ÖÖ6 :
,
ÖÖ: ;
$num
ÖÖ< @
,
ÖÖ@ A
$num
ÖÖB F
,
ÖÖF G
$num
ÖÖH L
,
ÖÖL M
$num
ÖÖN R
,
ÖÖR S
$num
ÖÖT X
,
ÖÖX Y
$num
ÖÖZ ^
,
ÖÖ^ _
$num
ÖÖ` d
,
ÖÖd e
$num
ÖÖf j
,
ÖÖj k
$num
ÜÜ 
,
ÜÜ 
$num
ÜÜ 
,
ÜÜ 
$num
ÜÜ 
,
ÜÜ 
$num
ÜÜ "
,
ÜÜ" #
$num
ÜÜ$ (
,
ÜÜ( )
$num
ÜÜ* .
,
ÜÜ. /
$num
ÜÜ0 4
,
ÜÜ4 5
$num
ÜÜ6 :
,
ÜÜ: ;
$num
ÜÜ< @
,
ÜÜ@ A
$num
ÜÜB F
,
ÜÜF G
$num
ÜÜH L
,
ÜÜL M
$num
ÜÜN R
,
ÜÜR S
$num
ÜÜT X
,
ÜÜX Y
$num
ÜÜZ ^
,
ÜÜ^ _
$num
ÜÜ` d
,
ÜÜd e
$num
ÜÜf j
,
ÜÜj k
$num
áá 
,
áá 
$num
áá 
,
áá 
$num
áá 
,
áá 
$num
áá "
,
áá" #
$num
áá$ (
,
áá( )
$num
áá* .
,
áá. /
$num
áá0 4
,
áá4 5
$num
áá6 :
,
áá: ;
$num
áá< @
,
áá@ A
$num
ááB F
,
ááF G
$num
ááH L
,
ááL M
$num
ááN R
,
ááR S
$num
ááT X
,
ááX Y
$num
ááZ ^
,
áá^ _
$num
áá` d
,
áád e
$num
ááf j
,
ááj k
$num
àà 
,
àà 
$num
àà 
,
àà 
$num
àà 
,
àà 
$num
àà "
,
àà" #
$num
àà$ (
,
àà( )
$num
àà* .
,
àà. /
$num
àà0 4
,
àà4 5
$num
àà6 :
,
àà: ;
$num
àà< @
,
àà@ A
$num
ààB F
,
ààF G
$num
ààH L
,
ààL M
$num
ààN R
,
ààR S
$num
ààT X
,
ààX Y
$num
ààZ ^
,
àà^ _
$num
àà` d
,
ààd e
$num
ààf j
,
ààj k
$num
ââ 
,
ââ 
$num
ââ 
,
ââ 
$num
ââ 
,
ââ 
$num
ââ "
,
ââ" #
$num
ââ$ (
,
ââ( )
$num
ââ* .
,
ââ. /
$num
ââ0 4
,
ââ4 5
$num
ââ6 :
,
ââ: ;
$num
ââ< @
,
ââ@ A
$num
ââB F
,
ââF G
$num
ââH L
,
ââL M
$num
ââN R
,
ââR S
$num
ââT X
,
ââX Y
$num
ââZ ^
,
ââ^ _
$num
ââ` d
,
ââd e
$num
ââf j
,
ââj k
$num
ãã 
,
ãã 
$num
ãã 
,
ãã 
$num
ãã 
,
ãã 
$num
ãã "
,
ãã" #
$num
ãã$ (
,
ãã( )
$num
ãã* .
,
ãã. /
$num
ãã0 4
,
ãã4 5
$num
ãã6 :
,
ãã: ;
$num
ãã< @
,
ãã@ A
$num
ããB F
,
ããF G
$num
ããH L
,
ããL M
$num
ããN R
,
ããR S
$num
ããT X
,
ããX Y
$num
ããZ ^
,
ãã^ _
$num
ãã` d
,
ããd e
$num
ããf j
,
ããj k
$num
åå 
,
åå 
$num
åå 
,
åå 
$num
åå 
,
åå 
$num
åå "
,
åå" #
$num
åå$ (
,
åå( )
$num
åå* .
,
åå. /
$num
åå0 4
,
åå4 5
$num
åå6 :
,
åå: ;
$num
åå< @
,
åå@ A
$num
ååB F
,
ååF G
$num
ååH L
,
ååL M
$num
ååN R
,
ååR S
$num
ååT X
,
ååX Y
$num
ååZ ^
,
åå^ _
$num
åå` d
,
ååd e
$num
ååf j
,
ååj k
$num
çç 
,
çç 
$num
çç 
,
çç 
$num
çç 
,
çç 
$num
çç "
,
çç" #
$num
çç$ (
,
çç( )
$num
çç* .
,
çç. /
$num
çç0 4
,
çç4 5
$num
çç6 :
,
çç: ;
$num
çç< @
,
çç@ A
$num
ççB F
,
ççF G
$num
ççH L
,
ççL M
$num
ççN R
,
ççR S
$num
ççT X
,
ççX Y
$num
ççZ ^
,
çç^ _
$num
çç` d
,
ççd e
$num
ççf j
,
ççj k
$num
éé 
,
éé 
$num
éé 
,
éé 
$num
éé 
,
éé 
$num
éé "
,
éé" #
$num
éé$ (
,
éé( )
$num
éé* .
,
éé. /
$num
éé0 4
,
éé4 5
$num
éé6 :
,
éé: ;
$num
éé< @
,
éé@ A
$num
ééB F
,
ééF G
$num
ééH L
,
ééL M
$num
ééN R
,
ééR S
$num
ééT X
,
ééX Y
$num
ééZ ^
,
éé^ _
$num
éé` d
,
ééd e
$num
ééf j
,
ééj k
}
èè 	
;
èè	 

}
êê 
}ëë ü+
eC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\ListExtensions.cs
	namespace 	
Unity
 
. 
Collections 
{ 
public		 

static		 
class		 
ListExtensions		 &
{

 
public 
static 
bool 
RemoveSwapBack )
<) *
T* +
>+ ,
(, -
this- 1
List2 6
<6 7
T7 8
>8 9
list: >
,> ?
T@ A
valueB G
)G H
{ 	
int 
index 
= 
list 
. 
IndexOf $
($ %
value% *
)* +
;+ ,
if 
( 
index 
< 
$num 
) 
return 
false 
; 
RemoveAtSwapBack 
( 
list !
,! "
index# (
)( )
;) *
return 
true 
; 
} 	
public)) 
static)) 
bool)) 
RemoveSwapBack)) )
<))) *
T))* +
>))+ ,
()), -
this))- 1
List))2 6
<))6 7
T))7 8
>))8 9
list)): >
,))> ?
	Predicate))@ I
<))I J
T))J K
>))K L
matcher))M T
)))T U
{** 	
int++ 
index++ 
=++ 
list++ 
.++ 
	FindIndex++ &
(++& '
matcher++' .
)++. /
;++/ 0
if,, 
(,, 
index,, 
<,, 
$num,, 
),, 
return-- 
false-- 
;-- 
RemoveAtSwapBack// 
(// 
list// !
,//! "
index//# (
)//( )
;//) *
return00 
true00 
;00 
}11 	
public<< 
static<< 
void<< 
RemoveAtSwapBack<< +
<<<+ ,
T<<, -
><<- .
(<<. /
this<</ 3
List<<4 8
<<<8 9
T<<9 :
><<: ;
list<<< @
,<<@ A
int<<B E
index<<F K
)<<K L
{== 	
int>> 
	lastIndex>> 
=>> 
list>>  
.>>  !
Count>>! &
->>' (
$num>>) *
;>>* +
list?? 
[?? 
index?? 
]?? 
=?? 
list?? 
[?? 
	lastIndex?? (
]??( )
;??) *
list@@ 
.@@ 
RemoveAt@@ 
(@@ 
	lastIndex@@ #
)@@# $
;@@$ %
}AA 	
publicJJ 
staticJJ 

NativeListJJ  
<JJ  !
TJJ! "
>JJ" #
ToNativeListJJ$ 0
<JJ0 1
TJJ1 2
>JJ2 3
(JJ3 4
thisJJ4 8
ListJJ9 =
<JJ= >
TJJ> ?
>JJ? @
listJJA E
,JJE F
AllocatorManagerJJG W
.JJW X
AllocatorHandleJJX g
	allocatorJJh q
)JJq r
whereJJs x
TJJy z
:JJ{ |
	unmanaged	JJ} Ü
{KK 	
varLL 
	containerLL 
=LL 
newLL 

NativeListLL  *
<LL* +
TLL+ ,
>LL, -
(LL- .
listLL. 2
.LL2 3
CountLL3 8
,LL8 9
	allocatorLL: C
)LLC D
;LLD E
forMM 
(MM 
intMM 
iMM 
=MM 
$numMM 
;MM 
iMM 
<MM 
listMM  $
.MM$ %
CountMM% *
;MM* +
iMM, -
++MM- /
)MM/ 0
{NN 
	containerOO 
.OO 
AddNoResizeOO %
(OO% &
listOO& *
[OO* +
iOO+ ,
]OO, -
)OO- .
;OO. /
}PP 
returnQQ 
	containerQQ 
;QQ 
}RR 	
public[[ 
unsafe[[ 
static[[ 
NativeArray[[ (
<[[( )
T[[) *
>[[* +
ToNativeArray[[, 9
<[[9 :
T[[: ;
>[[; <
([[< =
this[[= A
List[[B F
<[[F G
T[[G H
>[[H I
list[[J N
,[[N O
AllocatorManager[[P `
.[[` a
AllocatorHandle[[a p
	allocator[[q z
)[[z {
where	[[| Å
T
[[Ç É
:
[[Ñ Ö
	unmanaged
[[Ü è
{\\ 	
var]] 
	container]] 
=]] 
CollectionHelper]] ,
.]], -
CreateNativeArray]]- >
<]]> ?
T]]? @
>]]@ A
(]]A B
list]]B F
.]]F G
Count]]G L
,]]L M
	allocator]]N W
)]]W X
;]]X Y
for^^ 
(^^ 
int^^ 
i^^ 
=^^ 
$num^^ 
;^^ 
i^^ 
<^^ 
list^^  $
.^^$ %
Count^^% *
;^^* +
i^^, -
++^^- /
)^^/ 0
{__ 
	container`` 
[`` 
i`` 
]`` 
=`` 
list`` #
[``# $
i``$ %
]``% &
;``& '
}aa 
returnbb 
	containerbb 
;bb 
}cc 	
}dd 
}ee ∂€
rC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeHashSetExtensions.gen.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{ 
public		 

unsafe		 
static		 
class		 
HashSetExtensions		 0
{

 
public 
static 
void 

ExceptWith %
<% &
T& '
>' (
(( )
this) -
NativeHashSet. ;
<; <
T< =
>= >
	container? H
,H I
UnsafeHashSetJ W
<W X
TX Y
>Y Z
other[ `
)` a
where 
T 
: 
	unmanaged 
,  

IEquatable! +
<+ ,
T, -
>- .
{ 	
foreach 
( 
var 
item 
in  
other! &
)& '
{ 
	container 
. 
Remove  
(  !
item! %
)% &
;& '
} 
} 	
public   
static   
void   
IntersectWith   (
<  ( )
T  ) *
>  * +
(  + ,
this  , 0
NativeHashSet  1 >
<  > ?
T  ? @
>  @ A
	container  B K
,  K L
UnsafeHashSet  M Z
<  Z [
T  [ \
>  \ ]
other  ^ c
)  c d
where!! 
T!! 
:!! 
	unmanaged!! 
,!!  

IEquatable!!! +
<!!+ ,
T!!, -
>!!- .
{"" 	
var## 
result## 
=## 
new## 

UnsafeList## '
<##' (
T##( )
>##) *
(##* +
	container##+ 4
.##4 5
Count##5 :
(##: ;
)##; <
,##< =
	Allocator##> G
.##G H
Temp##H L
)##L M
;##M N
foreach%% 
(%% 
var%% 
item%% 
in%%  
other%%! &
)%%& '
{&& 
if'' 
('' 
	container'' 
.'' 
Contains'' &
(''& '
item''' +
)''+ ,
)'', -
{(( 
result)) 
.)) 
Add)) 
()) 
item)) #
)))# $
;))$ %
}** 
}++ 
	container-- 
.-- 
Clear-- 
(-- 
)-- 
;-- 
	container.. 
... 
	UnionWith.. 
(..  
result..  &
)..& '
;..' (
result00 
.00 
Dispose00 
(00 
)00 
;00 
}11 	
public99 
static99 
void99 
	UnionWith99 $
<99$ %
T99% &
>99& '
(99' (
this99( ,
NativeHashSet99- :
<99: ;
T99; <
>99< =
	container99> G
,99G H
UnsafeHashSet99I V
<99V W
T99W X
>99X Y
other99Z _
)99_ `
where:: 
T:: 
::: 
	unmanaged:: 
,::  

IEquatable::! +
<::+ ,
T::, -
>::- .
{;; 	
foreach<< 
(<< 
var<< 
item<< 
in<<  
other<<! &
)<<& '
{== 
	container>> 
.>> 
Add>> 
(>> 
item>> "
)>>" #
;>># $
}?? 
}@@ 	
publicGG 
staticGG 
voidGG 

ExceptWithGG %
<GG% &
TGG& '
>GG' (
(GG( )
thisGG) -
NativeHashSetGG. ;
<GG; <
TGG< =
>GG= >
	containerGG? H
,GGH I

UnsafeListGGJ T
<GGT U
TGGU V
>GGV W
otherGGX ]
)GG] ^
whereHH 
THH 
:HH 
	unmanagedHH 
,HH  

IEquatableHH! +
<HH+ ,
THH, -
>HH- .
{II 	
foreachJJ 
(JJ 
varJJ 
itemJJ 
inJJ  
otherJJ! &
)JJ& '
{KK 
	containerLL 
.LL 
RemoveLL  
(LL  !
itemLL! %
)LL% &
;LL& '
}MM 
}NN 	
publicVV 
staticVV 
voidVV 
IntersectWithVV (
<VV( )
TVV) *
>VV* +
(VV+ ,
thisVV, 0
NativeHashSetVV1 >
<VV> ?
TVV? @
>VV@ A
	containerVVB K
,VVK L

UnsafeListVVM W
<VVW X
TVVX Y
>VVY Z
otherVV[ `
)VV` a
whereWW 
TWW 
:WW 
	unmanagedWW 
,WW  

IEquatableWW! +
<WW+ ,
TWW, -
>WW- .
{XX 	
varYY 
resultYY 
=YY 
newYY 

UnsafeListYY '
<YY' (
TYY( )
>YY) *
(YY* +
	containerYY+ 4
.YY4 5
CountYY5 :
(YY: ;
)YY; <
,YY< =
	AllocatorYY> G
.YYG H
TempYYH L
)YYL M
;YYM N
foreach[[ 
([[ 
var[[ 
item[[ 
in[[  
other[[! &
)[[& '
{\\ 
if]] 
(]] 
	container]] 
.]] 
Contains]] &
(]]& '
item]]' +
)]]+ ,
)]], -
{^^ 
result__ 
.__ 
Add__ 
(__ 
item__ #
)__# $
;__$ %
}`` 
}aa 
	containercc 
.cc 
Clearcc 
(cc 
)cc 
;cc 
	containerdd 
.dd 
	UnionWithdd 
(dd  
resultdd  &
)dd& '
;dd' (
resultff 
.ff 
Disposeff 
(ff 
)ff 
;ff 
}gg 	
publicoo 
staticoo 
voidoo 
	UnionWithoo $
<oo$ %
Too% &
>oo& '
(oo' (
thisoo( ,
NativeHashSetoo- :
<oo: ;
Too; <
>oo< =
	containeroo> G
,ooG H

UnsafeListooI S
<ooS T
TooT U
>ooU V
otherooW \
)oo\ ]
wherepp 
Tpp 
:pp 
	unmanagedpp 
,pp  

IEquatablepp! +
<pp+ ,
Tpp, -
>pp- .
{qq 	
foreachrr 
(rr 
varrr 
itemrr 
inrr  
otherrr! &
)rr& '
{ss 
	containertt 
.tt 
Addtt 
(tt 
itemtt "
)tt" #
;tt# $
}uu 
}vv 	
public~~ 
static~~ 
void~~ 

ExceptWith~~ %
<~~% &
T~~& '
>~~' (
(~~( )
this~~) -
UnsafeHashSet~~. ;
<~~; <
T~~< =
>~~= >
	container~~? H
,~~H I
FixedList128Bytes~~J [
<~~[ \
T~~\ ]
>~~] ^
other~~_ d
)~~d e
where 
T 
: 
	unmanaged 
,  

IEquatable! +
<+ ,
T, -
>- .
{
ÄÄ 	
foreach
ÅÅ 
(
ÅÅ 
var
ÅÅ 
item
ÅÅ 
in
ÅÅ  
other
ÅÅ! &
)
ÅÅ& '
{
ÇÇ 
	container
ÉÉ 
.
ÉÉ 
Remove
ÉÉ  
(
ÉÉ  !
item
ÉÉ! %
)
ÉÉ% &
;
ÉÉ& '
}
ÑÑ 
}
ÖÖ 	
public
çç 
static
çç 
void
çç 
IntersectWith
çç (
<
çç( )
T
çç) *
>
çç* +
(
çç+ ,
this
çç, 0
UnsafeHashSet
çç1 >
<
çç> ?
T
çç? @
>
çç@ A
	container
ççB K
,
ççK L
FixedList128Bytes
ççM ^
<
çç^ _
T
çç_ `
>
çç` a
other
ççb g
)
ççg h
where
éé 
T
éé 
:
éé 
	unmanaged
éé 
,
éé  

IEquatable
éé! +
<
éé+ ,
T
éé, -
>
éé- .
{
èè 	
var
êê 
result
êê 
=
êê 
new
êê 

UnsafeList
êê '
<
êê' (
T
êê( )
>
êê) *
(
êê* +
	container
êê+ 4
.
êê4 5
Count
êê5 :
(
êê: ;
)
êê; <
,
êê< =
	Allocator
êê> G
.
êêG H
Temp
êêH L
)
êêL M
;
êêM N
foreach
íí 
(
íí 
var
íí 
item
íí 
in
íí  
other
íí! &
)
íí& '
{
ìì 
if
îî 
(
îî 
	container
îî 
.
îî 
Contains
îî &
(
îî& '
item
îî' +
)
îî+ ,
)
îî, -
{
ïï 
result
ññ 
.
ññ 
Add
ññ 
(
ññ 
item
ññ #
)
ññ# $
;
ññ$ %
}
óó 
}
òò 
	container
öö 
.
öö 
Clear
öö 
(
öö 
)
öö 
;
öö 
	container
õõ 
.
õõ 
	UnionWith
õõ 
(
õõ  
result
õõ  &
)
õõ& '
;
õõ' (
result
ùù 
.
ùù 
Dispose
ùù 
(
ùù 
)
ùù 
;
ùù 
}
ûû 	
public
¶¶ 
static
¶¶ 
void
¶¶ 
	UnionWith
¶¶ $
<
¶¶$ %
T
¶¶% &
>
¶¶& '
(
¶¶' (
this
¶¶( ,
UnsafeHashSet
¶¶- :
<
¶¶: ;
T
¶¶; <
>
¶¶< =
	container
¶¶> G
,
¶¶G H
FixedList128Bytes
¶¶I Z
<
¶¶Z [
T
¶¶[ \
>
¶¶\ ]
other
¶¶^ c
)
¶¶c d
where
ßß 
T
ßß 
:
ßß 
	unmanaged
ßß 
,
ßß  

IEquatable
ßß! +
<
ßß+ ,
T
ßß, -
>
ßß- .
{
®® 	
foreach
©© 
(
©© 
var
©© 
item
©© 
in
©©  
other
©©! &
)
©©& '
{
™™ 
	container
´´ 
.
´´ 
Add
´´ 
(
´´ 
item
´´ "
)
´´" #
;
´´# $
}
¨¨ 
}
≠≠ 	
public
¥¥ 
static
¥¥ 
void
¥¥ 

ExceptWith
¥¥ %
<
¥¥% &
T
¥¥& '
>
¥¥' (
(
¥¥( )
this
¥¥) -
UnsafeHashSet
¥¥. ;
<
¥¥; <
T
¥¥< =
>
¥¥= >
	container
¥¥? H
,
¥¥H I
FixedList32Bytes
¥¥J Z
<
¥¥Z [
T
¥¥[ \
>
¥¥\ ]
other
¥¥^ c
)
¥¥c d
where
µµ 
T
µµ 
:
µµ 
	unmanaged
µµ 
,
µµ  

IEquatable
µµ! +
<
µµ+ ,
T
µµ, -
>
µµ- .
{
∂∂ 	
foreach
∑∑ 
(
∑∑ 
var
∑∑ 
item
∑∑ 
in
∑∑  
other
∑∑! &
)
∑∑& '
{
∏∏ 
	container
ππ 
.
ππ 
Remove
ππ  
(
ππ  !
item
ππ! %
)
ππ% &
;
ππ& '
}
∫∫ 
}
ªª 	
public
√√ 
static
√√ 
void
√√ 
IntersectWith
√√ (
<
√√( )
T
√√) *
>
√√* +
(
√√+ ,
this
√√, 0
UnsafeHashSet
√√1 >
<
√√> ?
T
√√? @
>
√√@ A
	container
√√B K
,
√√K L
FixedList32Bytes
√√M ]
<
√√] ^
T
√√^ _
>
√√_ `
other
√√a f
)
√√f g
where
ƒƒ 
T
ƒƒ 
:
ƒƒ 
	unmanaged
ƒƒ 
,
ƒƒ  

IEquatable
ƒƒ! +
<
ƒƒ+ ,
T
ƒƒ, -
>
ƒƒ- .
{
≈≈ 	
var
∆∆ 
result
∆∆ 
=
∆∆ 
new
∆∆ 

UnsafeList
∆∆ '
<
∆∆' (
T
∆∆( )
>
∆∆) *
(
∆∆* +
	container
∆∆+ 4
.
∆∆4 5
Count
∆∆5 :
(
∆∆: ;
)
∆∆; <
,
∆∆< =
	Allocator
∆∆> G
.
∆∆G H
Temp
∆∆H L
)
∆∆L M
;
∆∆M N
foreach
»» 
(
»» 
var
»» 
item
»» 
in
»»  
other
»»! &
)
»»& '
{
…… 
if
   
(
   
	container
   
.
   
Contains
   &
(
  & '
item
  ' +
)
  + ,
)
  , -
{
ÀÀ 
result
ÃÃ 
.
ÃÃ 
Add
ÃÃ 
(
ÃÃ 
item
ÃÃ #
)
ÃÃ# $
;
ÃÃ$ %
}
ÕÕ 
}
ŒŒ 
	container
–– 
.
–– 
Clear
–– 
(
–– 
)
–– 
;
–– 
	container
—— 
.
—— 
	UnionWith
—— 
(
——  
result
——  &
)
——& '
;
——' (
result
”” 
.
”” 
Dispose
”” 
(
”” 
)
”” 
;
”” 
}
‘‘ 	
public
‹‹ 
static
‹‹ 
void
‹‹ 
	UnionWith
‹‹ $
<
‹‹$ %
T
‹‹% &
>
‹‹& '
(
‹‹' (
this
‹‹( ,
UnsafeHashSet
‹‹- :
<
‹‹: ;
T
‹‹; <
>
‹‹< =
	container
‹‹> G
,
‹‹G H
FixedList32Bytes
‹‹I Y
<
‹‹Y Z
T
‹‹Z [
>
‹‹[ \
other
‹‹] b
)
‹‹b c
where
›› 
T
›› 
:
›› 
	unmanaged
›› 
,
››  

IEquatable
››! +
<
››+ ,
T
››, -
>
››- .
{
ﬁﬁ 	
foreach
ﬂﬂ 
(
ﬂﬂ 
var
ﬂﬂ 
item
ﬂﬂ 
in
ﬂﬂ  
other
ﬂﬂ! &
)
ﬂﬂ& '
{
‡‡ 
	container
·· 
.
·· 
Add
·· 
(
·· 
item
·· "
)
··" #
;
··# $
}
‚‚ 
}
„„ 	
public
ÍÍ 
static
ÍÍ 
void
ÍÍ 

ExceptWith
ÍÍ %
<
ÍÍ% &
T
ÍÍ& '
>
ÍÍ' (
(
ÍÍ( )
this
ÍÍ) -
UnsafeHashSet
ÍÍ. ;
<
ÍÍ; <
T
ÍÍ< =
>
ÍÍ= >
	container
ÍÍ? H
,
ÍÍH I 
FixedList4096Bytes
ÍÍJ \
<
ÍÍ\ ]
T
ÍÍ] ^
>
ÍÍ^ _
other
ÍÍ` e
)
ÍÍe f
where
ÎÎ 
T
ÎÎ 
:
ÎÎ 
	unmanaged
ÎÎ 
,
ÎÎ  

IEquatable
ÎÎ! +
<
ÎÎ+ ,
T
ÎÎ, -
>
ÎÎ- .
{
ÏÏ 	
foreach
ÌÌ 
(
ÌÌ 
var
ÌÌ 
item
ÌÌ 
in
ÌÌ  
other
ÌÌ! &
)
ÌÌ& '
{
ÓÓ 
	container
ÔÔ 
.
ÔÔ 
Remove
ÔÔ  
(
ÔÔ  !
item
ÔÔ! %
)
ÔÔ% &
;
ÔÔ& '
}
 
}
ÒÒ 	
public
˘˘ 
static
˘˘ 
void
˘˘ 
IntersectWith
˘˘ (
<
˘˘( )
T
˘˘) *
>
˘˘* +
(
˘˘+ ,
this
˘˘, 0
UnsafeHashSet
˘˘1 >
<
˘˘> ?
T
˘˘? @
>
˘˘@ A
	container
˘˘B K
,
˘˘K L 
FixedList4096Bytes
˘˘M _
<
˘˘_ `
T
˘˘` a
>
˘˘a b
other
˘˘c h
)
˘˘h i
where
˙˙ 
T
˙˙ 
:
˙˙ 
	unmanaged
˙˙ 
,
˙˙  

IEquatable
˙˙! +
<
˙˙+ ,
T
˙˙, -
>
˙˙- .
{
˚˚ 	
var
¸¸ 
result
¸¸ 
=
¸¸ 
new
¸¸ 

UnsafeList
¸¸ '
<
¸¸' (
T
¸¸( )
>
¸¸) *
(
¸¸* +
	container
¸¸+ 4
.
¸¸4 5
Count
¸¸5 :
(
¸¸: ;
)
¸¸; <
,
¸¸< =
	Allocator
¸¸> G
.
¸¸G H
Temp
¸¸H L
)
¸¸L M
;
¸¸M N
foreach
˛˛ 
(
˛˛ 
var
˛˛ 
item
˛˛ 
in
˛˛  
other
˛˛! &
)
˛˛& '
{
ˇˇ 
if
ÄÄ 
(
ÄÄ 
	container
ÄÄ 
.
ÄÄ 
Contains
ÄÄ &
(
ÄÄ& '
item
ÄÄ' +
)
ÄÄ+ ,
)
ÄÄ, -
{
ÅÅ 
result
ÇÇ 
.
ÇÇ 
Add
ÇÇ 
(
ÇÇ 
item
ÇÇ #
)
ÇÇ# $
;
ÇÇ$ %
}
ÉÉ 
}
ÑÑ 
	container
ÜÜ 
.
ÜÜ 
Clear
ÜÜ 
(
ÜÜ 
)
ÜÜ 
;
ÜÜ 
	container
áá 
.
áá 
	UnionWith
áá 
(
áá  
result
áá  &
)
áá& '
;
áá' (
result
ââ 
.
ââ 
Dispose
ââ 
(
ââ 
)
ââ 
;
ââ 
}
ää 	
public
íí 
static
íí 
void
íí 
	UnionWith
íí $
<
íí$ %
T
íí% &
>
íí& '
(
íí' (
this
íí( ,
UnsafeHashSet
íí- :
<
íí: ;
T
íí; <
>
íí< =
	container
íí> G
,
ííG H 
FixedList4096Bytes
ííI [
<
íí[ \
T
íí\ ]
>
íí] ^
other
íí_ d
)
ííd e
where
ìì 
T
ìì 
:
ìì 
	unmanaged
ìì 
,
ìì  

IEquatable
ìì! +
<
ìì+ ,
T
ìì, -
>
ìì- .
{
îî 	
foreach
ïï 
(
ïï 
var
ïï 
item
ïï 
in
ïï  
other
ïï! &
)
ïï& '
{
ññ 
	container
óó 
.
óó 
Add
óó 
(
óó 
item
óó "
)
óó" #
;
óó# $
}
òò 
}
ôô 	
public
†† 
static
†† 
void
†† 

ExceptWith
†† %
<
††% &
T
††& '
>
††' (
(
††( )
this
††) -
UnsafeHashSet
††. ;
<
††; <
T
††< =
>
††= >
	container
††? H
,
††H I
FixedList512Bytes
††J [
<
††[ \
T
††\ ]
>
††] ^
other
††_ d
)
††d e
where
°° 
T
°° 
:
°° 
	unmanaged
°° 
,
°°  

IEquatable
°°! +
<
°°+ ,
T
°°, -
>
°°- .
{
¢¢ 	
foreach
££ 
(
££ 
var
££ 
item
££ 
in
££  
other
££! &
)
££& '
{
§§ 
	container
•• 
.
•• 
Remove
••  
(
••  !
item
••! %
)
••% &
;
••& '
}
¶¶ 
}
ßß 	
public
ØØ 
static
ØØ 
void
ØØ 
IntersectWith
ØØ (
<
ØØ( )
T
ØØ) *
>
ØØ* +
(
ØØ+ ,
this
ØØ, 0
UnsafeHashSet
ØØ1 >
<
ØØ> ?
T
ØØ? @
>
ØØ@ A
	container
ØØB K
,
ØØK L
FixedList512Bytes
ØØM ^
<
ØØ^ _
T
ØØ_ `
>
ØØ` a
other
ØØb g
)
ØØg h
where
∞∞ 
T
∞∞ 
:
∞∞ 
	unmanaged
∞∞ 
,
∞∞  

IEquatable
∞∞! +
<
∞∞+ ,
T
∞∞, -
>
∞∞- .
{
±± 	
var
≤≤ 
result
≤≤ 
=
≤≤ 
new
≤≤ 

UnsafeList
≤≤ '
<
≤≤' (
T
≤≤( )
>
≤≤) *
(
≤≤* +
	container
≤≤+ 4
.
≤≤4 5
Count
≤≤5 :
(
≤≤: ;
)
≤≤; <
,
≤≤< =
	Allocator
≤≤> G
.
≤≤G H
Temp
≤≤H L
)
≤≤L M
;
≤≤M N
foreach
¥¥ 
(
¥¥ 
var
¥¥ 
item
¥¥ 
in
¥¥  
other
¥¥! &
)
¥¥& '
{
µµ 
if
∂∂ 
(
∂∂ 
	container
∂∂ 
.
∂∂ 
Contains
∂∂ &
(
∂∂& '
item
∂∂' +
)
∂∂+ ,
)
∂∂, -
{
∑∑ 
result
∏∏ 
.
∏∏ 
Add
∏∏ 
(
∏∏ 
item
∏∏ #
)
∏∏# $
;
∏∏$ %
}
ππ 
}
∫∫ 
	container
ºº 
.
ºº 
Clear
ºº 
(
ºº 
)
ºº 
;
ºº 
	container
ΩΩ 
.
ΩΩ 
	UnionWith
ΩΩ 
(
ΩΩ  
result
ΩΩ  &
)
ΩΩ& '
;
ΩΩ' (
result
øø 
.
øø 
Dispose
øø 
(
øø 
)
øø 
;
øø 
}
¿¿ 	
public
»» 
static
»» 
void
»» 
	UnionWith
»» $
<
»»$ %
T
»»% &
>
»»& '
(
»»' (
this
»»( ,
UnsafeHashSet
»»- :
<
»»: ;
T
»»; <
>
»»< =
	container
»»> G
,
»»G H
FixedList512Bytes
»»I Z
<
»»Z [
T
»»[ \
>
»»\ ]
other
»»^ c
)
»»c d
where
…… 
T
…… 
:
…… 
	unmanaged
…… 
,
……  

IEquatable
……! +
<
……+ ,
T
……, -
>
……- .
{
   	
foreach
ÀÀ 
(
ÀÀ 
var
ÀÀ 
item
ÀÀ 
in
ÀÀ  
other
ÀÀ! &
)
ÀÀ& '
{
ÃÃ 
	container
ÕÕ 
.
ÕÕ 
Add
ÕÕ 
(
ÕÕ 
item
ÕÕ "
)
ÕÕ" #
;
ÕÕ# $
}
ŒŒ 
}
œœ 	
public
÷÷ 
static
÷÷ 
void
÷÷ 

ExceptWith
÷÷ %
<
÷÷% &
T
÷÷& '
>
÷÷' (
(
÷÷( )
this
÷÷) -
UnsafeHashSet
÷÷. ;
<
÷÷; <
T
÷÷< =
>
÷÷= >
	container
÷÷? H
,
÷÷H I
FixedList64Bytes
÷÷J Z
<
÷÷Z [
T
÷÷[ \
>
÷÷\ ]
other
÷÷^ c
)
÷÷c d
where
◊◊ 
T
◊◊ 
:
◊◊ 
	unmanaged
◊◊ 
,
◊◊  

IEquatable
◊◊! +
<
◊◊+ ,
T
◊◊, -
>
◊◊- .
{
ÿÿ 	
foreach
ŸŸ 
(
ŸŸ 
var
ŸŸ 
item
ŸŸ 
in
ŸŸ  
other
ŸŸ! &
)
ŸŸ& '
{
⁄⁄ 
	container
€€ 
.
€€ 
Remove
€€  
(
€€  !
item
€€! %
)
€€% &
;
€€& '
}
‹‹ 
}
›› 	
public
ÂÂ 
static
ÂÂ 
void
ÂÂ 
IntersectWith
ÂÂ (
<
ÂÂ( )
T
ÂÂ) *
>
ÂÂ* +
(
ÂÂ+ ,
this
ÂÂ, 0
UnsafeHashSet
ÂÂ1 >
<
ÂÂ> ?
T
ÂÂ? @
>
ÂÂ@ A
	container
ÂÂB K
,
ÂÂK L
FixedList64Bytes
ÂÂM ]
<
ÂÂ] ^
T
ÂÂ^ _
>
ÂÂ_ `
other
ÂÂa f
)
ÂÂf g
where
ÊÊ 
T
ÊÊ 
:
ÊÊ 
	unmanaged
ÊÊ 
,
ÊÊ  

IEquatable
ÊÊ! +
<
ÊÊ+ ,
T
ÊÊ, -
>
ÊÊ- .
{
ÁÁ 	
var
ËË 
result
ËË 
=
ËË 
new
ËË 

UnsafeList
ËË '
<
ËË' (
T
ËË( )
>
ËË) *
(
ËË* +
	container
ËË+ 4
.
ËË4 5
Count
ËË5 :
(
ËË: ;
)
ËË; <
,
ËË< =
	Allocator
ËË> G
.
ËËG H
Temp
ËËH L
)
ËËL M
;
ËËM N
foreach
ÍÍ 
(
ÍÍ 
var
ÍÍ 
item
ÍÍ 
in
ÍÍ  
other
ÍÍ! &
)
ÍÍ& '
{
ÎÎ 
if
ÏÏ 
(
ÏÏ 
	container
ÏÏ 
.
ÏÏ 
Contains
ÏÏ &
(
ÏÏ& '
item
ÏÏ' +
)
ÏÏ+ ,
)
ÏÏ, -
{
ÌÌ 
result
ÓÓ 
.
ÓÓ 
Add
ÓÓ 
(
ÓÓ 
item
ÓÓ #
)
ÓÓ# $
;
ÓÓ$ %
}
ÔÔ 
}
 
	container
ÚÚ 
.
ÚÚ 
Clear
ÚÚ 
(
ÚÚ 
)
ÚÚ 
;
ÚÚ 
	container
ÛÛ 
.
ÛÛ 
	UnionWith
ÛÛ 
(
ÛÛ  
result
ÛÛ  &
)
ÛÛ& '
;
ÛÛ' (
result
ıı 
.
ıı 
Dispose
ıı 
(
ıı 
)
ıı 
;
ıı 
}
ˆˆ 	
public
˛˛ 
static
˛˛ 
void
˛˛ 
	UnionWith
˛˛ $
<
˛˛$ %
T
˛˛% &
>
˛˛& '
(
˛˛' (
this
˛˛( ,
UnsafeHashSet
˛˛- :
<
˛˛: ;
T
˛˛; <
>
˛˛< =
	container
˛˛> G
,
˛˛G H
FixedList64Bytes
˛˛I Y
<
˛˛Y Z
T
˛˛Z [
>
˛˛[ \
other
˛˛] b
)
˛˛b c
where
ˇˇ 
T
ˇˇ 
:
ˇˇ 
	unmanaged
ˇˇ 
,
ˇˇ  

IEquatable
ˇˇ! +
<
ˇˇ+ ,
T
ˇˇ, -
>
ˇˇ- .
{
ÄÄ 	
foreach
ÅÅ 
(
ÅÅ 
var
ÅÅ 
item
ÅÅ 
in
ÅÅ  
other
ÅÅ! &
)
ÅÅ& '
{
ÇÇ 
	container
ÉÉ 
.
ÉÉ 
Add
ÉÉ 
(
ÉÉ 
item
ÉÉ "
)
ÉÉ" #
;
ÉÉ# $
}
ÑÑ 
}
ÖÖ 	
public
åå 
static
åå 
void
åå 

ExceptWith
åå %
<
åå% &
T
åå& '
>
åå' (
(
åå( )
this
åå) -
UnsafeHashSet
åå. ;
<
åå; <
T
åå< =
>
åå= >
	container
åå? H
,
ååH I
NativeArray
ååJ U
<
ååU V
T
ååV W
>
ååW X
other
ååY ^
)
åå^ _
where
çç 
T
çç 
:
çç 
	unmanaged
çç 
,
çç  

IEquatable
çç! +
<
çç+ ,
T
çç, -
>
çç- .
{
éé 	
foreach
èè 
(
èè 
var
èè 
item
èè 
in
èè  
other
èè! &
)
èè& '
{
êê 
	container
ëë 
.
ëë 
Remove
ëë  
(
ëë  !
item
ëë! %
)
ëë% &
;
ëë& '
}
íí 
}
ìì 	
public
õõ 
static
õõ 
void
õõ 
IntersectWith
õõ (
<
õõ( )
T
õõ) *
>
õõ* +
(
õõ+ ,
this
õõ, 0
UnsafeHashSet
õõ1 >
<
õõ> ?
T
õõ? @
>
õõ@ A
	container
õõB K
,
õõK L
NativeArray
õõM X
<
õõX Y
T
õõY Z
>
õõZ [
other
õõ\ a
)
õõa b
where
úú 
T
úú 
:
úú 
	unmanaged
úú 
,
úú  

IEquatable
úú! +
<
úú+ ,
T
úú, -
>
úú- .
{
ùù 	
var
ûû 
result
ûû 
=
ûû 
new
ûû 

UnsafeList
ûû '
<
ûû' (
T
ûû( )
>
ûû) *
(
ûû* +
	container
ûû+ 4
.
ûû4 5
Count
ûû5 :
(
ûû: ;
)
ûû; <
,
ûû< =
	Allocator
ûû> G
.
ûûG H
Temp
ûûH L
)
ûûL M
;
ûûM N
foreach
†† 
(
†† 
var
†† 
item
†† 
in
††  
other
††! &
)
††& '
{
°° 
if
¢¢ 
(
¢¢ 
	container
¢¢ 
.
¢¢ 
Contains
¢¢ &
(
¢¢& '
item
¢¢' +
)
¢¢+ ,
)
¢¢, -
{
££ 
result
§§ 
.
§§ 
Add
§§ 
(
§§ 
item
§§ #
)
§§# $
;
§§$ %
}
•• 
}
¶¶ 
	container
®® 
.
®® 
Clear
®® 
(
®® 
)
®® 
;
®® 
	container
©© 
.
©© 
	UnionWith
©© 
(
©©  
result
©©  &
)
©©& '
;
©©' (
result
´´ 
.
´´ 
Dispose
´´ 
(
´´ 
)
´´ 
;
´´ 
}
¨¨ 	
public
¥¥ 
static
¥¥ 
void
¥¥ 
	UnionWith
¥¥ $
<
¥¥$ %
T
¥¥% &
>
¥¥& '
(
¥¥' (
this
¥¥( ,
UnsafeHashSet
¥¥- :
<
¥¥: ;
T
¥¥; <
>
¥¥< =
	container
¥¥> G
,
¥¥G H
NativeArray
¥¥I T
<
¥¥T U
T
¥¥U V
>
¥¥V W
other
¥¥X ]
)
¥¥] ^
where
µµ 
T
µµ 
:
µµ 
	unmanaged
µµ 
,
µµ  

IEquatable
µµ! +
<
µµ+ ,
T
µµ, -
>
µµ- .
{
∂∂ 	
foreach
∑∑ 
(
∑∑ 
var
∑∑ 
item
∑∑ 
in
∑∑  
other
∑∑! &
)
∑∑& '
{
∏∏ 
	container
ππ 
.
ππ 
Add
ππ 
(
ππ 
item
ππ "
)
ππ" #
;
ππ# $
}
∫∫ 
}
ªª 	
public
¬¬ 
static
¬¬ 
void
¬¬ 

ExceptWith
¬¬ %
<
¬¬% &
T
¬¬& '
>
¬¬' (
(
¬¬( )
this
¬¬) -
UnsafeHashSet
¬¬. ;
<
¬¬; <
T
¬¬< =
>
¬¬= >
	container
¬¬? H
,
¬¬H I
NativeHashSet
¬¬J W
<
¬¬W X
T
¬¬X Y
>
¬¬Y Z
other
¬¬[ `
)
¬¬` a
where
√√ 
T
√√ 
:
√√ 
	unmanaged
√√ 
,
√√  

IEquatable
√√! +
<
√√+ ,
T
√√, -
>
√√- .
{
ƒƒ 	
foreach
≈≈ 
(
≈≈ 
var
≈≈ 
item
≈≈ 
in
≈≈  
other
≈≈! &
)
≈≈& '
{
∆∆ 
	container
«« 
.
«« 
Remove
««  
(
««  !
item
««! %
)
««% &
;
««& '
}
»» 
}
…… 	
public
—— 
static
—— 
void
—— 
IntersectWith
—— (
<
——( )
T
——) *
>
——* +
(
——+ ,
this
——, 0
UnsafeHashSet
——1 >
<
——> ?
T
——? @
>
——@ A
	container
——B K
,
——K L
NativeHashSet
——M Z
<
——Z [
T
——[ \
>
——\ ]
other
——^ c
)
——c d
where
““ 
T
““ 
:
““ 
	unmanaged
““ 
,
““  

IEquatable
““! +
<
““+ ,
T
““, -
>
““- .
{
”” 	
var
‘‘ 
result
‘‘ 
=
‘‘ 
new
‘‘ 

UnsafeList
‘‘ '
<
‘‘' (
T
‘‘( )
>
‘‘) *
(
‘‘* +
	container
‘‘+ 4
.
‘‘4 5
Count
‘‘5 :
(
‘‘: ;
)
‘‘; <
,
‘‘< =
	Allocator
‘‘> G
.
‘‘G H
Temp
‘‘H L
)
‘‘L M
;
‘‘M N
foreach
÷÷ 
(
÷÷ 
var
÷÷ 
item
÷÷ 
in
÷÷  
other
÷÷! &
)
÷÷& '
{
◊◊ 
if
ÿÿ 
(
ÿÿ 
	container
ÿÿ 
.
ÿÿ 
Contains
ÿÿ &
(
ÿÿ& '
item
ÿÿ' +
)
ÿÿ+ ,
)
ÿÿ, -
{
ŸŸ 
result
⁄⁄ 
.
⁄⁄ 
Add
⁄⁄ 
(
⁄⁄ 
item
⁄⁄ #
)
⁄⁄# $
;
⁄⁄$ %
}
€€ 
}
‹‹ 
	container
ﬁﬁ 
.
ﬁﬁ 
Clear
ﬁﬁ 
(
ﬁﬁ 
)
ﬁﬁ 
;
ﬁﬁ 
	container
ﬂﬂ 
.
ﬂﬂ 
	UnionWith
ﬂﬂ 
(
ﬂﬂ  
result
ﬂﬂ  &
)
ﬂﬂ& '
;
ﬂﬂ' (
result
·· 
.
·· 
Dispose
·· 
(
·· 
)
·· 
;
·· 
}
‚‚ 	
public
ÍÍ 
static
ÍÍ 
void
ÍÍ 
	UnionWith
ÍÍ $
<
ÍÍ$ %
T
ÍÍ% &
>
ÍÍ& '
(
ÍÍ' (
this
ÍÍ( ,
UnsafeHashSet
ÍÍ- :
<
ÍÍ: ;
T
ÍÍ; <
>
ÍÍ< =
	container
ÍÍ> G
,
ÍÍG H
NativeHashSet
ÍÍI V
<
ÍÍV W
T
ÍÍW X
>
ÍÍX Y
other
ÍÍZ _
)
ÍÍ_ `
where
ÎÎ 
T
ÎÎ 
:
ÎÎ 
	unmanaged
ÎÎ 
,
ÎÎ  

IEquatable
ÎÎ! +
<
ÎÎ+ ,
T
ÎÎ, -
>
ÎÎ- .
{
ÏÏ 	
foreach
ÌÌ 
(
ÌÌ 
var
ÌÌ 
item
ÌÌ 
in
ÌÌ  
other
ÌÌ! &
)
ÌÌ& '
{
ÓÓ 
	container
ÔÔ 
.
ÔÔ 
Add
ÔÔ 
(
ÔÔ 
item
ÔÔ "
)
ÔÔ" #
;
ÔÔ# $
}
 
}
ÒÒ 	
public
¯¯ 
static
¯¯ 
void
¯¯ 

ExceptWith
¯¯ %
<
¯¯% &
T
¯¯& '
>
¯¯' (
(
¯¯( )
this
¯¯) -
UnsafeHashSet
¯¯. ;
<
¯¯; <
T
¯¯< =
>
¯¯= >
	container
¯¯? H
,
¯¯H I

NativeList
¯¯J T
<
¯¯T U
T
¯¯U V
>
¯¯V W
other
¯¯X ]
)
¯¯] ^
where
˘˘ 
T
˘˘ 
:
˘˘ 
	unmanaged
˘˘ 
,
˘˘  

IEquatable
˘˘! +
<
˘˘+ ,
T
˘˘, -
>
˘˘- .
{
˙˙ 	
foreach
˚˚ 
(
˚˚ 
var
˚˚ 
item
˚˚ 
in
˚˚  
other
˚˚! &
)
˚˚& '
{
¸¸ 
	container
˝˝ 
.
˝˝ 
Remove
˝˝  
(
˝˝  !
item
˝˝! %
)
˝˝% &
;
˝˝& '
}
˛˛ 
}
ˇˇ 	
public
áá 
static
áá 
void
áá 
IntersectWith
áá (
<
áá( )
T
áá) *
>
áá* +
(
áá+ ,
this
áá, 0
UnsafeHashSet
áá1 >
<
áá> ?
T
áá? @
>
áá@ A
	container
ááB K
,
ááK L

NativeList
ááM W
<
ááW X
T
ááX Y
>
ááY Z
other
áá[ `
)
áá` a
where
àà 
T
àà 
:
àà 
	unmanaged
àà 
,
àà  

IEquatable
àà! +
<
àà+ ,
T
àà, -
>
àà- .
{
ââ 	
var
ää 
result
ää 
=
ää 
new
ää 

UnsafeList
ää '
<
ää' (
T
ää( )
>
ää) *
(
ää* +
	container
ää+ 4
.
ää4 5
Count
ää5 :
(
ää: ;
)
ää; <
,
ää< =
	Allocator
ää> G
.
ääG H
Temp
ääH L
)
ääL M
;
ääM N
foreach
åå 
(
åå 
var
åå 
item
åå 
in
åå  
other
åå! &
)
åå& '
{
çç 
if
éé 
(
éé 
	container
éé 
.
éé 
Contains
éé &
(
éé& '
item
éé' +
)
éé+ ,
)
éé, -
{
èè 
result
êê 
.
êê 
Add
êê 
(
êê 
item
êê #
)
êê# $
;
êê$ %
}
ëë 
}
íí 
	container
îî 
.
îî 
Clear
îî 
(
îî 
)
îî 
;
îî 
	container
ïï 
.
ïï 
	UnionWith
ïï 
(
ïï  
result
ïï  &
)
ïï& '
;
ïï' (
result
óó 
.
óó 
Dispose
óó 
(
óó 
)
óó 
;
óó 
}
òò 	
public
†† 
static
†† 
void
†† 
	UnionWith
†† $
<
††$ %
T
††% &
>
††& '
(
††' (
this
††( ,
UnsafeHashSet
††- :
<
††: ;
T
††; <
>
††< =
	container
††> G
,
††G H

NativeList
††I S
<
††S T
T
††T U
>
††U V
other
††W \
)
††\ ]
where
°° 
T
°° 
:
°° 
	unmanaged
°° 
,
°°  

IEquatable
°°! +
<
°°+ ,
T
°°, -
>
°°- .
{
¢¢ 	
foreach
££ 
(
££ 
var
££ 
item
££ 
in
££  
other
££! &
)
££& '
{
§§ 
	container
•• 
.
•• 
Add
•• 
(
•• 
item
•• "
)
••" #
;
••# $
}
¶¶ 
}
ßß 	
public
ÆÆ 
static
ÆÆ 
void
ÆÆ 

ExceptWith
ÆÆ %
<
ÆÆ% &
T
ÆÆ& '
>
ÆÆ' (
(
ÆÆ( )
this
ÆÆ) -
UnsafeHashSet
ÆÆ. ;
<
ÆÆ; <
T
ÆÆ< =
>
ÆÆ= >
	container
ÆÆ? H
,
ÆÆH I
UnsafeHashSet
ÆÆJ W
<
ÆÆW X
T
ÆÆX Y
>
ÆÆY Z
other
ÆÆ[ `
)
ÆÆ` a
where
ØØ 
T
ØØ 
:
ØØ 
	unmanaged
ØØ 
,
ØØ  

IEquatable
ØØ! +
<
ØØ+ ,
T
ØØ, -
>
ØØ- .
{
∞∞ 	
foreach
±± 
(
±± 
var
±± 
item
±± 
in
±±  
other
±±! &
)
±±& '
{
≤≤ 
	container
≥≥ 
.
≥≥ 
Remove
≥≥  
(
≥≥  !
item
≥≥! %
)
≥≥% &
;
≥≥& '
}
¥¥ 
}
µµ 	
public
ΩΩ 
static
ΩΩ 
void
ΩΩ 
IntersectWith
ΩΩ (
<
ΩΩ( )
T
ΩΩ) *
>
ΩΩ* +
(
ΩΩ+ ,
this
ΩΩ, 0
UnsafeHashSet
ΩΩ1 >
<
ΩΩ> ?
T
ΩΩ? @
>
ΩΩ@ A
	container
ΩΩB K
,
ΩΩK L
UnsafeHashSet
ΩΩM Z
<
ΩΩZ [
T
ΩΩ[ \
>
ΩΩ\ ]
other
ΩΩ^ c
)
ΩΩc d
where
ææ 
T
ææ 
:
ææ 
	unmanaged
ææ 
,
ææ  

IEquatable
ææ! +
<
ææ+ ,
T
ææ, -
>
ææ- .
{
øø 	
var
¿¿ 
result
¿¿ 
=
¿¿ 
new
¿¿ 

UnsafeList
¿¿ '
<
¿¿' (
T
¿¿( )
>
¿¿) *
(
¿¿* +
	container
¿¿+ 4
.
¿¿4 5
Count
¿¿5 :
(
¿¿: ;
)
¿¿; <
,
¿¿< =
	Allocator
¿¿> G
.
¿¿G H
Temp
¿¿H L
)
¿¿L M
;
¿¿M N
foreach
¬¬ 
(
¬¬ 
var
¬¬ 
item
¬¬ 
in
¬¬  
other
¬¬! &
)
¬¬& '
{
√√ 
if
ƒƒ 
(
ƒƒ 
	container
ƒƒ 
.
ƒƒ 
Contains
ƒƒ &
(
ƒƒ& '
item
ƒƒ' +
)
ƒƒ+ ,
)
ƒƒ, -
{
≈≈ 
result
∆∆ 
.
∆∆ 
Add
∆∆ 
(
∆∆ 
item
∆∆ #
)
∆∆# $
;
∆∆$ %
}
«« 
}
»» 
	container
   
.
   
Clear
   
(
   
)
   
;
   
	container
ÀÀ 
.
ÀÀ 
	UnionWith
ÀÀ 
(
ÀÀ  
result
ÀÀ  &
)
ÀÀ& '
;
ÀÀ' (
result
ÕÕ 
.
ÕÕ 
Dispose
ÕÕ 
(
ÕÕ 
)
ÕÕ 
;
ÕÕ 
}
ŒŒ 	
public
÷÷ 
static
÷÷ 
void
÷÷ 
	UnionWith
÷÷ $
<
÷÷$ %
T
÷÷% &
>
÷÷& '
(
÷÷' (
this
÷÷( ,
UnsafeHashSet
÷÷- :
<
÷÷: ;
T
÷÷; <
>
÷÷< =
	container
÷÷> G
,
÷÷G H
UnsafeHashSet
÷÷I V
<
÷÷V W
T
÷÷W X
>
÷÷X Y
other
÷÷Z _
)
÷÷_ `
where
◊◊ 
T
◊◊ 
:
◊◊ 
	unmanaged
◊◊ 
,
◊◊  

IEquatable
◊◊! +
<
◊◊+ ,
T
◊◊, -
>
◊◊- .
{
ÿÿ 	
foreach
ŸŸ 
(
ŸŸ 
var
ŸŸ 
item
ŸŸ 
in
ŸŸ  
other
ŸŸ! &
)
ŸŸ& '
{
⁄⁄ 
	container
€€ 
.
€€ 
Add
€€ 
(
€€ 
item
€€ "
)
€€" #
;
€€# $
}
‹‹ 
}
›› 	
public
‰‰ 
static
‰‰ 
void
‰‰ 

ExceptWith
‰‰ %
<
‰‰% &
T
‰‰& '
>
‰‰' (
(
‰‰( )
this
‰‰) -
UnsafeHashSet
‰‰. ;
<
‰‰; <
T
‰‰< =
>
‰‰= >
	container
‰‰? H
,
‰‰H I

UnsafeList
‰‰J T
<
‰‰T U
T
‰‰U V
>
‰‰V W
other
‰‰X ]
)
‰‰] ^
where
ÂÂ 
T
ÂÂ 
:
ÂÂ 
	unmanaged
ÂÂ 
,
ÂÂ  

IEquatable
ÂÂ! +
<
ÂÂ+ ,
T
ÂÂ, -
>
ÂÂ- .
{
ÊÊ 	
foreach
ÁÁ 
(
ÁÁ 
var
ÁÁ 
item
ÁÁ 
in
ÁÁ  
other
ÁÁ! &
)
ÁÁ& '
{
ËË 
	container
ÈÈ 
.
ÈÈ 
Remove
ÈÈ  
(
ÈÈ  !
item
ÈÈ! %
)
ÈÈ% &
;
ÈÈ& '
}
ÍÍ 
}
ÎÎ 	
public
ÛÛ 
static
ÛÛ 
void
ÛÛ 
IntersectWith
ÛÛ (
<
ÛÛ( )
T
ÛÛ) *
>
ÛÛ* +
(
ÛÛ+ ,
this
ÛÛ, 0
UnsafeHashSet
ÛÛ1 >
<
ÛÛ> ?
T
ÛÛ? @
>
ÛÛ@ A
	container
ÛÛB K
,
ÛÛK L

UnsafeList
ÛÛM W
<
ÛÛW X
T
ÛÛX Y
>
ÛÛY Z
other
ÛÛ[ `
)
ÛÛ` a
where
ÙÙ 
T
ÙÙ 
:
ÙÙ 
	unmanaged
ÙÙ 
,
ÙÙ  

IEquatable
ÙÙ! +
<
ÙÙ+ ,
T
ÙÙ, -
>
ÙÙ- .
{
ıı 	
var
ˆˆ 
result
ˆˆ 
=
ˆˆ 
new
ˆˆ 

UnsafeList
ˆˆ '
<
ˆˆ' (
T
ˆˆ( )
>
ˆˆ) *
(
ˆˆ* +
	container
ˆˆ+ 4
.
ˆˆ4 5
Count
ˆˆ5 :
(
ˆˆ: ;
)
ˆˆ; <
,
ˆˆ< =
	Allocator
ˆˆ> G
.
ˆˆG H
Temp
ˆˆH L
)
ˆˆL M
;
ˆˆM N
foreach
¯¯ 
(
¯¯ 
var
¯¯ 
item
¯¯ 
in
¯¯  
other
¯¯! &
)
¯¯& '
{
˘˘ 
if
˙˙ 
(
˙˙ 
	container
˙˙ 
.
˙˙ 
Contains
˙˙ &
(
˙˙& '
item
˙˙' +
)
˙˙+ ,
)
˙˙, -
{
˚˚ 
result
¸¸ 
.
¸¸ 
Add
¸¸ 
(
¸¸ 
item
¸¸ #
)
¸¸# $
;
¸¸$ %
}
˝˝ 
}
˛˛ 
	container
ÄÄ 
.
ÄÄ 
Clear
ÄÄ 
(
ÄÄ 
)
ÄÄ 
;
ÄÄ 
	container
ÅÅ 
.
ÅÅ 
	UnionWith
ÅÅ 
(
ÅÅ  
result
ÅÅ  &
)
ÅÅ& '
;
ÅÅ' (
result
ÉÉ 
.
ÉÉ 
Dispose
ÉÉ 
(
ÉÉ 
)
ÉÉ 
;
ÉÉ 
}
ÑÑ 	
public
åå 
static
åå 
void
åå 
	UnionWith
åå $
<
åå$ %
T
åå% &
>
åå& '
(
åå' (
this
åå( ,
UnsafeHashSet
åå- :
<
åå: ;
T
åå; <
>
åå< =
	container
åå> G
,
ååG H

UnsafeList
ååI S
<
ååS T
T
ååT U
>
ååU V
other
ååW \
)
åå\ ]
where
çç 
T
çç 
:
çç 
	unmanaged
çç 
,
çç  

IEquatable
çç! +
<
çç+ ,
T
çç, -
>
çç- .
{
éé 	
foreach
èè 
(
èè 
var
èè 
item
èè 
in
èè  
other
èè! &
)
èè& '
{
êê 
	container
ëë 
.
ëë 
Add
ëë 
(
ëë 
item
ëë "
)
ëë" #
;
ëë# $
}
íí 
}
ìì 	
}
îî 
}ïï ‰ò
qC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\FixedStringInternalMethods.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[ 
BurstCompatible 
] 
public 

unsafe 
static 
partial  
class! &
FixedStringMethods' 9
{ 
[ 	
BurstCompatible	 
(  
GenericTypeArguments -
=. /
new0 3
[3 4
]4 5
{6 7
typeof8 >
(> ?
FixedString128Bytes? R
)R S
}T U
)U V
]V W
internal 
static 
FormatError #
Append$ *
<* +
T+ ,
>, -
(- .
ref. 1
this2 6
T7 8
fs9 ;
,; <
char= A
aB C
,C D
charE I
bJ K
)K L
where 
T 
: 
struct 
, 
INativeList )
<) *
byte* .
>. /
,/ 0

IUTF8Bytes1 ;
{ 	
FormatError 
err 
= 
FormatError )
.) *
None* .
;. /
err 
|= 
fs 
. 
Append 
( 
( 
Unicode %
.% &
Rune& *
)* +
a, -
)- .
;. /
err 
|= 
fs 
. 
Append 
( 
( 
Unicode %
.% &
Rune& *
)* +
b, -
)- .
;. /
if 
( 
err 
!= 
FormatError "
." #
None# '
)' (
return 
FormatError "
." #
Overflow# +
;+ ,
return 
FormatError 
. 
None #
;# $
} 	
[ 	
BurstCompatible	 
(  
GenericTypeArguments -
=. /
new0 3
[3 4
]4 5
{6 7
typeof8 >
(> ?
FixedString128Bytes? R
)R S
}T U
)U V
]V W
internal 
static 
FormatError #
Append$ *
<* +
T+ ,
>, -
(- .
ref. 1
this2 6
T7 8
fs9 ;
,; <
char= A
aB C
,C D
charE I
bJ K
,K L
charM Q
cR S
)S T
where 
T 
: 
struct 
, 
INativeList )
<) *
byte* .
>. /
,/ 0

IUTF8Bytes1 ;
{ 	
FormatError 
err 
= 
FormatError )
.) *
None* .
;. /
err 
|= 
fs 
. 
Append 
( 
( 
Unicode %
.% &
Rune& *
)* +
a, -
)- .
;. /
err   
|=   
fs   
.   
Append   
(   
(   
Unicode   %
.  % &
Rune  & *
)  * +
b  , -
)  - .
;  . /
err!! 
|=!! 
fs!! 
.!! 
Append!! 
(!! 
(!! 
Unicode!! %
.!!% &
Rune!!& *
)!!* +
c!!, -
)!!- .
;!!. /
if"" 
("" 
err"" 
!="" 
FormatError"" "
.""" #
None""# '
)""' (
return## 
FormatError## "
.##" #
Overflow### +
;##+ ,
return$$ 
FormatError$$ 
.$$ 
None$$ #
;$$# $
}%% 	
[** 	
BurstCompatible**	 
(**  
GenericTypeArguments** -
=**. /
new**0 3
[**3 4
]**4 5
{**6 7
typeof**8 >
(**> ?
FixedString128Bytes**? R
)**R S
}**T U
)**U V
]**V W
internal++ 
static++ 
FormatError++ #
Append++$ *
<++* +
T+++ ,
>++, -
(++- .
ref++. 1
this++2 6
T++7 8
fs++9 ;
,++; <
char++= A
a++B C
,++C D
char++E I
b++J K
,++K L
char++M Q
c++R S
,++S T
char++U Y
d++Z [
,++[ \
char++] a
e++b c
,++c d
char++e i
f++j k
,++k l
char++m q
g++r s
,++s t
char++u y
h++z {
)++{ |
where,, 
T,, 
:,, 
struct,, 
,,, 
INativeList,, )
<,,) *
byte,,* .
>,,. /
,,,/ 0

IUTF8Bytes,,1 ;
{-- 	
FormatError.. 
err.. 
=.. 
FormatError.. )
...) *
None..* .
;... /
err// 
|=// 
fs// 
.// 
Append// 
(// 
(// 
Unicode// %
.//% &
Rune//& *
)//* +
a//, -
)//- .
;//. /
err00 
|=00 
fs00 
.00 
Append00 
(00 
(00 
Unicode00 %
.00% &
Rune00& *
)00* +
b00, -
)00- .
;00. /
err11 
|=11 
fs11 
.11 
Append11 
(11 
(11 
Unicode11 %
.11% &
Rune11& *
)11* +
c11, -
)11- .
;11. /
err22 
|=22 
fs22 
.22 
Append22 
(22 
(22 
Unicode22 %
.22% &
Rune22& *
)22* +
d22, -
)22- .
;22. /
err33 
|=33 
fs33 
.33 
Append33 
(33 
(33 
Unicode33 %
.33% &
Rune33& *
)33* +
e33, -
)33- .
;33. /
err44 
|=44 
fs44 
.44 
Append44 
(44 
(44 
Unicode44 %
.44% &
Rune44& *
)44* +
f44, -
)44- .
;44. /
err55 
|=55 
fs55 
.55 
Append55 
(55 
(55 
Unicode55 %
.55% &
Rune55& *
)55* +
g55, -
)55- .
;55. /
err66 
|=66 
fs66 
.66 
Append66 
(66 
(66 
Unicode66 %
.66% &
Rune66& *
)66* +
h66, -
)66- .
;66. /
if77 
(77 
err77 
!=77 
FormatError77 "
.77" #
None77# '
)77' (
return88 
FormatError88 "
.88" #
Overflow88# +
;88+ ,
return99 
FormatError99 
.99 
None99 #
;99# $
}:: 	
[<< 	
BurstCompatible<<	 
(<<  
GenericTypeArguments<< -
=<<. /
new<<0 3
[<<3 4
]<<4 5
{<<6 7
typeof<<8 >
(<<> ?
FixedString128Bytes<<? R
)<<R S
}<<T U
)<<U V
]<<V W
internal== 
static== 
FormatError== #
AppendScientific==$ 4
<==4 5
T==5 6
>==6 7
(==7 8
ref==8 ;
this==< @
T==A B
fs==C E
,==E F
char==G K
*==L M
source==M S
,==S T
int==U X
sourceLength==Y e
,==e f
int==g j
decimalExponent==k z
,==z {
char	==| Ä
decimalSeparator
==Å ë
=
==í ì
$char
==î ó
)
==ó ò
where>> 
T>> 
:>> 
struct>> 
,>> 
INativeList>> )
<>>) *
byte>>* .
>>>. /
,>>/ 0

IUTF8Bytes>>1 ;
{?? 	
FormatError@@ 
error@@ 
;@@ 
ifAA 
(AA 
(AA 
errorAA 
=AA 
fsAA 
.AA 
AppendAA "
(AA" #
sourceAA# )
[AA) *
$numAA* +
]AA+ ,
)AA, -
)AA- .
!=AA/ 1
FormatErrorAA2 =
.AA= >
NoneAA> B
)AAB C
returnBB 
errorBB 
;BB 
ifCC 
(CC 
sourceLengthCC 
>CC 
$numCC  
)CC  !
{DD 
ifEE 
(EE 
(EE 
errorEE 
=EE 
fsEE 
.EE  
AppendEE  &
(EE& '
decimalSeparatorEE' 7
)EE7 8
)EE8 9
!=EE: <
FormatErrorEE= H
.EEH I
NoneEEI M
)EEM N
returnFF 
errorFF  
;FF  !
forGG 
(GG 
varGG 
iGG 
=GG 
$numGG 
;GG 
iGG  !
<GG" #
sourceLengthGG$ 0
;GG0 1
++GG2 4
iGG4 5
)GG5 6
{HH 
ifII 
(II 
(II 
errorII 
=II  
fsII! #
.II# $
AppendII$ *
(II* +
sourceII+ 1
[II1 2
iII2 3
]II3 4
)II4 5
)II5 6
!=II7 9
FormatErrorII: E
.IIE F
NoneIIF J
)IIJ K
returnJJ 
errorJJ $
;JJ$ %
}KK 
}LL 
ifMM 
(MM 
(MM 
errorMM 
=MM 
fsMM 
.MM 
AppendMM "
(MM" #
$charMM# &
)MM& '
)MM' (
!=MM) +
FormatErrorMM, 7
.MM7 8
NoneMM8 <
)MM< =
returnNN 
errorNN 
;NN 
ifOO 
(OO 
decimalExponentOO 
<OO  !
$numOO" #
)OO# $
{PP 
ifQQ 
(QQ 
(QQ 
errorQQ 
=QQ 
fsQQ 
.QQ  
AppendQQ  &
(QQ& '
$charQQ' *
)QQ* +
)QQ+ ,
!=QQ- /
FormatErrorQQ0 ;
.QQ; <
NoneQQ< @
)QQ@ A
returnRR 
errorRR  
;RR  !
decimalExponentSS 
*=SS  "
-SS# $
$numSS$ %
;SS% &
decimalExponentTT 
-=TT  "
sourceLengthTT# /
-TT0 1
$numTT2 3
;TT3 4
}UU 
elseVV 
{WW 
ifXX 
(XX 
(XX 
errorXX 
=XX 
fsXX 
.XX  
AppendXX  &
(XX& '
$charXX' *
)XX* +
)XX+ ,
!=XX- /
FormatErrorXX0 ;
.XX; <
NoneXX< @
)XX@ A
returnYY 
errorYY  
;YY  !
decimalExponentZZ 
+=ZZ  "
sourceLengthZZ# /
-ZZ0 1
$numZZ2 3
;ZZ3 4
}[[ 
var\\ 
ascii\\ 
=\\ 

stackalloc\\ "
char\\# '
[\\' (
$num\\( )
]\\) *
;\\* +
const]] 
int]] 
decimalDigits]] #
=]]$ %
$num]]& '
;]]' (
for^^ 
(^^ 
var^^ 
i^^ 
=^^ 
$num^^ 
;^^ 
i^^ 
<^^ 
decimalDigits^^  -
;^^- .
++^^/ 1
i^^1 2
)^^2 3
{__ 
var`` 
decimalDigit``  
=``! "
decimalExponent``# 2
%``3 4
$num``5 7
;``7 8
asciiaa 
[aa 
$numaa 
-aa 
iaa 
]aa 
=aa 
(aa  
charaa  $
)aa$ %
(aa% &
$charaa& )
+aa* +
decimalDigitaa, 8
)aa8 9
;aa9 :
decimalExponentbb 
/=bb  "
$numbb# %
;bb% &
}cc 
fordd 
(dd 
vardd 
idd 
=dd 
$numdd 
;dd 
idd 
<dd 
decimalDigitsdd  -
;dd- .
++dd/ 1
idd1 2
)dd2 3
ifee 
(ee 
(ee 
erroree 
=ee 
fsee 
.ee  
Appendee  &
(ee& '
asciiee' ,
[ee, -
iee- .
]ee. /
)ee/ 0
)ee0 1
!=ee2 4
FormatErroree5 @
.ee@ A
NoneeeA E
)eeE F
returnff 
errorff  
;ff  !
returngg 
FormatErrorgg 
.gg 
Nonegg #
;gg# $
}hh 	
[rr 	
BurstCompatiblerr	 
(rr  
GenericTypeArgumentsrr -
=rr. /
newrr0 3
[rr3 4
]rr4 5
{rr6 7
typeofrr8 >
(rr> ?
FixedString128Bytesrr? R
)rrR S
}rrT U
)rrU V
]rrV W
internalss 
staticss 
boolss 
Foundss "
<ss" #
Tss# $
>ss$ %
(ss% &
refss& )
thisss* .
Tss/ 0
fsss1 3
,ss3 4
refss5 8
intss9 <
offsetss= C
,ssC D
charssE I
assJ K
,ssK L
charssM Q
bssR S
,ssS T
charssU Y
cssZ [
)ss[ \
wherett 
Ttt 
:tt 
structtt 
,tt 
INativeListtt )
<tt) *
bytett* .
>tt. /
,tt/ 0

IUTF8Bytestt1 ;
{uu 	
intvv 
oldvv 
=vv 
offsetvv 
;vv 
ifww 
(ww 
(ww 
fsww 
.ww 
Readww 
(ww 
refww 
offsetww #
)ww# $
.ww$ %
valueww% *
|ww+ ,
$numww- /
)ww/ 0
==ww1 3
aww4 5
&&xx 
(xx 
fsxx 
.xx 
Readxx 
(xx 
refxx 
offsetxx  &
)xx& '
.xx' (
valuexx( -
|xx. /
$numxx0 2
)xx2 3
==xx4 6
bxx7 8
&&yy 
(yy 
fsyy 
.yy 
Readyy 
(yy 
refyy 
offsetyy  &
)yy& '
.yy' (
valueyy( -
|yy. /
$numyy0 2
)yy2 3
==yy4 6
cyy7 8
)yy8 9
returnzz 
truezz 
;zz 
offset{{ 
={{ 
old{{ 
;{{ 
return|| 
false|| 
;|| 
}}} 	
[
åå 	
BurstCompatible
åå	 
(
åå "
GenericTypeArguments
åå -
=
åå. /
new
åå0 3
[
åå3 4
]
åå4 5
{
åå6 7
typeof
åå8 >
(
åå> ?!
FixedString128Bytes
åå? R
)
ååR S
}
ååT U
)
ååU V
]
ååV W
internal
çç 
static
çç 
bool
çç 
Found
çç "
<
çç" #
T
çç# $
>
çç$ %
(
çç% &
ref
çç& )
this
çç* .
T
çç/ 0
fs
çç1 3
,
çç3 4
ref
çç5 8
int
çç9 <
offset
çç= C
,
ççC D
char
ççE I
a
ççJ K
,
ççK L
char
ççM Q
b
ççR S
,
ççS T
char
ççU Y
c
ççZ [
,
çç[ \
char
çç] a
d
ççb c
,
ççc d
char
ççe i
e
ççj k
,
ççk l
char
ççm q
f
ççr s
,
ççs t
char
ççu y
g
ççz {
,
çç{ |
charçç} Å
hççÇ É
)ççÉ Ñ
where
éé 
T
éé 
:
éé 
struct
éé 
,
éé 
INativeList
éé )
<
éé) *
byte
éé* .
>
éé. /
,
éé/ 0

IUTF8Bytes
éé1 ;
{
èè 	
int
êê 
old
êê 
=
êê 
offset
êê 
;
êê 
if
ëë 
(
ëë 
(
ëë 
fs
ëë 
.
ëë 
Read
ëë 
(
ëë 
ref
ëë 
offset
ëë #
)
ëë# $
.
ëë$ %
value
ëë% *
|
ëë+ ,
$num
ëë- /
)
ëë/ 0
==
ëë1 3
a
ëë4 5
&&
íí 
(
íí 
fs
íí 
.
íí 
Read
íí 
(
íí 
ref
íí 
offset
íí  &
)
íí& '
.
íí' (
value
íí( -
|
íí. /
$num
íí0 2
)
íí2 3
==
íí4 6
b
íí7 8
&&
ìì 
(
ìì 
fs
ìì 
.
ìì 
Read
ìì 
(
ìì 
ref
ìì 
offset
ìì  &
)
ìì& '
.
ìì' (
value
ìì( -
|
ìì. /
$num
ìì0 2
)
ìì2 3
==
ìì4 6
c
ìì7 8
&&
îî 
(
îî 
fs
îî 
.
îî 
Read
îî 
(
îî 
ref
îî 
offset
îî  &
)
îî& '
.
îî' (
value
îî( -
|
îî. /
$num
îî0 2
)
îî2 3
==
îî4 6
d
îî7 8
&&
ïï 
(
ïï 
fs
ïï 
.
ïï 
Read
ïï 
(
ïï 
ref
ïï 
offset
ïï  &
)
ïï& '
.
ïï' (
value
ïï( -
|
ïï. /
$num
ïï0 2
)
ïï2 3
==
ïï4 6
e
ïï7 8
&&
ññ 
(
ññ 
fs
ññ 
.
ññ 
Read
ññ 
(
ññ 
ref
ññ 
offset
ññ  &
)
ññ& '
.
ññ' (
value
ññ( -
|
ññ. /
$num
ññ0 2
)
ññ2 3
==
ññ4 6
f
ññ7 8
&&
óó 
(
óó 
fs
óó 
.
óó 
Read
óó 
(
óó 
ref
óó 
offset
óó  &
)
óó& '
.
óó' (
value
óó( -
|
óó. /
$num
óó0 2
)
óó2 3
==
óó4 6
g
óó7 8
&&
òò 
(
òò 
fs
òò 
.
òò 
Read
òò 
(
òò 
ref
òò 
offset
òò  &
)
òò& '
.
òò' (
value
òò( -
|
òò. /
$num
òò0 2
)
òò2 3
==
òò4 6
h
òò7 8
)
òò8 9
return
ôô 
true
ôô 
;
ôô 
offset
öö 
=
öö 
old
öö 
;
öö 
return
õõ 
false
õõ 
;
õõ 
}
úú 	
}
ùù 
}ûû ùU
dC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeHashSet.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{		 
[ 
StructLayout 
( 

LayoutKind 
. 

Sequential '
)' (
]( )
[ 
DebuggerTypeProxy 
( 
typeof 
( *
UnsafeHashSetDebuggerTypeProxy <
<< =
>= >
)> ?
)? @
]@ A
[ 
BurstCompatible 
(  
GenericTypeArguments )
=* +
new, /
[0 1
]1 2
{3 4
typeof5 ;
(; <
int< ?
)? @
}A B
)B C
]C D
public 

unsafe 
struct 
UnsafeHashSet &
<& '
T' (
>( )
: 	
INativeDisposable
 
, 	
IEnumerable
 
< 
T 
> 
where 
T 
: 
	unmanaged 
, 

IEquatable '
<' (
T( )
>) *
{ 
internal 
UnsafeHashMap 
< 
T  
,  !
bool" &
>& '
m_Data( .
;. /
public 
UnsafeHashSet 
( 
int  
capacity! )
,) *
AllocatorManager+ ;
.; <
AllocatorHandle< K
	allocatorL U
)U V
{ 	
m_Data 
= 
new 
UnsafeHashMap &
<& '
T' (
,( )
bool* .
>. /
(/ 0
capacity0 8
,8 9
	allocator: C
)C D
;D E
}   	
public&& 
bool&& 
IsEmpty&& 
=>&& 
m_Data&& %
.&&% &
IsEmpty&&& -
;&&- .
public,, 
int,, 
Count,, 
(,, 
),, 
=>,, 
m_Data,, $
.,,$ %
Count,,% *
(,,* +
),,+ ,
;,,, -
public44 
int44 
Capacity44 
{44 
get44 !
=>44" $
m_Data44% +
.44+ ,
Capacity44, 4
;444 5
set446 9
=>44: <
m_Data44= C
.44C D
Capacity44D L
=44M N
value44O T
;44T U
}44V W
public:: 
bool:: 
	IsCreated:: 
=>::  
m_Data::! '
.::' (
	IsCreated::( 1
;::1 2
public?? 
void?? 
Dispose?? 
(?? 
)?? 
=>??  
m_Data??! '
.??' (
Dispose??( /
(??/ 0
)??0 1
;??1 2
[FF 	
NotBurstCompatibleFF	 
]
FFú ù
publicGG 
	JobHandleGG 
DisposeGG  
(GG  !
	JobHandleGG! *
	inputDepsGG+ 4
)GG4 5
=>GG6 8
m_DataGG9 ?
.GG? @
DisposeGG@ G
(GGG H
	inputDepsGGH Q
)GGQ R
;GGR S
publicMM 
voidMM 
ClearMM 
(MM 
)MM 
=>MM 
m_DataMM %
.MM% &
ClearMM& +
(MM+ ,
)MM, -
;MM- .
publicTT 
boolTT 
AddTT 
(TT 
TTT 
itemTT 
)TT 
=>TT  "
m_DataTT# )
.TT) *
TryAddTT* 0
(TT0 1
itemTT1 5
,TT5 6
falseTT7 <
)TT< =
;TT= >
public[[ 
bool[[ 
Remove[[ 
([[ 
T[[ 
item[[ !
)[[! "
=>[[# %
m_Data[[& ,
.[[, -
Remove[[- 3
([[3 4
item[[4 8
)[[8 9
;[[9 :
publicbb 
boolbb 
Containsbb 
(bb 
Tbb 
itembb #
)bb# $
=>bb% '
m_Databb( .
.bb. /
ContainsKeybb/ :
(bb: ;
itembb; ?
)bb? @
;bb@ A
publicii 
NativeArrayii 
<ii 
Tii 
>ii 
ToNativeArrayii +
(ii+ ,
AllocatorManagerii, <
.ii< =
AllocatorHandleii= L
	allocatoriiM V
)iiV W
=>iiX Z
m_Dataii[ a
.iia b
GetKeyArrayiib m
(iim n
	allocatoriin w
)iiw x
;iix y
publicoo 
ParallelWriteroo 
AsParallelWriteroo .
(oo. /
)oo/ 0
{pp 	
returnqq 
newqq 
ParallelWriterqq %
{qq& '
m_Dataqq( .
=qq/ 0
m_Dataqq1 7
.qq7 8
AsParallelWriterqq8 H
(qqH I
)qqI J
}qqK L
;qqL M
}rr 	
[zz 	,
 NativeContainerIsAtomicWriteOnlyzz	 )
]zz) *
[{{ 	
BurstCompatible{{	 
({{  
GenericTypeArguments{{ -
={{. /
new{{0 3
[{{4 5
]{{5 6
{{{7 8
typeof{{9 ?
({{? @
int{{@ C
){{C D
}{{E F
){{F G
]{{G H
public|| 
struct|| 
ParallelWriter|| $
{}} 	
internal~~ 
UnsafeHashMap~~ "
<~~" #
T~~# $
,~~$ %
bool~~& *
>~~* +
.~~+ ,
ParallelWriter~~, :
m_Data~~; A
;~~A B
public
ÑÑ 
int
ÑÑ 
Capacity
ÑÑ 
=>
ÑÑ  "
m_Data
ÑÑ# )
.
ÑÑ) *
Capacity
ÑÑ* 2
;
ÑÑ2 3
public
ãã 
bool
ãã 
Add
ãã 
(
ãã 
T
ãã 
item
ãã "
)
ãã" #
=>
ãã$ &
m_Data
ãã' -
.
ãã- .
TryAdd
ãã. 4
(
ãã4 5
item
ãã5 9
,
ãã9 :
false
ãã; @
)
ãã@ A
;
ããA B
}
åå 	
public
íí 

Enumerator
íí 
GetEnumerator
íí '
(
íí' (
)
íí( )
{
ìì 	
return
îî 
new
îî 

Enumerator
îî !
{
îî" #
m_Enumerator
îî$ 0
=
îî1 2
new
îî3 6)
UnsafeHashMapDataEnumerator
îî7 R
(
îîR S
m_Data
îîS Y
.
îîY Z
m_Buffer
îîZ b
)
îîb c
}
îîd e
;
îîe f
}
ïï 	
IEnumerator
úú 
<
úú 
T
úú 
>
úú 
IEnumerable
úú "
<
úú" #
T
úú# $
>
úú$ %
.
úú% &
GetEnumerator
úú& 3
(
úú3 4
)
úú4 5
{
ùù 	
throw
ûû 
new
ûû %
NotImplementedException
ûû -
(
ûû- .
)
ûû. /
;
ûû/ 0
}
üü 	
IEnumerator
¶¶ 
IEnumerable
¶¶ 
.
¶¶  
GetEnumerator
¶¶  -
(
¶¶- .
)
¶¶. /
{
ßß 	
throw
®® 
new
®® %
NotImplementedException
®® -
(
®®- .
)
®®. /
;
®®/ 0
}
©© 	
public
≤≤ 
struct
≤≤ 

Enumerator
≤≤  
:
≤≤! "
IEnumerator
≤≤# .
<
≤≤. /
T
≤≤/ 0
>
≤≤0 1
{
≥≥ 	
internal
¥¥ )
UnsafeHashMapDataEnumerator
¥¥ 0
m_Enumerator
¥¥1 =
;
¥¥= >
public
ππ 
void
ππ 
Dispose
ππ 
(
ππ  
)
ππ  !
{
ππ" #
}
ππ$ %
public
øø 
bool
øø 
MoveNext
øø  
(
øø  !
)
øø! "
=>
øø# %
m_Enumerator
øø& 2
.
øø2 3
MoveNext
øø3 ;
(
øø; <
)
øø< =
;
øø= >
public
ƒƒ 
void
ƒƒ 
Reset
ƒƒ 
(
ƒƒ 
)
ƒƒ 
=>
ƒƒ  "
m_Enumerator
ƒƒ# /
.
ƒƒ/ 0
Reset
ƒƒ0 5
(
ƒƒ5 6
)
ƒƒ6 7
;
ƒƒ7 8
public
   
T
   
Current
   
=>
   
m_Enumerator
    ,
.
  , -
GetCurrentKey
  - :
<
  : ;
T
  ; <
>
  < =
(
  = >
)
  > ?
;
  ? @
object
ÃÃ 
IEnumerator
ÃÃ 
.
ÃÃ 
Current
ÃÃ &
=>
ÃÃ' )
Current
ÃÃ* 1
;
ÃÃ1 2
}
ÕÕ 	
}
ŒŒ 
sealed
–– 

internal
–– 
class
–– ,
UnsafeHashSetDebuggerTypeProxy
–– 8
<
––8 9
T
––9 :
>
––: ;
where
—— 
T
—— 
:
—— 
	unmanaged
—— 
,
—— 

IEquatable
—— '
<
——' (
T
——( )
>
——) *
{
““ 
UnsafeHashSet
‘‘ 
<
‘‘ 
T
‘‘ 
>
‘‘ 
Data
‘‘ 
;
‘‘ 
public
÷÷ ,
UnsafeHashSetDebuggerTypeProxy
÷÷ -
(
÷÷- .
UnsafeHashSet
÷÷. ;
<
÷÷; <
T
÷÷< =
>
÷÷= >
data
÷÷? C
)
÷÷C D
{
◊◊ 	
Data
ÿÿ 
=
ÿÿ 
data
ÿÿ 
;
ÿÿ 
}
ŸŸ 	
public
€€ 
List
€€ 
<
€€ 
T
€€ 
>
€€ 
Items
€€ 
{
‹‹ 	
get
›› 
{
ﬁﬁ 
var
ﬂﬂ 
result
ﬂﬂ 
=
ﬂﬂ 
new
ﬂﬂ  
List
ﬂﬂ! %
<
ﬂﬂ% &
T
ﬂﬂ& '
>
ﬂﬂ' (
(
ﬂﬂ( )
)
ﬂﬂ) *
;
ﬂﬂ* +
using
‡‡ 
(
‡‡ 
var
‡‡ 
item
‡‡ 
=
‡‡  !
Data
‡‡" &
.
‡‡& '
ToNativeArray
‡‡' 4
(
‡‡4 5
	Allocator
‡‡5 >
.
‡‡> ?
Temp
‡‡? C
)
‡‡C D
)
‡‡D E
{
·· 
for
‚‚ 
(
‚‚ 
var
‚‚ 
k
‚‚ 
=
‚‚  
$num
‚‚! "
;
‚‚" #
k
‚‚$ %
<
‚‚& '
item
‚‚( ,
.
‚‚, -
Length
‚‚- 3
;
‚‚3 4
++
‚‚5 7
k
‚‚7 8
)
‚‚8 9
{
„„ 
result
‰‰ 
.
‰‰ 
Add
‰‰ "
(
‰‰" #
item
‰‰# '
[
‰‰' (
k
‰‰( )
]
‰‰) *
)
‰‰* +
;
‰‰+ ,
}
ÂÂ 
}
ÊÊ 
return
ËË 
result
ËË 
;
ËË 
}
ÈÈ 
}
ÍÍ 	
}
ÏÏ 
}ÌÌ ™ﬂ
lC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeArrayExtensions.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[ 
BurstCompatible 
] 
public 

unsafe 
static 
class !
NativeArrayExtensions 4
{ 
public 
struct 
NativeArrayStaticId )
<) *
T* +
>+ ,
where 
T 
: 
struct 
{ 	
internal 
static 
readonly $
SharedStatic% 1
<1 2
int2 5
>5 6
s_staticSafetyId7 G
=H I
SharedStaticJ V
<V W
intW Z
>Z [
.[ \
GetOrCreate\ g
<g h
NativeArrayh s
<s t
Tt u
>u v
>v w
(w x
)x y
;y z
} 	
[ 	
BurstCompatible	 
(  
GenericTypeArguments -
=. /
new0 3
[4 5
]5 6
{7 8
typeof9 ?
(? @
int@ C
)C D
,D E
typeofF L
(L M
intM P
)P Q
}R S
)S T
]T U
public 
static 
bool 
Contains #
<# $
T$ %
,% &
U' (
>( )
() *
this* .
NativeArray/ :
<: ;
T; <
>< =
array> C
,C D
UE F
valueG L
)L M
whereN S
TT U
:V W
structX ^
,^ _

IEquatable` j
<j k
Uk l
>l m
{ 	
return   
IndexOf   
<   
T   
,   
U   
>    
(    !
array  ! &
.  & ' 
GetUnsafeReadOnlyPtr  ' ;
(  ; <
)  < =
,  = >
array  ? D
.  D E
Length  E K
,  K L
value  M R
)  R S
!=  T V
-  W X
$num  X Y
;  Y Z
}!! 	
[++ 	
BurstCompatible++	 
(++  
GenericTypeArguments++ -
=++. /
new++0 3
[++4 5
]++5 6
{++7 8
typeof++9 ?
(++? @
int++@ C
)++C D
,++D E
typeof++F L
(++L M
int++M P
)++P Q
}++R S
)++S T
]++T U
public,, 
static,, 
int,, 
IndexOf,, !
<,,! "
T,," #
,,,# $
U,,% &
>,,& '
(,,' (
this,,( ,
NativeArray,,- 8
<,,8 9
T,,9 :
>,,: ;
array,,< A
,,,A B
U,,C D
value,,E J
),,J K
where,,L Q
T,,R S
:,,T U
struct,,V \
,,,\ ]

IEquatable,,^ h
<,,h i
U,,i j
>,,j k
{-- 	
return.. 
IndexOf.. 
<.. 
T.. 
,.. 
U.. 
>..  
(..  !
array..! &
...& ' 
GetUnsafeReadOnlyPtr..' ;
(..; <
)..< =
,..= >
array..? D
...D E
Length..E K
,..K L
value..M R
)..R S
;..S T
}// 	
[99 	
BurstCompatible99	 
(99  
GenericTypeArguments99 -
=99. /
new990 3
[994 5
]995 6
{997 8
typeof999 ?
(99? @
int99@ C
)99C D
,99D E
typeof99F L
(99L M
int99M P
)99P Q
}99R S
)99S T
]99T U
public:: 
static:: 
bool:: 
Contains:: #
<::# $
T::$ %
,::% &
U::' (
>::( )
(::) *
this::* .
NativeArray::/ :
<::: ;
T::; <
>::< =
.::= >
ReadOnly::> F
array::G L
,::L M
U::N O
value::P U
)::U V
where::W \
T::] ^
:::_ `
struct::a g
,::g h

IEquatable::i s
<::s t
U::t u
>::u v
{;; 	
return<< 
IndexOf<< 
<<< 
T<< 
,<< 
U<< 
><<  
(<<  !
array<<! &
.<<& '
m_Buffer<<' /
,<</ 0
array<<1 6
.<<6 7
m_Length<<7 ?
,<<? @
value<<A F
)<<F G
!=<<H J
-<<K L
$num<<L M
;<<M N
}== 	
[GG 	
BurstCompatibleGG	 
(GG  
GenericTypeArgumentsGG -
=GG. /
newGG0 3
[GG4 5
]GG5 6
{GG7 8
typeofGG9 ?
(GG? @
intGG@ C
)GGC D
,GGD E
typeofGGF L
(GGL M
intGGM P
)GGP Q
}GGR S
)GGS T
]GGT U
publicHH 
staticHH 
intHH 
IndexOfHH !
<HH! "
THH" #
,HH# $
UHH% &
>HH& '
(HH' (
thisHH( ,
NativeArrayHH- 8
<HH8 9
THH9 :
>HH: ;
.HH; <
ReadOnlyHH< D
arrayHHE J
,HHJ K
UHHL M
valueHHN S
)HHS T
whereHHU Z
THH[ \
:HH] ^
structHH_ e
,HHe f

IEquatableHHg q
<HHq r
UHHr s
>HHs t
{II 	
returnJJ 
IndexOfJJ 
<JJ 
TJJ 
,JJ 
UJJ 
>JJ  
(JJ  !
arrayJJ! &
.JJ& '
m_BufferJJ' /
,JJ/ 0
arrayJJ1 6
.JJ6 7
m_LengthJJ7 ?
,JJ? @
valueJJA F
)JJF G
;JJG H
}KK 	
[UU 	
BurstCompatibleUU	 
(UU  
GenericTypeArgumentsUU -
=UU. /
newUU0 3
[UU4 5
]UU5 6
{UU7 8
typeofUU9 ?
(UU? @
intUU@ C
)UUC D
,UUD E
typeofUUF L
(UUL M
intUUM P
)UUP Q
}UUR S
)UUS T
]UUT U
publicVV 
staticVV 
boolVV 
ContainsVV #
<VV# $
TVV$ %
,VV% &
UVV' (
>VV( )
(VV) *
thisVV* .

NativeListVV/ 9
<VV9 :
TVV: ;
>VV; <
listVV= A
,VVA B
UVVC D
valueVVE J
)VVJ K
whereVVL Q
TVVR S
:VVT U
	unmanagedVVV _
,VV_ `

IEquatableVVa k
<VVk l
UVVl m
>VVm n
{WW 	
returnXX 
IndexOfXX 
<XX 
TXX 
,XX 
UXX 
>XX  
(XX  !
listXX! %
.XX% & 
GetUnsafeReadOnlyPtrXX& :
(XX: ;
)XX; <
,XX< =
listXX> B
.XXB C
LengthXXC I
,XXI J
valueXXK P
)XXP Q
!=XXR T
-XXU V
$numXXV W
;XXW X
}YY 	
[cc 	
BurstCompatiblecc	 
(cc  
GenericTypeArgumentscc -
=cc. /
newcc0 3
[cc4 5
]cc5 6
{cc7 8
typeofcc9 ?
(cc? @
intcc@ C
)ccC D
,ccD E
typeofccF L
(ccL M
intccM P
)ccP Q
}ccR S
)ccS T
]ccT U
publicdd 
staticdd 
intdd 
IndexOfdd !
<dd! "
Tdd" #
,dd# $
Udd% &
>dd& '
(dd' (
thisdd( ,

NativeListdd- 7
<dd7 8
Tdd8 9
>dd9 :
listdd; ?
,dd? @
UddA B
valueddC H
)ddH I
whereddJ O
TddP Q
:ddR S
	unmanagedddT ]
,dd] ^

IEquatabledd_ i
<ddi j
Uddj k
>ddk l
{ee 	
returnff 
IndexOfff 
<ff 
Tff 
,ff 
Uff 
>ff  
(ff  !
listff! %
.ff% & 
GetUnsafeReadOnlyPtrff& :
(ff: ;
)ff; <
,ff< =
listff> B
.ffB C
LengthffC I
,ffI J
valueffK P
)ffP Q
;ffQ R
}gg 	
[rr 	
BurstCompatiblerr	 
(rr  
GenericTypeArgumentsrr -
=rr. /
newrr0 3
[rr4 5
]rr5 6
{rr7 8
typeofrr9 ?
(rr? @
intrr@ C
)rrC D
,rrD E
typeofrrF L
(rrL M
intrrM P
)rrP Q
}rrR S
)rrS T
]rrT U
publicss 
staticss 
boolss 
Containsss #
<ss# $
Tss$ %
,ss% &
Uss' (
>ss( )
(ss) *
voidss* .
*ss. /
ptrss0 3
,ss3 4
intss5 8
lengthss9 ?
,ss? @
UssA B
valuessC H
)ssH I
wheressJ O
TssP Q
:ssR S
structssT Z
,ssZ [

IEquatabless\ f
<ssf g
Ussg h
>ssh i
{tt 	
returnuu 
IndexOfuu 
<uu 
Tuu 
,uu 
Uuu 
>uu  
(uu  !
ptruu! $
,uu$ %
lengthuu& ,
,uu, -
valueuu. 3
)uu3 4
!=uu5 7
-uu8 9
$numuu9 :
;uu: ;
}vv 	
[
ÅÅ 	
BurstCompatible
ÅÅ	 
(
ÅÅ "
GenericTypeArguments
ÅÅ -
=
ÅÅ. /
new
ÅÅ0 3
[
ÅÅ4 5
]
ÅÅ5 6
{
ÅÅ7 8
typeof
ÅÅ9 ?
(
ÅÅ? @
int
ÅÅ@ C
)
ÅÅC D
,
ÅÅD E
typeof
ÅÅF L
(
ÅÅL M
int
ÅÅM P
)
ÅÅP Q
}
ÅÅR S
)
ÅÅS T
]
ÅÅT U
public
ÇÇ 
static
ÇÇ 
int
ÇÇ 
IndexOf
ÇÇ !
<
ÇÇ! "
T
ÇÇ" #
,
ÇÇ# $
U
ÇÇ% &
>
ÇÇ& '
(
ÇÇ' (
void
ÇÇ( ,
*
ÇÇ, -
ptr
ÇÇ. 1
,
ÇÇ1 2
int
ÇÇ3 6
length
ÇÇ7 =
,
ÇÇ= >
U
ÇÇ? @
value
ÇÇA F
)
ÇÇF G
where
ÇÇH M
T
ÇÇN O
:
ÇÇP Q
struct
ÇÇR X
,
ÇÇX Y

IEquatable
ÇÇZ d
<
ÇÇd e
U
ÇÇe f
>
ÇÇf g
{
ÉÉ 	
for
ÑÑ 
(
ÑÑ 
int
ÑÑ 
i
ÑÑ 
=
ÑÑ 
$num
ÑÑ 
;
ÑÑ 
i
ÑÑ 
!=
ÑÑ  
length
ÑÑ! '
;
ÑÑ' (
i
ÑÑ) *
++
ÑÑ* ,
)
ÑÑ, -
{
ÖÖ 
if
ÜÜ 
(
ÜÜ 
UnsafeUtility
ÜÜ !
.
ÜÜ! "
ReadArrayElement
ÜÜ" 2
<
ÜÜ2 3
T
ÜÜ3 4
>
ÜÜ4 5
(
ÜÜ5 6
ptr
ÜÜ6 9
,
ÜÜ9 :
i
ÜÜ; <
)
ÜÜ< =
.
ÜÜ= >
Equals
ÜÜ> D
(
ÜÜD E
value
ÜÜE J
)
ÜÜJ K
)
ÜÜK L
return
áá 
i
áá 
;
áá 
}
àà 
return
ââ 
-
ââ 
$num
ââ 
;
ââ 
}
ää 	
[
ïï 	
BurstCompatible
ïï	 
(
ïï "
GenericTypeArguments
ïï -
=
ïï. /
new
ïï0 3
[
ïï4 5
]
ïï5 6
{
ïï7 8
typeof
ïï9 ?
(
ïï? @
int
ïï@ C
)
ïïC D
,
ïïD E
typeof
ïïF L
(
ïïL M
int
ïïM P
)
ïïP Q
}
ïïR S
)
ïïS T
]
ïïT U
public
ññ 
static
ññ 
NativeArray
ññ !
<
ññ! "
U
ññ" #
>
ññ# $
Reinterpret
ññ% 0
<
ññ0 1
T
ññ1 2
,
ññ2 3
U
ññ4 5
>
ññ5 6
(
ññ6 7
this
ññ7 ;
NativeArray
ññ< G
<
ññG H
T
ññH I
>
ññI J
array
ññK P
)
ññP Q
where
ññR W
U
ññX Y
:
ññZ [
struct
ññ\ b
where
ññc h
T
ññi j
:
ññk l
struct
ññm s
{
óó 	
var
òò 
tSize
òò 
=
òò 
UnsafeUtility
òò %
.
òò% &
SizeOf
òò& ,
<
òò, -
T
òò- .
>
òò. /
(
òò/ 0
)
òò0 1
;
òò1 2
var
ôô 
uSize
ôô 
=
ôô 
UnsafeUtility
ôô %
.
ôô% &
SizeOf
ôô& ,
<
ôô, -
U
ôô- .
>
ôô. /
(
ôô/ 0
)
ôô0 1
;
ôô1 2
var
õõ 
byteLen
õõ 
=
õõ 
(
õõ 
(
õõ 
long
õõ  
)
õõ  !
array
õõ! &
.
õõ& '
Length
õõ' -
)
õõ- .
*
õõ/ 0
tSize
õõ1 6
;
õõ6 7
var
úú 
uLen
úú 
=
úú 
byteLen
úú 
/
úú  
uSize
úú! &
;
úú& '"
CheckReinterpretSize
ûû  
<
ûû  !
T
ûû! "
,
ûû" #
U
ûû$ %
>
ûû% &
(
ûû& '
ref
ûû' *
array
ûû+ 0
)
ûû0 1
;
ûû1 2
var
†† 
ptr
†† 
=
†† &
NativeArrayUnsafeUtility
†† .
.
††. /1
#GetUnsafeBufferPointerWithoutChecks
††/ R
(
††R S
array
††S X
)
††X Y
;
††Y Z
var
°° 
result
°° 
=
°° &
NativeArrayUnsafeUtility
°° 1
.
°°1 2.
 ConvertExistingDataToNativeArray
°°2 R
<
°°R S
U
°°S T
>
°°T U
(
°°U V
ptr
°°V Y
,
°°Y Z
(
°°[ \
int
°°\ _
)
°°_ `
uLen
°°` d
,
°°d e
	Allocator
°°f o
.
°°o p
None
°°p t
)
°°t u
;
°°u v
var
§§ 
handle
§§ 
=
§§ &
NativeArrayUnsafeUtility
§§ 1
.
§§1 2#
GetAtomicSafetyHandle
§§2 G
(
§§G H
array
§§H M
)
§§M N
;
§§N O&
NativeArrayUnsafeUtility
•• $
.
••$ %#
SetAtomicSafetyHandle
••% :
(
••: ;
ref
••; >
result
••? E
,
••E F
handle
••G M
)
••M N
;
••N O
return
®® 
result
®® 
;
®® 
}
©© 	
[
≤≤ 	
BurstCompatible
≤≤	 
(
≤≤ "
GenericTypeArguments
≤≤ -
=
≤≤. /
new
≤≤0 3
[
≤≤4 5
]
≤≤5 6
{
≤≤7 8
typeof
≤≤9 ?
(
≤≤? @
int
≤≤@ C
)
≤≤C D
}
≤≤E F
)
≤≤F G
]
≤≤G H
public
≥≥ 
static
≥≥ 
bool
≥≥ 
ArraysEqual
≥≥ &
<
≥≥& '
T
≥≥' (
>
≥≥( )
(
≥≥) *
this
≥≥* .
NativeArray
≥≥/ :
<
≥≥: ;
T
≥≥; <
>
≥≥< =
array
≥≥> C
,
≥≥C D
NativeArray
≥≥E P
<
≥≥P Q
T
≥≥Q R
>
≥≥R S
other
≥≥T Y
)
≥≥Y Z
where
≥≥[ `
T
≥≥a b
:
≥≥c d
struct
≥≥e k
,
≥≥k l

IEquatable
≥≥m w
<
≥≥w x
T
≥≥x y
>
≥≥y z
{
¥¥ 	
if
µµ 
(
µµ 
array
µµ 
.
µµ 
Length
µµ 
!=
µµ 
other
µµ  %
.
µµ% &
Length
µµ& ,
)
µµ, -
return
∂∂ 
false
∂∂ 
;
∂∂ 
for
∏∏ 
(
∏∏ 
int
∏∏ 
i
∏∏ 
=
∏∏ 
$num
∏∏ 
;
∏∏ 
i
∏∏ 
!=
∏∏  
array
∏∏! &
.
∏∏& '
Length
∏∏' -
;
∏∏- .
i
∏∏/ 0
++
∏∏0 2
)
∏∏2 3
{
ππ 
if
∫∫ 
(
∫∫ 
!
∫∫ 
array
∫∫ 
[
∫∫ 
i
∫∫ 
]
∫∫ 
.
∫∫ 
Equals
∫∫ $
(
∫∫$ %
other
∫∫% *
[
∫∫* +
i
∫∫+ ,
]
∫∫, -
)
∫∫- .
)
∫∫. /
return
ªª 
false
ªª  
;
ªª  !
}
ºº 
return
ææ 
true
ææ 
;
ææ 
}
øø 	
[
»» 	
BurstCompatible
»»	 
(
»» "
GenericTypeArguments
»» -
=
»». /
new
»»0 3
[
»»4 5
]
»»5 6
{
»»7 8
typeof
»»9 ?
(
»»? @
int
»»@ C
)
»»C D
}
»»E F
)
»»F G
]
»»G H
public
…… 
static
…… 
bool
…… 
ArraysEqual
…… &
<
……& '
T
……' (
>
……( )
(
……) *
this
……* .

NativeList
……/ 9
<
……9 :
T
……: ;
>
……; <
array
……= B
,
……B C
NativeArray
……D O
<
……O P
T
……P Q
>
……Q R
other
……S X
)
……X Y
where
……Z _
T
……` a
:
……b c
	unmanaged
……d m
,
……m n

IEquatable
……o y
<
……y z
T
……z {
>
……{ |
{
   	
return
ÀÀ 
ArraysEqual
ÀÀ 
(
ÀÀ 
array
ÀÀ $
.
ÀÀ$ %
AsArray
ÀÀ% ,
(
ÀÀ, -
)
ÀÀ- .
,
ÀÀ. /
other
ÀÀ0 5
)
ÀÀ5 6
;
ÀÀ6 7
}
ÃÃ 	
[
œœ 	
Conditional
œœ	 
(
œœ 
$str
œœ 6
)
œœ6 7
]
œœ7 8
static
–– 
void
–– "
CheckReinterpretSize
–– (
<
––( )
T
––) *
,
––* +
U
––, -
>
––- .
(
––. /
ref
––/ 2
NativeArray
––3 >
<
––> ?
T
––? @
>
––@ A
array
––B G
)
––G H
where
––I N
U
––O P
:
––Q R
struct
––S Y
where
––Z _
T
––` a
:
––b c
struct
––d j
{
—— 	
var
““ 
tSize
““ 
=
““ 
UnsafeUtility
““ %
.
““% &
SizeOf
““& ,
<
““, -
T
““- .
>
““. /
(
““/ 0
)
““0 1
;
““1 2
var
”” 
uSize
”” 
=
”” 
UnsafeUtility
”” %
.
””% &
SizeOf
””& ,
<
””, -
U
””- .
>
””. /
(
””/ 0
)
””0 1
;
””1 2
var
’’ 
byteLen
’’ 
=
’’ 
(
’’ 
(
’’ 
long
’’  
)
’’  !
array
’’! &
.
’’& '
Length
’’' -
)
’’- .
*
’’/ 0
tSize
’’1 6
;
’’6 7
var
÷÷ 
uLen
÷÷ 
=
÷÷ 
byteLen
÷÷ 
/
÷÷  
uSize
÷÷! &
;
÷÷& '
if
ÿÿ 
(
ÿÿ 
uLen
ÿÿ 
*
ÿÿ 
uSize
ÿÿ 
!=
ÿÿ 
byteLen
ÿÿ  '
)
ÿÿ' (
{
ŸŸ 
throw
⁄⁄ 
new
⁄⁄ '
InvalidOperationException
⁄⁄ 3
(
⁄⁄3 4
$"
⁄⁄4 6
$str
⁄⁄6 <
{
⁄⁄< =
typeof
⁄⁄= C
(
⁄⁄C D
T
⁄⁄D E
)
⁄⁄E F
}
⁄⁄F G
$str
⁄⁄G V
{
⁄⁄V W
array
⁄⁄W \
.
⁄⁄\ ]
Length
⁄⁄] c
}
⁄⁄c d
$str
⁄⁄d j
{
⁄⁄j k
typeof
⁄⁄k q
(
⁄⁄q r
U
⁄⁄r s
)
⁄⁄s t
}
⁄⁄t u
$str⁄⁄u Ÿ
"⁄⁄Ÿ ⁄
)⁄⁄⁄ €
;⁄⁄€ ‹
}
€€ 
}
‹‹ 	
[
ﬁﬁ 	
BurstCompatible
ﬁﬁ	 
(
ﬁﬁ "
GenericTypeArguments
ﬁﬁ -
=
ﬁﬁ. /
new
ﬁﬁ0 3
[
ﬁﬁ3 4
]
ﬁﬁ4 5
{
ﬁﬁ6 7
typeof
ﬁﬁ8 >
(
ﬁﬁ> ?
int
ﬁﬁ? B
)
ﬁﬁB C
}
ﬁﬁD E
)
ﬁﬁE F
]
ﬁﬁF G
internal
ﬂﬂ 
static
ﬂﬂ 
void
ﬂﬂ 

Initialize
ﬂﬂ '
<
ﬂﬂ' (
T
ﬂﬂ( )
>
ﬂﬂ) *
(
ﬂﬂ* +
ref
ﬂﬂ+ .
this
ﬂﬂ/ 3
NativeArray
ﬂﬂ4 ?
<
ﬂﬂ? @
T
ﬂﬂ@ A
>
ﬂﬂA B
array
ﬂﬂC H
,
ﬂﬂH I
int
‡‡, /
length
‡‡0 6
,
‡‡6 7
AllocatorManager
··, <
.
··< =
AllocatorHandle
··= L
	allocator
··M V
,
··V W 
NativeArrayOptions
‚‚, >
options
‚‚? F
=
‚‚G H 
NativeArrayOptions
‚‚I [
.
‚‚[ \!
UninitializedMemory
‚‚\ o
)
‚‚o p
where
„„ 
T
„„ 
:
„„ 
struct
„„ 
{
‰‰ 	
AllocatorHandle
ÂÂ 
handle
ÂÂ "
=
ÂÂ# $
	allocator
ÂÂ% .
;
ÂÂ. /
array
ÊÊ 
.
ÊÊ 
m_Buffer
ÊÊ 
=
ÊÊ 
handle
ÊÊ #
.
ÊÊ# $
AllocateStruct
ÊÊ$ 2
(
ÊÊ2 3
default
ÊÊ3 :
(
ÊÊ: ;
T
ÊÊ; <
)
ÊÊ< =
,
ÊÊ= >
length
ÊÊ? E
)
ÊÊE F
;
ÊÊF G
array
ÁÁ 
.
ÁÁ 
m_Length
ÁÁ 
=
ÁÁ 
length
ÁÁ #
;
ÁÁ# $
array
ËË 
.
ËË 
m_AllocatorLabel
ËË "
=
ËË# $
	Allocator
ËË% .
.
ËË. /
None
ËË/ 3
;
ËË3 4
if
ÈÈ 
(
ÈÈ 
options
ÈÈ 
==
ÈÈ  
NativeArrayOptions
ÈÈ -
.
ÈÈ- .
ClearMemory
ÈÈ. 9
)
ÈÈ9 :
{
ÍÍ 
UnsafeUtility
ÎÎ 
.
ÎÎ 
MemClear
ÎÎ &
(
ÎÎ& '
array
ÎÎ' ,
.
ÎÎ, -
m_Buffer
ÎÎ- 5
,
ÎÎ5 6
array
ÎÎ7 <
.
ÎÎ< =
m_Length
ÎÎ= E
*
ÎÎF G
UnsafeUtility
ÎÎH U
.
ÎÎU V
SizeOf
ÎÎV \
<
ÎÎ\ ]
T
ÎÎ] ^
>
ÎÎ^ _
(
ÎÎ_ `
)
ÎÎ` a
)
ÎÎa b
;
ÎÎb c
}
ÏÏ 
array
ÔÔ 
.
ÔÔ 

m_MinIndex
ÔÔ 
=
ÔÔ 
$num
ÔÔ  
;
ÔÔ  !
array
 
.
 

m_MaxIndex
 
=
 
length
 %
-
& '
$num
( )
;
) *
DisposeSentinel
ÒÒ 
.
ÒÒ 
Create
ÒÒ "
(
ÒÒ" #
out
ÒÒ# &
array
ÒÒ' ,
.
ÒÒ, -
m_Safety
ÒÒ- 5
,
ÒÒ5 6
out
ÒÒ7 :
array
ÒÒ; @
.
ÒÒ@ A
m_DisposeSentinel
ÒÒA R
,
ÒÒR S
$num
ÒÒT U
,
ÒÒU V
handle
ÒÒW ]
.
ÒÒ] ^
ToAllocator
ÒÒ^ i
)
ÒÒi j
;
ÒÒj k
DisposeSentinel
ÚÚ 
.
ÚÚ 
Clear
ÚÚ !
(
ÚÚ! "
ref
ÚÚ" %
array
ÚÚ& +
.
ÚÚ+ ,
m_DisposeSentinel
ÚÚ, =
)
ÚÚ= >
;
ÚÚ> ?
CollectionHelper
ÙÙ 
.
ÙÙ 
SetStaticSafetyId
ÙÙ .
<
ÙÙ. /
NativeArray
ÙÙ/ :
<
ÙÙ: ;
T
ÙÙ; <
>
ÙÙ< =
>
ÙÙ= >
(
ÙÙ> ?
ref
ÙÙ? B
array
ÙÙC H
.
ÙÙH I
m_Safety
ÙÙI Q
,
ÙÙQ R
ref
ÙÙS V!
NativeArrayStaticId
ÙÙW j
<
ÙÙj k
T
ÙÙk l
>
ÙÙl m
.
ÙÙm n
s_staticSafetyId
ÙÙn ~
.
ÙÙ~ 
DataÙÙ É
)ÙÙÉ Ñ
;ÙÙÑ Ö
handle
ıı 
.
ıı 
AddSafetyHandle
ıı "
(
ıı" #
array
ıı# (
.
ıı( )
m_Safety
ıı) 1
)
ıı1 2
;
ıı2 3
}
˜˜ 	
[
˘˘ 	
BurstCompatible
˘˘	 
(
˘˘ "
GenericTypeArguments
˘˘ -
=
˘˘. /
new
˘˘0 3
[
˘˘3 4
]
˘˘4 5
{
˘˘6 7
typeof
˘˘8 >
(
˘˘> ?
int
˘˘? B
)
˘˘B C
,
˘˘C D
typeof
˘˘E K
(
˘˘K L
AllocatorManager
˘˘L \
.
˘˘\ ]
AllocatorHandle
˘˘] l
)
˘˘l m
}
˘˘n o
)
˘˘o p
]
˘˘p q
internal
˙˙ 
static
˙˙ 
void
˙˙ 

Initialize
˙˙ '
<
˙˙' (
T
˙˙( )
,
˙˙) *
U
˙˙+ ,
>
˙˙, -
(
˙˙- .
ref
˙˙. 1
this
˙˙2 6
NativeArray
˙˙7 B
<
˙˙B C
T
˙˙C D
>
˙˙D E
array
˙˙F K
,
˙˙K L
int
˚˚0 3
length
˚˚4 :
,
˚˚: ;
ref
¸¸0 3
U
¸¸4 5
	allocator
¸¸6 ?
,
¸¸? @ 
NativeArrayOptions
˝˝0 B
options
˝˝C J
=
˝˝K L 
NativeArrayOptions
˝˝M _
.
˝˝_ `
ClearMemory
˝˝` k
)
˝˝k l
where
˛˛ 
T
˛˛ 
:
˛˛ 
struct
˛˛ 
where
ˇˇ 
U
ˇˇ 
:
ˇˇ 
	unmanaged
ˇˇ 
,
ˇˇ  
AllocatorManager
ˇˇ! 1
.
ˇˇ1 2

IAllocator
ˇˇ2 <
{
ÄÄ 	
array
ÅÅ 
.
ÅÅ 
m_Buffer
ÅÅ 
=
ÅÅ 
	allocator
ÅÅ &
.
ÅÅ& '
AllocateStruct
ÅÅ' 5
(
ÅÅ5 6
default
ÅÅ6 =
(
ÅÅ= >
T
ÅÅ> ?
)
ÅÅ? @
,
ÅÅ@ A
length
ÅÅB H
)
ÅÅH I
;
ÅÅI J
array
ÇÇ 
.
ÇÇ 
m_Length
ÇÇ 
=
ÇÇ 
length
ÇÇ #
;
ÇÇ# $
array
ÉÉ 
.
ÉÉ 
m_AllocatorLabel
ÉÉ "
=
ÉÉ# $
	Allocator
ÉÉ% .
.
ÉÉ. /
None
ÉÉ/ 3
;
ÉÉ3 4
if
ÑÑ 
(
ÑÑ 
options
ÑÑ 
==
ÑÑ  
NativeArrayOptions
ÑÑ -
.
ÑÑ- .
ClearMemory
ÑÑ. 9
)
ÑÑ9 :
{
ÖÖ 
UnsafeUtility
ÜÜ 
.
ÜÜ 
MemClear
ÜÜ &
(
ÜÜ& '
array
ÜÜ' ,
.
ÜÜ, -
m_Buffer
ÜÜ- 5
,
ÜÜ5 6
array
ÜÜ7 <
.
ÜÜ< =
m_Length
ÜÜ= E
*
ÜÜF G
UnsafeUtility
ÜÜH U
.
ÜÜU V
SizeOf
ÜÜV \
<
ÜÜ\ ]
T
ÜÜ] ^
>
ÜÜ^ _
(
ÜÜ_ `
)
ÜÜ` a
)
ÜÜa b
;
ÜÜb c
}
áá 
array
ää 
.
ää 

m_MinIndex
ää 
=
ää 
$num
ää  
;
ää  !
array
ãã 
.
ãã 

m_MaxIndex
ãã 
=
ãã 
length
ãã %
-
ãã& '
$num
ãã( )
;
ãã) *
DisposeSentinel
åå 
.
åå 
Create
åå "
(
åå" #
out
åå# &
array
åå' ,
.
åå, -
m_Safety
åå- 5
,
åå5 6
out
åå7 :
array
åå; @
.
åå@ A
m_DisposeSentinel
ååA R
,
ååR S
$num
ååT U
,
ååU V
	allocator
ååW `
.
åå` a
ToAllocator
ååa l
)
åål m
;
ååm n
DisposeSentinel
çç 
.
çç 
Clear
çç !
(
çç! "
ref
çç" %
array
çç& +
.
çç+ ,
m_DisposeSentinel
çç, =
)
çç= >
;
çç> ?
CollectionHelper
èè 
.
èè 
SetStaticSafetyId
èè .
<
èè. /
NativeArray
èè/ :
<
èè: ;
T
èè; <
>
èè< =
>
èè= >
(
èè> ?
ref
èè? B
array
èèC H
.
èèH I
m_Safety
èèI Q
,
èèQ R
ref
èèS V!
NativeArrayStaticId
èèW j
<
èèj k
T
èèk l
>
èèl m
.
èèm n
s_staticSafetyId
èèn ~
.
èè~ 
Dataèè É
)èèÉ Ñ
;èèÑ Ö
	allocator
êê 
.
êê 
Handle
êê 
.
êê 
AddSafetyHandle
êê ,
(
êê, -
array
êê- 2
.
êê2 3
m_Safety
êê3 ;
)
êê; <
;
êê< =
}
íí 	
}
ìì 
}îî öÊ
rC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeHashSetExtensions.gen.cs
	namespace 	
Unity
 
. 
Collections 
{ 
public		 

unsafe		 
static		 
class		 
HashSetExtensions		 0
{

 
public 
static 
void 

ExceptWith %
<% &
T& '
>' (
(( )
this) -
NativeHashSet. ;
<; <
T< =
>= >
	container? H
,H I
FixedList128BytesJ [
<[ \
T\ ]
>] ^
other_ d
)d e
where 
T 
: 
	unmanaged 
,  

IEquatable! +
<+ ,
T, -
>- .
{ 	
foreach 
( 
var 
item 
in  
other! &
)& '
{ 
	container 
. 
Remove  
(  !
item! %
)% &
;& '
} 
} 	
public   
static   
void   
IntersectWith   (
<  ( )
T  ) *
>  * +
(  + ,
this  , 0
NativeHashSet  1 >
<  > ?
T  ? @
>  @ A
	container  B K
,  K L
FixedList128Bytes  M ^
<  ^ _
T  _ `
>  ` a
other  b g
)  g h
where!! 
T!! 
:!! 
	unmanaged!! 
,!!  

IEquatable!!! +
<!!+ ,
T!!, -
>!!- .
{"" 	
var## 
result## 
=## 
new## 

UnsafeList## '
<##' (
T##( )
>##) *
(##* +
	container##+ 4
.##4 5
Count##5 :
(##: ;
)##; <
,##< =
	Allocator##> G
.##G H
Temp##H L
)##L M
;##M N
foreach%% 
(%% 
var%% 
item%% 
in%%  
other%%! &
)%%& '
{&& 
if'' 
('' 
	container'' 
.'' 
Contains'' &
(''& '
item''' +
)''+ ,
)'', -
{(( 
result)) 
.)) 
Add)) 
()) 
item)) #
)))# $
;))$ %
}** 
}++ 
	container-- 
.-- 
Clear-- 
(-- 
)-- 
;-- 
	container.. 
... 
	UnionWith.. 
(..  
result..  &
)..& '
;..' (
result00 
.00 
Dispose00 
(00 
)00 
;00 
}11 	
public99 
static99 
void99 
	UnionWith99 $
<99$ %
T99% &
>99& '
(99' (
this99( ,
NativeHashSet99- :
<99: ;
T99; <
>99< =
	container99> G
,99G H
FixedList128Bytes99I Z
<99Z [
T99[ \
>99\ ]
other99^ c
)99c d
where:: 
T:: 
::: 
	unmanaged:: 
,::  

IEquatable::! +
<::+ ,
T::, -
>::- .
{;; 	
foreach<< 
(<< 
var<< 
item<< 
in<<  
other<<! &
)<<& '
{== 
	container>> 
.>> 
Add>> 
(>> 
item>> "
)>>" #
;>># $
}?? 
}@@ 	
publicGG 
staticGG 
voidGG 

ExceptWithGG %
<GG% &
TGG& '
>GG' (
(GG( )
thisGG) -
NativeHashSetGG. ;
<GG; <
TGG< =
>GG= >
	containerGG? H
,GGH I
FixedList32BytesGGJ Z
<GGZ [
TGG[ \
>GG\ ]
otherGG^ c
)GGc d
whereHH 
THH 
:HH 
	unmanagedHH 
,HH  

IEquatableHH! +
<HH+ ,
THH, -
>HH- .
{II 	
foreachJJ 
(JJ 
varJJ 
itemJJ 
inJJ  
otherJJ! &
)JJ& '
{KK 
	containerLL 
.LL 
RemoveLL  
(LL  !
itemLL! %
)LL% &
;LL& '
}MM 
}NN 	
publicVV 
staticVV 
voidVV 
IntersectWithVV (
<VV( )
TVV) *
>VV* +
(VV+ ,
thisVV, 0
NativeHashSetVV1 >
<VV> ?
TVV? @
>VV@ A
	containerVVB K
,VVK L
FixedList32BytesVVM ]
<VV] ^
TVV^ _
>VV_ `
otherVVa f
)VVf g
whereWW 
TWW 
:WW 
	unmanagedWW 
,WW  

IEquatableWW! +
<WW+ ,
TWW, -
>WW- .
{XX 	
varYY 
resultYY 
=YY 
newYY 

UnsafeListYY '
<YY' (
TYY( )
>YY) *
(YY* +
	containerYY+ 4
.YY4 5
CountYY5 :
(YY: ;
)YY; <
,YY< =
	AllocatorYY> G
.YYG H
TempYYH L
)YYL M
;YYM N
foreach[[ 
([[ 
var[[ 
item[[ 
in[[  
other[[! &
)[[& '
{\\ 
if]] 
(]] 
	container]] 
.]] 
Contains]] &
(]]& '
item]]' +
)]]+ ,
)]], -
{^^ 
result__ 
.__ 
Add__ 
(__ 
item__ #
)__# $
;__$ %
}`` 
}aa 
	containercc 
.cc 
Clearcc 
(cc 
)cc 
;cc 
	containerdd 
.dd 
	UnionWithdd 
(dd  
resultdd  &
)dd& '
;dd' (
resultff 
.ff 
Disposeff 
(ff 
)ff 
;ff 
}gg 	
publicoo 
staticoo 
voidoo 
	UnionWithoo $
<oo$ %
Too% &
>oo& '
(oo' (
thisoo( ,
NativeHashSetoo- :
<oo: ;
Too; <
>oo< =
	containeroo> G
,ooG H
FixedList32BytesooI Y
<ooY Z
TooZ [
>oo[ \
otheroo] b
)oob c
wherepp 
Tpp 
:pp 
	unmanagedpp 
,pp  

IEquatablepp! +
<pp+ ,
Tpp, -
>pp- .
{qq 	
foreachrr 
(rr 
varrr 
itemrr 
inrr  
otherrr! &
)rr& '
{ss 
	containertt 
.tt 
Addtt 
(tt 
itemtt "
)tt" #
;tt# $
}uu 
}vv 	
public}} 
static}} 
void}} 

ExceptWith}} %
<}}% &
T}}& '
>}}' (
(}}( )
this}}) -
NativeHashSet}}. ;
<}}; <
T}}< =
>}}= >
	container}}? H
,}}H I
FixedList4096Bytes}}J \
<}}\ ]
T}}] ^
>}}^ _
other}}` e
)}}e f
where~~ 
T~~ 
:~~ 
	unmanaged~~ 
,~~  

IEquatable~~! +
<~~+ ,
T~~, -
>~~- .
{ 	
foreach
ÄÄ 
(
ÄÄ 
var
ÄÄ 
item
ÄÄ 
in
ÄÄ  
other
ÄÄ! &
)
ÄÄ& '
{
ÅÅ 
	container
ÇÇ 
.
ÇÇ 
Remove
ÇÇ  
(
ÇÇ  !
item
ÇÇ! %
)
ÇÇ% &
;
ÇÇ& '
}
ÉÉ 
}
ÑÑ 	
public
åå 
static
åå 
void
åå 
IntersectWith
åå (
<
åå( )
T
åå) *
>
åå* +
(
åå+ ,
this
åå, 0
NativeHashSet
åå1 >
<
åå> ?
T
åå? @
>
åå@ A
	container
ååB K
,
ååK L 
FixedList4096Bytes
ååM _
<
åå_ `
T
åå` a
>
ååa b
other
ååc h
)
ååh i
where
çç 
T
çç 
:
çç 
	unmanaged
çç 
,
çç  

IEquatable
çç! +
<
çç+ ,
T
çç, -
>
çç- .
{
éé 	
var
èè 
result
èè 
=
èè 
new
èè 

UnsafeList
èè '
<
èè' (
T
èè( )
>
èè) *
(
èè* +
	container
èè+ 4
.
èè4 5
Count
èè5 :
(
èè: ;
)
èè; <
,
èè< =
	Allocator
èè> G
.
èèG H
Temp
èèH L
)
èèL M
;
èèM N
foreach
ëë 
(
ëë 
var
ëë 
item
ëë 
in
ëë  
other
ëë! &
)
ëë& '
{
íí 
if
ìì 
(
ìì 
	container
ìì 
.
ìì 
Contains
ìì &
(
ìì& '
item
ìì' +
)
ìì+ ,
)
ìì, -
{
îî 
result
ïï 
.
ïï 
Add
ïï 
(
ïï 
item
ïï #
)
ïï# $
;
ïï$ %
}
ññ 
}
óó 
	container
ôô 
.
ôô 
Clear
ôô 
(
ôô 
)
ôô 
;
ôô 
	container
öö 
.
öö 
	UnionWith
öö 
(
öö  
result
öö  &
)
öö& '
;
öö' (
result
úú 
.
úú 
Dispose
úú 
(
úú 
)
úú 
;
úú 
}
ùù 	
public
•• 
static
•• 
void
•• 
	UnionWith
•• $
<
••$ %
T
••% &
>
••& '
(
••' (
this
••( ,
NativeHashSet
••- :
<
••: ;
T
••; <
>
••< =
	container
••> G
,
••G H 
FixedList4096Bytes
••I [
<
••[ \
T
••\ ]
>
••] ^
other
••_ d
)
••d e
where
¶¶ 
T
¶¶ 
:
¶¶ 
	unmanaged
¶¶ 
,
¶¶  

IEquatable
¶¶! +
<
¶¶+ ,
T
¶¶, -
>
¶¶- .
{
ßß 	
foreach
®® 
(
®® 
var
®® 
item
®® 
in
®®  
other
®®! &
)
®®& '
{
©© 
	container
™™ 
.
™™ 
Add
™™ 
(
™™ 
item
™™ "
)
™™" #
;
™™# $
}
´´ 
}
¨¨ 	
public
≥≥ 
static
≥≥ 
void
≥≥ 

ExceptWith
≥≥ %
<
≥≥% &
T
≥≥& '
>
≥≥' (
(
≥≥( )
this
≥≥) -
NativeHashSet
≥≥. ;
<
≥≥; <
T
≥≥< =
>
≥≥= >
	container
≥≥? H
,
≥≥H I
FixedList512Bytes
≥≥J [
<
≥≥[ \
T
≥≥\ ]
>
≥≥] ^
other
≥≥_ d
)
≥≥d e
where
¥¥ 
T
¥¥ 
:
¥¥ 
	unmanaged
¥¥ 
,
¥¥  

IEquatable
¥¥! +
<
¥¥+ ,
T
¥¥, -
>
¥¥- .
{
µµ 	
foreach
∂∂ 
(
∂∂ 
var
∂∂ 
item
∂∂ 
in
∂∂  
other
∂∂! &
)
∂∂& '
{
∑∑ 
	container
∏∏ 
.
∏∏ 
Remove
∏∏  
(
∏∏  !
item
∏∏! %
)
∏∏% &
;
∏∏& '
}
ππ 
}
∫∫ 	
public
¬¬ 
static
¬¬ 
void
¬¬ 
IntersectWith
¬¬ (
<
¬¬( )
T
¬¬) *
>
¬¬* +
(
¬¬+ ,
this
¬¬, 0
NativeHashSet
¬¬1 >
<
¬¬> ?
T
¬¬? @
>
¬¬@ A
	container
¬¬B K
,
¬¬K L
FixedList512Bytes
¬¬M ^
<
¬¬^ _
T
¬¬_ `
>
¬¬` a
other
¬¬b g
)
¬¬g h
where
√√ 
T
√√ 
:
√√ 
	unmanaged
√√ 
,
√√  

IEquatable
√√! +
<
√√+ ,
T
√√, -
>
√√- .
{
ƒƒ 	
var
≈≈ 
result
≈≈ 
=
≈≈ 
new
≈≈ 

UnsafeList
≈≈ '
<
≈≈' (
T
≈≈( )
>
≈≈) *
(
≈≈* +
	container
≈≈+ 4
.
≈≈4 5
Count
≈≈5 :
(
≈≈: ;
)
≈≈; <
,
≈≈< =
	Allocator
≈≈> G
.
≈≈G H
Temp
≈≈H L
)
≈≈L M
;
≈≈M N
foreach
«« 
(
«« 
var
«« 
item
«« 
in
««  
other
««! &
)
««& '
{
»» 
if
…… 
(
…… 
	container
…… 
.
…… 
Contains
…… &
(
……& '
item
……' +
)
……+ ,
)
……, -
{
   
result
ÀÀ 
.
ÀÀ 
Add
ÀÀ 
(
ÀÀ 
item
ÀÀ #
)
ÀÀ# $
;
ÀÀ$ %
}
ÃÃ 
}
ÕÕ 
	container
œœ 
.
œœ 
Clear
œœ 
(
œœ 
)
œœ 
;
œœ 
	container
–– 
.
–– 
	UnionWith
–– 
(
––  
result
––  &
)
––& '
;
––' (
result
““ 
.
““ 
Dispose
““ 
(
““ 
)
““ 
;
““ 
}
”” 	
public
€€ 
static
€€ 
void
€€ 
	UnionWith
€€ $
<
€€$ %
T
€€% &
>
€€& '
(
€€' (
this
€€( ,
NativeHashSet
€€- :
<
€€: ;
T
€€; <
>
€€< =
	container
€€> G
,
€€G H
FixedList512Bytes
€€I Z
<
€€Z [
T
€€[ \
>
€€\ ]
other
€€^ c
)
€€c d
where
‹‹ 
T
‹‹ 
:
‹‹ 
	unmanaged
‹‹ 
,
‹‹  

IEquatable
‹‹! +
<
‹‹+ ,
T
‹‹, -
>
‹‹- .
{
›› 	
foreach
ﬁﬁ 
(
ﬁﬁ 
var
ﬁﬁ 
item
ﬁﬁ 
in
ﬁﬁ  
other
ﬁﬁ! &
)
ﬁﬁ& '
{
ﬂﬂ 
	container
‡‡ 
.
‡‡ 
Add
‡‡ 
(
‡‡ 
item
‡‡ "
)
‡‡" #
;
‡‡# $
}
·· 
}
‚‚ 	
public
ÈÈ 
static
ÈÈ 
void
ÈÈ 

ExceptWith
ÈÈ %
<
ÈÈ% &
T
ÈÈ& '
>
ÈÈ' (
(
ÈÈ( )
this
ÈÈ) -
NativeHashSet
ÈÈ. ;
<
ÈÈ; <
T
ÈÈ< =
>
ÈÈ= >
	container
ÈÈ? H
,
ÈÈH I
FixedList64Bytes
ÈÈJ Z
<
ÈÈZ [
T
ÈÈ[ \
>
ÈÈ\ ]
other
ÈÈ^ c
)
ÈÈc d
where
ÍÍ 
T
ÍÍ 
:
ÍÍ 
	unmanaged
ÍÍ 
,
ÍÍ  

IEquatable
ÍÍ! +
<
ÍÍ+ ,
T
ÍÍ, -
>
ÍÍ- .
{
ÎÎ 	
foreach
ÏÏ 
(
ÏÏ 
var
ÏÏ 
item
ÏÏ 
in
ÏÏ  
other
ÏÏ! &
)
ÏÏ& '
{
ÌÌ 
	container
ÓÓ 
.
ÓÓ 
Remove
ÓÓ  
(
ÓÓ  !
item
ÓÓ! %
)
ÓÓ% &
;
ÓÓ& '
}
ÔÔ 
}
 	
public
¯¯ 
static
¯¯ 
void
¯¯ 
IntersectWith
¯¯ (
<
¯¯( )
T
¯¯) *
>
¯¯* +
(
¯¯+ ,
this
¯¯, 0
NativeHashSet
¯¯1 >
<
¯¯> ?
T
¯¯? @
>
¯¯@ A
	container
¯¯B K
,
¯¯K L
FixedList64Bytes
¯¯M ]
<
¯¯] ^
T
¯¯^ _
>
¯¯_ `
other
¯¯a f
)
¯¯f g
where
˘˘ 
T
˘˘ 
:
˘˘ 
	unmanaged
˘˘ 
,
˘˘  

IEquatable
˘˘! +
<
˘˘+ ,
T
˘˘, -
>
˘˘- .
{
˙˙ 	
var
˚˚ 
result
˚˚ 
=
˚˚ 
new
˚˚ 

UnsafeList
˚˚ '
<
˚˚' (
T
˚˚( )
>
˚˚) *
(
˚˚* +
	container
˚˚+ 4
.
˚˚4 5
Count
˚˚5 :
(
˚˚: ;
)
˚˚; <
,
˚˚< =
	Allocator
˚˚> G
.
˚˚G H
Temp
˚˚H L
)
˚˚L M
;
˚˚M N
foreach
˝˝ 
(
˝˝ 
var
˝˝ 
item
˝˝ 
in
˝˝  
other
˝˝! &
)
˝˝& '
{
˛˛ 
if
ˇˇ 
(
ˇˇ 
	container
ˇˇ 
.
ˇˇ 
Contains
ˇˇ &
(
ˇˇ& '
item
ˇˇ' +
)
ˇˇ+ ,
)
ˇˇ, -
{
ÄÄ 
result
ÅÅ 
.
ÅÅ 
Add
ÅÅ 
(
ÅÅ 
item
ÅÅ #
)
ÅÅ# $
;
ÅÅ$ %
}
ÇÇ 
}
ÉÉ 
	container
ÖÖ 
.
ÖÖ 
Clear
ÖÖ 
(
ÖÖ 
)
ÖÖ 
;
ÖÖ 
	container
ÜÜ 
.
ÜÜ 
	UnionWith
ÜÜ 
(
ÜÜ  
result
ÜÜ  &
)
ÜÜ& '
;
ÜÜ' (
result
àà 
.
àà 
Dispose
àà 
(
àà 
)
àà 
;
àà 
}
ââ 	
public
ëë 
static
ëë 
void
ëë 
	UnionWith
ëë $
<
ëë$ %
T
ëë% &
>
ëë& '
(
ëë' (
this
ëë( ,
NativeHashSet
ëë- :
<
ëë: ;
T
ëë; <
>
ëë< =
	container
ëë> G
,
ëëG H
FixedList64Bytes
ëëI Y
<
ëëY Z
T
ëëZ [
>
ëë[ \
other
ëë] b
)
ëëb c
where
íí 
T
íí 
:
íí 
	unmanaged
íí 
,
íí  

IEquatable
íí! +
<
íí+ ,
T
íí, -
>
íí- .
{
ìì 	
foreach
îî 
(
îî 
var
îî 
item
îî 
in
îî  
other
îî! &
)
îî& '
{
ïï 
	container
ññ 
.
ññ 
Add
ññ 
(
ññ 
item
ññ "
)
ññ" #
;
ññ# $
}
óó 
}
òò 	
public
üü 
static
üü 
void
üü 

ExceptWith
üü %
<
üü% &
T
üü& '
>
üü' (
(
üü( )
this
üü) -
NativeHashSet
üü. ;
<
üü; <
T
üü< =
>
üü= >
	container
üü? H
,
üüH I
NativeArray
üüJ U
<
üüU V
T
üüV W
>
üüW X
other
üüY ^
)
üü^ _
where
†† 
T
†† 
:
†† 
	unmanaged
†† 
,
††  

IEquatable
††! +
<
††+ ,
T
††, -
>
††- .
{
°° 	
foreach
¢¢ 
(
¢¢ 
var
¢¢ 
item
¢¢ 
in
¢¢  
other
¢¢! &
)
¢¢& '
{
££ 
	container
§§ 
.
§§ 
Remove
§§  
(
§§  !
item
§§! %
)
§§% &
;
§§& '
}
•• 
}
¶¶ 	
public
ÆÆ 
static
ÆÆ 
void
ÆÆ 
IntersectWith
ÆÆ (
<
ÆÆ( )
T
ÆÆ) *
>
ÆÆ* +
(
ÆÆ+ ,
this
ÆÆ, 0
NativeHashSet
ÆÆ1 >
<
ÆÆ> ?
T
ÆÆ? @
>
ÆÆ@ A
	container
ÆÆB K
,
ÆÆK L
NativeArray
ÆÆM X
<
ÆÆX Y
T
ÆÆY Z
>
ÆÆZ [
other
ÆÆ\ a
)
ÆÆa b
where
ØØ 
T
ØØ 
:
ØØ 
	unmanaged
ØØ 
,
ØØ  

IEquatable
ØØ! +
<
ØØ+ ,
T
ØØ, -
>
ØØ- .
{
∞∞ 	
var
±± 
result
±± 
=
±± 
new
±± 

UnsafeList
±± '
<
±±' (
T
±±( )
>
±±) *
(
±±* +
	container
±±+ 4
.
±±4 5
Count
±±5 :
(
±±: ;
)
±±; <
,
±±< =
	Allocator
±±> G
.
±±G H
Temp
±±H L
)
±±L M
;
±±M N
foreach
≥≥ 
(
≥≥ 
var
≥≥ 
item
≥≥ 
in
≥≥  
other
≥≥! &
)
≥≥& '
{
¥¥ 
if
µµ 
(
µµ 
	container
µµ 
.
µµ 
Contains
µµ &
(
µµ& '
item
µµ' +
)
µµ+ ,
)
µµ, -
{
∂∂ 
result
∑∑ 
.
∑∑ 
Add
∑∑ 
(
∑∑ 
item
∑∑ #
)
∑∑# $
;
∑∑$ %
}
∏∏ 
}
ππ 
	container
ªª 
.
ªª 
Clear
ªª 
(
ªª 
)
ªª 
;
ªª 
	container
ºº 
.
ºº 
	UnionWith
ºº 
(
ºº  
result
ºº  &
)
ºº& '
;
ºº' (
result
ææ 
.
ææ 
Dispose
ææ 
(
ææ 
)
ææ 
;
ææ 
}
øø 	
public
«« 
static
«« 
void
«« 
	UnionWith
«« $
<
««$ %
T
««% &
>
««& '
(
««' (
this
««( ,
NativeHashSet
««- :
<
««: ;
T
««; <
>
««< =
	container
««> G
,
««G H
NativeArray
««I T
<
««T U
T
««U V
>
««V W
other
««X ]
)
««] ^
where
»» 
T
»» 
:
»» 
	unmanaged
»» 
,
»»  

IEquatable
»»! +
<
»»+ ,
T
»», -
>
»»- .
{
…… 	
foreach
   
(
   
var
   
item
   
in
    
other
  ! &
)
  & '
{
ÀÀ 
	container
ÃÃ 
.
ÃÃ 
Add
ÃÃ 
(
ÃÃ 
item
ÃÃ "
)
ÃÃ" #
;
ÃÃ# $
}
ÕÕ 
}
ŒŒ 	
public
’’ 
static
’’ 
void
’’ 

ExceptWith
’’ %
<
’’% &
T
’’& '
>
’’' (
(
’’( )
this
’’) -
NativeHashSet
’’. ;
<
’’; <
T
’’< =
>
’’= >
	container
’’? H
,
’’H I
NativeHashSet
’’J W
<
’’W X
T
’’X Y
>
’’Y Z
other
’’[ `
)
’’` a
where
÷÷ 
T
÷÷ 
:
÷÷ 
	unmanaged
÷÷ 
,
÷÷  

IEquatable
÷÷! +
<
÷÷+ ,
T
÷÷, -
>
÷÷- .
{
◊◊ 	
foreach
ÿÿ 
(
ÿÿ 
var
ÿÿ 
item
ÿÿ 
in
ÿÿ  
other
ÿÿ! &
)
ÿÿ& '
{
ŸŸ 
	container
⁄⁄ 
.
⁄⁄ 
Remove
⁄⁄  
(
⁄⁄  !
item
⁄⁄! %
)
⁄⁄% &
;
⁄⁄& '
}
€€ 
}
‹‹ 	
public
‰‰ 
static
‰‰ 
void
‰‰ 
IntersectWith
‰‰ (
<
‰‰( )
T
‰‰) *
>
‰‰* +
(
‰‰+ ,
this
‰‰, 0
NativeHashSet
‰‰1 >
<
‰‰> ?
T
‰‰? @
>
‰‰@ A
	container
‰‰B K
,
‰‰K L
NativeHashSet
‰‰M Z
<
‰‰Z [
T
‰‰[ \
>
‰‰\ ]
other
‰‰^ c
)
‰‰c d
where
ÂÂ 
T
ÂÂ 
:
ÂÂ 
	unmanaged
ÂÂ 
,
ÂÂ  

IEquatable
ÂÂ! +
<
ÂÂ+ ,
T
ÂÂ, -
>
ÂÂ- .
{
ÊÊ 	
var
ÁÁ 
result
ÁÁ 
=
ÁÁ 
new
ÁÁ 

UnsafeList
ÁÁ '
<
ÁÁ' (
T
ÁÁ( )
>
ÁÁ) *
(
ÁÁ* +
	container
ÁÁ+ 4
.
ÁÁ4 5
Count
ÁÁ5 :
(
ÁÁ: ;
)
ÁÁ; <
,
ÁÁ< =
	Allocator
ÁÁ> G
.
ÁÁG H
Temp
ÁÁH L
)
ÁÁL M
;
ÁÁM N
foreach
ÈÈ 
(
ÈÈ 
var
ÈÈ 
item
ÈÈ 
in
ÈÈ  
other
ÈÈ! &
)
ÈÈ& '
{
ÍÍ 
if
ÎÎ 
(
ÎÎ 
	container
ÎÎ 
.
ÎÎ 
Contains
ÎÎ &
(
ÎÎ& '
item
ÎÎ' +
)
ÎÎ+ ,
)
ÎÎ, -
{
ÏÏ 
result
ÌÌ 
.
ÌÌ 
Add
ÌÌ 
(
ÌÌ 
item
ÌÌ #
)
ÌÌ# $
;
ÌÌ$ %
}
ÓÓ 
}
ÔÔ 
	container
ÒÒ 
.
ÒÒ 
Clear
ÒÒ 
(
ÒÒ 
)
ÒÒ 
;
ÒÒ 
	container
ÚÚ 
.
ÚÚ 
	UnionWith
ÚÚ 
(
ÚÚ  
result
ÚÚ  &
)
ÚÚ& '
;
ÚÚ' (
result
ÙÙ 
.
ÙÙ 
Dispose
ÙÙ 
(
ÙÙ 
)
ÙÙ 
;
ÙÙ 
}
ıı 	
public
˝˝ 
static
˝˝ 
void
˝˝ 
	UnionWith
˝˝ $
<
˝˝$ %
T
˝˝% &
>
˝˝& '
(
˝˝' (
this
˝˝( ,
NativeHashSet
˝˝- :
<
˝˝: ;
T
˝˝; <
>
˝˝< =
	container
˝˝> G
,
˝˝G H
NativeHashSet
˝˝I V
<
˝˝V W
T
˝˝W X
>
˝˝X Y
other
˝˝Z _
)
˝˝_ `
where
˛˛ 
T
˛˛ 
:
˛˛ 
	unmanaged
˛˛ 
,
˛˛  

IEquatable
˛˛! +
<
˛˛+ ,
T
˛˛, -
>
˛˛- .
{
ˇˇ 	
foreach
ÄÄ 
(
ÄÄ 
var
ÄÄ 
item
ÄÄ 
in
ÄÄ  
other
ÄÄ! &
)
ÄÄ& '
{
ÅÅ 
	container
ÇÇ 
.
ÇÇ 
Add
ÇÇ 
(
ÇÇ 
item
ÇÇ "
)
ÇÇ" #
;
ÇÇ# $
}
ÉÉ 
}
ÑÑ 	
public
ãã 
static
ãã 
void
ãã 

ExceptWith
ãã %
<
ãã% &
T
ãã& '
>
ãã' (
(
ãã( )
this
ãã) -
NativeHashSet
ãã. ;
<
ãã; <
T
ãã< =
>
ãã= >
	container
ãã? H
,
ããH I

NativeList
ããJ T
<
ããT U
T
ããU V
>
ããV W
other
ããX ]
)
ãã] ^
where
åå 
T
åå 
:
åå 
	unmanaged
åå 
,
åå  

IEquatable
åå! +
<
åå+ ,
T
åå, -
>
åå- .
{
çç 	
foreach
éé 
(
éé 
var
éé 
item
éé 
in
éé  
other
éé! &
)
éé& '
{
èè 
	container
êê 
.
êê 
Remove
êê  
(
êê  !
item
êê! %
)
êê% &
;
êê& '
}
ëë 
}
íí 	
public
öö 
static
öö 
void
öö 
IntersectWith
öö (
<
öö( )
T
öö) *
>
öö* +
(
öö+ ,
this
öö, 0
NativeHashSet
öö1 >
<
öö> ?
T
öö? @
>
öö@ A
	container
ööB K
,
ööK L

NativeList
ööM W
<
ööW X
T
ööX Y
>
ööY Z
other
öö[ `
)
öö` a
where
õõ 
T
õõ 
:
õõ 
	unmanaged
õõ 
,
õõ  

IEquatable
õõ! +
<
õõ+ ,
T
õõ, -
>
õõ- .
{
úú 	
var
ùù 
result
ùù 
=
ùù 
new
ùù 

UnsafeList
ùù '
<
ùù' (
T
ùù( )
>
ùù) *
(
ùù* +
	container
ùù+ 4
.
ùù4 5
Count
ùù5 :
(
ùù: ;
)
ùù; <
,
ùù< =
	Allocator
ùù> G
.
ùùG H
Temp
ùùH L
)
ùùL M
;
ùùM N
foreach
üü 
(
üü 
var
üü 
item
üü 
in
üü  
other
üü! &
)
üü& '
{
†† 
if
°° 
(
°° 
	container
°° 
.
°° 
Contains
°° &
(
°°& '
item
°°' +
)
°°+ ,
)
°°, -
{
¢¢ 
result
££ 
.
££ 
Add
££ 
(
££ 
item
££ #
)
££# $
;
££$ %
}
§§ 
}
•• 
	container
ßß 
.
ßß 
Clear
ßß 
(
ßß 
)
ßß 
;
ßß 
	container
®® 
.
®® 
	UnionWith
®® 
(
®®  
result
®®  &
)
®®& '
;
®®' (
result
™™ 
.
™™ 
Dispose
™™ 
(
™™ 
)
™™ 
;
™™ 
}
´´ 	
public
≥≥ 
static
≥≥ 
void
≥≥ 
	UnionWith
≥≥ $
<
≥≥$ %
T
≥≥% &
>
≥≥& '
(
≥≥' (
this
≥≥( ,
NativeHashSet
≥≥- :
<
≥≥: ;
T
≥≥; <
>
≥≥< =
	container
≥≥> G
,
≥≥G H

NativeList
≥≥I S
<
≥≥S T
T
≥≥T U
>
≥≥U V
other
≥≥W \
)
≥≥\ ]
where
¥¥ 
T
¥¥ 
:
¥¥ 
	unmanaged
¥¥ 
,
¥¥  

IEquatable
¥¥! +
<
¥¥+ ,
T
¥¥, -
>
¥¥- .
{
µµ 	
foreach
∂∂ 
(
∂∂ 
var
∂∂ 
item
∂∂ 
in
∂∂  
other
∂∂! &
)
∂∂& '
{
∑∑ 
	container
∏∏ 
.
∏∏ 
Add
∏∏ 
(
∏∏ 
item
∏∏ "
)
∏∏" #
;
∏∏# $
}
ππ 
}
∫∫ 	
}
ªª 
}ºº ù∏
aC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeList.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{ 
[ 
BurstCompile 
] 
internal 
unsafe 
struct 
UnsafeDisposeJob +
:, -
IJob. 2
{ 
[ 	-
!NativeDisableUnsafePtrRestriction	 *
]* +
public 
void 
* 
Ptr 
; 
public 
AllocatorManager 
.  
AllocatorHandle  /
	Allocator0 9
;9 :
public 
void 
Execute 
( 
) 
{ 	
AllocatorManager 
. 
Free !
(! "
	Allocator" +
,+ ,
Ptr- 0
)0 1
;1 2
} 	
} 
internal 
unsafe 
struct 
UntypedUnsafeList ,
{ 
[ 	-
!NativeDisableUnsafePtrRestriction	 *
]* +
public 
void 
* 
Ptr 
; 
public   
int   
m_length   
;   
public!! 
int!! 

m_capacity!! 
;!! 
public"" 
AllocatorManager"" 
.""  
AllocatorHandle""  /
	Allocator""0 9
;""9 :
internal## 
int## 
obsolete_length## $
;##$ %
internal$$ 
int$$ 
obsolete_capacity$$ &
;$$& '
}&& 
[,, 
DebuggerDisplay,, 
(,, 
$str,, m
),,m n
],,n o
[-- 
DebuggerTypeProxy-- 
(-- 
typeof-- 
(--  
UnsafeListTDebugView-- 2
<--2 3
>--3 4
)--4 5
)--5 6
]--6 7
[.. 
StructLayout.. 
(.. 

LayoutKind.. 
... 

Sequential.. '
)..' (
]..( )
[// 
BurstCompatible// 
(//  
GenericTypeArguments// )
=//* +
new//, /
[/// 0
]//0 1
{//2 3
typeof//4 :
(//: ;
int//; >
)//> ?
}//@ A
)//A B
]//B C
public00 

unsafe00 
struct00 

UnsafeList00 #
<00# $
T00$ %
>00% &
:11 	
INativeDisposable11
 
,22 	
INativeList22
 
<22 
T22 
>22 
,33 	
IEnumerable33
 
<33 
T33 
>33 
where44 
T44 
:44 
	unmanaged44 
{55 
[== 	-
!NativeDisableUnsafePtrRestriction==	 *
]==* +
public>> 
T>> 
*>> 
Ptr>> 
;>> 
publicCC 
intCC 
m_lengthCC 
;CC 
publicHH 
intHH 

m_capacityHH 
;HH 
publicMM 
AllocatorManagerMM 
.MM  
AllocatorHandleMM  /
	AllocatorMM0 9
;MM9 :
[OO 	
ObsoleteOO	 
(OO 
$strOO C
,OOC D
trueOOE I
)OOI J
]OOJ K
publicPP 
intPP 
lengthPP 
;PP 
[RR 	
ObsoleteRR	 
(RR 
$strRR G
,RRG H
trueRRI M
)RRM N
]RRN O
publicSS 
intSS 
capacitySS 
;SS 
publicYY 
intYY 
LengthYY 
{ZZ 	
get[[ 
{\\ 
return]] 
CollectionHelper]] '
.]]' (
AssumePositive]]( 6
(]]6 7
m_length]]7 ?
)]]? @
;]]@ A
}^^ 
set`` 
{aa 
ifbb 
(bb 
valuebb 
>bb 
Capacitybb $
)bb$ %
{cc 
Resizedd 
(dd 
valuedd  
)dd  !
;dd! "
}ee 
elseff 
{gg 
m_lengthhh 
=hh 
valuehh $
;hh$ %
}ii 
}jj 
}kk 	
publicqq 
intqq 
Capacityqq 
{rr 	
getss 
{tt 
returnuu 
CollectionHelperuu '
.uu' (
AssumePositiveuu( 6
(uu6 7

m_capacityuu7 A
)uuA B
;uuB C
}vv 
setxx 
{yy 
SetCapacityzz 
(zz 
valuezz !
)zz! "
;zz" #
}{{ 
}|| 	
public
ÉÉ 
T
ÉÉ 
this
ÉÉ 
[
ÉÉ 
int
ÉÉ 
index
ÉÉ 
]
ÉÉ  
{
ÑÑ 	
get
ÖÖ 
{
ÜÜ 
CollectionHelper
áá  
.
áá  !
CheckIndexInRange
áá! 2
(
áá2 3
index
áá3 8
,
áá8 9
Length
áá: @
)
áá@ A
;
ááA B
return
àà 
Ptr
àà 
[
àà 
CollectionHelper
àà +
.
àà+ ,
AssumePositive
àà, :
(
àà: ;
index
àà; @
)
àà@ A
]
ààA B
;
ààB C
}
ââ 
set
ãã 
{
åå 
CollectionHelper
çç  
.
çç  !
CheckIndexInRange
çç! 2
(
çç2 3
index
çç3 8
,
çç8 9
Length
çç: @
)
çç@ A
;
ççA B
Ptr
éé 
[
éé 
CollectionHelper
éé $
.
éé$ %
AssumePositive
éé% 3
(
éé3 4
index
éé4 9
)
éé9 :
]
éé: ;
=
éé< =
value
éé> C
;
ééC D
}
èè 
}
êê 	
public
óó 
ref
óó 
T
óó 
	ElementAt
óó 
(
óó 
int
óó "
index
óó# (
)
óó( )
{
òò 	
CollectionHelper
ôô 
.
ôô 
CheckIndexInRange
ôô .
(
ôô. /
index
ôô/ 4
,
ôô4 5
Length
ôô6 <
)
ôô< =
;
ôô= >
return
öö 
ref
öö 
Ptr
öö 
[
öö 
CollectionHelper
öö +
.
öö+ ,
AssumePositive
öö, :
(
öö: ;
index
öö; @
)
öö@ A
]
ööA B
;
ööB C
}
õõ 	
public
¢¢ 

UnsafeList
¢¢ 
(
¢¢ 
T
¢¢ 
*
¢¢ 
ptr
¢¢  
,
¢¢  !
int
¢¢" %
length
¢¢& ,
)
¢¢, -
:
¢¢. /
this
¢¢0 4
(
¢¢4 5
)
¢¢5 6
{
££ 	
Ptr
§§ 
=
§§ 
ptr
§§ 
;
§§ 
this
•• 
.
•• 
m_length
•• 
=
•• 
length
•• "
;
••" #

m_capacity
¶¶ 
=
¶¶ 
$num
¶¶ 
;
¶¶ 
	Allocator
ßß 
=
ßß 
AllocatorManager
ßß (
.
ßß( )
None
ßß) -
;
ßß- .
}
®® 	
public
∞∞ 

UnsafeList
∞∞ 
(
∞∞ 
int
∞∞ 
initialCapacity
∞∞ -
,
∞∞- .
AllocatorManager
∞∞/ ?
.
∞∞? @
AllocatorHandle
∞∞@ O
	allocator
∞∞P Y
,
∞∞Y Z 
NativeArrayOptions
∞∞[ m
options
∞∞n u
=
∞∞v w!
NativeArrayOptions∞∞x ä
.∞∞ä ã#
UninitializedMemory∞∞ã û
)∞∞û ü
:∞∞† °
this∞∞¢ ¶
(∞∞¶ ß
)∞∞ß ®
{
±± 	
Ptr
≤≤ 
=
≤≤ 
null
≤≤ 
;
≤≤ 
m_length
≥≥ 
=
≥≥ 
$num
≥≥ 
;
≥≥ 

m_capacity
¥¥ 
=
¥¥ 
$num
¥¥ 
;
¥¥ 
	Allocator
µµ 
=
µµ 
	allocator
µµ !
;
µµ! "
if
∑∑ 
(
∑∑ 
initialCapacity
∑∑ 
!=
∑∑  "
$num
∑∑# $
)
∑∑$ %
{
∏∏ 
SetCapacity
ππ 
(
ππ 
initialCapacity
ππ +
)
ππ+ ,
;
ππ, -
}
∫∫ 
if
ºº 
(
ºº 
options
ºº 
==
ºº  
NativeArrayOptions
ºº -
.
ºº- .
ClearMemory
ºº. 9
&&
ºº: <
Ptr
ºº= @
!=
ººA C
null
ººD H
)
ººH I
{
ΩΩ 
var
ææ 
sizeOf
ææ 
=
ææ 
sizeof
ææ #
(
ææ# $
T
ææ$ %
)
ææ% &
;
ææ& '
UnsafeUtility
øø 
.
øø 
MemClear
øø &
(
øø& '
Ptr
øø' *
,
øø* +
Capacity
øø, 4
*
øø5 6
sizeOf
øø7 =
)
øø= >
;
øø> ?
}
¿¿ 
}
¡¡ 	
[
√√ 	
BurstCompatible
√√	 
(
√√ "
GenericTypeArguments
√√ -
=
√√. /
new
√√0 3
[
√√4 5
]
√√5 6
{
√√7 8
typeof
√√9 ?
(
√√? @
AllocatorManager
√√@ P
.
√√P Q
AllocatorHandle
√√Q `
)
√√` a
}
√√b c
)
√√c d
]
√√d e
internal
ƒƒ 
void
ƒƒ 

Initialize
ƒƒ  
<
ƒƒ  !
U
ƒƒ! "
>
ƒƒ" #
(
ƒƒ# $
int
ƒƒ$ '
initialCapacity
ƒƒ( 7
,
ƒƒ7 8
ref
ƒƒ9 <
U
ƒƒ= >
	allocator
ƒƒ? H
,
ƒƒH I 
NativeArrayOptions
ƒƒJ \
options
ƒƒ] d
=
ƒƒe f 
NativeArrayOptions
ƒƒg y
.
ƒƒy z"
UninitializedMemoryƒƒz ç
)ƒƒç é
whereƒƒè î
Uƒƒï ñ
:ƒƒó ò
	unmanagedƒƒô ¢
,ƒƒ¢ £ 
AllocatorManagerƒƒ§ ¥
.ƒƒ¥ µ

IAllocatorƒƒµ ø
{
≈≈ 	
Ptr
∆∆ 
=
∆∆ 
null
∆∆ 
;
∆∆ 
m_length
«« 
=
«« 
$num
«« 
;
«« 

m_capacity
»» 
=
»» 
$num
»» 
;
»» 
	Allocator
…… 
=
…… 
AllocatorManager
…… (
.
……( )
None
……) -
;
……- .

Initialize
   
(
   
initialCapacity
   &
,
  & '
ref
  ( +
	allocator
  , 5
,
  5 6
options
  7 >
)
  > ?
;
  ? @
}
ÀÀ 	
[
ÕÕ 	
BurstCompatible
ÕÕ	 
(
ÕÕ "
GenericTypeArguments
ÕÕ -
=
ÕÕ. /
new
ÕÕ0 3
[
ÕÕ4 5
]
ÕÕ5 6
{
ÕÕ7 8
typeof
ÕÕ9 ?
(
ÕÕ? @
AllocatorManager
ÕÕ@ P
.
ÕÕP Q
AllocatorHandle
ÕÕQ `
)
ÕÕ` a
}
ÕÕb c
)
ÕÕc d
]
ÕÕd e
internal
ŒŒ 
static
ŒŒ 

UnsafeList
ŒŒ "
<
ŒŒ" #
T
ŒŒ# $
>
ŒŒ$ %
New
ŒŒ& )
<
ŒŒ) *
U
ŒŒ* +
>
ŒŒ+ ,
(
ŒŒ, -
int
ŒŒ- 0
initialCapacity
ŒŒ1 @
,
ŒŒ@ A
ref
ŒŒB E
U
ŒŒF G
	allocator
ŒŒH Q
,
ŒŒQ R 
NativeArrayOptions
ŒŒS e
options
ŒŒf m
=
ŒŒn o!
NativeArrayOptionsŒŒp Ç
.ŒŒÇ É#
UninitializedMemoryŒŒÉ ñ
)ŒŒñ ó
whereŒŒò ù
UŒŒû ü
:ŒŒ† °
	unmanagedŒŒ¢ ´
,ŒŒ´ ¨ 
AllocatorManagerŒŒ≠ Ω
.ŒŒΩ æ

IAllocatorŒŒæ »
{
œœ 	

UnsafeList
–– 
<
–– 
T
–– 
>
–– 
instance
–– "
=
––# $
default
––% ,
;
––, -
instance
—— 
.
—— 

Initialize
—— 
(
——  
initialCapacity
——  /
,
——/ 0
ref
——1 4
	allocator
——5 >
,
——> ?
options
——@ G
)
——G H
;
——H I
return
““ 
instance
““ 
;
““ 
}
”” 	
[
’’ 	
BurstCompatible
’’	 
(
’’ "
GenericTypeArguments
’’ -
=
’’. /
new
’’0 3
[
’’3 4
]
’’4 5
{
’’6 7
typeof
’’8 >
(
’’> ?
AllocatorManager
’’? O
.
’’O P
AllocatorHandle
’’P _
)
’’_ `
}
’’a b
)
’’b c
]
’’c d
internal
÷÷ 
static
÷÷ 

UnsafeList
÷÷ "
<
÷÷" #
T
÷÷# $
>
÷÷$ %
*
÷÷% &
Create
÷÷' -
<
÷÷- .
U
÷÷. /
>
÷÷/ 0
(
÷÷0 1
int
÷÷1 4
initialCapacity
÷÷5 D
,
÷÷D E
ref
÷÷F I
U
÷÷J K
	allocator
÷÷L U
,
÷÷U V 
NativeArrayOptions
÷÷W i
options
÷÷j q
=
÷÷r s!
NativeArrayOptions÷÷t Ü
.÷÷Ü á#
UninitializedMemory÷÷á ö
)÷÷ö õ
where÷÷ú °
U÷÷¢ £
:÷÷§ •
	unmanaged÷÷¶ Ø
,÷÷Ø ∞ 
AllocatorManager÷÷± ¡
.÷÷¡ ¬

IAllocator÷÷¬ Ã
{
◊◊ 	

UnsafeList
ÿÿ 
<
ÿÿ 
T
ÿÿ 
>
ÿÿ 
*
ÿÿ 
listData
ÿÿ #
=
ÿÿ$ %
	allocator
ÿÿ& /
.
ÿÿ/ 0
Allocate
ÿÿ0 8
(
ÿÿ8 9
default
ÿÿ9 @
(
ÿÿ@ A

UnsafeList
ÿÿA K
<
ÿÿK L
T
ÿÿL M
>
ÿÿM N
)
ÿÿN O
,
ÿÿO P
$num
ÿÿQ R
)
ÿÿR S
;
ÿÿS T
UnsafeUtility
ŸŸ 
.
ŸŸ 
MemClear
ŸŸ "
(
ŸŸ" #
listData
ŸŸ# +
,
ŸŸ+ ,
sizeof
ŸŸ- 3
(
ŸŸ3 4

UnsafeList
ŸŸ4 >
<
ŸŸ> ?
T
ŸŸ? @
>
ŸŸ@ A
)
ŸŸA B
)
ŸŸB C
;
ŸŸC D
listData
€€ 
->
€€ 
	Allocator
€€ 
=
€€  !
	allocator
€€" +
.
€€+ ,
Handle
€€, 2
;
€€2 3
if
›› 
(
›› 
initialCapacity
›› 
!=
››  "
$num
››# $
)
››$ %
{
ﬁﬁ 
listData
ﬂﬂ 
->
ﬂﬂ 
SetCapacity
ﬂﬂ %
(
ﬂﬂ% &
ref
ﬂﬂ& )
	allocator
ﬂﬂ* 3
,
ﬂﬂ3 4
initialCapacity
ﬂﬂ5 D
)
ﬂﬂD E
;
ﬂﬂE F
}
‡‡ 
if
‚‚ 
(
‚‚ 
options
‚‚ 
==
‚‚  
NativeArrayOptions
‚‚ -
.
‚‚- .
ClearMemory
‚‚. 9
&&
„„ 
listData
„„ 
->
„„ 
Ptr
„„  
!=
„„! #
null
„„$ (
)
„„( )
{
‰‰ 
var
ÂÂ 
sizeOf
ÂÂ 
=
ÂÂ 
sizeof
ÂÂ #
(
ÂÂ# $
T
ÂÂ$ %
)
ÂÂ% &
;
ÂÂ& '
UnsafeUtility
ÊÊ 
.
ÊÊ 
MemClear
ÊÊ &
(
ÊÊ& '
listData
ÊÊ' /
->
ÊÊ/ 1
Ptr
ÊÊ1 4
,
ÊÊ4 5
listData
ÊÊ6 >
->
ÊÊ> @
Capacity
ÊÊ@ H
*
ÊÊI J
sizeOf
ÊÊK Q
)
ÊÊQ R
;
ÊÊR S
}
ÁÁ 
return
ÈÈ 
listData
ÈÈ 
;
ÈÈ 
}
ÍÍ 	
[
ÏÏ 	
BurstCompatible
ÏÏ	 
(
ÏÏ "
GenericTypeArguments
ÏÏ -
=
ÏÏ. /
new
ÏÏ0 3
[
ÏÏ3 4
]
ÏÏ4 5
{
ÏÏ6 7
typeof
ÏÏ8 >
(
ÏÏ> ?
AllocatorManager
ÏÏ? O
.
ÏÏO P
AllocatorHandle
ÏÏP _
)
ÏÏ_ `
}
ÏÏa b
)
ÏÏb c
]
ÏÏc d
internal
ÌÌ 
static
ÌÌ 
void
ÌÌ 
Destroy
ÌÌ $
<
ÌÌ$ %
U
ÌÌ% &
>
ÌÌ& '
(
ÌÌ' (

UnsafeList
ÌÌ( 2
<
ÌÌ2 3
T
ÌÌ3 4
>
ÌÌ4 5
*
ÌÌ5 6
listData
ÌÌ7 ?
,
ÌÌ? @
ref
ÌÌA D
U
ÌÌE F
	allocator
ÌÌG P
)
ÌÌP Q
where
ÌÌR W
U
ÌÌX Y
:
ÌÌZ [
	unmanaged
ÌÌ\ e
,
ÌÌe f
AllocatorManager
ÌÌg w
.
ÌÌw x

IAllocatorÌÌx Ç
{
ÓÓ 	
	CheckNull
ÔÔ 
(
ÔÔ 
listData
ÔÔ 
)
ÔÔ 
;
ÔÔ  
listData
 
->
 
Dispose
 
(
 
ref
 !
	allocator
" +
)
+ ,
;
, -
	allocator
ÒÒ 
.
ÒÒ 
Free
ÒÒ 
(
ÒÒ 
listData
ÒÒ #
,
ÒÒ# $
sizeof
ÒÒ% +
(
ÒÒ+ ,

UnsafeList
ÒÒ, 6
<
ÒÒ6 7
T
ÒÒ7 8
>
ÒÒ8 9
)
ÒÒ9 :
,
ÒÒ: ;
UnsafeUtility
ÒÒ< I
.
ÒÒI J
AlignOf
ÒÒJ Q
<
ÒÒQ R

UnsafeList
ÒÒR \
<
ÒÒ\ ]
T
ÒÒ] ^
>
ÒÒ^ _
>
ÒÒ_ `
(
ÒÒ` a
)
ÒÒa b
,
ÒÒb c
$num
ÒÒd e
)
ÒÒe f
;
ÒÒf g
}
ÚÚ 	
public
˚˚ 
static
˚˚ 

UnsafeList
˚˚  
<
˚˚  !
T
˚˚! "
>
˚˚" #
*
˚˚# $
Create
˚˚% +
(
˚˚+ ,
int
˚˚, /
initialCapacity
˚˚0 ?
,
˚˚? @
AllocatorManager
˚˚A Q
.
˚˚Q R
AllocatorHandle
˚˚R a
	allocator
˚˚b k
,
˚˚k l 
NativeArrayOptions
˚˚m 
options˚˚Ä á
=˚˚à â"
NativeArrayOptions˚˚ä ú
.˚˚ú ù#
UninitializedMemory˚˚ù ∞
)˚˚∞ ±
{
¸¸ 	

UnsafeList
˝˝ 
<
˝˝ 
T
˝˝ 
>
˝˝ 
*
˝˝ 
listData
˝˝ #
=
˝˝$ %
AllocatorManager
˝˝& 6
.
˝˝6 7
Allocate
˝˝7 ?
<
˝˝? @

UnsafeList
˝˝@ J
<
˝˝J K
T
˝˝K L
>
˝˝L M
>
˝˝M N
(
˝˝N O
	allocator
˝˝O X
)
˝˝X Y
;
˝˝Y Z
*
˛˛ 
listData
˛˛ 
=
˛˛ 
new
˛˛ 

UnsafeList
˛˛ &
<
˛˛& '
T
˛˛' (
>
˛˛( )
(
˛˛) *
initialCapacity
˛˛* 9
,
˛˛9 :
	allocator
˛˛; D
,
˛˛D E
options
˛˛F M
)
˛˛M N
;
˛˛N O
return
ÄÄ 
listData
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
public
áá 
static
áá 
void
áá 
Destroy
áá "
(
áá" #

UnsafeList
áá# -
<
áá- .
T
áá. /
>
áá/ 0
*
áá0 1
listData
áá2 :
)
áá: ;
{
àà 	
	CheckNull
ââ 
(
ââ 
listData
ââ 
)
ââ 
;
ââ  
var
ää 
	allocator
ää 
=
ää 
listData
ää $
->
ää$ &
	Allocator
ää& /
;
ää/ 0
listData
ãã 
->
ãã 
Dispose
ãã 
(
ãã 
)
ãã 
;
ãã  
AllocatorManager
åå 
.
åå 
Free
åå !
(
åå! "
	allocator
åå" +
,
åå+ ,
listData
åå- 5
)
åå5 6
;
åå6 7
}
çç 	
public
ìì 
bool
ìì 
IsEmpty
ìì 
=>
ìì 
!
ìì  
	IsCreated
ìì  )
||
ìì* ,
m_length
ìì- 5
==
ìì6 8
$num
ìì9 :
;
ìì: ;
public
ôô 
bool
ôô 
	IsCreated
ôô 
=>
ôô  
Ptr
ôô! $
!=
ôô% '
null
ôô( ,
;
ôô, -
[
õõ 	
BurstCompatible
õõ	 
(
õõ "
GenericTypeArguments
õõ -
=
õõ. /
new
õõ0 3
[
õõ3 4
]
õõ4 5
{
õõ6 7
typeof
õõ8 >
(
õõ> ?
AllocatorManager
õõ? O
.
õõO P
AllocatorHandle
õõP _
)
õõ_ `
}
õõa b
)
õõb c
]
õõc d
internal
úú 
void
úú 
Dispose
úú 
<
úú 
U
úú 
>
úú  
(
úú  !
ref
úú! $
U
úú% &
	allocator
úú' 0
)
úú0 1
where
úú2 7
U
úú8 9
:
úú: ;
	unmanaged
úú< E
,
úúE F
AllocatorManager
úúG W
.
úúW X

IAllocator
úúX b
{
ùù 	
	allocator
ûû 
.
ûû 
Free
ûû 
(
ûû 
Ptr
ûû 
,
ûû 
m_length
ûû  (
)
ûû( )
;
ûû) *
Ptr
üü 
=
üü 
null
üü 
;
üü 
m_length
†† 
=
†† 
$num
†† 
;
†† 

m_capacity
°° 
=
°° 
$num
°° 
;
°° 
}
¢¢ 	
public
ßß 
void
ßß 
Dispose
ßß 
(
ßß 
)
ßß 
{
®® 	
if
©© 
(
©© 
CollectionHelper
©©  
.
©©  !
ShouldDeallocate
©©! 1
(
©©1 2
	Allocator
©©2 ;
)
©©; <
)
©©< =
{
™™ 
AllocatorManager
´´  
.
´´  !
Free
´´! %
(
´´% &
	Allocator
´´& /
,
´´/ 0
Ptr
´´1 4
)
´´4 5
;
´´5 6
	Allocator
¨¨ 
=
¨¨ 
AllocatorManager
¨¨ ,
.
¨¨, -
Invalid
¨¨- 4
;
¨¨4 5
}
≠≠ 
Ptr
ØØ 
=
ØØ 
null
ØØ 
;
ØØ 
m_length
∞∞ 
=
∞∞ 
$num
∞∞ 
;
∞∞ 

m_capacity
±± 
=
±± 
$num
±± 
;
±± 
}
≤≤ 	
[
ππ 	 
NotBurstCompatible
ππ	 
]ππú ù
public
∫∫ 
	JobHandle
∫∫ 
Dispose
∫∫  
(
∫∫  !
	JobHandle
∫∫! *
	inputDeps
∫∫+ 4
)
∫∫4 5
{
ªª 	
if
ºº 
(
ºº 
CollectionHelper
ºº  
.
ºº  !
ShouldDeallocate
ºº! 1
(
ºº1 2
	Allocator
ºº2 ;
)
ºº; <
)
ºº< =
{
ΩΩ 
var
ææ 
	jobHandle
ææ 
=
ææ 
new
ææ  #
UnsafeDisposeJob
ææ$ 4
{
ææ5 6
Ptr
ææ7 :
=
ææ; <
Ptr
ææ= @
,
ææ@ A
	Allocator
ææB K
=
ææL M
	Allocator
ææN W
}
ææX Y
.
ææY Z
Schedule
ææZ b
(
ææb c
	inputDeps
ææc l
)
ææl m
;
ææm n
Ptr
¿¿ 
=
¿¿ 
null
¿¿ 
;
¿¿ 
	Allocator
¡¡ 
=
¡¡ 
AllocatorManager
¡¡ ,
.
¡¡, -
Invalid
¡¡- 4
;
¡¡4 5
return
√√ 
	jobHandle
√√  
;
√√  !
}
ƒƒ 
Ptr
∆∆ 
=
∆∆ 
null
∆∆ 
;
∆∆ 
return
»» 
	inputDeps
»» 
;
»» 
}
…… 	
public
œœ 
void
œœ 
Clear
œœ 
(
œœ 
)
œœ 
{
–– 	
m_length
—— 
=
—— 
$num
—— 
;
—— 
}
““ 	
public
ŸŸ 
void
ŸŸ 
Resize
ŸŸ 
(
ŸŸ 
int
ŸŸ 
length
ŸŸ %
,
ŸŸ% & 
NativeArrayOptions
ŸŸ' 9
options
ŸŸ: A
=
ŸŸB C 
NativeArrayOptions
ŸŸD V
.
ŸŸV W!
UninitializedMemory
ŸŸW j
)
ŸŸj k
{
⁄⁄ 	
var
€€ 
	oldLength
€€ 
=
€€ 
m_length
€€ $
;
€€$ %
if
›› 
(
›› 
length
›› 
>
›› 
Capacity
›› !
)
››! "
{
ﬁﬁ 
SetCapacity
ﬂﬂ 
(
ﬂﬂ 
length
ﬂﬂ "
)
ﬂﬂ" #
;
ﬂﬂ# $
}
‡‡ 
m_length
‚‚ 
=
‚‚ 
length
‚‚ 
;
‚‚ 
if
‰‰ 
(
‰‰ 
options
‰‰ 
==
‰‰  
NativeArrayOptions
‰‰ -
.
‰‰- .
ClearMemory
‰‰. 9
&&
‰‰: <
	oldLength
‰‰= F
<
‰‰G H
length
‰‰I O
)
‰‰O P
{
ÂÂ 
var
ÊÊ 
num
ÊÊ 
=
ÊÊ 
length
ÊÊ  
-
ÊÊ! "
	oldLength
ÊÊ# ,
;
ÊÊ, -
byte
ÁÁ 
*
ÁÁ 
ptr
ÁÁ 
=
ÁÁ 
(
ÁÁ 
byte
ÁÁ !
*
ÁÁ! "
)
ÁÁ" #
Ptr
ÁÁ# &
;
ÁÁ& '
var
ËË 
sizeOf
ËË 
=
ËË 
sizeof
ËË #
(
ËË# $
T
ËË$ %
)
ËË% &
;
ËË& '
UnsafeUtility
ÈÈ 
.
ÈÈ 
MemClear
ÈÈ &
(
ÈÈ& '
ptr
ÈÈ' *
+
ÈÈ+ ,
	oldLength
ÈÈ- 6
*
ÈÈ7 8
sizeOf
ÈÈ9 ?
,
ÈÈ? @
num
ÈÈA D
*
ÈÈE F
sizeOf
ÈÈG M
)
ÈÈM N
;
ÈÈN O
}
ÍÍ 
}
ÎÎ 	
void
ÌÌ 
Realloc
ÌÌ 
<
ÌÌ 
U
ÌÌ 
>
ÌÌ 
(
ÌÌ 
ref
ÌÌ 
U
ÌÌ 
	allocator
ÌÌ '
,
ÌÌ' (
int
ÌÌ) ,
newCapacity
ÌÌ- 8
)
ÌÌ8 9
where
ÌÌ: ?
U
ÌÌ@ A
:
ÌÌB C
	unmanaged
ÌÌD M
,
ÌÌM N
AllocatorManager
ÌÌO _
.
ÌÌ_ `

IAllocator
ÌÌ` j
{
ÓÓ 	
CollectionHelper
ÔÔ 
.
ÔÔ 
CheckAllocator
ÔÔ +
(
ÔÔ+ ,
	Allocator
ÔÔ, 5
)
ÔÔ5 6
;
ÔÔ6 7
T
 
*
 

newPointer
 
=
 
null
  
;
  !
var
ÚÚ 
alignOf
ÚÚ 
=
ÚÚ 
UnsafeUtility
ÚÚ '
.
ÚÚ' (
AlignOf
ÚÚ( /
<
ÚÚ/ 0
T
ÚÚ0 1
>
ÚÚ1 2
(
ÚÚ2 3
)
ÚÚ3 4
;
ÚÚ4 5
var
ÛÛ 
sizeOf
ÛÛ 
=
ÛÛ 
sizeof
ÛÛ 
(
ÛÛ  
T
ÛÛ  !
)
ÛÛ! "
;
ÛÛ" #
if
ıı 
(
ıı 
newCapacity
ıı 
>
ıı 
$num
ıı 
)
ıı  
{
ˆˆ 

newPointer
˜˜ 
=
˜˜ 
(
˜˜ 
T
˜˜ 
*
˜˜  
)
˜˜  !
	allocator
˜˜! *
.
˜˜* +
Allocate
˜˜+ 3
(
˜˜3 4
sizeOf
˜˜4 :
,
˜˜: ;
alignOf
˜˜< C
,
˜˜C D
newCapacity
˜˜E P
)
˜˜P Q
;
˜˜Q R
if
˘˘ 
(
˘˘ 

m_capacity
˘˘ 
>
˘˘  
$num
˘˘! "
)
˘˘" #
{
˙˙ 
var
˚˚ 
itemsToCopy
˚˚ #
=
˚˚$ %
math
˚˚& *
.
˚˚* +
min
˚˚+ .
(
˚˚. /
newCapacity
˚˚/ :
,
˚˚: ;
Capacity
˚˚< D
)
˚˚D E
;
˚˚E F
var
¸¸ 
bytesToCopy
¸¸ #
=
¸¸$ %
itemsToCopy
¸¸& 1
*
¸¸2 3
sizeOf
¸¸4 :
;
¸¸: ;
UnsafeUtility
˝˝ !
.
˝˝! "
MemCpy
˝˝" (
(
˝˝( )

newPointer
˝˝) 3
,
˝˝3 4
Ptr
˝˝5 8
,
˝˝8 9
bytesToCopy
˝˝: E
)
˝˝E F
;
˝˝F G
}
˛˛ 
}
ˇˇ 
	allocator
ÅÅ 
.
ÅÅ 
Free
ÅÅ 
(
ÅÅ 
Ptr
ÅÅ 
,
ÅÅ 
Capacity
ÅÅ  (
)
ÅÅ( )
;
ÅÅ) *
Ptr
ÉÉ 
=
ÉÉ 

newPointer
ÉÉ 
;
ÉÉ 

m_capacity
ÑÑ 
=
ÑÑ 
newCapacity
ÑÑ $
;
ÑÑ$ %
m_length
ÖÖ 
=
ÖÖ 
math
ÖÖ 
.
ÖÖ 
min
ÖÖ 
(
ÖÖ  
m_length
ÖÖ  (
,
ÖÖ( )
newCapacity
ÖÖ* 5
)
ÖÖ5 6
;
ÖÖ6 7
}
ÜÜ 	
void
àà 
Realloc
àà 
(
àà 
int
àà 
capacity
àà !
)
àà! "
{
ââ 	
Realloc
ää 
(
ää 
ref
ää 
	Allocator
ää !
,
ää! "
capacity
ää# +
)
ää+ ,
;
ää, -
}
ãã 	
void
çç 
SetCapacity
çç 
<
çç 
U
çç 
>
çç 
(
çç 
ref
çç 
U
çç  !
	allocator
çç" +
,
çç+ ,
int
çç- 0
capacity
çç1 9
)
çç9 :
where
çç; @
U
ççA B
:
ççC D
	unmanaged
ççE N
,
ççN O
AllocatorManager
ççP `
.
çç` a

IAllocator
çça k
{
éé 	
CollectionHelper
èè 
.
èè "
CheckCapacityInRange
èè 1
(
èè1 2
capacity
èè2 :
,
èè: ;
Length
èè< B
)
èèB C
;
èèC D
var
ëë 
sizeOf
ëë 
=
ëë 
sizeof
ëë 
(
ëë  
T
ëë  !
)
ëë! "
;
ëë" #
var
íí 
newCapacity
íí 
=
íí 
math
íí "
.
íí" #
max
íí# &
(
íí& '
capacity
íí' /
,
íí/ 0
$num
íí1 3
/
íí4 5
sizeOf
íí6 <
)
íí< =
;
íí= >
newCapacity
ìì 
=
ìì 
math
ìì 
.
ìì 
ceilpow2
ìì '
(
ìì' (
newCapacity
ìì( 3
)
ìì3 4
;
ìì4 5
if
ïï 
(
ïï 
newCapacity
ïï 
==
ïï 
Capacity
ïï '
)
ïï' (
{
ññ 
return
óó 
;
óó 
}
òò 
Realloc
öö 
(
öö 
ref
öö 
	allocator
öö !
,
öö! "
newCapacity
öö# .
)
öö. /
;
öö/ 0
}
õõ 	
public
°° 
void
°° 
SetCapacity
°° 
(
°°  
int
°°  #
capacity
°°$ ,
)
°°, -
{
¢¢ 	
SetCapacity
££ 
(
££ 
ref
££ 
	Allocator
££ %
,
££% &
capacity
££' /
)
££/ 0
;
££0 1
}
§§ 	
public
©© 
void
©© 

TrimExcess
©© 
(
©© 
)
©©  
{
™™ 	
if
´´ 
(
´´ 
Capacity
´´ 
!=
´´ 
m_length
´´ $
)
´´$ %
{
¨¨ 
Realloc
≠≠ 
(
≠≠ 
m_length
≠≠  
)
≠≠  !
;
≠≠! "
}
ÆÆ 
}
ØØ 	
public
ππ 
void
ππ 
AddNoResize
ππ 
(
ππ  
T
ππ  !
value
ππ" '
)
ππ' (
{
∫∫ 	,
CheckNoResizeHasEnoughCapacity
ªª *
(
ªª* +
$num
ªª+ ,
)
ªª, -
;
ªª- .
UnsafeUtility
ºº 
.
ºº 
WriteArrayElement
ºº +
(
ºº+ ,
Ptr
ºº, /
,
ºº/ 0
m_length
ºº1 9
,
ºº9 :
value
ºº; @
)
ºº@ A
;
ººA B
m_length
ΩΩ 
+=
ΩΩ 
$num
ΩΩ 
;
ΩΩ 
}
ææ 	
public
…… 
void
…… 
AddRangeNoResize
…… $
(
……$ %
void
……% )
*
……) *
ptr
……+ .
,
……. /
int
……0 3
count
……4 9
)
……9 :
{
   	,
CheckNoResizeHasEnoughCapacity
ÀÀ *
(
ÀÀ* +
count
ÀÀ+ 0
)
ÀÀ0 1
;
ÀÀ1 2
var
ÃÃ 
sizeOf
ÃÃ 
=
ÃÃ 
sizeof
ÃÃ 
(
ÃÃ  
T
ÃÃ  !
)
ÃÃ! "
;
ÃÃ" #
void
ÕÕ 
*
ÕÕ 
dst
ÕÕ 
=
ÕÕ 
(
ÕÕ 
byte
ÕÕ 
*
ÕÕ 
)
ÕÕ 
Ptr
ÕÕ "
+
ÕÕ# $
m_length
ÕÕ% -
*
ÕÕ. /
sizeOf
ÕÕ0 6
;
ÕÕ6 7
UnsafeUtility
ŒŒ 
.
ŒŒ 
MemCpy
ŒŒ  
(
ŒŒ  !
dst
ŒŒ! $
,
ŒŒ$ %
ptr
ŒŒ& )
,
ŒŒ) *
count
ŒŒ+ 0
*
ŒŒ1 2
sizeOf
ŒŒ3 9
)
ŒŒ9 :
;
ŒŒ: ;
m_length
œœ 
+=
œœ 
count
œœ 
;
œœ 
}
–– 	
[
⁄⁄ 	
BurstCompatible
⁄⁄	 
(
⁄⁄ "
GenericTypeArguments
⁄⁄ -
=
⁄⁄. /
new
⁄⁄0 3
[
⁄⁄3 4
]
⁄⁄4 5
{
⁄⁄6 7
typeof
⁄⁄8 >
(
⁄⁄> ?
int
⁄⁄? B
)
⁄⁄B C
}
⁄⁄D E
)
⁄⁄E F
]
⁄⁄F G
public
€€ 
void
€€ 
AddRangeNoResize
€€ $
(
€€$ %

UnsafeList
€€% /
<
€€/ 0
T
€€0 1
>
€€1 2
list
€€3 7
)
€€7 8
{
‹‹ 	
AddRangeNoResize
›› 
(
›› 
list
›› !
.
››! "
Ptr
››" %
,
››% &
CollectionHelper
››' 7
.
››7 8
AssumePositive
››8 F
(
››F G
list
››G K
.
››K L
m_length
››L T
)
››T U
)
››U V
;
››V W
}
ﬁﬁ 	
public
ÁÁ 
void
ÁÁ 
Add
ÁÁ 
(
ÁÁ 
in
ÁÁ 
T
ÁÁ 
value
ÁÁ "
)
ÁÁ" #
{
ËË 	
var
ÈÈ 
idx
ÈÈ 
=
ÈÈ 
m_length
ÈÈ 
;
ÈÈ 
if
ÎÎ 
(
ÎÎ 
m_length
ÎÎ 
+
ÎÎ 
$num
ÎÎ 
>
ÎÎ 
Capacity
ÎÎ '
)
ÎÎ' (
{
ÏÏ 
Resize
ÌÌ 
(
ÌÌ 
idx
ÌÌ 
+
ÌÌ 
$num
ÌÌ 
)
ÌÌ 
;
ÌÌ  
}
ÓÓ 
else
ÔÔ 
{
 
m_length
ÒÒ 
+=
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
}
ÚÚ 
UnsafeUtility
ÙÙ 
.
ÙÙ 
WriteArrayElement
ÙÙ +
(
ÙÙ+ ,
Ptr
ÙÙ, /
,
ÙÙ/ 0
idx
ÙÙ1 4
,
ÙÙ4 5
value
ÙÙ6 ;
)
ÙÙ; <
;
ÙÙ< =
}
ıı 	
public
ˇˇ 
void
ˇˇ 
AddRange
ˇˇ 
(
ˇˇ 
void
ˇˇ !
*
ˇˇ! "
ptr
ˇˇ# &
,
ˇˇ& '
int
ˇˇ( +
count
ˇˇ, 1
)
ˇˇ1 2
{
ÄÄ 	
var
ÅÅ 
idx
ÅÅ 
=
ÅÅ 
m_length
ÅÅ 
;
ÅÅ 
if
ÉÉ 
(
ÉÉ 
m_length
ÉÉ 
+
ÉÉ 
count
ÉÉ  
>
ÉÉ! "
Capacity
ÉÉ# +
)
ÉÉ+ ,
{
ÑÑ 
Resize
ÖÖ 
(
ÖÖ 
m_length
ÖÖ 
+
ÖÖ  !
count
ÖÖ" '
)
ÖÖ' (
;
ÖÖ( )
}
ÜÜ 
else
áá 
{
àà 
m_length
ââ 
+=
ââ 
count
ââ !
;
ââ! "
}
ää 
var
åå 
sizeOf
åå 
=
åå 
sizeof
åå 
(
åå  
T
åå  !
)
åå! "
;
åå" #
void
çç 
*
çç 
dst
çç 
=
çç 
(
çç 
byte
çç 
*
çç 
)
çç 
Ptr
çç "
+
çç# $
idx
çç% (
*
çç) *
sizeOf
çç+ 1
;
çç1 2
UnsafeUtility
éé 
.
éé 
MemCpy
éé  
(
éé  !
dst
éé! $
,
éé$ %
ptr
éé& )
,
éé) *
count
éé+ 0
*
éé1 2
sizeOf
éé3 9
)
éé9 :
;
éé: ;
}
èè 	
[
òò 	
BurstCompatible
òò	 
(
òò "
GenericTypeArguments
òò -
=
òò. /
new
òò0 3
[
òò3 4
]
òò4 5
{
òò6 7
typeof
òò8 >
(
òò> ?
int
òò? B
)
òòB C
}
òòD E
)
òòE F
]
òòF G
public
ôô 
void
ôô 
AddRange
ôô 
(
ôô 

UnsafeList
ôô '
<
ôô' (
T
ôô( )
>
ôô) *
list
ôô+ /
)
ôô/ 0
{
öö 	
AddRange
õõ 
(
õõ 
list
õõ 
.
õõ 
Ptr
õõ 
,
õõ 
list
õõ #
.
õõ# $
Length
õõ$ *
)
õõ* +
;
õõ+ ,
}
úú 	
public
∞∞ 
void
∞∞ %
InsertRangeWithBeginEnd
∞∞ +
(
∞∞+ ,
int
∞∞, /
begin
∞∞0 5
,
∞∞5 6
int
∞∞7 :
end
∞∞; >
)
∞∞> ?
{
±± 	
CheckBeginEnd
≤≤ 
(
≤≤ 
begin
≤≤ 
,
≤≤  
end
≤≤! $
)
≤≤$ %
;
≤≤% &
int
¥¥ 
items
¥¥ 
=
¥¥ 
end
¥¥ 
-
¥¥ 
begin
¥¥ #
;
¥¥# $
if
µµ 
(
µµ 
items
µµ 
<
µµ 
$num
µµ 
)
µµ 
{
∂∂ 
return
∑∑ 
;
∑∑ 
}
∏∏ 
var
∫∫ 
	oldLength
∫∫ 
=
∫∫ 
m_length
∫∫ $
;
∫∫$ %
if
ºº 
(
ºº 
m_length
ºº 
+
ºº 
items
ºº  
>
ºº! "
Capacity
ºº# +
)
ºº+ ,
{
ΩΩ 
Resize
ææ 
(
ææ 
m_length
ææ 
+
ææ  !
items
ææ" '
)
ææ' (
;
ææ( )
}
øø 
else
¿¿ 
{
¡¡ 
m_length
¬¬ 
+=
¬¬ 
items
¬¬ !
;
¬¬! "
}
√√ 
var
≈≈ 
itemsToCopy
≈≈ 
=
≈≈ 
	oldLength
≈≈ '
-
≈≈( )
begin
≈≈* /
;
≈≈/ 0
if
«« 
(
«« 
itemsToCopy
«« 
<
«« 
$num
«« 
)
««  
{
»» 
return
…… 
;
…… 
}
   
var
ÃÃ 
sizeOf
ÃÃ 
=
ÃÃ 
sizeof
ÃÃ 
(
ÃÃ  
T
ÃÃ  !
)
ÃÃ! "
;
ÃÃ" #
var
ÕÕ 
bytesToCopy
ÕÕ 
=
ÕÕ 
itemsToCopy
ÕÕ )
*
ÕÕ* +
sizeOf
ÕÕ, 2
;
ÕÕ2 3
unsafe
ŒŒ 
{
œœ 
byte
–– 
*
–– 
ptr
–– 
=
–– 
(
–– 
byte
–– !
*
––! "
)
––" #
Ptr
––# &
;
––& '
byte
—— 
*
—— 
dest
—— 
=
—— 
ptr
——  
+
——! "
end
——# &
*
——' (
sizeOf
——) /
;
——/ 0
byte
““ 
*
““ 
src
““ 
=
““ 
ptr
““ 
+
““  !
begin
““" '
*
““( )
sizeOf
““* 0
;
““0 1
UnsafeUtility
”” 
.
”” 
MemMove
”” %
(
””% &
dest
””& *
,
””* +
src
””, /
,
””/ 0
bytesToCopy
””1 <
)
””< =
;
””= >
}
‘‘ 
}
’’ 	
public
›› 
void
›› 
RemoveAtSwapBack
›› $
(
››$ %
int
››% (
index
››) .
)
››. /
{
ﬁﬁ 	!
RemoveRangeSwapBack
ﬂﬂ 
(
ﬂﬂ  
index
ﬂﬂ  %
,
ﬂﬂ% &
$num
ﬂﬂ' (
)
ﬂﬂ( )
;
ﬂﬂ) *
}
‡‡ 	
public
ÓÓ 
void
ÓÓ !
RemoveRangeSwapBack
ÓÓ '
(
ÓÓ' (
int
ÓÓ( +
index
ÓÓ, 1
,
ÓÓ1 2
int
ÓÓ3 6
count
ÓÓ7 <
)
ÓÓ< =
{
ÔÔ 	
CheckIndexCount
 
(
 
index
 !
,
! "
count
# (
)
( )
;
) *
if
ÚÚ 
(
ÚÚ 
count
ÚÚ 
>
ÚÚ 
$num
ÚÚ 
)
ÚÚ 
{
ÛÛ 
int
ÙÙ 
copyFrom
ÙÙ 
=
ÙÙ 
math
ÙÙ #
.
ÙÙ# $
max
ÙÙ$ '
(
ÙÙ' (
m_length
ÙÙ( 0
-
ÙÙ1 2
count
ÙÙ3 8
,
ÙÙ8 9
index
ÙÙ: ?
+
ÙÙ@ A
count
ÙÙB G
)
ÙÙG H
;
ÙÙH I
var
ıı 
sizeOf
ıı 
=
ıı 
sizeof
ıı #
(
ıı# $
T
ıı$ %
)
ıı% &
;
ıı& '
void
ˆˆ 
*
ˆˆ 
dst
ˆˆ 
=
ˆˆ 
(
ˆˆ 
byte
ˆˆ !
*
ˆˆ! "
)
ˆˆ" #
Ptr
ˆˆ# &
+
ˆˆ' (
index
ˆˆ) .
*
ˆˆ/ 0
sizeOf
ˆˆ1 7
;
ˆˆ7 8
void
˜˜ 
*
˜˜ 
src
˜˜ 
=
˜˜ 
(
˜˜ 
byte
˜˜ !
*
˜˜! "
)
˜˜" #
Ptr
˜˜# &
+
˜˜' (
copyFrom
˜˜) 1
*
˜˜2 3
sizeOf
˜˜4 :
;
˜˜: ;
UnsafeUtility
¯¯ 
.
¯¯ 
MemCpy
¯¯ $
(
¯¯$ %
dst
¯¯% (
,
¯¯( )
src
¯¯* -
,
¯¯- .
(
¯¯/ 0
m_length
¯¯0 8
-
¯¯9 :
copyFrom
¯¯; C
)
¯¯C D
*
¯¯E F
sizeOf
¯¯G M
)
¯¯M N
;
¯¯N O
m_length
˘˘ 
-=
˘˘ 
count
˘˘ !
;
˘˘! "
}
˙˙ 
}
˚˚ 	
[
ää 	
Obsolete
ää	 
(
ää 
$strää ó
,ääó ò
falseääô û
)ääû ü
]ääü †
public
ãã 
void
ãã -
RemoveRangeSwapBackWithBeginEnd
ãã 3
(
ãã3 4
int
ãã4 7
begin
ãã8 =
,
ãã= >
int
ãã? B
end
ããC F
)
ããF G
{
åå 	
CheckBeginEnd
çç 
(
çç 
begin
çç 
,
çç  
end
çç! $
)
çç$ %
;
çç% &
int
èè 
itemsToRemove
èè 
=
èè 
end
èè  #
-
èè$ %
begin
èè& +
;
èè+ ,
if
êê 
(
êê 
itemsToRemove
êê 
>
êê 
$num
êê  !
)
êê! "
{
ëë 
int
íí 
copyFrom
íí 
=
íí 
math
íí #
.
íí# $
max
íí$ '
(
íí' (
m_length
íí( 0
-
íí1 2
itemsToRemove
íí3 @
,
íí@ A
end
ííB E
)
ííE F
;
ííF G
var
ìì 
sizeOf
ìì 
=
ìì 
sizeof
ìì #
(
ìì# $
T
ìì$ %
)
ìì% &
;
ìì& '
void
îî 
*
îî 
dst
îî 
=
îî 
(
îî 
byte
îî !
*
îî! "
)
îî" #
Ptr
îî# &
+
îî' (
begin
îî) .
*
îî/ 0
sizeOf
îî1 7
;
îî7 8
void
ïï 
*
ïï 
src
ïï 
=
ïï 
(
ïï 
byte
ïï !
*
ïï! "
)
ïï" #
Ptr
ïï# &
+
ïï' (
copyFrom
ïï) 1
*
ïï2 3
sizeOf
ïï4 :
;
ïï: ;
UnsafeUtility
ññ 
.
ññ 
MemCpy
ññ $
(
ññ$ %
dst
ññ% (
,
ññ( )
src
ññ* -
,
ññ- .
(
ññ/ 0
m_length
ññ0 8
-
ññ9 :
copyFrom
ññ; C
)
ññC D
*
ññE F
sizeOf
ññG M
)
ññM N
;
ññN O
m_length
óó 
-=
óó 
itemsToRemove
óó )
;
óó) *
}
òò 
}
ôô 	
public
££ 
void
££ 
RemoveAt
££ 
(
££ 
int
££  
index
££! &
)
££& '
{
§§ 	
RemoveRange
•• 
(
•• 
index
•• 
,
•• 
$num
••  
)
••  !
;
••! "
}
¶¶ 	
public
≥≥ 
void
≥≥ 
RemoveRange
≥≥ 
(
≥≥  
int
≥≥  #
index
≥≥$ )
,
≥≥) *
int
≥≥+ .
count
≥≥/ 4
)
≥≥4 5
{
¥¥ 	
CheckIndexCount
µµ 
(
µµ 
index
µµ !
,
µµ! "
count
µµ# (
)
µµ( )
;
µµ) *
if
∑∑ 
(
∑∑ 
count
∑∑ 
>
∑∑ 
$num
∑∑ 
)
∑∑ 
{
∏∏ 
int
ππ 
copyFrom
ππ 
=
ππ 
math
ππ #
.
ππ# $
min
ππ$ '
(
ππ' (
index
ππ( -
+
ππ. /
count
ππ0 5
,
ππ5 6
m_length
ππ7 ?
)
ππ? @
;
ππ@ A
var
∫∫ 
sizeOf
∫∫ 
=
∫∫ 
sizeof
∫∫ #
(
∫∫# $
T
∫∫$ %
)
∫∫% &
;
∫∫& '
void
ªª 
*
ªª 
dst
ªª 
=
ªª 
(
ªª 
byte
ªª !
*
ªª! "
)
ªª" #
Ptr
ªª# &
+
ªª' (
index
ªª) .
*
ªª/ 0
sizeOf
ªª1 7
;
ªª7 8
void
ºº 
*
ºº 
src
ºº 
=
ºº 
(
ºº 
byte
ºº !
*
ºº! "
)
ºº" #
Ptr
ºº# &
+
ºº' (
copyFrom
ºº) 1
*
ºº2 3
sizeOf
ºº4 :
;
ºº: ;
UnsafeUtility
ΩΩ 
.
ΩΩ 
MemCpy
ΩΩ $
(
ΩΩ$ %
dst
ΩΩ% (
,
ΩΩ( )
src
ΩΩ* -
,
ΩΩ- .
(
ΩΩ/ 0
m_length
ΩΩ0 8
-
ΩΩ9 :
copyFrom
ΩΩ; C
)
ΩΩC D
*
ΩΩE F
sizeOf
ΩΩG M
)
ΩΩM N
;
ΩΩN O
m_length
ææ 
-=
ææ 
count
ææ !
;
ææ! "
}
øø 
}
¿¿ 	
[
ÃÃ 	
Obsolete
ÃÃ	 
(
ÃÃ 
$strÃÃ á
,ÃÃá à
falseÃÃâ é
)ÃÃé è
]ÃÃè ê
public
ÕÕ 
void
ÕÕ %
RemoveRangeWithBeginEnd
ÕÕ +
(
ÕÕ+ ,
int
ÕÕ, /
begin
ÕÕ0 5
,
ÕÕ5 6
int
ÕÕ7 :
end
ÕÕ; >
)
ÕÕ> ?
{
ŒŒ 	
CheckBeginEnd
œœ 
(
œœ 
begin
œœ 
,
œœ  
end
œœ! $
)
œœ$ %
;
œœ% &
int
—— 
itemsToRemove
—— 
=
—— 
end
——  #
-
——$ %
begin
——& +
;
——+ ,
if
““ 
(
““ 
itemsToRemove
““ 
>
““ 
$num
““  !
)
““! "
{
”” 
int
‘‘ 
copyFrom
‘‘ 
=
‘‘ 
math
‘‘ #
.
‘‘# $
min
‘‘$ '
(
‘‘' (
begin
‘‘( -
+
‘‘. /
itemsToRemove
‘‘0 =
,
‘‘= >
m_length
‘‘? G
)
‘‘G H
;
‘‘H I
var
’’ 
sizeOf
’’ 
=
’’ 
sizeof
’’ #
(
’’# $
T
’’$ %
)
’’% &
;
’’& '
void
÷÷ 
*
÷÷ 
dst
÷÷ 
=
÷÷ 
(
÷÷ 
byte
÷÷ !
*
÷÷! "
)
÷÷" #
Ptr
÷÷# &
+
÷÷' (
begin
÷÷) .
*
÷÷/ 0
sizeOf
÷÷1 7
;
÷÷7 8
void
◊◊ 
*
◊◊ 
src
◊◊ 
=
◊◊ 
(
◊◊ 
byte
◊◊ !
*
◊◊! "
)
◊◊" #
Ptr
◊◊# &
+
◊◊' (
copyFrom
◊◊) 1
*
◊◊2 3
sizeOf
◊◊4 :
;
◊◊: ;
UnsafeUtility
ÿÿ 
.
ÿÿ 
MemCpy
ÿÿ $
(
ÿÿ$ %
dst
ÿÿ% (
,
ÿÿ( )
src
ÿÿ* -
,
ÿÿ- .
(
ÿÿ/ 0
m_length
ÿÿ0 8
-
ÿÿ9 :
copyFrom
ÿÿ; C
)
ÿÿC D
*
ÿÿE F
sizeOf
ÿÿG M
)
ÿÿM N
;
ÿÿN O
m_length
ŸŸ 
-=
ŸŸ 
itemsToRemove
ŸŸ )
;
ŸŸ) *
}
⁄⁄ 
}
€€ 	
public
·· 
ParallelReader
·· 
AsParallelReader
·· .
(
··. /
)
··/ 0
{
‚‚ 	
return
„„ 
new
„„ 
ParallelReader
„„ %
(
„„% &
Ptr
„„& )
,
„„) *
Length
„„+ 1
)
„„1 2
;
„„2 3
}
‰‰ 	
[
ÏÏ 	
BurstCompatible
ÏÏ	 
(
ÏÏ "
GenericTypeArguments
ÏÏ -
=
ÏÏ. /
new
ÏÏ0 3
[
ÏÏ4 5
]
ÏÏ5 6
{
ÏÏ7 8
typeof
ÏÏ9 ?
(
ÏÏ? @
int
ÏÏ@ C
)
ÏÏC D
}
ÏÏE F
)
ÏÏF G
]
ÏÏG H
public
ÌÌ 
unsafe
ÌÌ 
struct
ÌÌ 
ParallelReader
ÌÌ +
{
ÓÓ 	
[
ÚÚ /
!NativeDisableUnsafePtrRestriction
ÚÚ .
]
ÚÚ. /
public
ÛÛ 
readonly
ÛÛ 
T
ÛÛ 
*
ÛÛ 
Ptr
ÛÛ "
;
ÛÛ" #
public
¯¯ 
readonly
¯¯ 
int
¯¯ 
Length
¯¯  &
;
¯¯& '
internal
˙˙ 
ParallelReader
˙˙ #
(
˙˙# $
T
˙˙$ %
*
˙˙% &
ptr
˙˙' *
,
˙˙* +
int
˙˙, /
length
˙˙0 6
)
˙˙6 7
{
˚˚ 
Ptr
¸¸ 
=
¸¸ 
ptr
¸¸ 
;
¸¸ 
Length
˝˝ 
=
˝˝ 
length
˝˝ 
;
˝˝  
}
˛˛ 
}
ˇˇ 	
public
ÖÖ 
ParallelWriter
ÖÖ 
AsParallelWriter
ÖÖ .
(
ÖÖ. /
)
ÖÖ/ 0
{
ÜÜ 	
return
áá 
new
áá 
ParallelWriter
áá %
(
áá% &
(
áá& '

UnsafeList
áá' 1
<
áá1 2
T
áá2 3
>
áá3 4
*
áá4 5
)
áá5 6
UnsafeUtility
áá6 C
.
ááC D
	AddressOf
ááD M
(
ááM N
ref
ááN Q
this
ááR V
)
ááV W
)
ááW X
;
ááX Y
}
àà 	
[
êê 	
BurstCompatible
êê	 
(
êê "
GenericTypeArguments
êê -
=
êê. /
new
êê0 3
[
êê4 5
]
êê5 6
{
êê7 8
typeof
êê9 ?
(
êê? @
int
êê@ C
)
êêC D
}
êêE F
)
êêF G
]
êêG H
public
ëë 
unsafe
ëë 
struct
ëë 
ParallelWriter
ëë +
{
íí 	
public
ññ 
readonly
ññ 
void
ññ  
*
ññ  !
Ptr
ññ" %
=>
ññ& (
ListData
ññ) 1
->
ññ1 3
Ptr
ññ3 6
;
ññ6 7
[
õõ /
!NativeDisableUnsafePtrRestriction
õõ .
]
õõ. /
public
úú 

UnsafeList
úú 
<
úú 
T
úú 
>
úú  
*
úú  !
ListData
úú" *
;
úú* +
internal
ûû 
unsafe
ûû 
ParallelWriter
ûû *
(
ûû* +

UnsafeList
ûû+ 5
<
ûû5 6
T
ûû6 7
>
ûû7 8
*
ûû8 9
listData
ûû: B
)
ûûB C
{
üü 
ListData
†† 
=
†† 
listData
†† #
;
††# $
}
°° 
[
´´ 
BurstCompatible
´´ 
(
´´ "
GenericTypeArguments
´´ 1
=
´´2 3
new
´´4 7
[
´´7 8
]
´´8 9
{
´´: ;
typeof
´´< B
(
´´B C
int
´´C F
)
´´F G
}
´´H I
)
´´I J
]
´´J K
public
¨¨ 
void
¨¨ 
AddNoResize
¨¨ #
(
¨¨# $
T
¨¨$ %
value
¨¨& +
)
¨¨+ ,
{
≠≠ 
var
ÆÆ 
idx
ÆÆ 
=
ÆÆ 
Interlocked
ÆÆ %
.
ÆÆ% &
	Increment
ÆÆ& /
(
ÆÆ/ 0
ref
ÆÆ0 3
ListData
ÆÆ4 <
->
ÆÆ< >
m_length
ÆÆ> F
)
ÆÆF G
-
ÆÆH I
$num
ÆÆJ K
;
ÆÆK L
ListData
ØØ 
->
ØØ ,
CheckNoResizeHasEnoughCapacity
ØØ 8
(
ØØ8 9
idx
ØØ9 <
,
ØØ< =
$num
ØØ> ?
)
ØØ? @
;
ØØ@ A
UnsafeUtility
∞∞ 
.
∞∞ 
WriteArrayElement
∞∞ /
(
∞∞/ 0
ListData
∞∞0 8
->
∞∞8 :
Ptr
∞∞: =
,
∞∞= >
idx
∞∞? B
,
∞∞B C
value
∞∞D I
)
∞∞I J
;
∞∞J K
}
±± 
[
ºº 
BurstCompatible
ºº 
(
ºº "
GenericTypeArguments
ºº 1
=
ºº2 3
new
ºº4 7
[
ºº7 8
]
ºº8 9
{
ºº: ;
typeof
ºº< B
(
ººB C
int
ººC F
)
ººF G
}
ººH I
)
ººI J
]
ººJ K
public
ΩΩ 
void
ΩΩ 
AddRangeNoResize
ΩΩ (
(
ΩΩ( )
void
ΩΩ) -
*
ΩΩ- .
ptr
ΩΩ/ 2
,
ΩΩ2 3
int
ΩΩ4 7
count
ΩΩ8 =
)
ΩΩ= >
{
ææ 
var
øø 
idx
øø 
=
øø 
Interlocked
øø %
.
øø% &
Add
øø& )
(
øø) *
ref
øø* -
ListData
øø. 6
->
øø6 8
m_length
øø8 @
,
øø@ A
count
øøB G
)
øøG H
-
øøI J
count
øøK P
;
øøP Q
ListData
¿¿ 
->
¿¿ ,
CheckNoResizeHasEnoughCapacity
¿¿ 8
(
¿¿8 9
idx
¿¿9 <
,
¿¿< =
count
¿¿> C
)
¿¿C D
;
¿¿D E
void
¡¡ 
*
¡¡ 
dst
¡¡ 
=
¡¡ 
(
¡¡ 
byte
¡¡ !
*
¡¡! "
)
¡¡" #
ListData
¡¡# +
->
¡¡+ -
Ptr
¡¡- 0
+
¡¡1 2
idx
¡¡3 6
*
¡¡7 8
sizeof
¡¡9 ?
(
¡¡? @
T
¡¡@ A
)
¡¡A B
;
¡¡B C
UnsafeUtility
¬¬ 
.
¬¬ 
MemCpy
¬¬ $
(
¬¬$ %
dst
¬¬% (
,
¬¬( )
ptr
¬¬* -
,
¬¬- .
count
¬¬/ 4
*
¬¬5 6
sizeof
¬¬7 =
(
¬¬= >
T
¬¬> ?
)
¬¬? @
)
¬¬@ A
;
¬¬A B
}
√√ 
[
ÕÕ 
BurstCompatible
ÕÕ 
(
ÕÕ "
GenericTypeArguments
ÕÕ 1
=
ÕÕ2 3
new
ÕÕ4 7
[
ÕÕ7 8
]
ÕÕ8 9
{
ÕÕ: ;
typeof
ÕÕ< B
(
ÕÕB C
int
ÕÕC F
)
ÕÕF G
}
ÕÕH I
)
ÕÕI J
]
ÕÕJ K
public
ŒŒ 
void
ŒŒ 
AddRangeNoResize
ŒŒ (
(
ŒŒ( )

UnsafeList
ŒŒ) 3
<
ŒŒ3 4
T
ŒŒ4 5
>
ŒŒ5 6
list
ŒŒ7 ;
)
ŒŒ; <
{
œœ 
AddRangeNoResize
––  
(
––  !
list
––! %
.
––% &
Ptr
––& )
,
––) *
list
––+ /
.
––/ 0
Length
––0 6
)
––6 7
;
––7 8
}
—— 
}
““ 	
public
ÿÿ 
void
ÿÿ 
CopyFrom
ÿÿ 
(
ÿÿ 

UnsafeList
ÿÿ '
<
ÿÿ' (
T
ÿÿ( )
>
ÿÿ) *
array
ÿÿ+ 0
)
ÿÿ0 1
{
ŸŸ 	
Resize
⁄⁄ 
(
⁄⁄ 
array
⁄⁄ 
.
⁄⁄ 
Length
⁄⁄ 
)
⁄⁄  
;
⁄⁄  !
UnsafeUtility
€€ 
.
€€ 
MemCpy
€€  
(
€€  !
Ptr
€€! $
,
€€$ %
array
€€& +
.
€€+ ,
Ptr
€€, /
,
€€/ 0
UnsafeUtility
€€1 >
.
€€> ?
SizeOf
€€? E
<
€€E F
T
€€F G
>
€€G H
(
€€H I
)
€€I J
*
€€K L
Length
€€M S
)
€€S T
;
€€T U
}
‹‹ 	
public
„„ 

Enumerator
„„ 
GetEnumerator
„„ '
(
„„' (
)
„„( )
{
‰‰ 	
return
ÂÂ 
new
ÂÂ 

Enumerator
ÂÂ !
{
ÂÂ" #
m_Ptr
ÂÂ$ )
=
ÂÂ* +
Ptr
ÂÂ, /
,
ÂÂ/ 0
m_Length
ÂÂ1 9
=
ÂÂ: ;
Length
ÂÂ< B
,
ÂÂB C
m_Index
ÂÂD K
=
ÂÂL M
-
ÂÂN O
$num
ÂÂO P
}
ÂÂQ R
;
ÂÂR S
}
ÊÊ 	
IEnumerator
ÌÌ 
IEnumerable
ÌÌ 
.
ÌÌ  
GetEnumerator
ÌÌ  -
(
ÌÌ- .
)
ÌÌ. /
{
ÓÓ 	
throw
ÔÔ 
new
ÔÔ %
NotImplementedException
ÔÔ -
(
ÔÔ- .
)
ÔÔ. /
;
ÔÔ/ 0
}
 	
IEnumerator
˜˜ 
<
˜˜ 
T
˜˜ 
>
˜˜ 
IEnumerable
˜˜ "
<
˜˜" #
T
˜˜# $
>
˜˜$ %
.
˜˜% &
GetEnumerator
˜˜& 3
(
˜˜3 4
)
˜˜4 5
{
¯¯ 	
throw
˘˘ 
new
˘˘ %
NotImplementedException
˘˘ -
(
˘˘- .
)
˘˘. /
;
˘˘/ 0
}
˙˙ 	
public
ÉÉ 
struct
ÉÉ 

Enumerator
ÉÉ  
:
ÉÉ! "
IEnumerator
ÉÉ# .
<
ÉÉ. /
T
ÉÉ/ 0
>
ÉÉ0 1
{
ÑÑ 	
internal
ÖÖ 
T
ÖÖ 
*
ÖÖ 
m_Ptr
ÖÖ 
;
ÖÖ 
internal
ÜÜ 
int
ÜÜ 
m_Length
ÜÜ !
;
ÜÜ! "
internal
áá 
int
áá 
m_Index
áá  
;
áá  !
public
åå 
void
åå 
Dispose
åå 
(
åå  
)
åå  !
{
åå" #
}
åå$ %
public
ïï 
bool
ïï 
MoveNext
ïï  
(
ïï  !
)
ïï! "
=>
ïï# %
++
ïï& (
m_Index
ïï( /
<
ïï0 1
m_Length
ïï2 :
;
ïï: ;
public
öö 
void
öö 
Reset
öö 
(
öö 
)
öö 
=>
öö  "
m_Index
öö# *
=
öö+ ,
-
öö- .
$num
öö. /
;
öö/ 0
public
†† 
T
†† 
Current
†† 
=>
†† 
m_Ptr
††  %
[
††% &
m_Index
††& -
]
††- .
;
††. /
object
¢¢ 
IEnumerator
¢¢ 
.
¢¢ 
Current
¢¢ &
=>
¢¢' )
Current
¢¢* 1
;
¢¢1 2
}
££ 	
[
•• 	
Conditional
••	 
(
•• 
$str
•• 6
)
••6 7
]
••7 8
internal
¶¶ 
static
¶¶ 
void
¶¶ 
	CheckNull
¶¶ &
(
¶¶& '
void
¶¶' +
*
¶¶+ ,
listData
¶¶- 5
)
¶¶5 6
{
ßß 	
if
®® 
(
®® 
listData
®® 
==
®® 
null
®®  
)
®®  !
{
©© 
throw
™™ 
new
™™ 
	Exception
™™ #
(
™™# $
$str
™™$ ]
)
™™] ^
;
™™^ _
}
´´ 
}
¨¨ 	
[
ÆÆ 	
Conditional
ÆÆ	 
(
ÆÆ 
$str
ÆÆ 6
)
ÆÆ6 7
]
ÆÆ7 8
void
ØØ 
CheckIndexCount
ØØ 
(
ØØ 
int
ØØ  
index
ØØ! &
,
ØØ& '
int
ØØ( +
count
ØØ, 1
)
ØØ1 2
{
∞∞ 	
if
±± 
(
±± 
count
±± 
<
±± 
$num
±± 
)
±± 
{
≤≤ 
throw
≥≥ 
new
≥≥ )
ArgumentOutOfRangeException
≥≥ 5
(
≥≥5 6
$"
≥≥6 8
$str
≥≥8 H
{
≥≥H I
count
≥≥I N
}
≥≥N O
$str
≥≥O a
"
≥≥a b
)
≥≥b c
;
≥≥c d
}
¥¥ 
if
∂∂ 
(
∂∂ 
index
∂∂ 
<
∂∂ 
$num
∂∂ 
)
∂∂ 
{
∑∑ 
throw
∏∏ 
new
∏∏ )
ArgumentOutOfRangeException
∏∏ 5
(
∏∏5 6
$"
∏∏6 8
$str
∏∏8 H
{
∏∏H I
index
∏∏I N
}
∏∏N O
$str
∏∏O a
"
∏∏a b
)
∏∏b c
;
∏∏c d
}
ππ 
if
ªª 
(
ªª 
index
ªª 
>
ªª 
Length
ªª 
)
ªª 
{
ºº 
throw
ΩΩ 
new
ΩΩ )
ArgumentOutOfRangeException
ΩΩ 5
(
ΩΩ5 6
$"
ΩΩ6 8
$str
ΩΩ8 H
{
ΩΩH I
index
ΩΩI N
}
ΩΩN O
$str
ΩΩO a
"
ΩΩa b
)
ΩΩb c
;
ΩΩc d
}
ææ 
if
¿¿ 
(
¿¿ 
index
¿¿ 
+
¿¿ 
count
¿¿ 
>
¿¿ 
Length
¿¿ $
)
¿¿$ %
{
¡¡ 
throw
¬¬ 
new
¬¬ )
ArgumentOutOfRangeException
¬¬ 5
(
¬¬5 6
$"
¬¬6 8
$str
¬¬8 H
{
¬¬H I
count
¬¬I N
}
¬¬N O
$str
¬¬O a
"
¬¬a b
)
¬¬b c
;
¬¬c d
}
√√ 
}
ƒƒ 	
[
∆∆ 	
Conditional
∆∆	 
(
∆∆ 
$str
∆∆ 6
)
∆∆6 7
]
∆∆7 8
void
«« 
CheckBeginEnd
«« 
(
«« 
int
«« 
begin
«« $
,
««$ %
int
««& )
end
««* -
)
««- .
{
»» 	
if
…… 
(
…… 
begin
…… 
>
…… 
end
…… 
)
…… 
{
   
throw
ÀÀ 
new
ÀÀ 
ArgumentException
ÀÀ +
(
ÀÀ+ ,
$"
ÀÀ, .
$str
ÀÀ. >
{
ÀÀ> ?
begin
ÀÀ? D
}
ÀÀD E
$str
ÀÀE f
{
ÀÀf g
end
ÀÀg j
}
ÀÀj k
$str
ÀÀk l
"
ÀÀl m
)
ÀÀm n
;
ÀÀn o
}
ÃÃ 
if
ŒŒ 
(
ŒŒ 
begin
ŒŒ 
<
ŒŒ 
$num
ŒŒ 
)
ŒŒ 
{
œœ 
throw
–– 
new
–– )
ArgumentOutOfRangeException
–– 5
(
––5 6
$"
––6 8
$str
––8 H
{
––H I
begin
––I N
}
––N O
$str
––O a
"
––a b
)
––b c
;
––c d
}
—— 
if
”” 
(
”” 
begin
”” 
>
”” 
Length
”” 
)
”” 
{
‘‘ 
throw
’’ 
new
’’ )
ArgumentOutOfRangeException
’’ 5
(
’’5 6
$"
’’6 8
$str
’’8 H
{
’’H I
begin
’’I N
}
’’N O
$str
’’O a
"
’’a b
)
’’b c
;
’’c d
}
÷÷ 
if
ÿÿ 
(
ÿÿ 
end
ÿÿ 
>
ÿÿ 
Length
ÿÿ 
)
ÿÿ 
{
ŸŸ 
throw
⁄⁄ 
new
⁄⁄ )
ArgumentOutOfRangeException
⁄⁄ 5
(
⁄⁄5 6
$"
⁄⁄6 8
$str
⁄⁄8 F
{
⁄⁄F G
end
⁄⁄G J
}
⁄⁄J K
$str
⁄⁄K ]
"
⁄⁄] ^
)
⁄⁄^ _
;
⁄⁄_ `
}
€€ 
}
‹‹ 	
[
ﬁﬁ 	
Conditional
ﬁﬁ	 
(
ﬁﬁ 
$str
ﬁﬁ 6
)
ﬁﬁ6 7
]
ﬁﬁ7 8
void
ﬂﬂ ,
CheckNoResizeHasEnoughCapacity
ﬂﬂ +
(
ﬂﬂ+ ,
int
ﬂﬂ, /
length
ﬂﬂ0 6
)
ﬂﬂ6 7
{
‡‡ 	,
CheckNoResizeHasEnoughCapacity
·· *
(
··* +
length
··+ 1
,
··1 2
Length
··3 9
)
··9 :
;
··: ;
}
‚‚ 	
[
‰‰ 	
Conditional
‰‰	 
(
‰‰ 
$str
‰‰ 6
)
‰‰6 7
]
‰‰7 8
void
ÂÂ ,
CheckNoResizeHasEnoughCapacity
ÂÂ +
(
ÂÂ+ ,
int
ÂÂ, /
length
ÂÂ0 6
,
ÂÂ6 7
int
ÂÂ8 ;
index
ÂÂ< A
)
ÂÂA B
{
ÊÊ 	
if
ÁÁ 
(
ÁÁ 
Capacity
ÁÁ 
<
ÁÁ 
index
ÁÁ  
+
ÁÁ! "
length
ÁÁ# )
)
ÁÁ) *
{
ËË 
throw
ÈÈ 
new
ÈÈ 
	Exception
ÈÈ #
(
ÈÈ# $
$"
ÈÈ$ &
$str
ÈÈ& e
{
ÈÈe f
Capacity
ÈÈf n
}
ÈÈn o
$str
ÈÈo x
{
ÈÈx y
Length
ÈÈy 
}ÈÈ Ä
$strÈÈÄ î
{ÈÈî ï
lengthÈÈï õ
}ÈÈõ ú
$strÈÈú ù
"ÈÈù û
)ÈÈû ü
;ÈÈü †
}
ÍÍ 
}
ÎÎ 	
}
ÏÏ 
[
ÒÒ 
BurstCompatible
ÒÒ 
]
ÒÒ 
public
ÚÚ 

unsafe
ÚÚ 
static
ÚÚ 
class
ÚÚ "
UnsafeListExtensions
ÚÚ 3
{
ÛÛ 
[
¸¸ 	
BurstCompatible
¸¸	 
(
¸¸ "
GenericTypeArguments
¸¸ -
=
¸¸. /
new
¸¸0 3
[
¸¸4 5
]
¸¸5 6
{
¸¸7 8
typeof
¸¸9 ?
(
¸¸? @
int
¸¸@ C
)
¸¸C D
,
¸¸D E
typeof
¸¸F L
(
¸¸L M
int
¸¸M P
)
¸¸P Q
}
¸¸R S
)
¸¸S T
]
¸¸T U
public
˝˝ 
static
˝˝ 
int
˝˝ 
IndexOf
˝˝ !
<
˝˝! "
T
˝˝" #
,
˝˝# $
U
˝˝% &
>
˝˝& '
(
˝˝' (
this
˝˝( ,

UnsafeList
˝˝- 7
<
˝˝7 8
T
˝˝8 9
>
˝˝9 :
list
˝˝; ?
,
˝˝? @
U
˝˝A B
value
˝˝C H
)
˝˝H I
where
˝˝J O
T
˝˝P Q
:
˝˝R S
	unmanaged
˝˝T ]
,
˝˝] ^

IEquatable
˝˝_ i
<
˝˝i j
U
˝˝j k
>
˝˝k l
{
˛˛ 	
return
ˇˇ #
NativeArrayExtensions
ˇˇ (
.
ˇˇ( )
IndexOf
ˇˇ) 0
<
ˇˇ0 1
T
ˇˇ1 2
,
ˇˇ2 3
U
ˇˇ4 5
>
ˇˇ5 6
(
ˇˇ6 7
list
ˇˇ7 ;
.
ˇˇ; <
Ptr
ˇˇ< ?
,
ˇˇ? @
list
ˇˇA E
.
ˇˇE F
Length
ˇˇF L
,
ˇˇL M
value
ˇˇN S
)
ˇˇS T
;
ˇˇT U
}
ÄÄ 	
[
ää 	
BurstCompatible
ää	 
(
ää "
GenericTypeArguments
ää -
=
ää. /
new
ää0 3
[
ää4 5
]
ää5 6
{
ää7 8
typeof
ää9 ?
(
ää? @
int
ää@ C
)
ääC D
,
ääD E
typeof
ääF L
(
ääL M
int
ääM P
)
ääP Q
}
ääR S
)
ääS T
]
ääT U
public
ãã 
static
ãã 
bool
ãã 
Contains
ãã #
<
ãã# $
T
ãã$ %
,
ãã% &
U
ãã' (
>
ãã( )
(
ãã) *
this
ãã* .

UnsafeList
ãã/ 9
<
ãã9 :
T
ãã: ;
>
ãã; <
list
ãã= A
,
ããA B
U
ããC D
value
ããE J
)
ããJ K
where
ããL Q
T
ããR S
:
ããT U
	unmanaged
ããV _
,
ãã_ `

IEquatable
ããa k
<
ããk l
U
ããl m
>
ããm n
{
åå 	
return
çç 
list
çç 
.
çç 
IndexOf
çç 
(
çç  
value
çç  %
)
çç% &
!=
çç' )
-
çç* +
$num
çç+ ,
;
çç, -
}
éé 	
[
òò 	
BurstCompatible
òò	 
(
òò "
GenericTypeArguments
òò -
=
òò. /
new
òò0 3
[
òò4 5
]
òò5 6
{
òò7 8
typeof
òò9 ?
(
òò? @
int
òò@ C
)
òòC D
,
òòD E
typeof
òòF L
(
òòL M
int
òòM P
)
òòP Q
}
òòR S
)
òòS T
]
òòT U
public
ôô 
static
ôô 
int
ôô 
IndexOf
ôô !
<
ôô! "
T
ôô" #
,
ôô# $
U
ôô% &
>
ôô& '
(
ôô' (
this
ôô( ,

UnsafeList
ôô- 7
<
ôô7 8
T
ôô8 9
>
ôô9 :
.
ôô: ;
ParallelReader
ôô; I
list
ôôJ N
,
ôôN O
U
ôôP Q
value
ôôR W
)
ôôW X
where
ôôY ^
T
ôô_ `
:
ôôa b
	unmanaged
ôôc l
,
ôôl m

IEquatable
ôôn x
<
ôôx y
U
ôôy z
>
ôôz {
{
öö 	
return
õõ #
NativeArrayExtensions
õõ (
.
õõ( )
IndexOf
õõ) 0
<
õõ0 1
T
õõ1 2
,
õõ2 3
U
õõ4 5
>
õõ5 6
(
õõ6 7
list
õõ7 ;
.
õõ; <
Ptr
õõ< ?
,
õõ? @
list
õõA E
.
õõE F
Length
õõF L
,
õõL M
value
õõN S
)
õõS T
;
õõT U
}
úú 	
[
¶¶ 	
BurstCompatible
¶¶	 
(
¶¶ "
GenericTypeArguments
¶¶ -
=
¶¶. /
new
¶¶0 3
[
¶¶4 5
]
¶¶5 6
{
¶¶7 8
typeof
¶¶9 ?
(
¶¶? @
int
¶¶@ C
)
¶¶C D
,
¶¶D E
typeof
¶¶F L
(
¶¶L M
int
¶¶M P
)
¶¶P Q
}
¶¶R S
)
¶¶S T
]
¶¶T U
public
ßß 
static
ßß 
bool
ßß 
Contains
ßß #
<
ßß# $
T
ßß$ %
,
ßß% &
U
ßß' (
>
ßß( )
(
ßß) *
this
ßß* .

UnsafeList
ßß/ 9
<
ßß9 :
T
ßß: ;
>
ßß; <
.
ßß< =
ParallelReader
ßß= K
list
ßßL P
,
ßßP Q
U
ßßR S
value
ßßT Y
)
ßßY Z
where
ßß[ `
T
ßßa b
:
ßßc d
	unmanaged
ßße n
,
ßßn o

IEquatable
ßßp z
<
ßßz {
U
ßß{ |
>
ßß| }
{
®® 	
return
©© 
list
©© 
.
©© 
IndexOf
©© 
(
©©  
value
©©  %
)
©©% &
!=
©©' )
-
©©* +
$num
©©+ ,
;
©©, -
}
™™ 	
[
¥¥ 	
BurstCompatible
¥¥	 
(
¥¥ "
GenericTypeArguments
¥¥ -
=
¥¥. /
new
¥¥0 3
[
¥¥4 5
]
¥¥5 6
{
¥¥7 8
typeof
¥¥9 ?
(
¥¥? @
int
¥¥@ C
)
¥¥C D
}
¥¥E F
)
¥¥F G
]
¥¥G H
public
µµ 
static
µµ 
bool
µµ 
ArraysEqual
µµ &
<
µµ& '
T
µµ' (
>
µµ( )
(
µµ) *
this
µµ* .

UnsafeList
µµ/ 9
<
µµ9 :
T
µµ: ;
>
µµ; <
array
µµ= B
,
µµB C

UnsafeList
µµD N
<
µµN O
T
µµO P
>
µµP Q
other
µµR W
)
µµW X
where
µµY ^
T
µµ_ `
:
µµa b
	unmanaged
µµc l
,
µµl m

IEquatable
µµn x
<
µµx y
T
µµy z
>
µµz {
{
∂∂ 	
if
∑∑ 
(
∑∑ 
array
∑∑ 
.
∑∑ 
Length
∑∑ 
!=
∑∑ 
other
∑∑  %
.
∑∑% &
Length
∑∑& ,
)
∑∑, -
return
∏∏ 
false
∏∏ 
;
∏∏ 
for
∫∫ 
(
∫∫ 
int
∫∫ 
i
∫∫ 
=
∫∫ 
$num
∫∫ 
;
∫∫ 
i
∫∫ 
!=
∫∫  
array
∫∫! &
.
∫∫& '
Length
∫∫' -
;
∫∫- .
i
∫∫/ 0
++
∫∫0 2
)
∫∫2 3
{
ªª 
if
ºº 
(
ºº 
!
ºº 
array
ºº 
[
ºº 
i
ºº 
]
ºº 
.
ºº 
Equals
ºº $
(
ºº$ %
other
ºº% *
[
ºº* +
i
ºº+ ,
]
ºº, -
)
ºº- .
)
ºº. /
return
ΩΩ 
false
ΩΩ  
;
ΩΩ  !
}
ææ 
return
¿¿ 
true
¿¿ 
;
¿¿ 
}
¡¡ 	
}
√√ 
internal
≈≈ 
sealed
≈≈ 
class
≈≈ "
UnsafeListTDebugView
≈≈ .
<
≈≈. /
T
≈≈/ 0
>
≈≈0 1
where
∆∆ 
T
∆∆ 
:
∆∆ 
	unmanaged
∆∆ 
{
«« 

UnsafeList
»» 
<
»» 
T
»» 
>
»» 
Data
»» 
;
»» 
public
   "
UnsafeListTDebugView
   #
(
  # $

UnsafeList
  $ .
<
  . /
T
  / 0
>
  0 1
data
  2 6
)
  6 7
{
ÀÀ 	
Data
ÃÃ 
=
ÃÃ 
data
ÃÃ 
;
ÃÃ 
}
ÕÕ 	
public
œœ 
unsafe
œœ 
T
œœ 
[
œœ 
]
œœ 
Items
œœ 
{
–– 	
get
—— 
{
““ 
T
”” 
[
”” 
]
”” 
result
”” 
=
”” 
new
””  
T
””! "
[
””" #
Data
””# '
.
””' (
Length
””( .
]
””. /
;
””/ 0
for
’’ 
(
’’ 
var
’’ 
i
’’ 
=
’’ 
$num
’’ 
;
’’ 
i
’’  !
<
’’" #
result
’’$ *
.
’’* +
Length
’’+ 1
;
’’1 2
++
’’3 5
i
’’5 6
)
’’6 7
{
÷÷ 
result
◊◊ 
[
◊◊ 
i
◊◊ 
]
◊◊ 
=
◊◊ 
Data
◊◊  $
.
◊◊$ %
Ptr
◊◊% (
[
◊◊( )
i
◊◊) *
]
◊◊* +
;
◊◊+ ,
}
ÿÿ 
return
⁄⁄ 
result
⁄⁄ 
;
⁄⁄ 
}
€€ 
}
‹‹ 	
}
›› 
[
„„ 
DebuggerDisplay
„„ 
(
„„ 
$str
„„ m
)
„„m n
]
„„n o
[
‰‰ 
DebuggerTypeProxy
‰‰ 
(
‰‰ 
typeof
‰‰ 
(
‰‰ %
UnsafePtrListTDebugView
‰‰ 5
<
‰‰5 6
>
‰‰6 7
)
‰‰7 8
)
‰‰8 9
]
‰‰9 :
[
ÂÂ 
StructLayout
ÂÂ 
(
ÂÂ 

LayoutKind
ÂÂ 
.
ÂÂ 

Sequential
ÂÂ '
)
ÂÂ' (
]
ÂÂ( )
[
ÊÊ 
BurstCompatible
ÊÊ 
(
ÊÊ "
GenericTypeArguments
ÊÊ )
=
ÊÊ* +
new
ÊÊ, /
[
ÊÊ/ 0
]
ÊÊ0 1
{
ÊÊ2 3
typeof
ÊÊ4 :
(
ÊÊ: ;
int
ÊÊ; >
)
ÊÊ> ?
}
ÊÊ@ A
)
ÊÊA B
]
ÊÊB C
public
ÁÁ 

unsafe
ÁÁ 
struct
ÁÁ 
UnsafePtrList
ÁÁ &
<
ÁÁ& '
T
ÁÁ' (
>
ÁÁ( )
:
ËË 	
INativeDisposable
ËË
 
,
ÍÍ 	
IEnumerable
ÍÍ
 
<
ÍÍ 
IntPtr
ÍÍ 
>
ÍÍ 
where
ÎÎ 
T
ÎÎ 
:
ÎÎ 
	unmanaged
ÎÎ 
{
ÏÏ 
[
 	/
!NativeDisableUnsafePtrRestriction
	 *
]
* +
public
ÒÒ 
readonly
ÒÒ 
T
ÒÒ 
*
ÒÒ 
*
ÒÒ 
Ptr
ÒÒ 
;
ÒÒ  
public
ˆˆ 
readonly
ˆˆ 
int
ˆˆ 
m_length
ˆˆ $
;
ˆˆ$ %
public
˚˚ 
readonly
˚˚ 
int
˚˚ 

m_capacity
˚˚ &
;
˚˚& '
public
Ä	Ä	 
readonly
Ä	Ä	 
AllocatorManager
Ä	Ä	 (
.
Ä	Ä	( )
AllocatorHandle
Ä	Ä	) 8
	Allocator
Ä	Ä	9 B
;
Ä	Ä	B C
[
Ç	Ç	 	
Obsolete
Ç	Ç		 
(
Ç	Ç	 
$str
Ç	Ç	 C
,
Ç	Ç	C D
true
Ç	Ç	E I
)
Ç	Ç	I J
]
Ç	Ç	J K
public
É	É	 
int
É	É	 
length
É	É	 
;
É	É	 
[
Ö	Ö	 	
Obsolete
Ö	Ö		 
(
Ö	Ö	 
$str
Ö	Ö	 G
,
Ö	Ö	G H
true
Ö	Ö	I M
)
Ö	Ö	M N
]
Ö	Ö	N O
public
Ü	Ü	 
int
Ü	Ü	 
capacity
Ü	Ü	 
;
Ü	Ü	 
public
å	å	 
int
å	å	 
Length
å	å	 
{
ç	ç	 	
get
é	é	 
{
è	è	 
return
ê	ê	 
this
ê	ê	 
.
ê	ê	 
ListData
ê	ê	 $
(
ê	ê	$ %
)
ê	ê	% &
.
ê	ê	& '
Length
ê	ê	' -
;
ê	ê	- .
}
ë	ë	 
set
ì	ì	 
{
î	î	 
this
ï	ï	 
.
ï	ï	 
ListData
ï	ï	 
(
ï	ï	 
)
ï	ï	 
.
ï	ï	  
Length
ï	ï	  &
=
ï	ï	' (
value
ï	ï	) .
;
ï	ï	. /
}
ñ	ñ	 
}
ó	ó	 	
public
ù	ù	 
int
ù	ù	 
Capacity
ù	ù	 
{
û	û	 	
get
ü	ü	 
{
†	†	 
return
°	°	 
this
°	°	 
.
°	°	 
ListData
°	°	 $
(
°	°	$ %
)
°	°	% &
.
°	°	& '
Capacity
°	°	' /
;
°	°	/ 0
}
¢	¢	 
set
§	§	 
{
•	•	 
this
¶	¶	 
.
¶	¶	 
ListData
¶	¶	 
(
¶	¶	 
)
¶	¶	 
.
¶	¶	  
Capacity
¶	¶	  (
=
¶	¶	) *
value
¶	¶	+ 0
;
¶	¶	0 1
}
ß	ß	 
}
®	®	 	
public
Ø	Ø	 
T
Ø	Ø	 
*
Ø	Ø	 
this
Ø	Ø	 
[
Ø	Ø	 
int
Ø	Ø	 
index
Ø	Ø	  
]
Ø	Ø	  !
{
∞	∞	 	
get
±	±	 
{
≤	≤	 
CollectionHelper
≥	≥	  
.
≥	≥	  !
CheckIndexInRange
≥	≥	! 2
(
≥	≥	2 3
index
≥	≥	3 8
,
≥	≥	8 9
Length
≥	≥	: @
)
≥	≥	@ A
;
≥	≥	A B
return
¥	¥	 
Ptr
¥	¥	 
[
¥	¥	 
CollectionHelper
¥	¥	 +
.
¥	¥	+ ,
AssumePositive
¥	¥	, :
(
¥	¥	: ;
index
¥	¥	; @
)
¥	¥	@ A
]
¥	¥	A B
;
¥	¥	B C
}
µ	µ	 
set
∑	∑	 
{
∏	∏	 
CollectionHelper
π	π	  
.
π	π	  !
CheckIndexInRange
π	π	! 2
(
π	π	2 3
index
π	π	3 8
,
π	π	8 9
Length
π	π	: @
)
π	π	@ A
;
π	π	A B
Ptr
∫	∫	 
[
∫	∫	 
CollectionHelper
∫	∫	 $
.
∫	∫	$ %
AssumePositive
∫	∫	% 3
(
∫	∫	3 4
index
∫	∫	4 9
)
∫	∫	9 :
]
∫	∫	: ;
=
∫	∫	< =
value
∫	∫	> C
;
∫	∫	C D
}
ª	ª	 
}
º	º	 	
public
√	√	 
ref
√	√	 
T
√	√	 
*
√	√	 
	ElementAt
√	√	 
(
√	√	  
int
√	√	  #
index
√	√	$ )
)
√	√	) *
{
ƒ	ƒ	 	
CollectionHelper
≈	≈	 
.
≈	≈	 
CheckIndexInRange
≈	≈	 .
(
≈	≈	. /
index
≈	≈	/ 4
,
≈	≈	4 5
Length
≈	≈	6 <
)
≈	≈	< =
;
≈	≈	= >
return
∆	∆	 
ref
∆	∆	 
Ptr
∆	∆	 
[
∆	∆	 
CollectionHelper
∆	∆	 +
.
∆	∆	+ ,
AssumePositive
∆	∆	, :
(
∆	∆	: ;
index
∆	∆	; @
)
∆	∆	@ A
]
∆	∆	A B
;
∆	∆	B C
}
«	«	 	
public
Œ	Œ	 
unsafe
Œ	Œ	 
UnsafePtrList
Œ	Œ	 #
(
Œ	Œ	# $
T
Œ	Œ	$ %
*
Œ	Œ	% &
*
Œ	Œ	& '
ptr
Œ	Œ	( +
,
Œ	Œ	+ ,
int
Œ	Œ	- 0
length
Œ	Œ	1 7
)
Œ	Œ	7 8
:
Œ	Œ	9 :
this
Œ	Œ	; ?
(
Œ	Œ	? @
)
Œ	Œ	@ A
{
œ	œ	 	
Ptr
–	–	 
=
–	–	 
ptr
–	–	 
;
–	–	 
this
—	—	 
.
—	—	 
m_length
—	—	 
=
—	—	 
length
—	—	 "
;
—	—	" #
this
“	“	 
.
“	“	 

m_capacity
“	“	 
=
“	“	 
length
“	“	 $
;
“	“	$ %
	Allocator
”	”	 
=
”	”	 
AllocatorManager
”	”	 (
.
”	”	( )
None
”	”	) -
;
”	”	- .
}
‘	‘	 	
public
‹	‹	 
unsafe
‹	‹	 
UnsafePtrList
‹	‹	 #
(
‹	‹	# $
int
‹	‹	$ '
initialCapacity
‹	‹	( 7
,
‹	‹	7 8
AllocatorManager
‹	‹	9 I
.
‹	‹	I J
AllocatorHandle
‹	‹	J Y
	allocator
‹	‹	Z c
,
‹	‹	c d 
NativeArrayOptions
‹	‹	e w
options
‹	‹	x 
=‹	‹	Ä Å"
NativeArrayOptions‹	‹	Ç î
.‹	‹	î ï#
UninitializedMemory‹	‹	ï ®
)‹	‹	® ©
:‹	‹	™ ´
this‹	‹	¨ ∞
(‹	‹	∞ ±
)‹	‹	± ≤
{
›	›	 	
Ptr
ﬁ	ﬁ	 
=
ﬁ	ﬁ	 
null
ﬁ	ﬁ	 
;
ﬁ	ﬁ	 
m_length
ﬂ	ﬂ	 
=
ﬂ	ﬂ	 
$num
ﬂ	ﬂ	 
;
ﬂ	ﬂ	 

m_capacity
‡	‡	 
=
‡	‡	 
$num
‡	‡	 
;
‡	‡	 
	Allocator
·	·	 
=
·	·	 
AllocatorManager
·	·	 (
.
·	·	( )
None
·	·	) -
;
·	·	- .
this
„	„	 
.
„	„	 
ListData
„	„	 
(
„	„	 
)
„	„	 
=
„	„	 
new
„	„	 !

UnsafeList
„	„	" ,
<
„	„	, -
IntPtr
„	„	- 3
>
„	„	3 4
(
„	„	4 5
initialCapacity
„	„	5 D
,
„	„	D E
	allocator
„	„	F O
,
„	„	O P
options
„	„	Q X
)
„	„	X Y
;
„	„	Y Z
}
‰	‰	 	
public
Ï	Ï	 
static
Ï	Ï	 
UnsafePtrList
Ï	Ï	 #
<
Ï	Ï	# $
T
Ï	Ï	$ %
>
Ï	Ï	% &
*
Ï	Ï	& '
Create
Ï	Ï	( .
(
Ï	Ï	. /
T
Ï	Ï	/ 0
*
Ï	Ï	0 1
*
Ï	Ï	1 2
ptr
Ï	Ï	3 6
,
Ï	Ï	6 7
int
Ï	Ï	8 ;
length
Ï	Ï	< B
)
Ï	Ï	B C
{
Ì	Ì	 	
UnsafePtrList
Ó	Ó	 
<
Ó	Ó	 
T
Ó	Ó	 
>
Ó	Ó	 
*
Ó	Ó	 
listData
Ó	Ó	 &
=
Ó	Ó	' (
AllocatorManager
Ó	Ó	) 9
.
Ó	Ó	9 :
Allocate
Ó	Ó	: B
<
Ó	Ó	B C
UnsafePtrList
Ó	Ó	C P
<
Ó	Ó	P Q
T
Ó	Ó	Q R
>
Ó	Ó	R S
>
Ó	Ó	S T
(
Ó	Ó	T U
AllocatorManager
Ó	Ó	U e
.
Ó	Ó	e f

Persistent
Ó	Ó	f p
)
Ó	Ó	p q
;
Ó	Ó	q r
*
Ô	Ô	 
listData
Ô	Ô	 
=
Ô	Ô	 
new
Ô	Ô	 
UnsafePtrList
Ô	Ô	 )
<
Ô	Ô	) *
T
Ô	Ô	* +
>
Ô	Ô	+ ,
(
Ô	Ô	, -
ptr
Ô	Ô	- 0
,
Ô	Ô	0 1
length
Ô	Ô	2 8
)
Ô	Ô	8 9
;
Ô	Ô	9 :
return
		 
listData
		 
;
		 
}
Ò	Ò	 	
public
˙	˙	 
static
˙	˙	 
UnsafePtrList
˙	˙	 #
<
˙	˙	# $
T
˙	˙	$ %
>
˙	˙	% &
*
˙	˙	& '
Create
˙	˙	( .
(
˙	˙	. /
int
˙	˙	/ 2
initialCapacity
˙	˙	3 B
,
˙	˙	B C
AllocatorManager
˙	˙	D T
.
˙	˙	T U
AllocatorHandle
˙	˙	U d
	allocator
˙	˙	e n
,
˙	˙	n o!
NativeArrayOptions˙	˙	p Ç
options˙	˙	É ä
=˙	˙	ã å"
NativeArrayOptions˙	˙	ç ü
.˙	˙	ü †#
UninitializedMemory˙	˙	† ≥
)˙	˙	≥ ¥
{
˚	˚	 	
UnsafePtrList
¸	¸	 
<
¸	¸	 
T
¸	¸	 
>
¸	¸	 
*
¸	¸	 
listData
¸	¸	 &
=
¸	¸	' (
AllocatorManager
¸	¸	) 9
.
¸	¸	9 :
Allocate
¸	¸	: B
<
¸	¸	B C
UnsafePtrList
¸	¸	C P
<
¸	¸	P Q
T
¸	¸	Q R
>
¸	¸	R S
>
¸	¸	S T
(
¸	¸	T U
	allocator
¸	¸	U ^
)
¸	¸	^ _
;
¸	¸	_ `
*
˝	˝	 
listData
˝	˝	 
=
˝	˝	 
new
˝	˝	 
UnsafePtrList
˝	˝	 )
<
˝	˝	) *
T
˝	˝	* +
>
˝	˝	+ ,
(
˝	˝	, -
initialCapacity
˝	˝	- <
,
˝	˝	< =
	allocator
˝	˝	> G
,
˝	˝	G H
options
˝	˝	I P
)
˝	˝	P Q
;
˝	˝	Q R
return
˛	˛	 
listData
˛	˛	 
;
˛	˛	 
}
ˇ	ˇ	 	
public
Ö
Ö
 
static
Ö
Ö
 
void
Ö
Ö
 
Destroy
Ö
Ö
 "
(
Ö
Ö
" #
UnsafePtrList
Ö
Ö
# 0
<
Ö
Ö
0 1
T
Ö
Ö
1 2
>
Ö
Ö
2 3
*
Ö
Ö
3 4
listData
Ö
Ö
5 =
)
Ö
Ö
= >
{
Ü
Ü
 	

UnsafeList
á
á
 
<
á
á
 
IntPtr
á
á
 
>
á
á
 
.
á
á
 
	CheckNull
á
á
 (
(
á
á
( )
listData
á
á
) 1
)
á
á
1 2
;
á
á
2 3
var
à
à
 
	allocator
à
à
 
=
à
à
 
listData
à
à
 $
->
à
à
$ &
ListData
à
à
& .
(
à
à
. /
)
à
à
/ 0
.
à
à
0 1
	Allocator
à
à
1 :
.
à
à
: ;
Value
à
à
; @
==
à
à
A C
AllocatorManager
à
à
D T
.
à
à
T U
Invalid
à
à
U \
.
à
à
\ ]
Value
à
à
] b
?
â
â
 
AllocatorManager
â
â
 "
.
â
â
" #

Persistent
â
â
# -
:
ä
ä
 
listData
ä
ä
 
->
ä
ä
 
ListData
ä
ä
 $
(
ä
ä
$ %
)
ä
ä
% &
.
ä
ä
& '
	Allocator
ä
ä
' 0
;
ã
ã
 
listData
å
å
 
->
å
å
 
Dispose
å
å
 
(
å
å
 
)
å
å
 
;
å
å
  
AllocatorManager
ç
ç
 
.
ç
ç
 
Free
ç
ç
 !
(
ç
ç
! "
	allocator
ç
ç
" +
,
ç
ç
+ ,
listData
ç
ç
- 5
)
ç
ç
5 6
;
ç
ç
6 7
}
é
é
 	
public
î
î
 
bool
î
î
 
IsEmpty
î
î
 
=>
î
î
 
!
î
î
  
	IsCreated
î
î
  )
||
î
î
* ,
Length
î
î
- 3
==
î
î
4 6
$num
î
î
7 8
;
î
î
8 9
public
ö
ö
 
bool
ö
ö
 
	IsCreated
ö
ö
 
=>
ö
ö
  
Ptr
ö
ö
! $
!=
ö
ö
% '
null
ö
ö
( ,
;
ö
ö
, -
public
ü
ü
 
void
ü
ü
 
Dispose
ü
ü
 
(
ü
ü
 
)
ü
ü
 
{
†
†
 	
this
°
°
 
.
°
°
 
ListData
°
°
 
(
°
°
 
)
°
°
 
.
°
°
 
Dispose
°
°
 #
(
°
°
# $
)
°
°
$ %
;
°
°
% &
}
¢
¢
 	
[
©
©
 	 
NotBurstCompatible
©
©
	 
]©
©
ú ù
public
™
™
 
	JobHandle
™
™
 
Dispose
™
™
  
(
™
™
  !
	JobHandle
™
™
! *
	inputDeps
™
™
+ 4
)
™
™
4 5
=>
™
™
6 8
this
™
™
9 =
.
™
™
= >
ListData
™
™
> F
(
™
™
F G
)
™
™
G H
.
™
™
H I
Dispose
™
™
I P
(
™
™
P Q
	inputDeps
™
™
Q Z
)
™
™
Z [
;
™
™
[ \
public
∞
∞
 
void
∞
∞
 
Clear
∞
∞
 
(
∞
∞
 
)
∞
∞
 
=>
∞
∞
 
this
∞
∞
 #
.
∞
∞
# $
ListData
∞
∞
$ ,
(
∞
∞
, -
)
∞
∞
- .
.
∞
∞
. /
Clear
∞
∞
/ 4
(
∞
∞
4 5
)
∞
∞
5 6
;
∞
∞
6 7
public
∑
∑
 
void
∑
∑
 
Resize
∑
∑
 
(
∑
∑
 
int
∑
∑
 
length
∑
∑
 %
,
∑
∑
% & 
NativeArrayOptions
∑
∑
' 9
options
∑
∑
: A
=
∑
∑
B C 
NativeArrayOptions
∑
∑
D V
.
∑
∑
V W!
UninitializedMemory
∑
∑
W j
)
∑
∑
j k
=>
∑
∑
l n
this
∑
∑
o s
.
∑
∑
s t
ListData
∑
∑
t |
(
∑
∑
| }
)
∑
∑
} ~
.
∑
∑
~ 
Resize∑
∑
 Ö
(∑
∑
Ö Ü
length∑
∑
Ü å
,∑
∑
å ç
options∑
∑
é ï
)∑
∑
ï ñ
;∑
∑
ñ ó
public
Ω
Ω
 
void
Ω
Ω
 
SetCapacity
Ω
Ω
 
(
Ω
Ω
  
int
Ω
Ω
  #
capacity
Ω
Ω
$ ,
)
Ω
Ω
, -
=>
Ω
Ω
. 0
this
Ω
Ω
1 5
.
Ω
Ω
5 6
ListData
Ω
Ω
6 >
(
Ω
Ω
> ?
)
Ω
Ω
? @
.
Ω
Ω
@ A
SetCapacity
Ω
Ω
A L
(
Ω
Ω
L M
capacity
Ω
Ω
M U
)
Ω
Ω
U V
;
Ω
Ω
V W
public
¬
¬
 
void
¬
¬
 

TrimExcess
¬
¬
 
(
¬
¬
 
)
¬
¬
  
=>
¬
¬
! #
this
¬
¬
$ (
.
¬
¬
( )
ListData
¬
¬
) 1
(
¬
¬
1 2
)
¬
¬
2 3
.
¬
¬
3 4

TrimExcess
¬
¬
4 >
(
¬
¬
> ?
)
¬
¬
? @
;
¬
¬
@ A
public
…
…
 
int
…
…
 
IndexOf
…
…
 
(
…
…
 
void
…
…
 
*
…
…
  
ptr
…
…
! $
)
…
…
$ %
{
 
 
 	
for
À
À
 
(
À
À
 
int
À
À
 
i
À
À
 
=
À
À
 
$num
À
À
 
;
À
À
 
i
À
À
 
<
À
À
 
Length
À
À
  &
;
À
À
& '
++
À
À
( *
i
À
À
* +
)
À
À
+ ,
{
Ã
Ã
 
if
Õ
Õ
 
(
Õ
Õ
 
Ptr
Õ
Õ
 
[
Õ
Õ
 
i
Õ
Õ
 
]
Õ
Õ
 
==
Õ
Õ
 
ptr
Õ
Õ
 !
)
Õ
Õ
! "
return
Õ
Õ
# )
i
Õ
Õ
* +
;
Õ
Õ
+ ,
}
Œ
Œ
 
return
–
–
 
-
–
–
 
$num
–
–
 
;
–
–
 
}
—
—
 	
public
ÿ
ÿ
 
bool
ÿ
ÿ
 
Contains
ÿ
ÿ
 
(
ÿ
ÿ
 
void
ÿ
ÿ
 !
*
ÿ
ÿ
! "
ptr
ÿ
ÿ
# &
)
ÿ
ÿ
& '
{
Ÿ
Ÿ
 	
return
⁄
⁄
 
IndexOf
⁄
⁄
 
(
⁄
⁄
 
ptr
⁄
⁄
 
)
⁄
⁄
 
!=
⁄
⁄
  "
-
⁄
⁄
# $
$num
⁄
⁄
$ %
;
⁄
⁄
% &
}
€
€
 	
public
Â
Â
 
void
Â
Â
 
AddNoResize
Â
Â
 
(
Â
Â
  
void
Â
Â
  $
*
Â
Â
$ %
value
Â
Â
& +
)
Â
Â
+ ,
{
Ê
Ê
 	
this
Á
Á
 
.
Á
Á
 
ListData
Á
Á
 
(
Á
Á
 
)
Á
Á
 
.
Á
Á
 
AddNoResize
Á
Á
 '
(
Á
Á
' (
(
Á
Á
( )
IntPtr
Á
Á
) /
)
Á
Á
/ 0
value
Á
Á
0 5
)
Á
Á
5 6
;
Á
Á
6 7
}
Ë
Ë
 	
public
Û
Û
 
void
Û
Û
 
AddRangeNoResize
Û
Û
 $
(
Û
Û
$ %
void
Û
Û
% )
*
Û
Û
) *
*
Û
Û
* +
ptr
Û
Û
, /
,
Û
Û
/ 0
int
Û
Û
1 4
count
Û
Û
5 :
)
Û
Û
: ;
=>
Û
Û
< >
this
Û
Û
? C
.
Û
Û
C D
ListData
Û
Û
D L
(
Û
Û
L M
)
Û
Û
M N
.
Û
Û
N O
AddRangeNoResize
Û
Û
O _
(
Û
Û
_ `
ptr
Û
Û
` c
,
Û
Û
c d
count
Û
Û
e j
)
Û
Û
j k
;
Û
Û
k l
public
˝
˝
 
void
˝
˝
 
AddRangeNoResize
˝
˝
 $
(
˝
˝
$ %
UnsafePtrList
˝
˝
% 2
<
˝
˝
2 3
T
˝
˝
3 4
>
˝
˝
4 5
list
˝
˝
6 :
)
˝
˝
: ;
=>
˝
˝
< >
this
˝
˝
? C
.
˝
˝
C D
ListData
˝
˝
D L
(
˝
˝
L M
)
˝
˝
M N
.
˝
˝
N O
AddRangeNoResize
˝
˝
O _
(
˝
˝
_ `
list
˝
˝
` d
.
˝
˝
d e
Ptr
˝
˝
e h
,
˝
˝
h i
list
˝
˝
j n
.
˝
˝
n o
Length
˝
˝
o u
)
˝
˝
u v
;
˝
˝
v w
public
ÜÜ 
void
ÜÜ 
Add
ÜÜ 
(
ÜÜ 
in
ÜÜ 
IntPtr
ÜÜ !
value
ÜÜ" '
)
ÜÜ' (
{
áá 	
this
àà 
.
àà 
ListData
àà 
(
àà 
)
àà 
.
àà 
Add
àà 
(
àà  
value
àà  %
)
àà% &
;
àà& '
}
ââ 	
public
íí 
void
íí 
Add
íí 
(
íí 
void
íí 
*
íí 
value
íí #
)
íí# $
{
ìì 	
this
îî 
.
îî 
ListData
îî 
(
îî 
)
îî 
.
îî 
Add
îî 
(
îî  
(
îî  !
IntPtr
îî! '
)
îî' (
value
îî( -
)
îî- .
;
îî. /
}
ïï 	
public
úú 
void
úú 
AddRange
úú 
(
úú 
void
úú !
*
úú! "
ptr
úú# &
,
úú& '
int
úú( +
length
úú, 2
)
úú2 3
=>
úú4 6
this
úú7 ;
.
úú; <
ListData
úú< D
(
úúD E
)
úúE F
.
úúF G
AddRange
úúG O
(
úúO P
ptr
úúP S
,
úúS T
length
úúU [
)
úú[ \
;
úú\ ]
public
•• 
void
•• 
AddRange
•• 
(
•• 
UnsafePtrList
•• *
<
••* +
T
••+ ,
>
••, -
list
••. 2
)
••2 3
=>
••4 6
this
••7 ;
.
••; <
ListData
••< D
(
••D E
)
••E F
.
••F G
AddRange
••G O
(
••O P
list
••P T
.
••T U
ListData
••U ]
(
••] ^
)
••^ _
)
••_ `
;
••` a
public
ππ 
void
ππ %
InsertRangeWithBeginEnd
ππ +
(
ππ+ ,
int
ππ, /
begin
ππ0 5
,
ππ5 6
int
ππ7 :
end
ππ; >
)
ππ> ?
=>
ππ@ B
this
ππC G
.
ππG H
ListData
ππH P
(
ππP Q
)
ππQ R
.
ππR S%
InsertRangeWithBeginEnd
ππS j
(
ππj k
begin
ππk p
,
ππp q
end
ππr u
)
ππu v
;
ππv w
public
¡¡ 
void
¡¡ 
RemoveAtSwapBack
¡¡ $
(
¡¡$ %
int
¡¡% (
index
¡¡) .
)
¡¡. /
=>
¡¡0 2
this
¡¡3 7
.
¡¡7 8
ListData
¡¡8 @
(
¡¡@ A
)
¡¡A B
.
¡¡B C
RemoveAtSwapBack
¡¡C S
(
¡¡S T
index
¡¡T Y
)
¡¡Y Z
;
¡¡Z [
public
œœ 
void
œœ !
RemoveRangeSwapBack
œœ '
(
œœ' (
int
œœ( +
index
œœ, 1
,
œœ1 2
int
œœ3 6
count
œœ7 <
)
œœ< =
=>
œœ> @
this
œœA E
.
œœE F
ListData
œœF N
(
œœN O
)
œœO P
.
œœP Q!
RemoveRangeSwapBack
œœQ d
(
œœd e
index
œœe j
,
œœj k
count
œœl q
)
œœq r
;
œœr s
[
ﬁﬁ 	
Obsolete
ﬁﬁ	 
(
ﬁﬁ 
$strﬁﬁ ó
,ﬁﬁó ò
falseﬁﬁô û
)ﬁﬁû ü
]ﬁﬁü †
public
ﬂﬂ 
void
ﬂﬂ -
RemoveRangeSwapBackWithBeginEnd
ﬂﬂ 3
(
ﬂﬂ3 4
int
ﬂﬂ4 7
begin
ﬂﬂ8 =
,
ﬂﬂ= >
int
ﬂﬂ? B
end
ﬂﬂC F
)
ﬂﬂF G
=>
ﬂﬂH J
this
ﬂﬂK O
.
ﬂﬂO P
ListData
ﬂﬂP X
(
ﬂﬂX Y
)
ﬂﬂY Z
.
ﬂﬂZ [-
RemoveRangeSwapBackWithBeginEnd
ﬂﬂ[ z
(
ﬂﬂz {
beginﬂﬂ{ Ä
,ﬂﬂÄ Å
endﬂﬂÇ Ö
)ﬂﬂÖ Ü
;ﬂﬂÜ á
public
ÈÈ 
void
ÈÈ 
RemoveAt
ÈÈ 
(
ÈÈ 
int
ÈÈ  
index
ÈÈ! &
)
ÈÈ& '
=>
ÈÈ( *
this
ÈÈ+ /
.
ÈÈ/ 0
ListData
ÈÈ0 8
(
ÈÈ8 9
)
ÈÈ9 :
.
ÈÈ: ;
RemoveAt
ÈÈ; C
(
ÈÈC D
index
ÈÈD I
)
ÈÈI J
;
ÈÈJ K
public
ˆˆ 
void
ˆˆ 
RemoveRange
ˆˆ 
(
ˆˆ  
int
ˆˆ  #
index
ˆˆ$ )
,
ˆˆ) *
int
ˆˆ+ .
count
ˆˆ/ 4
)
ˆˆ4 5
=>
ˆˆ6 8
this
ˆˆ9 =
.
ˆˆ= >
ListData
ˆˆ> F
(
ˆˆF G
)
ˆˆG H
.
ˆˆH I
RemoveRange
ˆˆI T
(
ˆˆT U
index
ˆˆU Z
,
ˆˆZ [
count
ˆˆ\ a
)
ˆˆa b
;
ˆˆb c
[
ÇÇ 	
Obsolete
ÇÇ	 
(
ÇÇ 
$strÇÇ á
,ÇÇá à
falseÇÇâ é
)ÇÇé è
]ÇÇè ê
public
ÉÉ 
void
ÉÉ %
RemoveRangeWithBeginEnd
ÉÉ +
(
ÉÉ+ ,
int
ÉÉ, /
begin
ÉÉ0 5
,
ÉÉ5 6
int
ÉÉ7 :
end
ÉÉ; >
)
ÉÉ> ?
=>
ÉÉ@ B
this
ÉÉC G
.
ÉÉG H
ListData
ÉÉH P
(
ÉÉP Q
)
ÉÉQ R
.
ÉÉR S%
RemoveRangeWithBeginEnd
ÉÉS j
(
ÉÉj k
begin
ÉÉk p
,
ÉÉp q
end
ÉÉr u
)
ÉÉu v
;
ÉÉv w
IEnumerator
ãã 
IEnumerable
ãã 
.
ãã  
GetEnumerator
ãã  -
(
ãã- .
)
ãã. /
{
åå 	
throw
çç 
new
çç %
NotImplementedException
çç -
(
çç- .
)
çç. /
;
çç/ 0
}
éé 	
IEnumerator
ññ 
<
ññ 
IntPtr
ññ 
>
ññ 
IEnumerable
ññ '
<
ññ' (
IntPtr
ññ( .
>
ññ. /
.
ññ/ 0
GetEnumerator
ññ0 =
(
ññ= >
)
ññ> ?
{
óó 	
throw
òò 
new
òò %
NotImplementedException
òò -
(
òò- .
)
òò. /
;
òò/ 0
}
ôô 	
public
üü 
ParallelReader
üü 
AsParallelReader
üü .
(
üü. /
)
üü/ 0
{
†† 	
return
°° 
new
°° 
ParallelReader
°° %
(
°°% &
Ptr
°°& )
,
°°) *
Length
°°+ 1
)
°°1 2
;
°°2 3
}
¢¢ 	
[
™™ 	
BurstCompatible
™™	 
(
™™ "
GenericTypeArguments
™™ -
=
™™. /
new
™™0 3
[
™™3 4
]
™™4 5
{
™™6 7
typeof
™™8 >
(
™™> ?
int
™™? B
)
™™B C
}
™™D E
)
™™E F
]
™™F G
public
´´ 
unsafe
´´ 
struct
´´ 
ParallelReader
´´ +
{
¨¨ 	
[
∞∞ /
!NativeDisableUnsafePtrRestriction
∞∞ .
]
∞∞. /
public
±± 
readonly
±± 
T
±± 
*
±± 
*
±± 
Ptr
±±  #
;
±±# $
public
∂∂ 
readonly
∂∂ 
int
∂∂ 
Length
∂∂  &
;
∂∂& '
internal
∏∏ 
ParallelReader
∏∏ #
(
∏∏# $
T
∏∏$ %
*
∏∏% &
*
∏∏& '
ptr
∏∏( +
,
∏∏+ ,
int
∏∏- 0
length
∏∏1 7
)
∏∏7 8
{
ππ 
Ptr
∫∫ 
=
∫∫ 
ptr
∫∫ 
;
∫∫ 
Length
ªª 
=
ªª 
length
ªª 
;
ªª  
}
ºº 
public
√√ 
int
√√ 
IndexOf
√√ 
(
√√ 
void
√√ #
*
√√# $
ptr
√√% (
)
√√( )
{
ƒƒ 
for
≈≈ 
(
≈≈ 
int
≈≈ 
i
≈≈ 
=
≈≈ 
$num
≈≈ 
;
≈≈ 
i
≈≈  !
<
≈≈" #
Length
≈≈$ *
;
≈≈* +
++
≈≈, .
i
≈≈. /
)
≈≈/ 0
{
∆∆ 
if
«« 
(
«« 
Ptr
«« 
[
«« 
i
«« 
]
«« 
==
«« !
ptr
««" %
)
««% &
return
««' -
i
««. /
;
««/ 0
}
»» 
return
…… 
-
…… 
$num
…… 
;
…… 
}
   
public
—— 
bool
—— 
Contains
——  
(
——  !
void
——! %
*
——% &
ptr
——' *
)
——* +
{
““ 
return
”” 
IndexOf
”” 
(
”” 
ptr
”” "
)
””" #
!=
””$ &
-
””' (
$num
””( )
;
””) *
}
‘‘ 
}
’’ 	
public
€€ 
ParallelWriter
€€ 
AsParallelWriter
€€ .
(
€€. /
)
€€/ 0
{
‹‹ 	
return
›› 
new
›› 
ParallelWriter
›› %
(
››% &
Ptr
››& )
,
››) *
(
››+ ,

UnsafeList
››, 6
<
››6 7
IntPtr
››7 =
>
››= >
*
››> ?
)
››? @
UnsafeUtility
››@ M
.
››M N
	AddressOf
››N W
(
››W X
ref
››X [
this
››\ `
)
››` a
)
››a b
;
››b c
}
ﬁﬁ 	
[
ÊÊ 	
BurstCompatible
ÊÊ	 
(
ÊÊ "
GenericTypeArguments
ÊÊ -
=
ÊÊ. /
new
ÊÊ0 3
[
ÊÊ3 4
]
ÊÊ4 5
{
ÊÊ6 7
typeof
ÊÊ8 >
(
ÊÊ> ?
int
ÊÊ? B
)
ÊÊB C
}
ÊÊD E
)
ÊÊE F
]
ÊÊF G
public
ÁÁ 
unsafe
ÁÁ 
struct
ÁÁ 
ParallelWriter
ÁÁ +
{
ËË 	
[
ÏÏ /
!NativeDisableUnsafePtrRestriction
ÏÏ .
]
ÏÏ. /
public
ÌÌ 
readonly
ÌÌ 
T
ÌÌ 
*
ÌÌ 
*
ÌÌ 
Ptr
ÌÌ  #
;
ÌÌ# $
[
ÚÚ /
!NativeDisableUnsafePtrRestriction
ÚÚ .
]
ÚÚ. /
public
ÛÛ 

UnsafeList
ÛÛ 
<
ÛÛ 
IntPtr
ÛÛ $
>
ÛÛ$ %
*
ÛÛ% &
ListData
ÛÛ' /
;
ÛÛ/ 0
internal
ıı 
unsafe
ıı 
ParallelWriter
ıı *
(
ıı* +
T
ıı+ ,
*
ıı, -
*
ıı- .
ptr
ıı/ 2
,
ıı2 3

UnsafeList
ıı4 >
<
ıı> ?
IntPtr
ıı? E
>
ııE F
*
ııF G
listData
ııH P
)
ııP Q
{
ˆˆ 
Ptr
˜˜ 
=
˜˜ 
ptr
˜˜ 
;
˜˜ 
ListData
¯¯ 
=
¯¯ 
listData
¯¯ #
;
¯¯# $
}
˘˘ 
public
ÉÉ 
void
ÉÉ 
AddNoResize
ÉÉ #
(
ÉÉ# $
T
ÉÉ$ %
*
ÉÉ% &
value
ÉÉ' ,
)
ÉÉ, -
=>
ÉÉ. 0
ListData
ÉÉ1 9
->
ÉÉ9 ;
AddNoResize
ÉÉ; F
(
ÉÉF G
(
ÉÉG H
IntPtr
ÉÉH N
)
ÉÉN O
value
ÉÉO T
)
ÉÉT U
;
ÉÉU V
public
éé 
void
éé 
AddRangeNoResize
éé (
(
éé( )
T
éé) *
*
éé* +
*
éé+ ,
ptr
éé- 0
,
éé0 1
int
éé2 5
count
éé6 ;
)
éé; <
=>
éé= ?
ListData
éé@ H
->
ééH J
AddRangeNoResize
ééJ Z
(
ééZ [
ptr
éé[ ^
,
éé^ _
count
éé` e
)
éée f
;
ééf g
public
òò 
void
òò 
AddRangeNoResize
òò (
(
òò( )
UnsafePtrList
òò) 6
<
òò6 7
T
òò7 8
>
òò8 9
list
òò: >
)
òò> ?
=>
òò@ B
ListData
òòC K
->
òòK M
AddRangeNoResize
òòM ]
(
òò] ^
list
òò^ b
.
òòb c
Ptr
òòc f
,
òòf g
list
òòh l
.
òòl m
Length
òòm s
)
òòs t
;
òòt u
}
ôô 	
}
öö 
[
úú 
BurstCompatible
úú 
]
úú 
internal
ùù 
static
ùù 
class
ùù &
UnsafePtrListTExtensions
ùù 2
{
ûû 
[
üü 	
BurstCompatible
üü	 
(
üü "
GenericTypeArguments
üü -
=
üü. /
new
üü0 3
[
üü3 4
]
üü4 5
{
üü6 7
typeof
üü8 >
(
üü> ?
int
üü? B
)
üüB C
}
üüD E
)
üüE F
]
üüF G
public
†† 
static
†† 
ref
†† 

UnsafeList
†† $
<
††$ %
IntPtr
††% +
>
††+ ,
ListData
††- 5
<
††5 6
T
††6 7
>
††7 8
(
††8 9
ref
††9 <
this
††= A
UnsafePtrList
††B O
<
††O P
T
††P Q
>
††Q R
from
††S W
)
††W X
where
††Y ^
T
††_ `
:
††a b
	unmanaged
††c l
=>
††m o
ref
††p s
UnsafeUtility††t Å
.††Å Ç
As††Ç Ñ
<††Ñ Ö
UnsafePtrList††Ö í
<††í ì
T††ì î
>††î ï
,††ï ñ

UnsafeList††ó °
<††° ¢
IntPtr††¢ ®
>††® ©
>††© ™
(††™ ´
ref††´ Æ
from††Ø ≥
)††≥ ¥
;††¥ µ
}
°° 
internal
££ 
sealed
££ 
class
££ %
UnsafePtrListTDebugView
££ 1
<
££1 2
T
££2 3
>
££3 4
where
§§ 
T
§§ 
:
§§ 
	unmanaged
§§ 
{
•• 
UnsafePtrList
¶¶ 
<
¶¶ 
T
¶¶ 
>
¶¶ 
Data
¶¶ 
;
¶¶ 
public
®® %
UnsafePtrListTDebugView
®® &
(
®®& '
UnsafePtrList
®®' 4
<
®®4 5
T
®®5 6
>
®®6 7
data
®®8 <
)
®®< =
{
©© 	
Data
™™ 
=
™™ 
data
™™ 
;
™™ 
}
´´ 	
public
≠≠ 
unsafe
≠≠ 
T
≠≠ 
*
≠≠ 
[
≠≠ 
]
≠≠ 
Items
≠≠  
{
ÆÆ 	
get
ØØ 
{
∞∞ 
T
±± 
*
±± 
[
±± 
]
±± 
result
±± 
=
±± 
new
±± !
T
±±" #
*
±±# $
[
±±$ %
Data
±±% )
.
±±) *
Length
±±* 0
]
±±0 1
;
±±1 2
for
≥≥ 
(
≥≥ 
var
≥≥ 
i
≥≥ 
=
≥≥ 
$num
≥≥ 
;
≥≥ 
i
≥≥  !
<
≥≥" #
result
≥≥$ *
.
≥≥* +
Length
≥≥+ 1
;
≥≥1 2
++
≥≥3 5
i
≥≥5 6
)
≥≥6 7
{
¥¥ 
result
µµ 
[
µµ 
i
µµ 
]
µµ 
=
µµ 
Data
µµ  $
.
µµ$ %
Ptr
µµ% (
[
µµ( )
i
µµ) *
]
µµ* +
;
µµ+ ,
}
∂∂ 
return
∏∏ 
result
∏∏ 
;
∏∏ 
}
ππ 
}
∫∫ 	
}
ªª 
}ºº ™^
aC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeText.cs
	namespace		 	
Unity		
 
.		 
Collections		 
.		 
LowLevel		 $
.		$ %
Unsafe		% +
{

 
internal 
static 
class  
UnsafeTextExtensions .
{ 
public 
static 
ref 

UnsafeList $
<$ %
byte% )
>) *
AsUnsafeListOfBytes+ >
(> ?
this@ D
refE H

UnsafeTextI S
textT X
)Y Z
{ 	
return 
ref 
UnsafeUtility $
.$ %
As% '
<' (
UntypedUnsafeList( 9
,9 :

UnsafeList; E
<E F
byteF J
>J K
>K L
(L M
refM P
textQ U
.U V
m_UntypedListDataV g
)g h
;h i
} 	
} 
[ 
BurstCompatible 
] 
[ 
DebuggerDisplay 
( 
$str m
)m n
]n o
[ 
StructLayout 
( 

LayoutKind 
. 

Sequential '
)' (
]( )
public 

unsafe 
struct 

UnsafeText #
:$ %
INativeDisposable& 7
,7 8

IUTF8Bytes9 C
,C D
INativeListE P
<P Q
byteQ U
>U V
{ 
internal   
UntypedUnsafeList   "
m_UntypedListData  # 4
;  4 5
public'' 

UnsafeText'' 
('' 
int'' 
capacity'' &
,''& '
AllocatorManager''( 8
.''8 9
AllocatorHandle''9 H
	allocator''I R
)''R S
{(( 	
m_UntypedListData)) 
=)) 
default))  '
;))' (
this++ 
.++ 
AsUnsafeListOfBytes++ $
(++$ %
)++% &
=++' (
new++) ,

UnsafeList++- 7
<++7 8
byte++8 <
>++< =
(++= >
capacity++> F
+++G H
$num++I J
,++J K
	allocator++L U
)++U V
;++V W
Length,, 
=,, 
$num,, 
;,, 
}-- 	
public33 
bool33 
	IsCreated33 
=>33  
this33! %
.33% &
AsUnsafeListOfBytes33& 9
(339 :
)33: ;
.33; <
	IsCreated33< E
;33E F
public99 
void99 
Dispose99 
(99 
)99 
{:: 	
this;; 
.;; 
AsUnsafeListOfBytes;; $
(;;$ %
);;% &
.;;& '
Dispose;;' .
(;;. /
);;/ 0
;;;0 1
}<< 	
[CC 	
NotBurstCompatibleCC	 
]
CCú ù
publicDD 
	JobHandleDD 
DisposeDD  
(DD  !
	JobHandleDD! *
	inputDepsDD+ 4
)DD4 5
{EE 	
returnFF 
thisFF 
.FF 
AsUnsafeListOfBytesFF +
(FF+ ,
)FF, -
.FF- .
DisposeFF. 5
(FF5 6
	inputDepsFF6 ?
)FF? @
;FF@ A
}GG 	
publicMM 
boolMM 
IsEmptyMM 
=>MM 
!MM  
	IsCreatedMM  )
||MM* ,
LengthMM- 3
==MM4 6
$numMM7 8
;MM8 9
publicUU 
byteUU 
thisUU 
[UU 
intUU 
indexUU "
]UU" #
{VV 	
getWW 
{XX 
CheckIndexInRangeYY !
(YY! "
indexYY" '
)YY' (
;YY( )
returnZZ 
UnsafeUtilityZZ $
.ZZ$ %
ReadArrayElementZZ% 5
<ZZ5 6
byteZZ6 :
>ZZ: ;
(ZZ; <
m_UntypedListDataZZ< M
.ZZM N
PtrZZN Q
,ZZQ R
indexZZS X
)ZZX Y
;ZZY Z
}[[ 
set\\ 
{]] 
CheckIndexInRange^^ !
(^^! "
index^^" '
)^^' (
;^^( )
UnsafeUtility__ 
.__ 
WriteArrayElement__ /
(__/ 0
m_UntypedListData__0 A
.__A B
Ptr__B E
,__E F
index__G L
,__L M
value__N S
)__S T
;__T U
}`` 
}aa 	
publicll 
refll 
bytell 
	ElementAtll !
(ll! "
intll" %
indexll& +
)ll+ ,
{mm 	
CheckIndexInRangenn 
(nn 
indexnn #
)nn# $
;nn$ %
returnoo 
refoo 
UnsafeUtilityoo $
.oo$ %
ArrayElementAsRefoo% 6
<oo6 7
byteoo7 ;
>oo; <
(oo< =
m_UntypedListDataoo= N
.ooN O
PtrooO R
,ooR S
indexooT Y
)ooY Z
;ooZ [
}pp 	
publicuu 
voiduu 
Clearuu 
(uu 
)uu 
{vv 	
Lengthww 
=ww 
$numww 
;ww 
}xx 	
public
ÅÅ 
byte
ÅÅ 
*
ÅÅ 
GetUnsafePtr
ÅÅ !
(
ÅÅ! "
)
ÅÅ" #
{
ÇÇ 	
return
ÉÉ 
(
ÉÉ 
byte
ÉÉ 
*
ÉÉ 
)
ÉÉ 
m_UntypedListData
ÉÉ +
.
ÉÉ+ ,
Ptr
ÉÉ, /
;
ÉÉ/ 0
}
ÑÑ 	
public
åå 
bool
åå 
	TryResize
åå 
(
åå 
int
åå !
	newLength
åå" +
,
åå+ , 
NativeArrayOptions
åå- ?
clearOptions
åå@ L
=
ååM N 
NativeArrayOptions
ååO a
.
ååa b
ClearMemory
ååb m
)
ååm n
{
çç 	
this
èè 
.
èè !
AsUnsafeListOfBytes
èè $
(
èè$ %
)
èè% &
.
èè& '
Resize
èè' -
(
èè- .
	newLength
èè. 7
+
èè8 9
$num
èè: ;
,
èè; <
clearOptions
èè= I
)
èèI J
;
èèJ K
this
êê 
.
êê !
AsUnsafeListOfBytes
êê $
(
êê$ %
)
êê% &
[
êê& '
	newLength
êê' 0
]
êê0 1
=
êê2 3
$num
êê4 5
;
êê5 6
return
ëë 
true
ëë 
;
ëë 
}
íí 	
public
õõ 
int
õõ 
Capacity
õõ 
{
úú 	
get
ùù 
=>
ùù 
this
ùù 
.
ùù !
AsUnsafeListOfBytes
ùù +
(
ùù+ ,
)
ùù, -
.
ùù- .
Capacity
ùù. 6
-
ùù7 8
$num
ùù9 :
;
ùù: ;
set
ûû 
{
üü "
CheckCapacityInRange
†† $
(
††$ %
value
††% *
+
††+ ,
$num
††- .
,
††. /
this
††0 4
.
††4 5!
AsUnsafeListOfBytes
††5 H
(
††H I
)
††I J
.
††J K
Length
††K Q
)
††Q R
;
††R S
this
°° 
.
°° !
AsUnsafeListOfBytes
°° (
(
°°( )
)
°°) *
.
°°* +
SetCapacity
°°+ 6
(
°°6 7
value
°°7 <
+
°°= >
$num
°°? @
)
°°@ A
;
°°A B
}
¢¢ 
}
££ 	
public
¨¨ 
int
¨¨ 
Length
¨¨ 
{
≠≠ 	
get
ÆÆ 
=>
ÆÆ 
this
ÆÆ 
.
ÆÆ !
AsUnsafeListOfBytes
ÆÆ +
(
ÆÆ+ ,
)
ÆÆ, -
.
ÆÆ- .
Length
ÆÆ. 4
-
ÆÆ5 6
$num
ÆÆ7 8
;
ÆÆ8 9
set
ØØ 
{
∞∞ 
this
±± 
.
±± !
AsUnsafeListOfBytes
±± (
(
±±( )
)
±±) *
.
±±* +
Resize
±±+ 1
(
±±1 2
value
±±2 7
+
±±8 9
$num
±±: ;
)
±±; <
;
±±< =
this
≤≤ 
.
≤≤ !
AsUnsafeListOfBytes
≤≤ (
(
≤≤( )
)
≤≤) *
[
≤≤* +
value
≤≤+ 0
]
≤≤0 1
=
≤≤2 3
$num
≤≤4 5
;
≤≤5 6
}
≥≥ 
}
¥¥ 	
[
∫∫ 	 
NotBurstCompatible
∫∫	 
]
∫∫ 
public
ªª 
override
ªª 
string
ªª 
ToString
ªª '
(
ªª' (
)
ªª( )
{
ºº 	
if
ΩΩ 
(
ΩΩ 
!
ΩΩ 
	IsCreated
ΩΩ 
)
ΩΩ 
return
ææ 
$str
ææ 
;
ææ 
return
øø 
this
øø 
.
øø 
ConvertToString
øø '
(
øø' (
)
øø( )
;
øø) *
}
¿¿ 	
[
¬¬ 	
Conditional
¬¬	 
(
¬¬ 
$str
¬¬ 6
)
¬¬6 7
]
¬¬7 8
void
√√ 
CheckIndexInRange
√√ 
(
√√ 
int
√√ "
index
√√# (
)
√√( )
{
ƒƒ 	
if
≈≈ 
(
≈≈ 
index
≈≈ 
<
≈≈ 
$num
≈≈ 
)
≈≈ 
throw
∆∆ 
new
∆∆ &
IndexOutOfRangeException
∆∆ 2
(
∆∆2 3
$"
∆∆3 5
$str
∆∆5 ;
{
∆∆; <
index
∆∆< A
}
∆∆A B
$str
∆∆B T
"
∆∆T U
)
∆∆U V
;
∆∆V W
if
«« 
(
«« 
index
«« 
>=
«« 
Length
«« 
)
««  
throw
»» 
new
»» &
IndexOutOfRangeException
»» 2
(
»»2 3
$"
»»3 5
$str
»»5 ;
{
»»; <
index
»»< A
}
»»A B
$str
»»B d
{
»»d e
Length
»»e k
}
»»k l
$str
»»l t
"
»»t u
)
»»u v
;
»»v w
}
…… 	
[
ÀÀ 	
Conditional
ÀÀ	 
(
ÀÀ 
$str
ÀÀ 6
)
ÀÀ6 7
]
ÀÀ7 8
void
ÃÃ 
ThrowCopyError
ÃÃ 
(
ÃÃ 
	CopyError
ÃÃ %
error
ÃÃ& +
,
ÃÃ+ ,
string
ÃÃ- 3
source
ÃÃ4 :
)
ÃÃ: ;
{
ÕÕ 	
throw
ŒŒ 
new
ŒŒ 
ArgumentException
ŒŒ '
(
ŒŒ' (
$"
ŒŒ( *
$str
ŒŒ* 6
{
ŒŒ6 7
error
ŒŒ7 <
}
ŒŒ< =
$str
ŒŒ= N
{
ŒŒN O
source
ŒŒO U
}
ŒŒU V
$str
ŒŒV X
"
ŒŒX Y
)
ŒŒY Z
;
ŒŒZ [
}
œœ 	
[
—— 	
Conditional
——	 
(
—— 
$str
—— 6
)
——6 7
]
——7 8
static
““ 
void
““ "
CheckCapacityInRange
““ (
(
““( )
int
““) ,
value
““- 2
,
““2 3
int
““4 7
length
““8 >
)
““> ?
{
”” 	
if
‘‘ 
(
‘‘ 
value
‘‘ 
<
‘‘ 
$num
‘‘ 
)
‘‘ 
throw
’’ 
new
’’ )
ArgumentOutOfRangeException
’’ 5
(
’’5 6
$"
’’6 8
$str
’’8 >
{
’’> ?
value
’’? D
}
’’D E
$str
’’E W
"
’’W X
)
’’X Y
;
’’Y Z
if
◊◊ 
(
◊◊ 
(
◊◊ 
uint
◊◊ 
)
◊◊ 
value
◊◊ 
<
◊◊ 
(
◊◊ 
uint
◊◊ #
)
◊◊# $
length
◊◊$ *
)
◊◊* +
throw
ÿÿ 
new
ÿÿ )
ArgumentOutOfRangeException
ÿÿ 5
(
ÿÿ5 6
$"
ÿÿ6 8
$str
ÿÿ8 >
{
ÿÿ> ?
value
ÿÿ? D
}
ÿÿD E
$str
ÿÿE h
{
ÿÿh i
length
ÿÿi o
}
ÿÿo p
$str
ÿÿp y
"
ÿÿy z
)
ÿÿz {
;
ÿÿ{ |
}
ŸŸ 	
}
⁄⁄ 
}€€ ñâ
eC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\ConcurrentMask.cs
	namespace 	
Unity
 
. 
Collections 
{		 
internal

 
struct

 
Long8

 
{ 
internal 
long 
f0 
, 
f1 
, 
f2 
, 
f3 !
,! "
f4" $
,$ %
f5% '
,' (
f6( *
,* +
f7+ -
;- .
} 
internal 
struct 
Long64 
{ 
internal 
Long8 
f0 
, 
f1 
, 
f2 
,  
f3  "
," #
f4# %
,% &
f5& (
,( )
f6) +
,+ ,
f7, .
;. /
} 
internal 
struct 
Long512 
{ 
internal 
Long64 
f0 
, 
f1 
, 
f2  
,  !
f3! #
,# $
f4$ &
,& '
f5' )
,) *
f6* ,
,, -
f7- /
;/ 0
} 
internal 
struct 
Long1024 
: 

IIndexable )
<) *
long* .
>. /
{ 
internal 
Long512 
f0 
, 
f1 
; 
public 
int 
Length 
{ 
get 
{  !
return" (
$num) -
;- .
}. /
set0 3
{4 5
}5 6
}7 8
public 
ref 
long 
	ElementAt !
(! "
int" %
index& +
)+ ,
{ 	
unsafe 
{ 
fixed 
( 
Long512 "
*" #
p$ %
=& '
&( )
f0) +
)+ ,
{- .
return   
ref   
UnsafeUtility   (
.  ( )
AsRef  ) .
<  . /
long  / 3
>  3 4
(  4 5
(  5 6
long  6 :
*  : ;
)  ; <
p  < =
+  > ?
index  @ E
)  E F
;  F G
}!! 
}!! 
}"" 	
}## 
internal%% 
class%% 
ConcurrentMask%% !
{&& 
internal'' 
static'' 
void'' "
longestConsecutiveOnes'' 3
(''3 4
long''4 8
value''9 >
,''> ?
out''@ C
int''D G
offset''H N
,''N O
out''P S
int''T W
count''X ]
)''] ^
{(( 	
count)) 
=)) 
$num)) 
;)) 
var** 
newvalue** 
=** 
value**  
;**  !
while++ 
(++ 
newvalue++ 
!=++ 
$num++ 
)++  
{,, 
value-- 
=-- 
newvalue--  
;--  !
newvalue.. 
=.. 
value..  
&..! "
(..# $
long..$ (
)..( )
(..) *
(..* +
ulong..+ 0
)..0 1
value..1 6
>>..7 9
$num..: ;
)..; <
;..< =
++// 
count// 
;// 
}00 
offset11 
=11 
math11 
.11 
tzcnt11 
(11  
value11  %
)11% &
;11& '
}22 	
internal44 
static44 
bool44 /
#foundAtLeastThisManyConsecutiveOnes44 @
(44@ A
long44A E
value44F K
,44K L
int44M P
minimum44Q X
,44X Y
out44Z ]
int44^ a
offset44b h
,44h i
out44j m
int44n q
count44r w
)44w x
{55 	
if66 
(66 
minimum66 
==66 
$num66 
)66 
{77 
offset88 
=88 
math88 
.88 
tzcnt88 #
(88# $
value88$ )
)88) *
;88* +
count99 
=99 
$num99 
;99 
return:: 
offset:: 
!=::  
$num::! #
;::# $
};; "
longestConsecutiveOnes<< "
(<<" #
value<<# (
,<<( )
out<<* -
offset<<. 4
,<<4 5
out<<6 9
count<<: ?
)<<? @
;<<@ A
return== 
count== 
>=== 
minimum== #
;==# $
}>> 	
internal@@ 
static@@ 
bool@@ 1
%foundAtLeastThisManyConsecutiveZeroes@@ B
(@@B C
long@@C G
value@@H M
,@@M N
int@@O R
minimum@@S Z
,@@Z [
out@@\ _
int@@` c
offset@@d j
,@@j k
out@@l o
int@@p s
count@@t y
)@@y z
{AA 	
returnBB /
#foundAtLeastThisManyConsecutiveOnesBB 6
(BB6 7
~BB7 8
valueBB8 =
,BB= >
minimumBB? F
,BBF G
outBBH K
offsetBBL R
,BBR S
outBBT W
countBBX ]
)BB] ^
;BB^ _
}CC 	
internalEE 
constEE 
intEE 
ErrorFailedToFreeEE ,
=EE- .
-EE/ 0
$numEE0 1
;EE1 2
internalFF 
constFF 
intFF !
ErrorFailedToAllocateFF 0
=FF1 2
-FF3 4
$numFF4 5
;FF5 6
internalGG 
constGG 
intGG !
EmptyBeforeAllocationGG 0
=GG1 2
$numGG3 4
;GG4 5
internalHH 
constHH 
intHH 
EmptyAfterFreeHH )
=HH* +
$numHH, -
;HH- .
internalJJ 
staticJJ 
boolJJ 
	SucceededJJ &
(JJ& '
intJJ' *
errorJJ+ 0
)JJ0 1
{KK 	
returnLL 
errorLL 
>=LL 
$numLL 
;LL 
}MM 	
internalOO 
staticOO 
longOO 
MakeMaskOO %
(OO% &
intOO& )
offsetOO* 0
,OO0 1
intOO2 5
bitsOO6 :
)OO: ;
{PP 	
returnQQ 
(QQ 
longQQ 
)QQ 
(QQ 
~QQ 
$numQQ 
>>QQ !
(QQ" #
$numQQ# %
-QQ% &
bitsQQ& *
)QQ* +
)QQ+ ,
<<QQ- /
offsetQQ0 6
;QQ6 7
}RR 	
internalTT 
staticTT 
intTT 
TryAllocateTT '
(TT' (
refTT( +
longTT, 0
lTT1 2
,TT2 3
intTT4 7
offsetTT8 >
,TT> ?
intTT@ C
bitsTTD H
)TTH I
{UU 	
varVV 
maskVV 
=VV 
MakeMaskVV 
(VV  
offsetVV  &
,VV& '
bitsVV( ,
)VV, -
;VV- .
varWW 
	readValueWW 
=WW 
InterlockedWW '
.WW' (
ReadWW( ,
(WW, -
refWW- 0
lWW1 2
)WW2 3
;WW3 4
longXX 
oldReadValueXX 
,XX 
writtenValueXX +
;XX+ ,
doYY 
{ZZ 
if[[ 
([[ 
([[ 
	readValue[[ 
&[[ 
mask[[  $
)[[$ %
!=[[& (
$num[[) *
)[[* +
return\\ !
ErrorFailedToAllocate\\ 0
;\\0 1
writtenValue]] 
=]] 
	readValue]] (
|]]) *
mask]]+ /
;]]/ 0
oldReadValue^^ 
=^^ 
	readValue^^ (
;^^( )
	readValue__ 
=__ 
Interlocked__ '
.__' (
CompareExchange__( 7
(__7 8
ref__8 ;
l__< =
,__= >
writtenValue__? K
,__K L
oldReadValue__M Y
)__Y Z
;__Z [
}`` 
while`` 
(`` 
	readValue`` 
!=``  
oldReadValue``! -
)``- .
;``. /
returnaa 
mathaa 
.aa 
	countbitsaa !
(aa! "
	readValueaa" +
)aa+ ,
;aa, -
}bb 	
internaldd 
staticdd 
intdd 
TryFreedd #
(dd# $
refdd$ '
longdd( ,
ldd- .
,dd. /
intdd0 3
offsetdd4 :
,dd: ;
intdd< ?
bitsdd@ D
)ddD E
{ee 	
varff 
maskff 
=ff 
MakeMaskff 
(ff  
offsetff  &
,ff& '
bitsff( ,
)ff, -
;ff- .
vargg 
	readValuegg 
=gg 
Interlockedgg '
.gg' (
Readgg( ,
(gg, -
refgg- 0
lgg1 2
)gg2 3
;gg3 4
longhh 
oldReadValuehh 
,hh 
writtenValuehh +
;hh+ ,
doii 
{jj 
ifkk 
(kk 
(kk 
	readValuekk 
&kk 
maskkk  $
)kk$ %
!=kk& (
maskkk) -
)kk- .
returnll 
ErrorFailedToFreell ,
;ll, -
writtenValuemm 
=mm 
	readValuemm (
&mm) *
~mm+ ,
maskmm, 0
;mm0 1
oldReadValuenn 
=nn 
	readValuenn (
;nn( )
	readValueoo 
=oo 
Interlockedoo '
.oo' (
CompareExchangeoo( 7
(oo7 8
refoo8 ;
loo< =
,oo= >
writtenValueoo? K
,ooK L
oldReadValueooM Y
)ooY Z
;ooZ [
}pp 
whilepp 
(pp 
	readValuepp 
!=pp  
oldReadValuepp! -
)pp- .
;pp. /
returnqq 
mathqq 
.qq 
	countbitsqq !
(qq! "
writtenValueqq" .
)qq. /
;qq/ 0
}rr 	
internaltt 
statictt 
inttt 
TryAllocatett '
(tt' (
reftt( +
longtt, 0
ltt1 2
,tt2 3
outtt4 7
inttt8 ;
offsettt< B
,ttB C
intttD G
bitsttH L
)ttL M
{uu 	
varvv 
	readValuevv 
=vv 
Interlockedvv '
.vv' (
Readvv( ,
(vv, -
refvv- 0
lvv1 2
)vv2 3
;vv3 4
longww 
oldReadValueww 
,ww 
writtenValueww +
;ww+ ,
doxx 
{yy 
ifzz 
(zz 
!zz 1
%foundAtLeastThisManyConsecutiveZeroeszz 9
(zz9 :
	readValuezz: C
,zzC D
bitszzE I
,zzI J
outzzK N
offsetzzO U
,zzU V
outzzW Z
intzz[ ^
_zz_ `
)zz` a
)zza b
return{{ !
ErrorFailedToAllocate{{ 0
;{{0 1
var|| 
mask|| 
=|| 
MakeMask|| #
(||# $
offset||$ *
,||* +
bits||, 0
)||0 1
;||1 2
writtenValue}} 
=}} 
	readValue}} (
|}}) *
mask}}+ /
;}}/ 0
oldReadValue~~ 
=~~ 
	readValue~~ (
;~~( )
	readValue 
= 
Interlocked '
.' (
CompareExchange( 7
(7 8
ref8 ;
l< =
,= >
writtenValue? K
,K L
oldReadValueM Y
)Y Z
;Z [
}
ÄÄ 
while
ÄÄ 
(
ÄÄ 
	readValue
ÄÄ 
!=
ÄÄ  
oldReadValue
ÄÄ! -
)
ÄÄ- .
;
ÄÄ. /
return
ÅÅ 
math
ÅÅ 
.
ÅÅ 
	countbits
ÅÅ !
(
ÅÅ! "
	readValue
ÅÅ" +
)
ÅÅ+ ,
;
ÅÅ, -
}
ÇÇ 	
internal
ÑÑ 
static
ÑÑ 
int
ÑÑ 
TryAllocate
ÑÑ '
<
ÑÑ' (
T
ÑÑ( )
>
ÑÑ) *
(
ÑÑ* +
ref
ÑÑ+ .
T
ÑÑ/ 0
t
ÑÑ1 2
,
ÑÑ2 3
int
ÑÑ4 7
offset
ÑÑ8 >
,
ÑÑ> ?
int
ÑÑ@ C
bits
ÑÑD H
)
ÑÑH I
where
ÑÑJ O
T
ÑÑP Q
:
ÑÑR S

IIndexable
ÑÑT ^
<
ÑÑ^ _
long
ÑÑ_ c
>
ÑÑc d
{
ÖÖ 	
var
ÜÜ 

wordOffset
ÜÜ 
=
ÜÜ 
offset
ÜÜ #
>>
ÜÜ$ &
$num
ÜÜ' (
;
ÜÜ( )
var
áá 
	bitOffset
áá 
=
áá 
offset
áá "
&
áá# $
$num
áá% '
;
áá' (
return
àà 
TryAllocate
àà 
(
àà 
ref
àà "
t
àà# $
.
àà$ %
	ElementAt
àà% .
(
àà. /

wordOffset
àà/ 9
)
àà9 :
,
àà: ;
	bitOffset
àà< E
,
ààE F
bits
ààG K
)
ààK L
;
ààL M
}
ââ 	
internal
ãã 
static
ãã 
int
ãã 
TryFree
ãã #
<
ãã# $
T
ãã$ %
>
ãã% &
(
ãã& '
ref
ãã' *
T
ãã+ ,
t
ãã- .
,
ãã. /
int
ãã0 3
offset
ãã4 :
,
ãã: ;
int
ãã< ?
bits
ãã@ D
)
ããD E
where
ããF K
T
ããL M
:
ããN O

IIndexable
ããP Z
<
ããZ [
long
ãã[ _
>
ãã_ `
{
åå 	
var
çç 

wordOffset
çç 
=
çç 
offset
çç #
>>
çç$ &
$num
çç' (
;
çç( )
var
éé 
	bitOffset
éé 
=
éé 
offset
éé "
&
éé# $
$num
éé% '
;
éé' (
return
èè 
TryFree
èè 
(
èè 
ref
èè 
t
èè  
.
èè  !
	ElementAt
èè! *
(
èè* +

wordOffset
èè+ 5
)
èè5 6
,
èè6 7
	bitOffset
èè8 A
,
èèA B
bits
èèC G
)
èèG H
;
èèH I
}
êê 	
internal
íí 
static
íí 
int
íí 
TryAllocate
íí '
<
íí' (
T
íí( )
>
íí) *
(
íí* +
ref
íí+ .
T
íí/ 0
t
íí1 2
,
íí2 3
out
íí4 7
int
íí8 ;
offset
íí< B
,
ííB C
int
ííD G
begin
ííH M
,
ííM N
int
ííO R
end
ííS V
,
ííV W
int
ííX [
bits
íí\ `
)
íí` a
where
ííb g
T
ííh i
:
ííj k

IIndexable
ííl v
<
íív w
long
ííw {
>
íí{ |
{
ìì 	
for
îî 
(
îî 
var
îî 

wordOffset
îî 
=
îî  
begin
îî! &
;
îî& '

wordOffset
îî( 2
<
îî3 4
end
îî5 8
;
îî8 9
++
îî: <

wordOffset
îî< F
)
îîF G
{
ïï 
int
ññ 
error
ññ 
,
ññ 
	bitOffset
ññ $
;
ññ$ %
error
óó 
=
óó 
TryAllocate
óó #
(
óó# $
ref
óó$ '
t
óó( )
.
óó) *
	ElementAt
óó* 3
(
óó3 4

wordOffset
óó4 >
)
óó> ?
,
óó? @
out
óóA D
	bitOffset
óóE N
,
óóN O
bits
óóP T
)
óóT U
;
óóU V
if
òò 
(
òò 
	Succeeded
òò 
(
òò 
error
òò "
)
òò" #
)
òò# $
{
ôô 
offset
öö 
=
öö 

wordOffset
öö '
*
öö( )
$num
öö* ,
+
öö- .
	bitOffset
öö/ 8
;
öö8 9
return
õõ 
error
õõ  
;
õõ  !
}
úú 
}
ùù 
offset
ûû 
=
ûû 
-
ûû 
$num
ûû 
;
ûû 
return
üü #
ErrorFailedToAllocate
üü (
;
üü( )
}
†† 	
internal
¢¢ 
static
¢¢ 
int
¢¢ 
TryAllocate
¢¢ '
<
¢¢' (
T
¢¢( )
>
¢¢) *
(
¢¢* +
ref
¢¢+ .
T
¢¢/ 0
t
¢¢1 2
,
¢¢2 3
out
¢¢4 7
int
¢¢8 ;
offset
¢¢< B
,
¢¢B C
int
¢¢D G
bits
¢¢H L
)
¢¢L M
where
¢¢N S
T
¢¢T U
:
¢¢V W

IIndexable
¢¢X b
<
¢¢b c
long
¢¢c g
>
¢¢g h
{
££ 	
return
§§ 
TryAllocate
§§ 
(
§§ 
ref
§§ "
t
§§# $
,
§§$ %
out
§§& )
offset
§§* 0
,
§§0 1
$num
§§2 3
,
§§3 4
t
§§5 6
.
§§6 7
Length
§§7 =
,
§§= >
bits
§§? C
)
§§C D
;
§§D E
}
•• 	
}
ßß 
}®® á¶
aC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\Deprecated.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{ 
[ 
DebuggerDisplay 
( 
$str m
)m n
]n o
[ 
StructLayout 
( 

LayoutKind 
. 

Sequential '
)' (
]( )
[ 
Obsolete 
( 
$str m
,m n
falseo t
)t u
]u v
public 

unsafe 
struct 

UnsafeList #
: 	
INativeDisposable
 
{ 
[ 	-
!NativeDisableUnsafePtrRestriction	 *
]* +
public 
void 
* 
Ptr 
; 
public"" 
int"" 
Length"" 
;"" 
public$$ 
readonly$$ 
int$$ 
unused$$ "
;$$" #
public(( 
int(( 
Capacity(( 
;(( 
public,, 
AllocatorManager,, 
.,,  
AllocatorHandle,,  /
	Allocator,,0 9
;,,9 :
public55 

UnsafeList55 
(55 
	Allocator55 #
	allocator55$ -
)55- .
:55/ 0
this551 5
(555 6
)556 7
{66 	
Ptr77 
=77 
null77 
;77 
Length88 
=88 
$num88 
;88 
Capacity99 
=99 
$num99 
;99 
	Allocator:: 
=:: 
	allocator:: !
;::! "
};; 	
publicBB 

UnsafeListBB 
(BB 
voidBB 
*BB 
ptrBB  #
,BB# $
intBB% (
lengthBB) /
)BB/ 0
:BB1 2
thisBB3 7
(BB7 8
)BB8 9
{CC 	
PtrDD 
=DD 
ptrDD 
;DD 
LengthEE 
=EE 
lengthEE 
;EE 
CapacityFF 
=FF 
lengthFF 
;FF 
	AllocatorGG 
=GG 
CollectionsGG #
.GG# $
	AllocatorGG$ -
.GG- .
NoneGG. 2
;GG2 3
}HH 	
internalJJ 
voidJJ 

InitializeJJ  
<JJ  !
UJJ! "
>JJ" #
(JJ# $
intJJ$ '
sizeOfJJ( .
,JJ. /
intJJ0 3
alignOfJJ4 ;
,JJ; <
intJJ= @
initialCapacityJJA P
,JJP Q
refJJR U
UJJV W
	allocatorJJX a
,JJa b
NativeArrayOptionsJJc u
optionsJJv }
=JJ~  
NativeArrayOptions
JJÄ í
.
JJí ì!
UninitializedMemory
JJì ¶
)
JJ¶ ß
where
JJ® ≠
U
JJÆ Ø
:
JJ∞ ±
	unmanaged
JJ≤ ª
,
JJª º
AllocatorManager
JJΩ Õ
.
JJÕ Œ

IAllocator
JJŒ ÿ
{KK 	
	AllocatorLL 
=LL 
	allocatorLL !
.LL! "
HandleLL" (
;LL( )
PtrMM 
=MM 
nullMM 
;MM 
LengthNN 
=NN 
$numNN 
;NN 
CapacityOO 
=OO 
$numOO 
;OO 
ifQQ 
(QQ 
initialCapacityQQ 
!=QQ  "
$numQQ# $
)QQ$ %
{RR 
SetCapacitySS 
(SS 
refSS 
	allocatorSS  )
,SS) *
sizeOfSS+ 1
,SS1 2
alignOfSS3 :
,SS: ;
initialCapacitySS< K
)SSK L
;SSL M
}TT 
ifVV 
(VV 
optionsVV 
==VV 
NativeArrayOptionsVV -
.VV- .
ClearMemoryVV. 9
&&WW 
PtrWW 
!=WW 
nullWW 
)WW 
{XX 
UnsafeUtilityYY 
.YY 
MemClearYY &
(YY& '
PtrYY' *
,YY* +
CapacityYY, 4
*YY5 6
sizeOfYY7 =
)YY= >
;YY> ?
}ZZ 
}[[ 	
internal]] 
static]] 

UnsafeList]] "
New]]# &
<]]& '
U]]' (
>]]( )
(]]) *
int]]* -
sizeOf]]. 4
,]]4 5
int]]6 9
alignOf]]: A
,]]A B
int]]C F
initialCapacity]]G V
,]]V W
ref]]X [
U]]\ ]
	allocator]]^ g
,]]g h
NativeArrayOptions]]i {
options	]]| É
=
]]Ñ Ö 
NativeArrayOptions
]]Ü ò
.
]]ò ô!
UninitializedMemory
]]ô ¨
)
]]¨ ≠
where
]]Æ ≥
U
]]¥ µ
:
]]∂ ∑
	unmanaged
]]∏ ¡
,
]]¡ ¬
AllocatorManager
]]√ ”
.
]]” ‘

IAllocator
]]‘ ﬁ
{^^ 	
var__ 
temp__ 
=__ 
new__ 

UnsafeList__ %
(__% &
)__& '
;__' (
temp`` 
.`` 

Initialize`` 
(`` 
sizeOf`` "
,``" #
alignOf``$ +
,``+ ,
initialCapacity``- <
,``< =
ref``> A
	allocator``B K
,``K L
options``M T
)``T U
;``U V
returnaa 
tempaa 
;aa 
}bb 	
publicnn 

UnsafeListnn 
(nn 
intnn 
sizeOfnn $
,nn$ %
intnn& )
alignOfnn* 1
,nn1 2
intnn3 6
initialCapacitynn7 F
,nnF G
AllocatorManagernnH X
.nnX Y
AllocatorHandlennY h
	allocatornni r
,nnr s
NativeArrayOptions	nnt Ü
options
nná é
=
nnè ê 
NativeArrayOptions
nnë £
.
nn£ §!
UninitializedMemory
nn§ ∑
)
nn∑ ∏
:
nnπ ∫
this
nnª ø
(
nnø ¿
)
nn¿ ¡
{oo 	
thispp 
=pp 
defaultpp 
;pp 

Initializeqq 
(qq 
sizeOfqq 
,qq 
alignOfqq &
,qq& '
initialCapacityqq( 7
,qq7 8
refqq9 <
	allocatorqq= F
,qqF G
optionsqqH O
)qqO P
;qqP Q
}rr 	
public~~ 

UnsafeList~~ 
(~~ 
int~~ 
sizeOf~~ $
,~~$ %
int~~& )
alignOf~~* 1
,~~1 2
int~~3 6
initialCapacity~~7 F
,~~F G
	Allocator~~H Q
	allocator~~R [
,~~[ \
NativeArrayOptions~~] o
options~~p w
=~~x y
NativeArrayOptions	~~z å
.
~~å ç!
UninitializedMemory
~~ç †
)
~~† °
:
~~¢ £
this
~~§ ®
(
~~® ©
)
~~© ™
{ 	
	Allocator
ÄÄ 
=
ÄÄ 
	allocator
ÄÄ !
;
ÄÄ! "
Ptr
ÅÅ 
=
ÅÅ 
null
ÅÅ 
;
ÅÅ 
Length
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
Capacity
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
if
ÖÖ 
(
ÖÖ 
initialCapacity
ÖÖ 
!=
ÖÖ  "
$num
ÖÖ# $
)
ÖÖ$ %
{
ÜÜ 
SetCapacity
áá 
(
áá 
sizeOf
áá "
,
áá" #
alignOf
áá$ +
,
áá+ ,
initialCapacity
áá- <
)
áá< =
;
áá= >
}
àà 
if
ää 
(
ää 
options
ää 
==
ää  
NativeArrayOptions
ää -
.
ää- .
ClearMemory
ää. 9
&&
ãã 
Ptr
ãã 
!=
ãã 
null
ãã 
)
ãã 
{
åå 
UnsafeUtility
çç 
.
çç 
MemClear
çç &
(
çç& '
Ptr
çç' *
,
çç* +
Capacity
çç, 4
*
çç5 6
sizeOf
çç7 =
)
çç= >
;
çç> ?
}
éé 
}
èè 	
public
úú 
static
úú 

UnsafeList
úú  
*
úú  !
Create
úú" (
(
úú( )
int
úú) ,
sizeOf
úú- 3
,
úú3 4
int
úú5 8
alignOf
úú9 @
,
úú@ A
int
úúB E
initialCapacity
úúF U
,
úúU V
	Allocator
úúW `
	allocator
úúa j
,
úúj k 
NativeArrayOptions
úúl ~
optionsúú Ü
=úúá à"
NativeArrayOptionsúúâ õ
.úúõ ú#
UninitializedMemoryúúú Ø
)úúØ ∞
{
ùù 	
var
ûû 
handle
ûû 
=
ûû 
(
ûû 
AllocatorManager
ûû *
.
ûû* +
AllocatorHandle
ûû+ :
)
ûû: ;
	allocator
ûû; D
;
ûûD E

UnsafeList
üü 
*
üü 
listData
üü  
=
üü! "
AllocatorManager
üü# 3
.
üü3 4
Allocate
üü4 <
<
üü< =

UnsafeList
üü= G
>
üüG H
(
üüH I
handle
üüI O
)
üüO P
;
üüP Q
UnsafeUtility
†† 
.
†† 
MemClear
†† "
(
††" #
listData
††# +
,
††+ ,
UnsafeUtility
††- :
.
††: ;
SizeOf
††; A
<
††A B

UnsafeList
††B L
>
††L M
(
††M N
)
††N O
)
††O P
;
††P Q
listData
¢¢ 
->
¢¢ 
	Allocator
¢¢ 
=
¢¢  !
	allocator
¢¢" +
;
¢¢+ ,
if
§§ 
(
§§ 
initialCapacity
§§ 
!=
§§  "
$num
§§# $
)
§§$ %
{
•• 
listData
¶¶ 
->
¶¶ 
SetCapacity
¶¶ %
(
¶¶% &
sizeOf
¶¶& ,
,
¶¶, -
alignOf
¶¶. 5
,
¶¶5 6
initialCapacity
¶¶7 F
)
¶¶F G
;
¶¶G H
}
ßß 
if
©© 
(
©© 
options
©© 
==
©©  
NativeArrayOptions
©© -
.
©©- .
ClearMemory
©©. 9
&&
™™ 
listData
™™ 
->
™™ 
Ptr
™™  
!=
™™! #
null
™™$ (
)
™™( )
{
´´ 
UnsafeUtility
¨¨ 
.
¨¨ 
MemClear
¨¨ &
(
¨¨& '
listData
¨¨' /
->
¨¨/ 1
Ptr
¨¨1 4
,
¨¨4 5
listData
¨¨6 >
->
¨¨> @
Capacity
¨¨@ H
*
¨¨I J
sizeOf
¨¨K Q
)
¨¨Q R
;
¨¨R S
}
≠≠ 
return
ØØ 
listData
ØØ 
;
ØØ 
}
∞∞ 	
internal
≤≤ 
static
≤≤ 

UnsafeList
≤≤ "
*
≤≤" #
Create
≤≤$ *
<
≤≤* +
U
≤≤+ ,
>
≤≤, -
(
≤≤- .
int
≤≤. 1
sizeOf
≤≤2 8
,
≤≤8 9
int
≤≤: =
alignOf
≤≤> E
,
≤≤E F
int
≤≤G J
initialCapacity
≤≤K Z
,
≤≤Z [
ref
≤≤\ _
U
≤≤` a
	allocator
≤≤b k
,
≤≤k l 
NativeArrayOptions
≤≤m 
options≤≤Ä á
=≤≤à â"
NativeArrayOptions≤≤ä ú
.≤≤ú ù#
UninitializedMemory≤≤ù ∞
)≤≤∞ ±
where≤≤≤ ∑
U≤≤∏ π
:≤≤∫ ª
	unmanaged≤≤º ≈
,≤≤≈ ∆ 
AllocatorManager≤≤« ◊
.≤≤◊ ÿ

IAllocator≤≤ÿ ‚
{
≥≥ 	

UnsafeList
¥¥ 
*
¥¥ 
listData
¥¥  
=
¥¥! "
	allocator
¥¥# ,
.
¥¥, -
Allocate
¥¥- 5
(
¥¥5 6
default
¥¥6 =
(
¥¥= >

UnsafeList
¥¥> H
)
¥¥H I
,
¥¥I J
$num
¥¥K L
)
¥¥L M
;
¥¥M N
UnsafeUtility
µµ 
.
µµ 
MemClear
µµ "
(
µµ" #
listData
µµ# +
,
µµ+ ,
UnsafeUtility
µµ- :
.
µµ: ;
SizeOf
µµ; A
<
µµA B

UnsafeList
µµB L
>
µµL M
(
µµM N
)
µµN O
)
µµO P
;
µµP Q
listData
∑∑ 
->
∑∑ 
	Allocator
∑∑ 
=
∑∑  !
	allocator
∑∑" +
.
∑∑+ ,
Handle
∑∑, 2
;
∑∑2 3
if
ππ 
(
ππ 
initialCapacity
ππ 
!=
ππ  "
$num
ππ# $
)
ππ$ %
{
∫∫ 
listData
ªª 
->
ªª 
SetCapacity
ªª %
(
ªª% &
ref
ªª& )
	allocator
ªª* 3
,
ªª3 4
sizeOf
ªª5 ;
,
ªª; <
alignOf
ªª= D
,
ªªD E
initialCapacity
ªªF U
)
ªªU V
;
ªªV W
}
ºº 
if
ææ 
(
ææ 
options
ææ 
==
ææ  
NativeArrayOptions
ææ -
.
ææ- .
ClearMemory
ææ. 9
&&
øø 
listData
øø 
->
øø 
Ptr
øø  
!=
øø! #
null
øø$ (
)
øø( )
{
¿¿ 
UnsafeUtility
¡¡ 
.
¡¡ 
MemClear
¡¡ &
(
¡¡& '
listData
¡¡' /
->
¡¡/ 1
Ptr
¡¡1 4
,
¡¡4 5
listData
¡¡6 >
->
¡¡> @
Capacity
¡¡@ H
*
¡¡I J
sizeOf
¡¡K Q
)
¡¡Q R
;
¡¡R S
}
¬¬ 
return
ƒƒ 
listData
ƒƒ 
;
ƒƒ 
}
≈≈ 	
internal
«« 
static
«« 
void
«« 
Destroy
«« $
<
««$ %
U
««% &
>
««& '
(
««' (

UnsafeList
««( 2
*
««2 3
listData
««4 <
,
««< =
ref
««> A
U
««B C
	allocator
««D M
,
««M N
int
««O R
sizeOf
««S Y
,
««Y Z
int
««[ ^
alignOf
««_ f
)
««f g
where
««h m
U
««n o
:
««p q
	unmanaged
««r {
,
««{ |
AllocatorManager««} ç
.««ç é

IAllocator««é ò
{
»» 	
	CheckNull
…… 
(
…… 
listData
…… 
)
…… 
;
……  
listData
   
->
   
Dispose
   
(
   
ref
   !
	allocator
  " +
,
  + ,
sizeOf
  - 3
,
  3 4
alignOf
  5 <
)
  < =
;
  = >
	allocator
ÀÀ 
.
ÀÀ 
Free
ÀÀ 
(
ÀÀ 
listData
ÀÀ #
,
ÀÀ# $
UnsafeUtility
ÀÀ% 2
.
ÀÀ2 3
SizeOf
ÀÀ3 9
<
ÀÀ9 :

UnsafeList
ÀÀ: D
>
ÀÀD E
(
ÀÀE F
)
ÀÀF G
,
ÀÀG H
UnsafeUtility
ÀÀI V
.
ÀÀV W
AlignOf
ÀÀW ^
<
ÀÀ^ _

UnsafeList
ÀÀ_ i
>
ÀÀi j
(
ÀÀj k
)
ÀÀk l
,
ÀÀl m
$num
ÀÀn o
)
ÀÀo p
;
ÀÀp q
}
ÃÃ 	
public
““ 
static
““ 
void
““ 
Destroy
““ "
(
““" #

UnsafeList
““# -
*
““- .
listData
““/ 7
)
““7 8
{
”” 	
	CheckNull
‘‘ 
(
‘‘ 
listData
‘‘ 
)
‘‘ 
;
‘‘  
var
’’ 
	allocator
’’ 
=
’’ 
listData
’’ $
->
’’$ &
	Allocator
’’& /
;
’’/ 0
listData
÷÷ 
->
÷÷ 
Dispose
÷÷ 
(
÷÷ 
)
÷÷ 
;
÷÷  
AllocatorManager
◊◊ 
.
◊◊ 
Free
◊◊ !
(
◊◊! "
	allocator
◊◊" +
,
◊◊+ ,
listData
◊◊- 5
)
◊◊5 6
;
◊◊6 7
}
ÿÿ 	
public
ﬁﬁ 
bool
ﬁﬁ 
IsEmpty
ﬁﬁ 
=>
ﬁﬁ 
!
ﬁﬁ  
	IsCreated
ﬁﬁ  )
||
ﬁﬁ* ,
Length
ﬁﬁ- 3
==
ﬁﬁ4 6
$num
ﬁﬁ7 8
;
ﬁﬁ8 9
public
ÌÌ 
bool
ÌÌ 
	IsCreated
ÌÌ 
=>
ÌÌ  
Ptr
ÌÌ! $
!=
ÌÌ% '
null
ÌÌ( ,
;
ÌÌ, -
public
ÚÚ 
void
ÚÚ 
Dispose
ÚÚ 
(
ÚÚ 
)
ÚÚ 
{
ÛÛ 	
if
ÙÙ 
(
ÙÙ 
CollectionHelper
ÙÙ  
.
ÙÙ  !
ShouldDeallocate
ÙÙ! 1
(
ÙÙ1 2
	Allocator
ÙÙ2 ;
)
ÙÙ; <
)
ÙÙ< =
{
ıı 
AllocatorManager
ˆˆ  
.
ˆˆ  !
Free
ˆˆ! %
(
ˆˆ% &
	Allocator
ˆˆ& /
,
ˆˆ/ 0
Ptr
ˆˆ1 4
)
ˆˆ4 5
;
ˆˆ5 6
	Allocator
˜˜ 
=
˜˜ 
AllocatorManager
˜˜ ,
.
˜˜, -
Invalid
˜˜- 4
;
˜˜4 5
}
¯¯ 
Ptr
˙˙ 
=
˙˙ 
null
˙˙ 
;
˙˙ 
Length
˚˚ 
=
˚˚ 
$num
˚˚ 
;
˚˚ 
Capacity
¸¸ 
=
¸¸ 
$num
¸¸ 
;
¸¸ 
}
˝˝ 	
internal
ˇˇ 
void
ˇˇ 
Dispose
ˇˇ 
<
ˇˇ 
U
ˇˇ 
>
ˇˇ  
(
ˇˇ  !
ref
ˇˇ! $
U
ˇˇ% &
	allocator
ˇˇ' 0
,
ˇˇ0 1
int
ˇˇ2 5
sizeOf
ˇˇ6 <
,
ˇˇ< =
int
ˇˇ> A
alignOf
ˇˇB I
)
ˇˇI J
where
ˇˇK P
U
ˇˇQ R
:
ˇˇS T
	unmanaged
ˇˇU ^
,
ˇˇ^ _
AllocatorManager
ˇˇ` p
.
ˇˇp q

IAllocator
ˇˇq {
{
ÄÄ 	
	allocator
ÅÅ 
.
ÅÅ 
Free
ÅÅ 
(
ÅÅ 
Ptr
ÅÅ 
,
ÅÅ 
sizeOf
ÅÅ  &
,
ÅÅ& '
alignOf
ÅÅ( /
,
ÅÅ/ 0
Length
ÅÅ1 7
)
ÅÅ7 8
;
ÅÅ8 9
Ptr
ÇÇ 
=
ÇÇ 
null
ÇÇ 
;
ÇÇ 
Length
ÉÉ 
=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
Capacity
ÑÑ 
=
ÑÑ 
$num
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
[
íí 	 
NotBurstCompatible
íí	 
]ííú ù
public
ìì 
	JobHandle
ìì 
Dispose
ìì  
(
ìì  !
	JobHandle
ìì! *
	inputDeps
ìì+ 4
)
ìì4 5
{
îî 	
if
ïï 
(
ïï 
CollectionHelper
ïï  
.
ïï  !
ShouldDeallocate
ïï! 1
(
ïï1 2
	Allocator
ïï2 ;
)
ïï; <
)
ïï< =
{
ññ 
var
óó 
	jobHandle
óó 
=
óó 
new
óó  #
UnsafeDisposeJob
óó$ 4
{
óó5 6
Ptr
óó7 :
=
óó; <
Ptr
óó= @
,
óó@ A
	Allocator
óóB K
=
óóL M
(
óóN O
	Allocator
óóO X
)
óóX Y
	Allocator
óóY b
.
óób c
Value
óóc h
}
óói j
.
óój k
Schedule
óók s
(
óós t
	inputDeps
óót }
)
óó} ~
;
óó~ 
Ptr
ôô 
=
ôô 
null
ôô 
;
ôô 
	Allocator
öö 
=
öö 
AllocatorManager
öö ,
.
öö, -
Invalid
öö- 4
;
öö4 5
return
úú 
	jobHandle
úú  
;
úú  !
}
ùù 
Ptr
üü 
=
üü 
null
üü 
;
üü 
return
°° 
	inputDeps
°° 
;
°° 
}
¢¢ 	
public
®® 
void
®® 
Clear
®® 
(
®® 
)
®® 
{
©© 	
Length
™™ 
=
™™ 
$num
™™ 
;
™™ 
}
´´ 	
public
¥¥ 
void
¥¥ 
Resize
¥¥ 
(
¥¥ 
int
¥¥ 
sizeOf
¥¥ %
,
¥¥% &
int
¥¥' *
alignOf
¥¥+ 2
,
¥¥2 3
int
¥¥4 7
length
¥¥8 >
,
¥¥> ? 
NativeArrayOptions
¥¥@ R
options
¥¥S Z
=
¥¥[ \ 
NativeArrayOptions
¥¥] o
.
¥¥o p"
UninitializedMemory¥¥p É
)¥¥É Ñ
{
µµ 	
var
∂∂ 
	oldLength
∂∂ 
=
∂∂ 
Length
∂∂ "
;
∂∂" #
if
∏∏ 
(
∏∏ 
length
∏∏ 
>
∏∏ 
Capacity
∏∏ !
)
∏∏! "
{
ππ 
SetCapacity
∫∫ 
(
∫∫ 
sizeOf
∫∫ "
,
∫∫" #
alignOf
∫∫$ +
,
∫∫+ ,
length
∫∫- 3
)
∫∫3 4
;
∫∫4 5
}
ªª 
Length
ΩΩ 
=
ΩΩ 
length
ΩΩ 
;
ΩΩ 
if
øø 
(
øø 
options
øø 
==
øø  
NativeArrayOptions
øø -
.
øø- .
ClearMemory
øø. 9
&&
¿¿ 
	oldLength
¿¿ 
<
¿¿ 
length
¿¿ %
)
¿¿% &
{
¡¡ 
var
¬¬ 
num
¬¬ 
=
¬¬ 
length
¬¬  
-
¬¬! "
	oldLength
¬¬# ,
;
¬¬, -
byte
√√ 
*
√√ 
ptr
√√ 
=
√√ 
(
√√ 
byte
√√ !
*
√√! "
)
√√" #
Ptr
√√# &
;
√√& '
UnsafeUtility
ƒƒ 
.
ƒƒ 
MemClear
ƒƒ &
(
ƒƒ& '
ptr
ƒƒ' *
+
ƒƒ+ ,
	oldLength
ƒƒ- 6
*
ƒƒ7 8
sizeOf
ƒƒ9 ?
,
ƒƒ? @
num
ƒƒA D
*
ƒƒE F
sizeOf
ƒƒG M
)
ƒƒM N
;
ƒƒN O
}
≈≈ 
}
∆∆ 	
public
ŒŒ 
void
ŒŒ 
Resize
ŒŒ 
<
ŒŒ 
T
ŒŒ 
>
ŒŒ 
(
ŒŒ 
int
ŒŒ !
length
ŒŒ" (
,
ŒŒ( ) 
NativeArrayOptions
ŒŒ* <
options
ŒŒ= D
=
ŒŒE F 
NativeArrayOptions
ŒŒG Y
.
ŒŒY Z!
UninitializedMemory
ŒŒZ m
)
ŒŒm n
where
ŒŒo t
T
ŒŒu v
:
ŒŒw x
struct
ŒŒy 
{
œœ 	
Resize
–– 
(
–– 
UnsafeUtility
––  
.
––  !
SizeOf
––! '
<
––' (
T
––( )
>
––) *
(
––* +
)
––+ ,
,
––, -
UnsafeUtility
––. ;
.
––; <
AlignOf
––< C
<
––C D
T
––D E
>
––E F
(
––F G
)
––G H
,
––H I
length
––J P
,
––P Q
options
––R Y
)
––Y Z
;
––Z [
}
—— 	
void
”” 
Realloc
”” 
<
”” 
U
”” 
>
”” 
(
”” 
ref
”” 
U
”” 
	allocator
”” '
,
””' (
int
””) ,
sizeOf
””- 3
,
””3 4
int
””5 8
alignOf
””9 @
,
””@ A
int
””B E
capacity
””F N
)
””N O
where
””P U
U
””V W
:
””X Y
	unmanaged
””Z c
,
””c d
AllocatorManager
””e u
.
””u v

IAllocator””v Ä
{
‘‘ 	
void
’’ 
*
’’ 

newPointer
’’ 
=
’’ 
null
’’ #
;
’’# $
if
◊◊ 
(
◊◊ 
capacity
◊◊ 
>
◊◊ 
$num
◊◊ 
)
◊◊ 
{
ÿÿ 

newPointer
ŸŸ 
=
ŸŸ 
	allocator
ŸŸ &
.
ŸŸ& '
Allocate
ŸŸ' /
(
ŸŸ/ 0
sizeOf
ŸŸ0 6
,
ŸŸ6 7
alignOf
ŸŸ8 ?
,
ŸŸ? @
capacity
ŸŸA I
)
ŸŸI J
;
ŸŸJ K
if
€€ 
(
€€ 
Capacity
€€ 
>
€€ 
$num
€€  
)
€€  !
{
‹‹ 
var
›› 
itemsToCopy
›› #
=
››$ %
math
››& *
.
››* +
min
››+ .
(
››. /
capacity
››/ 7
,
››7 8
Capacity
››9 A
)
››A B
;
››B C
var
ﬁﬁ 
bytesToCopy
ﬁﬁ #
=
ﬁﬁ$ %
itemsToCopy
ﬁﬁ& 1
*
ﬁﬁ2 3
sizeOf
ﬁﬁ4 :
;
ﬁﬁ: ;
UnsafeUtility
ﬂﬂ !
.
ﬂﬂ! "
MemCpy
ﬂﬂ" (
(
ﬂﬂ( )

newPointer
ﬂﬂ) 3
,
ﬂﬂ3 4
Ptr
ﬂﬂ5 8
,
ﬂﬂ8 9
bytesToCopy
ﬂﬂ: E
)
ﬂﬂE F
;
ﬂﬂF G
}
‡‡ 
}
·· 
	allocator
„„ 
.
„„ 
Free
„„ 
(
„„ 
Ptr
„„ 
,
„„ 
sizeOf
„„  &
,
„„& '
alignOf
„„( /
,
„„/ 0
Capacity
„„1 9
)
„„9 :
;
„„: ;
Ptr
ÂÂ 
=
ÂÂ 

newPointer
ÂÂ 
;
ÂÂ 
Capacity
ÊÊ 
=
ÊÊ 
capacity
ÊÊ 
;
ÊÊ  
Length
ÁÁ 
=
ÁÁ 
math
ÁÁ 
.
ÁÁ 
min
ÁÁ 
(
ÁÁ 
Length
ÁÁ $
,
ÁÁ$ %
capacity
ÁÁ& .
)
ÁÁ. /
;
ÁÁ/ 0
}
ËË 	
void
ÍÍ 
Realloc
ÍÍ 
(
ÍÍ 
int
ÍÍ 
sizeOf
ÍÍ 
,
ÍÍ  
int
ÍÍ! $
alignOf
ÍÍ% ,
,
ÍÍ, -
int
ÍÍ. 1
capacity
ÍÍ2 :
)
ÍÍ: ;
{
ÎÎ 	
Realloc
ÏÏ 
(
ÏÏ 
ref
ÏÏ 
	Allocator
ÏÏ !
,
ÏÏ! "
sizeOf
ÏÏ# )
,
ÏÏ) *
alignOf
ÏÏ+ 2
,
ÏÏ2 3
capacity
ÏÏ4 <
)
ÏÏ< =
;
ÏÏ= >
}
ÌÌ 	
void
ÔÔ 
SetCapacity
ÔÔ 
<
ÔÔ 
U
ÔÔ 
>
ÔÔ 
(
ÔÔ 
ref
ÔÔ 
U
ÔÔ  !
	allocator
ÔÔ" +
,
ÔÔ+ ,
int
ÔÔ- 0
sizeOf
ÔÔ1 7
,
ÔÔ7 8
int
ÔÔ9 <
alignOf
ÔÔ= D
,
ÔÔD E
int
ÔÔF I
capacity
ÔÔJ R
)
ÔÔR S
where
ÔÔT Y
U
ÔÔZ [
:
ÔÔ\ ]
	unmanaged
ÔÔ^ g
,
ÔÔg h
AllocatorManager
ÔÔi y
.
ÔÔy z

IAllocatorÔÔz Ñ
{
 	
var
ÒÒ 
newCapacity
ÒÒ 
=
ÒÒ 
math
ÒÒ "
.
ÒÒ" #
max
ÒÒ# &
(
ÒÒ& '
capacity
ÒÒ' /
,
ÒÒ/ 0
$num
ÒÒ1 3
/
ÒÒ4 5
sizeOf
ÒÒ6 <
)
ÒÒ< =
;
ÒÒ= >
newCapacity
ÚÚ 
=
ÚÚ 
math
ÚÚ 
.
ÚÚ 
ceilpow2
ÚÚ '
(
ÚÚ' (
newCapacity
ÚÚ( 3
)
ÚÚ3 4
;
ÚÚ4 5
if
ÙÙ 
(
ÙÙ 
newCapacity
ÙÙ 
==
ÙÙ 
Capacity
ÙÙ '
)
ÙÙ' (
{
ıı 
return
ˆˆ 
;
ˆˆ 
}
˜˜ 
Realloc
˘˘ 
(
˘˘ 
ref
˘˘ 
	allocator
˘˘ !
,
˘˘! "
sizeOf
˘˘# )
,
˘˘) *
alignOf
˘˘+ 2
,
˘˘2 3
newCapacity
˘˘4 ?
)
˘˘? @
;
˘˘@ A
}
˙˙ 	
void
¸¸ 
SetCapacity
¸¸ 
(
¸¸ 
int
¸¸ 
sizeOf
¸¸ #
,
¸¸# $
int
¸¸% (
alignOf
¸¸) 0
,
¸¸0 1
int
¸¸2 5
capacity
¸¸6 >
)
¸¸> ?
{
˝˝ 	
SetCapacity
˛˛ 
(
˛˛ 
ref
˛˛ 
	Allocator
˛˛ %
,
˛˛% &
sizeOf
˛˛' -
,
˛˛- .
alignOf
˛˛/ 6
,
˛˛6 7
capacity
˛˛8 @
)
˛˛@ A
;
˛˛A B
}
ˇˇ 	
public
ÜÜ 
void
ÜÜ 
SetCapacity
ÜÜ 
<
ÜÜ  
T
ÜÜ  !
>
ÜÜ! "
(
ÜÜ" #
int
ÜÜ# &
capacity
ÜÜ' /
)
ÜÜ/ 0
where
ÜÜ1 6
T
ÜÜ7 8
:
ÜÜ9 :
struct
ÜÜ; A
{
áá 	
SetCapacity
àà 
(
àà 
UnsafeUtility
àà %
.
àà% &
SizeOf
àà& ,
<
àà, -
T
àà- .
>
àà. /
(
àà/ 0
)
àà0 1
,
àà1 2
UnsafeUtility
àà3 @
.
àà@ A
AlignOf
ààA H
<
ààH I
T
ààI J
>
ààJ K
(
ààK L
)
ààL M
,
ààM N
capacity
ààO W
)
ààW X
;
ààX Y
}
ââ 	
public
èè 
void
èè 

TrimExcess
èè 
<
èè 
T
èè  
>
èè  !
(
èè! "
)
èè" #
where
èè$ )
T
èè* +
:
èè, -
struct
èè. 4
{
êê 	
if
ëë 
(
ëë 
Capacity
ëë 
!=
ëë 
Length
ëë "
)
ëë" #
{
íí 
Realloc
ìì 
(
ìì 
UnsafeUtility
ìì %
.
ìì% &
SizeOf
ìì& ,
<
ìì, -
T
ìì- .
>
ìì. /
(
ìì/ 0
)
ìì0 1
,
ìì1 2
UnsafeUtility
ìì3 @
.
ìì@ A
AlignOf
ììA H
<
ììH I
T
ììI J
>
ììJ K
(
ììK L
)
ììL M
,
ììM N
Length
ììO U
)
ììU V
;
ììV W
}
îî 
}
ïï 	
public
ùù 
int
ùù 
IndexOf
ùù 
<
ùù 
T
ùù 
>
ùù 
(
ùù 
T
ùù 
value
ùù  %
)
ùù% &
where
ùù' ,
T
ùù- .
:
ùù/ 0
struct
ùù1 7
,
ùù7 8

IEquatable
ùù9 C
<
ùùC D
T
ùùD E
>
ùùE F
{
ûû 	
return
üü #
NativeArrayExtensions
üü (
.
üü( )
IndexOf
üü) 0
<
üü0 1
T
üü1 2
,
üü2 3
T
üü4 5
>
üü5 6
(
üü6 7
Ptr
üü7 :
,
üü: ;
Length
üü< B
,
üüB C
value
üüD I
)
üüI J
;
üüJ K
}
†† 	
public
®® 
bool
®® 
Contains
®® 
<
®® 
T
®® 
>
®® 
(
®®  
T
®®  !
value
®®" '
)
®®' (
where
®®) .
T
®®/ 0
:
®®1 2
struct
®®3 9
,
®®9 :

IEquatable
®®; E
<
®®E F
T
®®F G
>
®®G H
{
©© 	
return
™™ 
IndexOf
™™ 
(
™™ 
value
™™  
)
™™  !
!=
™™" $
-
™™% &
$num
™™& '
;
™™' (
}
´´ 	
public
µµ 
void
µµ 
AddNoResize
µµ 
<
µµ  
T
µµ  !
>
µµ! "
(
µµ" #
T
µµ# $
value
µµ% *
)
µµ* +
where
µµ, 1
T
µµ2 3
:
µµ4 5
struct
µµ6 <
{
∂∂ 	,
CheckNoResizeHasEnoughCapacity
∑∑ *
(
∑∑* +
$num
∑∑+ ,
)
∑∑, -
;
∑∑- .
UnsafeUtility
∏∏ 
.
∏∏ 
WriteArrayElement
∏∏ +
(
∏∏+ ,
Ptr
∏∏, /
,
∏∏/ 0
Length
∏∏1 7
,
∏∏7 8
value
∏∏9 >
)
∏∏> ?
;
∏∏? @
Length
ππ 
+=
ππ 
$num
ππ 
;
ππ 
}
∫∫ 	
void
ºº 
AddRangeNoResize
ºº 
(
ºº 
int
ºº !
sizeOf
ºº" (
,
ºº( )
void
ºº* .
*
ºº. /
ptr
ºº0 3
,
ºº3 4
int
ºº5 8
length
ºº9 ?
)
ºº? @
{
ΩΩ 	,
CheckNoResizeHasEnoughCapacity
ææ *
(
ææ* +
length
ææ+ 1
)
ææ1 2
;
ææ2 3
void
øø 
*
øø 
dst
øø 
=
øø 
(
øø 
byte
øø 
*
øø 
)
øø 
Ptr
øø "
+
øø# $
Length
øø% +
*
øø, -
sizeOf
øø. 4
;
øø4 5
UnsafeUtility
¿¿ 
.
¿¿ 
MemCpy
¿¿  
(
¿¿  !
dst
¿¿! $
,
¿¿$ %
ptr
¿¿& )
,
¿¿) *
length
¿¿+ 1
*
¿¿2 3
sizeOf
¿¿4 :
)
¿¿: ;
;
¿¿; <
Length
¡¡ 
+=
¡¡ 
length
¡¡ 
;
¡¡ 
}
¬¬ 	
public
ÕÕ 
void
ÕÕ 
AddRangeNoResize
ÕÕ $
<
ÕÕ$ %
T
ÕÕ% &
>
ÕÕ& '
(
ÕÕ' (
void
ÕÕ( ,
*
ÕÕ, -
ptr
ÕÕ. 1
,
ÕÕ1 2
int
ÕÕ3 6
length
ÕÕ7 =
)
ÕÕ= >
where
ÕÕ? D
T
ÕÕE F
:
ÕÕG H
struct
ÕÕI O
{
ŒŒ 	
AddRangeNoResize
œœ 
(
œœ 
UnsafeUtility
œœ *
.
œœ* +
SizeOf
œœ+ 1
<
œœ1 2
T
œœ2 3
>
œœ3 4
(
œœ4 5
)
œœ5 6
,
œœ6 7
ptr
œœ8 ;
,
œœ; <
length
œœ= C
)
œœC D
;
œœD E
}
–– 	
public
⁄⁄ 
void
⁄⁄ 
AddRangeNoResize
⁄⁄ $
<
⁄⁄$ %
T
⁄⁄% &
>
⁄⁄& '
(
⁄⁄' (

UnsafeList
⁄⁄( 2
list
⁄⁄3 7
)
⁄⁄7 8
where
⁄⁄9 >
T
⁄⁄? @
:
⁄⁄A B
struct
⁄⁄C I
{
€€ 	
AddRangeNoResize
‹‹ 
(
‹‹ 
UnsafeUtility
‹‹ *
.
‹‹* +
SizeOf
‹‹+ 1
<
‹‹1 2
T
‹‹2 3
>
‹‹3 4
(
‹‹4 5
)
‹‹5 6
,
‹‹6 7
list
‹‹8 <
.
‹‹< =
Ptr
‹‹= @
,
‹‹@ A
CollectionHelper
‹‹B R
.
‹‹R S
AssumePositive
‹‹S a
(
‹‹a b
list
‹‹b f
.
‹‹f g
Length
‹‹g m
)
‹‹m n
)
‹‹n o
;
‹‹o p
}
›› 	
public
ËË 
void
ËË 
Add
ËË 
<
ËË 
T
ËË 
>
ËË 
(
ËË 
T
ËË 
value
ËË "
)
ËË" #
where
ËË$ )
T
ËË* +
:
ËË, -
struct
ËË. 4
{
ÈÈ 	
var
ÍÍ 
idx
ÍÍ 
=
ÍÍ 
Length
ÍÍ 
;
ÍÍ 
if
ÏÏ 
(
ÏÏ 
Length
ÏÏ 
+
ÏÏ 
$num
ÏÏ 
>
ÏÏ 
Capacity
ÏÏ %
)
ÏÏ% &
{
ÌÌ 
Resize
ÓÓ 
<
ÓÓ 
T
ÓÓ 
>
ÓÓ 
(
ÓÓ 
idx
ÓÓ 
+
ÓÓ 
$num
ÓÓ  !
)
ÓÓ! "
;
ÓÓ" #
}
ÔÔ 
else
 
{
ÒÒ 
Length
ÚÚ 
+=
ÚÚ 
$num
ÚÚ 
;
ÚÚ 
}
ÛÛ 
UnsafeUtility
ıı 
.
ıı 
WriteArrayElement
ıı +
(
ıı+ ,
Ptr
ıı, /
,
ıı/ 0
idx
ıı1 4
,
ıı4 5
value
ıı6 ;
)
ıı; <
;
ıı< =
}
ˆˆ 	
void
¯¯ 
AddRange
¯¯ 
(
¯¯ 
int
¯¯ 
sizeOf
¯¯  
,
¯¯  !
int
¯¯" %
alignOf
¯¯& -
,
¯¯- .
void
¯¯/ 3
*
¯¯3 4
ptr
¯¯5 8
,
¯¯8 9
int
¯¯: =
length
¯¯> D
)
¯¯D E
{
˘˘ 	
var
˙˙ 
idx
˙˙ 
=
˙˙ 
Length
˙˙ 
;
˙˙ 
if
¸¸ 
(
¸¸ 
Length
¸¸ 
+
¸¸ 
length
¸¸ 
>
¸¸  !
Capacity
¸¸" *
)
¸¸* +
{
˝˝ 
Resize
˛˛ 
(
˛˛ 
sizeOf
˛˛ 
,
˛˛ 
alignOf
˛˛ &
,
˛˛& '
Length
˛˛( .
+
˛˛/ 0
length
˛˛1 7
)
˛˛7 8
;
˛˛8 9
}
ˇˇ 
else
ÄÄ 
{
ÅÅ 
Length
ÇÇ 
+=
ÇÇ 
length
ÇÇ  
;
ÇÇ  !
}
ÉÉ 
void
ÖÖ 
*
ÖÖ 
dst
ÖÖ 
=
ÖÖ 
(
ÖÖ 
byte
ÖÖ 
*
ÖÖ 
)
ÖÖ 
Ptr
ÖÖ "
+
ÖÖ# $
idx
ÖÖ% (
*
ÖÖ) *
sizeOf
ÖÖ+ 1
;
ÖÖ1 2
UnsafeUtility
ÜÜ 
.
ÜÜ 
MemCpy
ÜÜ  
(
ÜÜ  !
dst
ÜÜ! $
,
ÜÜ$ %
ptr
ÜÜ& )
,
ÜÜ) *
length
ÜÜ+ 1
*
ÜÜ2 3
sizeOf
ÜÜ4 :
)
ÜÜ: ;
;
ÜÜ; <
}
áá 	
public
èè 
void
èè 
AddRange
èè 
<
èè 
T
èè 
>
èè 
(
èè  
void
èè  $
*
èè$ %
ptr
èè& )
,
èè) *
int
èè+ .
length
èè/ 5
)
èè5 6
where
èè7 <
T
èè= >
:
èè? @
struct
èèA G
{
êê 	
AddRange
ëë 
(
ëë 
UnsafeUtility
ëë "
.
ëë" #
SizeOf
ëë# )
<
ëë) *
T
ëë* +
>
ëë+ ,
(
ëë, -
)
ëë- .
,
ëë. /
UnsafeUtility
ëë0 =
.
ëë= >
AlignOf
ëë> E
<
ëëE F
T
ëëF G
>
ëëG H
(
ëëH I
)
ëëI J
,
ëëJ K
ptr
ëëL O
,
ëëO P
length
ëëQ W
)
ëëW X
;
ëëX Y
}
íí 	
public
ùù 
void
ùù 
AddRange
ùù 
<
ùù 
T
ùù 
>
ùù 
(
ùù  

UnsafeList
ùù  *
list
ùù+ /
)
ùù/ 0
where
ùù1 6
T
ùù7 8
:
ùù9 :
struct
ùù; A
{
ûû 	
AddRange
üü 
(
üü 
UnsafeUtility
üü "
.
üü" #
SizeOf
üü# )
<
üü) *
T
üü* +
>
üü+ ,
(
üü, -
)
üü- .
,
üü. /
UnsafeUtility
üü0 =
.
üü= >
AlignOf
üü> E
<
üüE F
T
üüF G
>
üüG H
(
üüH I
)
üüI J
,
üüJ K
list
üüL P
.
üüP Q
Ptr
üüQ T
,
üüT U
list
üüV Z
.
üüZ [
Length
üü[ a
)
üüa b
;
üüb c
}
†† 	
void
¢¢ %
InsertRangeWithBeginEnd
¢¢ $
(
¢¢$ %
int
¢¢% (
sizeOf
¢¢) /
,
¢¢/ 0
int
¢¢1 4
alignOf
¢¢5 <
,
¢¢< =
int
¢¢> A
begin
¢¢B G
,
¢¢G H
int
¢¢I L
end
¢¢M P
)
¢¢P Q
{
££ 	
CheckBeginEnd
§§ 
(
§§ 
begin
§§ 
,
§§  
end
§§! $
)
§§$ %
;
§§% &
int
¶¶ 
items
¶¶ 
=
¶¶ 
end
¶¶ 
-
¶¶ 
begin
¶¶ #
;
¶¶# $
if
ßß 
(
ßß 
items
ßß 
<
ßß 
$num
ßß 
)
ßß 
{
®® 
return
©© 
;
©© 
}
™™ 
var
¨¨ 
	oldLength
¨¨ 
=
¨¨ 
Length
¨¨ "
;
¨¨" #
if
ÆÆ 
(
ÆÆ 
Length
ÆÆ 
+
ÆÆ 
items
ÆÆ 
>
ÆÆ  
Capacity
ÆÆ! )
)
ÆÆ) *
{
ØØ 
Resize
∞∞ 
(
∞∞ 
sizeOf
∞∞ 
,
∞∞ 
alignOf
∞∞ &
,
∞∞& '
Length
∞∞( .
+
∞∞/ 0
items
∞∞1 6
)
∞∞6 7
;
∞∞7 8
}
±± 
else
≤≤ 
{
≥≥ 
Length
¥¥ 
+=
¥¥ 
items
¥¥ 
;
¥¥  
}
µµ 
var
∑∑ 
itemsToCopy
∑∑ 
=
∑∑ 
	oldLength
∑∑ '
-
∑∑( )
begin
∑∑* /
;
∑∑/ 0
if
ππ 
(
ππ 
itemsToCopy
ππ 
<
ππ 
$num
ππ 
)
ππ  
{
∫∫ 
return
ªª 
;
ªª 
}
ºº 
var
ææ 
bytesToCopy
ææ 
=
ææ 
itemsToCopy
ææ )
*
ææ* +
sizeOf
ææ, 2
;
ææ2 3
unsafe
øø 
{
¿¿ 
byte
¡¡ 
*
¡¡ 
ptr
¡¡ 
=
¡¡ 
(
¡¡ 
byte
¡¡ !
*
¡¡! "
)
¡¡" #
Ptr
¡¡# &
;
¡¡& '
byte
¬¬ 
*
¬¬ 
dest
¬¬ 
=
¬¬ 
ptr
¬¬  
+
¬¬! "
end
¬¬# &
*
¬¬' (
sizeOf
¬¬) /
;
¬¬/ 0
byte
√√ 
*
√√ 
src
√√ 
=
√√ 
ptr
√√ 
+
√√  !
begin
√√" '
*
√√( )
sizeOf
√√* 0
;
√√0 1
UnsafeUtility
ƒƒ 
.
ƒƒ 
MemMove
ƒƒ %
(
ƒƒ% &
dest
ƒƒ& *
,
ƒƒ* +
src
ƒƒ, /
,
ƒƒ/ 0
bytesToCopy
ƒƒ1 <
)
ƒƒ< =
;
ƒƒ= >
}
≈≈ 
}
∆∆ 	
public
–– 
void
–– %
InsertRangeWithBeginEnd
–– +
<
––+ ,
T
––, -
>
––- .
(
––. /
int
––/ 2
begin
––3 8
,
––8 9
int
––: =
end
––> A
)
––A B
where
––C H
T
––I J
:
––K L
struct
––M S
{
—— 	%
InsertRangeWithBeginEnd
““ #
(
““# $
UnsafeUtility
““$ 1
.
““1 2
SizeOf
““2 8
<
““8 9
T
““9 :
>
““: ;
(
““; <
)
““< =
,
““= >
UnsafeUtility
““? L
.
““L M
AlignOf
““M T
<
““T U
T
““U V
>
““V W
(
““W X
)
““X Y
,
““Y Z
begin
““[ `
,
““` a
end
““b e
)
““e f
;
““f g
}
”” 	
void
’’ -
RemoveRangeSwapBackWithBeginEnd
’’ ,
(
’’, -
int
’’- 0
sizeOf
’’1 7
,
’’7 8
int
’’9 <
begin
’’= B
,
’’B C
int
’’D G
end
’’H K
)
’’K L
{
÷÷ 	
CheckBeginEnd
◊◊ 
(
◊◊ 
begin
◊◊ 
,
◊◊  
end
◊◊! $
)
◊◊$ %
;
◊◊% &
int
ŸŸ 
itemsToRemove
ŸŸ 
=
ŸŸ 
end
ŸŸ  #
-
ŸŸ$ %
begin
ŸŸ& +
;
ŸŸ+ ,
if
⁄⁄ 
(
⁄⁄ 
itemsToRemove
⁄⁄ 
>
⁄⁄ 
$num
⁄⁄  !
)
⁄⁄! "
{
€€ 
int
‹‹ 
copyFrom
‹‹ 
=
‹‹ 
math
‹‹ #
.
‹‹# $
max
‹‹$ '
(
‹‹' (
Length
‹‹( .
-
‹‹/ 0
itemsToRemove
‹‹1 >
,
‹‹> ?
end
‹‹@ C
)
‹‹C D
;
‹‹D E
void
›› 
*
›› 
dst
›› 
=
›› 
(
›› 
byte
›› !
*
››! "
)
››" #
Ptr
››# &
+
››' (
begin
››) .
*
››/ 0
sizeOf
››1 7
;
››7 8
void
ﬁﬁ 
*
ﬁﬁ 
src
ﬁﬁ 
=
ﬁﬁ 
(
ﬁﬁ 
byte
ﬁﬁ !
*
ﬁﬁ! "
)
ﬁﬁ" #
Ptr
ﬁﬁ# &
+
ﬁﬁ' (
copyFrom
ﬁﬁ) 1
*
ﬁﬁ2 3
sizeOf
ﬁﬁ4 :
;
ﬁﬁ: ;
UnsafeUtility
ﬂﬂ 
.
ﬂﬂ 
MemCpy
ﬂﬂ $
(
ﬂﬂ$ %
dst
ﬂﬂ% (
,
ﬂﬂ( )
src
ﬂﬂ* -
,
ﬂﬂ- .
(
ﬂﬂ/ 0
Length
ﬂﬂ0 6
-
ﬂﬂ7 8
copyFrom
ﬂﬂ9 A
)
ﬂﬂA B
*
ﬂﬂC D
sizeOf
ﬂﬂE K
)
ﬂﬂK L
;
ﬂﬂL M
Length
‡‡ 
-=
‡‡ 
itemsToRemove
‡‡ '
;
‡‡' (
}
·· 
}
‚‚ 	
public
ÏÏ 
void
ÏÏ 
RemoveAtSwapBack
ÏÏ $
<
ÏÏ$ %
T
ÏÏ% &
>
ÏÏ& '
(
ÏÏ' (
int
ÏÏ( +
index
ÏÏ, 1
)
ÏÏ1 2
where
ÏÏ3 8
T
ÏÏ9 :
:
ÏÏ; <
struct
ÏÏ= C
{
ÌÌ 	-
RemoveRangeSwapBackWithBeginEnd
ÓÓ +
<
ÓÓ+ ,
T
ÓÓ, -
>
ÓÓ- .
(
ÓÓ. /
index
ÓÓ/ 4
,
ÓÓ4 5
index
ÓÓ6 ;
+
ÓÓ< =
$num
ÓÓ> ?
)
ÓÓ? @
;
ÓÓ@ A
}
ÔÔ 	
public
˙˙ 
void
˙˙ -
RemoveRangeSwapBackWithBeginEnd
˙˙ 3
<
˙˙3 4
T
˙˙4 5
>
˙˙5 6
(
˙˙6 7
int
˙˙7 :
begin
˙˙; @
,
˙˙@ A
int
˙˙B E
end
˙˙F I
)
˙˙I J
where
˙˙K P
T
˙˙Q R
:
˙˙S T
struct
˙˙U [
{
˚˚ 	-
RemoveRangeSwapBackWithBeginEnd
¸¸ +
(
¸¸+ ,
UnsafeUtility
¸¸, 9
.
¸¸9 :
SizeOf
¸¸: @
<
¸¸@ A
T
¸¸A B
>
¸¸B C
(
¸¸C D
)
¸¸D E
,
¸¸E F
begin
¸¸G L
,
¸¸L M
end
¸¸N Q
)
¸¸Q R
;
¸¸R S
}
˝˝ 	
void
ˇˇ %
RemoveRangeWithBeginEnd
ˇˇ $
(
ˇˇ$ %
int
ˇˇ% (
sizeOf
ˇˇ) /
,
ˇˇ/ 0
int
ˇˇ1 4
begin
ˇˇ5 :
,
ˇˇ: ;
int
ˇˇ< ?
end
ˇˇ@ C
)
ˇˇC D
{
ÄÄ 	
CheckBeginEnd
ÅÅ 
(
ÅÅ 
begin
ÅÅ 
,
ÅÅ  
end
ÅÅ! $
)
ÅÅ$ %
;
ÅÅ% &
int
ÉÉ 
itemsToRemove
ÉÉ 
=
ÉÉ 
end
ÉÉ  #
-
ÉÉ$ %
begin
ÉÉ& +
;
ÉÉ+ ,
if
ÑÑ 
(
ÑÑ 
itemsToRemove
ÑÑ 
>
ÑÑ 
$num
ÑÑ  !
)
ÑÑ! "
{
ÖÖ 
int
ÜÜ 
copyFrom
ÜÜ 
=
ÜÜ 
math
ÜÜ #
.
ÜÜ# $
min
ÜÜ$ '
(
ÜÜ' (
begin
ÜÜ( -
+
ÜÜ. /
itemsToRemove
ÜÜ0 =
,
ÜÜ= >
Length
ÜÜ? E
)
ÜÜE F
;
ÜÜF G
void
áá 
*
áá 
dst
áá 
=
áá 
(
áá 
byte
áá !
*
áá! "
)
áá" #
Ptr
áá# &
+
áá' (
begin
áá) .
*
áá/ 0
sizeOf
áá1 7
;
áá7 8
void
àà 
*
àà 
src
àà 
=
àà 
(
àà 
byte
àà !
*
àà! "
)
àà" #
Ptr
àà# &
+
àà' (
copyFrom
àà) 1
*
àà2 3
sizeOf
àà4 :
;
àà: ;
UnsafeUtility
ââ 
.
ââ 
MemCpy
ââ $
(
ââ$ %
dst
ââ% (
,
ââ( )
src
ââ* -
,
ââ- .
(
ââ/ 0
Length
ââ0 6
-
ââ7 8
copyFrom
ââ9 A
)
ââA B
*
ââC D
sizeOf
ââE K
)
ââK L
;
ââL M
Length
ää 
-=
ää 
itemsToRemove
ää '
;
ää' (
}
ãã 
}
åå 	
public
òò 
void
òò 
RemoveAt
òò 
<
òò 
T
òò 
>
òò 
(
òò  
int
òò  #
index
òò$ )
)
òò) *
where
òò+ 0
T
òò1 2
:
òò3 4
struct
òò5 ;
{
ôô 	%
RemoveRangeWithBeginEnd
öö #
<
öö# $
T
öö$ %
>
öö% &
(
öö& '
index
öö' ,
,
öö, -
index
öö. 3
+
öö4 5
$num
öö6 7
)
öö7 8
;
öö8 9
}
õõ 	
public
™™ 
void
™™ %
RemoveRangeWithBeginEnd
™™ +
<
™™+ ,
T
™™, -
>
™™- .
(
™™. /
int
™™/ 2
begin
™™3 8
,
™™8 9
int
™™: =
end
™™> A
)
™™A B
where
™™C H
T
™™I J
:
™™K L
struct
™™M S
{
´´ 	%
RemoveRangeWithBeginEnd
¨¨ #
(
¨¨# $
UnsafeUtility
¨¨$ 1
.
¨¨1 2
SizeOf
¨¨2 8
<
¨¨8 9
T
¨¨9 :
>
¨¨: ;
(
¨¨; <
)
¨¨< =
,
¨¨= >
begin
¨¨? D
,
¨¨D E
end
¨¨F I
)
¨¨I J
;
¨¨J K
}
≠≠ 	
public
≥≥ 
ParallelReader
≥≥ 
AsParallelReader
≥≥ .
(
≥≥. /
)
≥≥/ 0
{
¥¥ 	
return
µµ 
new
µµ 
ParallelReader
µµ %
(
µµ% &
Ptr
µµ& )
,
µµ) *
Length
µµ+ 1
)
µµ1 2
;
µµ2 3
}
∂∂ 	
public
ªª 
unsafe
ªª 
struct
ªª 
ParallelReader
ªª +
{
ºº 	
[
¿¿ /
!NativeDisableUnsafePtrRestriction
¿¿ .
]
¿¿. /
public
¡¡ 
readonly
¡¡ 
void
¡¡  
*
¡¡  !
Ptr
¡¡" %
;
¡¡% &
public
∆∆ 
readonly
∆∆ 
int
∆∆ 
Length
∆∆  &
;
∆∆& '
internal
»» 
ParallelReader
»» #
(
»»# $
void
»»$ (
*
»»( )
ptr
»»* -
,
»»- .
int
»»/ 2
length
»»3 9
)
»»9 :
{
…… 
Ptr
   
=
   
ptr
   
;
   
Length
ÀÀ 
=
ÀÀ 
length
ÀÀ 
;
ÀÀ  
}
ÃÃ 
public
‘‘ 
int
‘‘ 
IndexOf
‘‘ 
<
‘‘ 
T
‘‘  
>
‘‘  !
(
‘‘! "
T
‘‘" #
value
‘‘$ )
)
‘‘) *
where
‘‘+ 0
T
‘‘1 2
:
‘‘3 4
struct
‘‘5 ;
,
‘‘; <

IEquatable
‘‘= G
<
‘‘G H
T
‘‘H I
>
‘‘I J
{
’’ 
return
÷÷ #
NativeArrayExtensions
÷÷ ,
.
÷÷, -
IndexOf
÷÷- 4
<
÷÷4 5
T
÷÷5 6
,
÷÷6 7
T
÷÷8 9
>
÷÷9 :
(
÷÷: ;
Ptr
÷÷; >
,
÷÷> ?
Length
÷÷@ F
,
÷÷F G
value
÷÷H M
)
÷÷M N
;
÷÷N O
}
◊◊ 
public
ﬂﬂ 
bool
ﬂﬂ 
Contains
ﬂﬂ  
<
ﬂﬂ  !
T
ﬂﬂ! "
>
ﬂﬂ" #
(
ﬂﬂ# $
T
ﬂﬂ$ %
value
ﬂﬂ& +
)
ﬂﬂ+ ,
where
ﬂﬂ- 2
T
ﬂﬂ3 4
:
ﬂﬂ5 6
struct
ﬂﬂ7 =
,
ﬂﬂ= >

IEquatable
ﬂﬂ? I
<
ﬂﬂI J
T
ﬂﬂJ K
>
ﬂﬂK L
{
‡‡ 
return
·· 
IndexOf
·· 
(
·· 
value
·· $
)
··$ %
!=
··& (
-
··) *
$num
··* +
;
··+ ,
}
‚‚ 
}
„„ 	
public
ÈÈ 
ParallelWriter
ÈÈ 
AsParallelWriter
ÈÈ .
(
ÈÈ. /
)
ÈÈ/ 0
{
ÍÍ 	
return
ÎÎ 
new
ÎÎ 
ParallelWriter
ÎÎ %
(
ÎÎ% &
Ptr
ÎÎ& )
,
ÎÎ) *
(
ÎÎ+ ,

UnsafeList
ÎÎ, 6
*
ÎÎ6 7
)
ÎÎ7 8
UnsafeUtility
ÎÎ8 E
.
ÎÎE F
	AddressOf
ÎÎF O
(
ÎÎO P
ref
ÎÎP S
this
ÎÎT X
)
ÎÎX Y
)
ÎÎY Z
;
ÎÎZ [
}
ÏÏ 	
public
ÒÒ 
unsafe
ÒÒ 
struct
ÒÒ 
ParallelWriter
ÒÒ +
{
ÚÚ 	
[
ˆˆ /
!NativeDisableUnsafePtrRestriction
ˆˆ .
]
ˆˆ. /
public
˜˜ 
readonly
˜˜ 
void
˜˜  
*
˜˜  !
Ptr
˜˜" %
;
˜˜% &
[
¸¸ /
!NativeDisableUnsafePtrRestriction
¸¸ .
]
¸¸. /
public
˝˝ 

UnsafeList
˝˝ 
*
˝˝ 
ListData
˝˝ '
;
˝˝' (
internal
ˇˇ 
unsafe
ˇˇ 
ParallelWriter
ˇˇ *
(
ˇˇ* +
void
ˇˇ+ /
*
ˇˇ/ 0
ptr
ˇˇ1 4
,
ˇˇ4 5

UnsafeList
ˇˇ6 @
*
ˇˇ@ A
listData
ˇˇB J
)
ˇˇJ K
{
ÄÄ 
Ptr
ÅÅ 
=
ÅÅ 
ptr
ÅÅ 
;
ÅÅ 
ListData
ÇÇ 
=
ÇÇ 
listData
ÇÇ #
;
ÇÇ# $
}
ÉÉ 
public
çç 
void
çç 
AddNoResize
çç #
<
çç# $
T
çç$ %
>
çç% &
(
çç& '
T
çç' (
value
çç) .
)
çç. /
where
çç0 5
T
çç6 7
:
çç8 9
struct
çç: @
{
éé 
var
èè 
idx
èè 
=
èè 
Interlocked
èè %
.
èè% &
	Increment
èè& /
(
èè/ 0
ref
èè0 3
ListData
èè4 <
->
èè< >
Length
èè> D
)
èèD E
-
èèF G
$num
èèH I
;
èèI J
ListData
êê 
->
êê ,
CheckNoResizeHasEnoughCapacity
êê 8
(
êê8 9
idx
êê9 <
,
êê< =
$num
êê> ?
)
êê? @
;
êê@ A
UnsafeUtility
ëë 
.
ëë 
WriteArrayElement
ëë /
(
ëë/ 0
Ptr
ëë0 3
,
ëë3 4
idx
ëë5 8
,
ëë8 9
value
ëë: ?
)
ëë? @
;
ëë@ A
}
íí 
void
îî 
AddRangeNoResize
îî !
(
îî! "
int
îî" %
sizeOf
îî& ,
,
îî, -
int
îî. 1
alignOf
îî2 9
,
îî9 :
void
îî; ?
*
îî? @
ptr
îîA D
,
îîD E
int
îîF I
length
îîJ P
)
îîP Q
{
ïï 
var
ññ 
idx
ññ 
=
ññ 
Interlocked
ññ %
.
ññ% &
Add
ññ& )
(
ññ) *
ref
ññ* -
ListData
ññ. 6
->
ññ6 8
Length
ññ8 >
,
ññ> ?
length
ññ@ F
)
ññF G
-
ññH I
length
ññJ P
;
ññP Q
ListData
óó 
->
óó ,
CheckNoResizeHasEnoughCapacity
óó 8
(
óó8 9
idx
óó9 <
,
óó< =
length
óó> D
)
óóD E
;
óóE F
void
òò 
*
òò 
dst
òò 
=
òò 
(
òò 
byte
òò !
*
òò! "
)
òò" #
Ptr
òò# &
+
òò' (
idx
òò) ,
*
òò- .
sizeOf
òò/ 5
;
òò5 6
UnsafeUtility
ôô 
.
ôô 
MemCpy
ôô $
(
ôô$ %
dst
ôô% (
,
ôô( )
ptr
ôô* -
,
ôô- .
length
ôô/ 5
*
ôô6 7
sizeOf
ôô8 >
)
ôô> ?
;
ôô? @
}
öö 
public
•• 
void
•• 
AddRangeNoResize
•• (
<
••( )
T
••) *
>
••* +
(
••+ ,
void
••, 0
*
••0 1
ptr
••2 5
,
••5 6
int
••7 :
length
••; A
)
••A B
where
••C H
T
••I J
:
••K L
struct
••M S
{
¶¶ 
AddRangeNoResize
ßß  
(
ßß  !
UnsafeUtility
ßß! .
.
ßß. /
SizeOf
ßß/ 5
<
ßß5 6
T
ßß6 7
>
ßß7 8
(
ßß8 9
)
ßß9 :
,
ßß: ;
UnsafeUtility
ßß< I
.
ßßI J
AlignOf
ßßJ Q
<
ßßQ R
T
ßßR S
>
ßßS T
(
ßßT U
)
ßßU V
,
ßßV W
ptr
ßßX [
,
ßß[ \
length
ßß] c
)
ßßc d
;
ßßd e
}
®® 
public
≤≤ 
void
≤≤ 
AddRangeNoResize
≤≤ (
<
≤≤( )
T
≤≤) *
>
≤≤* +
(
≤≤+ ,

UnsafeList
≤≤, 6
list
≤≤7 ;
)
≤≤; <
where
≤≤= B
T
≤≤C D
:
≤≤E F
struct
≤≤G M
{
≥≥ 
AddRangeNoResize
¥¥  
(
¥¥  !
UnsafeUtility
¥¥! .
.
¥¥. /
SizeOf
¥¥/ 5
<
¥¥5 6
T
¥¥6 7
>
¥¥7 8
(
¥¥8 9
)
¥¥9 :
,
¥¥: ;
UnsafeUtility
¥¥< I
.
¥¥I J
AlignOf
¥¥J Q
<
¥¥Q R
T
¥¥R S
>
¥¥S T
(
¥¥T U
)
¥¥U V
,
¥¥V W
list
¥¥X \
.
¥¥\ ]
Ptr
¥¥] `
,
¥¥` a
list
¥¥b f
.
¥¥f g
Length
¥¥g m
)
¥¥m n
;
¥¥n o
}
µµ 
}
∂∂ 	
[
∏∏ 	
Conditional
∏∏	 
(
∏∏ 
$str
∏∏ 6
)
∏∏6 7
]
∏∏7 8
internal
ππ 
static
ππ 
void
ππ 
	CheckNull
ππ &
(
ππ& '
void
ππ' +
*
ππ+ ,
listData
ππ- 5
)
ππ5 6
{
∫∫ 	
if
ªª 
(
ªª 
listData
ªª 
==
ªª 
null
ªª  
)
ªª  !
{
ºº 
throw
ΩΩ 
new
ΩΩ 
	Exception
ΩΩ #
(
ΩΩ# $
$str
ΩΩ$ ]
)
ΩΩ] ^
;
ΩΩ^ _
}
ææ 
}
øø 	
[
¡¡ 	
Conditional
¡¡	 
(
¡¡ 
$str
¡¡ 6
)
¡¡6 7
]
¡¡7 8
static
¬¬ 
void
¬¬ 
CheckAllocator
¬¬ "
(
¬¬" #
	Allocator
¬¬# ,
a
¬¬- .
)
¬¬. /
{
√√ 	
if
ƒƒ 
(
ƒƒ 
!
ƒƒ 
CollectionHelper
ƒƒ !
.
ƒƒ! "
ShouldDeallocate
ƒƒ" 2
(
ƒƒ2 3
a
ƒƒ3 4
)
ƒƒ4 5
)
ƒƒ5 6
{
≈≈ 
throw
∆∆ 
new
∆∆ 
	Exception
∆∆ #
(
∆∆# $
$str
∆∆$ v
)
∆∆v w
;
∆∆w x
}
«« 
}
»» 	
[
   	
Conditional
  	 
(
   
$str
   6
)
  6 7
]
  7 8
static
ÀÀ 
void
ÀÀ 
CheckAllocator
ÀÀ "
(
ÀÀ" #
AllocatorManager
ÀÀ# 3
.
ÀÀ3 4
AllocatorHandle
ÀÀ4 C
a
ÀÀD E
)
ÀÀE F
{
ÃÃ 	
if
ÕÕ 
(
ÕÕ 
!
ÕÕ 
CollectionHelper
ÕÕ !
.
ÕÕ! "
ShouldDeallocate
ÕÕ" 2
(
ÕÕ2 3
a
ÕÕ3 4
)
ÕÕ4 5
)
ÕÕ5 6
{
ŒŒ 
throw
œœ 
new
œœ 
	Exception
œœ #
(
œœ# $
$str
œœ$ v
)
œœv w
;
œœw x
}
–– 
}
—— 	
[
”” 	
Conditional
””	 
(
”” 
$str
”” 6
)
””6 7
]
””7 8
void
‘‘ 
CheckBeginEnd
‘‘ 
(
‘‘ 
int
‘‘ 
begin
‘‘ $
,
‘‘$ %
int
‘‘& )
end
‘‘* -
)
‘‘- .
{
’’ 	
if
÷÷ 
(
÷÷ 
begin
÷÷ 
>
÷÷ 
end
÷÷ 
)
÷÷ 
{
◊◊ 
throw
ÿÿ 
new
ÿÿ 
ArgumentException
ÿÿ +
(
ÿÿ+ ,
$"
ÿÿ, .
$str
ÿÿ. >
{
ÿÿ> ?
begin
ÿÿ? D
}
ÿÿD E
$str
ÿÿE f
{
ÿÿf g
end
ÿÿg j
}
ÿÿj k
$str
ÿÿk l
"
ÿÿl m
)
ÿÿm n
;
ÿÿn o
}
ŸŸ 
if
€€ 
(
€€ 
begin
€€ 
<
€€ 
$num
€€ 
)
€€ 
{
‹‹ 
throw
›› 
new
›› )
ArgumentOutOfRangeException
›› 5
(
››5 6
$"
››6 8
$str
››8 H
{
››H I
begin
››I N
}
››N O
$str
››O a
"
››a b
)
››b c
;
››c d
}
ﬁﬁ 
if
‡‡ 
(
‡‡ 
begin
‡‡ 
>
‡‡ 
Length
‡‡ 
)
‡‡ 
{
·· 
throw
‚‚ 
new
‚‚ )
ArgumentOutOfRangeException
‚‚ 5
(
‚‚5 6
$"
‚‚6 8
$str
‚‚8 H
{
‚‚H I
begin
‚‚I N
}
‚‚N O
$str
‚‚O a
"
‚‚a b
)
‚‚b c
;
‚‚c d
}
„„ 
if
ÂÂ 
(
ÂÂ 
end
ÂÂ 
>
ÂÂ 
Length
ÂÂ 
)
ÂÂ 
{
ÊÊ 
throw
ÁÁ 
new
ÁÁ )
ArgumentOutOfRangeException
ÁÁ 5
(
ÁÁ5 6
$"
ÁÁ6 8
$str
ÁÁ8 F
{
ÁÁF G
end
ÁÁG J
}
ÁÁJ K
$str
ÁÁK ]
"
ÁÁ] ^
)
ÁÁ^ _
;
ÁÁ_ `
}
ËË 
}
ÈÈ 	
[
ÎÎ 	
Conditional
ÎÎ	 
(
ÎÎ 
$str
ÎÎ 6
)
ÎÎ6 7
]
ÎÎ7 8
void
ÏÏ ,
CheckNoResizeHasEnoughCapacity
ÏÏ +
(
ÏÏ+ ,
int
ÏÏ, /
length
ÏÏ0 6
)
ÏÏ6 7
{
ÌÌ 	,
CheckNoResizeHasEnoughCapacity
ÓÓ *
(
ÓÓ* +
length
ÓÓ+ 1
,
ÓÓ1 2
Length
ÓÓ3 9
)
ÓÓ9 :
;
ÓÓ: ;
}
ÔÔ 	
[
ÒÒ 	
Conditional
ÒÒ	 
(
ÒÒ 
$str
ÒÒ 6
)
ÒÒ6 7
]
ÒÒ7 8
void
ÚÚ ,
CheckNoResizeHasEnoughCapacity
ÚÚ +
(
ÚÚ+ ,
int
ÚÚ, /
length
ÚÚ0 6
,
ÚÚ6 7
int
ÚÚ8 ;
index
ÚÚ< A
)
ÚÚA B
{
ÛÛ 	
if
ÙÙ 
(
ÙÙ 
Capacity
ÙÙ 
<
ÙÙ 
index
ÙÙ  
+
ÙÙ! "
length
ÙÙ# )
)
ÙÙ) *
{
ıı 
throw
ˆˆ 
new
ˆˆ 
	Exception
ˆˆ #
(
ˆˆ# $
$"
ˆˆ$ &
$str
ˆˆ& e
{
ˆˆe f
Capacity
ˆˆf n
}
ˆˆn o
$str
ˆˆo x
{
ˆˆx y
Length
ˆˆy 
}ˆˆ Ä
$strˆˆÄ î
{ˆˆî ï
lengthˆˆï õ
}ˆˆõ ú
$strˆˆú ù
"ˆˆù û
)ˆˆû ü
;ˆˆü †
}
˜˜ 
}
¯¯ 	
}
˘˘ 
public
˛˛ 

static
˛˛ 
class
˛˛ !
UnsafeListExtension
˛˛ +
{
ˇˇ 
[
ÄÄ 	
BurstCompatible
ÄÄ	 
(
ÄÄ "
GenericTypeArguments
ÄÄ -
=
ÄÄ. /
new
ÄÄ0 3
[
ÄÄ3 4
]
ÄÄ4 5
{
ÄÄ6 7
typeof
ÄÄ8 >
(
ÄÄ> ?
int
ÄÄ? B
)
ÄÄB C
}
ÄÄD E
)
ÄÄE F
]
ÄÄF G
internal
ÅÅ 
static
ÅÅ 
ref
ÅÅ 

UnsafeList
ÅÅ &
ListData
ÅÅ' /
<
ÅÅ/ 0
T
ÅÅ0 1
>
ÅÅ1 2
(
ÅÅ2 3
ref
ÅÅ3 6
this
ÅÅ7 ;

UnsafeList
ÅÅ< F
<
ÅÅF G
T
ÅÅG H
>
ÅÅH I
from
ÅÅJ N
)
ÅÅN O
where
ÅÅP U
T
ÅÅV W
:
ÅÅX Y
	unmanaged
ÅÅZ c
=>
ÅÅd f
ref
ÅÅg j
UnsafeUtility
ÅÅk x
.
ÅÅx y
As
ÅÅy {
<
ÅÅ{ |

UnsafeListÅÅ| Ü
<ÅÅÜ á
TÅÅá à
>ÅÅà â
,ÅÅâ ä

UnsafeListÅÅã ï
>ÅÅï ñ
(ÅÅñ ó
refÅÅó ö
fromÅÅõ ü
)ÅÅü †
;ÅÅ† °
public
àà 
unsafe
àà 
static
àà 
void
àà !
Sort
àà" &
<
àà& '
T
àà' (
>
àà( )
(
àà) *
this
àà* .

UnsafeList
àà/ 9
list
àà: >
)
àà> ?
where
àà@ E
T
ààF G
:
ààH I
	unmanaged
ààJ S
,
ààS T
IComparable
ààU `
<
àà` a
T
ààa b
>
ààb c
{
ââ 	
list
ää 
.
ää 
Sort
ää 
<
ää 
T
ää 
,
ää !
NativeSortExtension
ää ,
.
ää, -
DefaultComparer
ää- <
<
ää< =
T
ää= >
>
ää> ?
>
ää? @
(
ää@ A
new
ääA D!
NativeSortExtension
ääE X
.
ääX Y
DefaultComparer
ääY h
<
ääh i
T
ääi j
>
ääj k
(
ääk l
)
ääl m
)
ääm n
;
ään o
}
ãã 	
public
îî 
unsafe
îî 
static
îî 
void
îî !
Sort
îî" &
<
îî& '
T
îî' (
,
îî( )
U
îî* +
>
îî+ ,
(
îî, -
this
îî- 1

UnsafeList
îî2 <
list
îî= A
,
îîA B
U
îîC D
comp
îîE I
)
îîI J
where
îîK P
T
îîQ R
:
îîS T
	unmanaged
îîU ^
where
îî_ d
U
îîe f
:
îîg h
	IComparer
îîi r
<
îîr s
T
îîs t
>
îît u
{
ïï 	!
NativeSortExtension
ññ 
.
ññ  
	IntroSort
ññ  )
<
ññ) *
T
ññ* +
,
ññ+ ,
U
ññ- .
>
ññ. /
(
ññ/ 0
list
ññ0 4
.
ññ4 5
Ptr
ññ5 8
,
ññ8 9
list
ññ: >
.
ññ> ?
Length
ññ? E
,
ññE F
comp
ññG K
)
ññK L
;
ññL M
}
óó 	
[
°° 	 
NotBurstCompatible
°°	 
]°°ú ù
[
¢¢ 	
Obsolete
¢¢	 
(
¢¢ 
$str
¢¢ h
,
¢¢h i
false
¢¢j o
)
¢¢o p
]
¢¢p q
public
££ 
unsafe
££ 
static
££ 
	JobHandle
££ &
Sort
££' +
<
££+ ,
T
££, -
>
££- .
(
££. /
this
££/ 3

UnsafeList
££4 >
	container
££? H
,
££H I
	JobHandle
££J S
	inputDeps
££T ]
)
££] ^
where
§§ 
T
§§ 
:
§§ 
	unmanaged
§§ 
,
§§  
IComparable
§§! ,
<
§§, -
T
§§- .
>
§§. /
{
•• 	
return
¶¶ 
	container
¶¶ 
.
¶¶ 
Sort
¶¶ !
<
¶¶! "
T
¶¶" #
,
¶¶# $!
NativeSortExtension
¶¶% 8
.
¶¶8 9
DefaultComparer
¶¶9 H
<
¶¶H I
T
¶¶I J
>
¶¶J K
>
¶¶K L
(
¶¶L M
new
¶¶M P!
NativeSortExtension
¶¶Q d
.
¶¶d e
DefaultComparer
¶¶e t
<
¶¶t u
T
¶¶u v
>
¶¶v w
(
¶¶w x
)
¶¶x y
,
¶¶y z
	inputDeps¶¶{ Ñ
)¶¶Ñ Ö
;¶¶Ö Ü
}
ßß 	
public
ØØ 
unsafe
ØØ 
static
ØØ 
SortJob
ØØ $
<
ØØ$ %
T
ØØ% &
,
ØØ& '!
NativeSortExtension
ØØ( ;
.
ØØ; <
DefaultComparer
ØØ< K
<
ØØK L
T
ØØL M
>
ØØM N
>
ØØN O
SortJob
ØØP W
<
ØØW X
T
ØØX Y
>
ØØY Z
(
ØØZ [
this
ØØ[ _

UnsafeList
ØØ` j
list
ØØk o
)
ØØo p
where
∞∞ 
T
∞∞ 
:
∞∞ 
	unmanaged
∞∞ 
,
∞∞  
IComparable
∞∞! ,
<
∞∞, -
T
∞∞- .
>
∞∞. /
{
±± 	
return
≤≤ !
NativeSortExtension
≤≤ &
.
≤≤& '
SortJob
≤≤' .
(
≤≤. /
(
≤≤/ 0
T
≤≤0 1
*
≤≤1 2
)
≤≤2 3
list
≤≤3 7
.
≤≤7 8
Ptr
≤≤8 ;
,
≤≤; <
list
≤≤= A
.
≤≤A B
Length
≤≤B H
,
≤≤H I
new
≤≤J M!
NativeSortExtension
≤≤N a
.
≤≤a b
DefaultComparer
≤≤b q
<
≤≤q r
T
≤≤r s
>
≤≤s t
(
≤≤t u
)
≤≤u v
)
≤≤v w
;
≤≤w x
}
≥≥ 	
[
øø 	 
NotBurstCompatible
øø	 
]øøú ù
[
¿¿ 	
Obsolete
¿¿	 
(
¿¿ 
$str
¿¿ k
,
¿¿k l
false
¿¿m r
)
¿¿r s
]
¿¿s t
public
¡¡ 
unsafe
¡¡ 
static
¡¡ 
	JobHandle
¡¡ &
Sort
¡¡' +
<
¡¡+ ,
T
¡¡, -
,
¡¡- .
U
¡¡/ 0
>
¡¡0 1
(
¡¡1 2
this
¡¡2 6

UnsafeList
¡¡7 A
	container
¡¡B K
,
¡¡K L
U
¡¡M N
comp
¡¡O S
,
¡¡S T
	JobHandle
¡¡U ^
	inputDeps
¡¡_ h
)
¡¡h i
where
¬¬ 
T
¬¬ 
:
¬¬ 
	unmanaged
¬¬ 
where
√√ 
U
√√ 
:
√√ 
	IComparer
√√ 
<
√√  
T
√√  !
>
√√! "
{
ƒƒ 	
return
≈≈ !
NativeSortExtension
≈≈ &
.
≈≈& '
Sort
≈≈' +
(
≈≈+ ,
(
≈≈, -
T
≈≈- .
*
≈≈. /
)
≈≈/ 0
	container
≈≈0 9
.
≈≈9 :
Ptr
≈≈: =
,
≈≈= >
	container
≈≈? H
.
≈≈H I
Length
≈≈I O
,
≈≈O P
comp
≈≈Q U
,
≈≈U V
	inputDeps
≈≈W `
)
≈≈` a
;
≈≈a b
}
∆∆ 	
public
–– 
unsafe
–– 
static
–– 
SortJob
–– $
<
––$ %
T
––% &
,
––& '
U
––( )
>
––) *
SortJob
––+ 2
<
––2 3
T
––3 4
,
––4 5
U
––6 7
>
––7 8
(
––8 9
this
––9 =

UnsafeList
––> H
list
––I M
,
––M N
U
––O P
comp
––Q U
)
––U V
where
—— 
T
—— 
:
—— 
	unmanaged
—— 
where
““ 
U
““ 
:
““ 
	IComparer
““ 
<
““  
T
““  !
>
““! "
{
”” 	
return
‘‘ !
NativeSortExtension
‘‘ &
.
‘‘& '
SortJob
‘‘' .
(
‘‘. /
(
‘‘/ 0
T
‘‘0 1
*
‘‘1 2
)
‘‘2 3
list
‘‘3 7
.
‘‘7 8
Ptr
‘‘8 ;
,
‘‘; <
list
‘‘= A
.
‘‘A B
Length
‘‘B H
,
‘‘H I
comp
‘‘J N
)
‘‘N O
;
‘‘O P
}
’’ 	
public
ﬂﬂ 
static
ﬂﬂ 
int
ﬂﬂ 
BinarySearch
ﬂﬂ &
<
ﬂﬂ& '
T
ﬂﬂ' (
>
ﬂﬂ( )
(
ﬂﬂ) *
this
ﬂﬂ* .

UnsafeList
ﬂﬂ/ 9
	container
ﬂﬂ: C
,
ﬂﬂC D
T
ﬂﬂE F
value
ﬂﬂG L
)
ﬂﬂL M
where
‡‡ 
T
‡‡ 
:
‡‡ 
	unmanaged
‡‡ 
,
‡‡  
IComparable
‡‡! ,
<
‡‡, -
T
‡‡- .
>
‡‡. /
{
·· 	
return
‚‚ 
	container
‚‚ 
.
‚‚ 
BinarySearch
‚‚ )
(
‚‚) *
value
‚‚* /
,
‚‚/ 0
new
‚‚1 4!
NativeSortExtension
‚‚5 H
.
‚‚H I
DefaultComparer
‚‚I X
<
‚‚X Y
T
‚‚Y Z
>
‚‚Z [
(
‚‚[ \
)
‚‚\ ]
)
‚‚] ^
;
‚‚^ _
}
„„ 	
public
ÔÔ 
unsafe
ÔÔ 
static
ÔÔ 
int
ÔÔ  
BinarySearch
ÔÔ! -
<
ÔÔ- .
T
ÔÔ. /
,
ÔÔ/ 0
U
ÔÔ1 2
>
ÔÔ2 3
(
ÔÔ3 4
this
ÔÔ4 8

UnsafeList
ÔÔ9 C
	container
ÔÔD M
,
ÔÔM N
T
ÔÔO P
value
ÔÔQ V
,
ÔÔV W
U
ÔÔX Y
comp
ÔÔZ ^
)
ÔÔ^ _
where
 
T
 
:
 
	unmanaged
 
where
ÒÒ 
U
ÒÒ 
:
ÒÒ 
	IComparer
ÒÒ 
<
ÒÒ  
T
ÒÒ  !
>
ÒÒ! "
{
ÚÚ 	
return
ÛÛ !
NativeSortExtension
ÛÛ &
.
ÛÛ& '
BinarySearch
ÛÛ' 3
(
ÛÛ3 4
(
ÛÛ4 5
T
ÛÛ5 6
*
ÛÛ6 7
)
ÛÛ7 8
	container
ÛÛ8 A
.
ÛÛA B
Ptr
ÛÛB E
,
ÛÛE F
	container
ÛÛG P
.
ÛÛP Q
Length
ÛÛQ W
,
ÛÛW X
value
ÛÛY ^
,
ÛÛ^ _
comp
ÛÛ` d
)
ÛÛd e
;
ÛÛe f
}
ÙÙ 	
}
ˆˆ 
[
¸¸ 
DebuggerDisplay
¸¸ 
(
¸¸ 
$str
¸¸ m
)
¸¸m n
]
¸¸n o
[
˝˝ 
DebuggerTypeProxy
˝˝ 
(
˝˝ 
typeof
˝˝ 
(
˝˝ $
UnsafePtrListDebugView
˝˝ 4
)
˝˝4 5
)
˝˝5 6
]
˝˝6 7
[
˛˛ 
Obsolete
˛˛ 
(
˛˛ 
$str
˛˛ s
,
˛˛s t
false
˛˛u z
)
˛˛z {
]
˛˛{ |
public
ˇˇ 

unsafe
ˇˇ 
struct
ˇˇ 
UnsafePtrList
ˇˇ &
:
ÄÄ 	
INativeDisposable
ÄÄ
 
,
ÅÅ 	
INativeList
ÅÅ
 
<
ÅÅ 
IntPtr
ÅÅ 
>
ÅÅ 
,
ÇÇ 	
IEnumerable
ÇÇ
 
<
ÇÇ 
IntPtr
ÇÇ 
>
ÇÇ 
{
ÉÉ 
[
áá 	/
!NativeDisableUnsafePtrRestriction
áá	 *
]
áá* +
public
àà 
readonly
àà 
void
àà 
*
àà 
*
àà 
Ptr
àà "
;
àà" #
public
çç 
readonly
çç 
int
çç 
length
çç "
;
çç" #
public
èè 
readonly
èè 
int
èè 
unused
èè "
;
èè" #
public
îî 
readonly
îî 
int
îî 
capacity
îî $
;
îî$ %
public
ôô 
readonly
ôô 
AllocatorManager
ôô (
.
ôô( )
AllocatorHandle
ôô) 8
	Allocator
ôô9 B
;
ôôB C
public
ûû 
int
ûû 
Length
ûû 
{
ûû 
get
ûû 
{
ûû  !
return
ûû" (
length
ûû) /
;
ûû/ 0
}
ûû1 2
set
ûû3 6
{
ûû7 8
}
ûû9 :
}
ûû; <
public
££ 
int
££ 
Capacity
££ 
{
££ 
get
££ !
{
££" #
return
££$ *
capacity
££+ 3
;
££3 4
}
££5 6
set
££7 :
{
££; <
}
££= >
}
££? @
public
™™ 
IntPtr
™™ 
this
™™ 
[
™™ 
int
™™ 
index
™™ $
]
™™$ %
{
´´ 	
get
¨¨ 
{
¨¨ 
return
¨¨ 
new
¨¨ 
IntPtr
¨¨ #
(
¨¨# $
Ptr
¨¨$ '
[
¨¨' (
index
¨¨( -
]
¨¨- .
)
¨¨. /
;
¨¨/ 0
}
¨¨1 2
set
≠≠ 
{
≠≠ 
Ptr
≠≠ 
[
≠≠ 
index
≠≠ 
]
≠≠ 
=
≠≠ 
(
≠≠  
void
≠≠  $
*
≠≠$ %
)
≠≠% &
value
≠≠& +
;
≠≠+ ,
}
≠≠- .
}
ÆÆ 	
public
µµ 
ref
µµ 
IntPtr
µµ 
	ElementAt
µµ #
(
µµ# $
int
µµ$ '
index
µµ( -
)
µµ- .
{
∂∂ 	
return
∑∑ 
ref
∑∑ 
(
∑∑ 
(
∑∑ 
IntPtr
∑∑ 
*
∑∑  
)
∑∑  !
Ptr
∑∑! $
)
∑∑$ %
[
∑∑% &
index
∑∑& +
]
∑∑+ ,
;
∑∑, -
}
∏∏ 	
public
øø 
unsafe
øø 
UnsafePtrList
øø #
(
øø# $
void
øø$ (
*
øø( )
*
øø) *
ptr
øø+ .
,
øø. /
int
øø0 3
length
øø4 :
)
øø: ;
:
øø< =
this
øø> B
(
øøB C
)
øøC D
{
¿¿ 	
Ptr
¡¡ 
=
¡¡ 
ptr
¡¡ 
;
¡¡ 
this
¬¬ 
.
¬¬ 
length
¬¬ 
=
¬¬ 
length
¬¬  
;
¬¬  !
this
√√ 
.
√√ 
capacity
√√ 
=
√√ 
length
√√ "
;
√√" #
	Allocator
ƒƒ 
=
ƒƒ 
AllocatorManager
ƒƒ (
.
ƒƒ( )
None
ƒƒ) -
;
ƒƒ- .
}
≈≈ 	
public
—— 
unsafe
—— 
UnsafePtrList
—— #
(
——# $
int
——$ '
initialCapacity
——( 7
,
——7 8
AllocatorManager
——9 I
.
——I J
AllocatorHandle
——J Y
	allocator
——Z c
,
——c d 
NativeArrayOptions
——e w
options
——x 
=——Ä Å"
NativeArrayOptions——Ç î
.——î ï#
UninitializedMemory——ï ®
)——® ©
:——™ ´
this——¨ ∞
(——∞ ±
)——± ≤
{
““ 	
Ptr
”” 
=
”” 
null
”” 
;
”” 
length
‘‘ 
=
‘‘ 
$num
‘‘ 
;
‘‘ 
capacity
’’ 
=
’’ 
$num
’’ 
;
’’ 
	Allocator
÷÷ 
=
÷÷ 
AllocatorManager
÷÷ (
.
÷÷( )
None
÷÷) -
;
÷÷- .
var
ÿÿ 
sizeOf
ÿÿ 
=
ÿÿ 
IntPtr
ÿÿ 
.
ÿÿ  
Size
ÿÿ  $
;
ÿÿ$ %
this
ŸŸ 
.
ŸŸ 
ListData
ŸŸ 
(
ŸŸ 
)
ŸŸ 
=
ŸŸ 
new
ŸŸ !

UnsafeList
ŸŸ" ,
(
ŸŸ, -
sizeOf
ŸŸ- 3
,
ŸŸ3 4
sizeOf
ŸŸ5 ;
,
ŸŸ; <
initialCapacity
ŸŸ= L
,
ŸŸL M
	allocator
ŸŸN W
,
ŸŸW X
options
ŸŸY `
)
ŸŸ` a
;
ŸŸa b
}
⁄⁄ 	
public
ÊÊ 
unsafe
ÊÊ 
UnsafePtrList
ÊÊ #
(
ÊÊ# $
int
ÊÊ$ '
initialCapacity
ÊÊ( 7
,
ÊÊ7 8
	Allocator
ÊÊ9 B
	allocator
ÊÊC L
,
ÊÊL M 
NativeArrayOptions
ÊÊN `
options
ÊÊa h
=
ÊÊi j 
NativeArrayOptions
ÊÊk }
.
ÊÊ} ~"
UninitializedMemoryÊÊ~ ë
)ÊÊë í
:ÊÊì î
thisÊÊï ô
(ÊÊô ö
)ÊÊö õ
{
ÁÁ 	
Ptr
ËË 
=
ËË 
null
ËË 
;
ËË 
length
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
;
ÈÈ 
capacity
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
;
ÍÍ 
	Allocator
ÎÎ 
=
ÎÎ 
AllocatorManager
ÎÎ (
.
ÎÎ( )
None
ÎÎ) -
;
ÎÎ- .
var
ÌÌ 
sizeOf
ÌÌ 
=
ÌÌ 
IntPtr
ÌÌ 
.
ÌÌ  
Size
ÌÌ  $
;
ÌÌ$ %
this
ÓÓ 
.
ÓÓ 
ListData
ÓÓ 
(
ÓÓ 
)
ÓÓ 
=
ÓÓ 
new
ÓÓ !

UnsafeList
ÓÓ" ,
(
ÓÓ, -
sizeOf
ÓÓ- 3
,
ÓÓ3 4
sizeOf
ÓÓ5 ;
,
ÓÓ; <
initialCapacity
ÓÓ= L
,
ÓÓL M
	allocator
ÓÓN W
,
ÓÓW X
options
ÓÓY `
)
ÓÓ` a
;
ÓÓa b
}
ÔÔ 	
public
˜˜ 
static
˜˜ 
UnsafePtrList
˜˜ #
*
˜˜# $
Create
˜˜% +
(
˜˜+ ,
void
˜˜, 0
*
˜˜0 1
*
˜˜1 2
ptr
˜˜3 6
,
˜˜6 7
int
˜˜8 ;
length
˜˜< B
)
˜˜B C
{
¯¯ 	
UnsafePtrList
˘˘ 
*
˘˘ 
listData
˘˘ #
=
˘˘$ %
AllocatorManager
˘˘& 6
.
˘˘6 7
Allocate
˘˘7 ?
<
˘˘? @
UnsafePtrList
˘˘@ M
>
˘˘M N
(
˘˘N O
AllocatorManager
˘˘O _
.
˘˘_ `

Persistent
˘˘` j
)
˘˘j k
;
˘˘k l
*
˙˙ 
listData
˙˙ 
=
˙˙ 
new
˙˙ 
UnsafePtrList
˙˙ )
(
˙˙) *
ptr
˙˙* -
,
˙˙- .
length
˙˙/ 5
)
˙˙5 6
;
˙˙6 7
return
˚˚ 
listData
˚˚ 
;
˚˚ 
}
¸¸ 	
public
á	á	 
static
á	á	 
UnsafePtrList
á	á	 #
*
á	á	# $
Create
á	á	% +
(
á	á	+ ,
int
á	á	, /
initialCapacity
á	á	0 ?
,
á	á	? @
	Allocator
á	á	A J
	allocator
á	á	K T
,
á	á	T U 
NativeArrayOptions
á	á	V h
options
á	á	i p
=
á	á	q r!
NativeArrayOptionsá	á	s Ö
.á	á	Ö Ü#
UninitializedMemoryá	á	Ü ô
)á	á	ô ö
{
à	à	 	
UnsafePtrList
â	â	 
*
â	â	 
listData
â	â	 #
=
â	â	$ %
AllocatorManager
â	â	& 6
.
â	â	6 7
Allocate
â	â	7 ?
<
â	â	? @
UnsafePtrList
â	â	@ M
>
â	â	M N
(
â	â	N O
	allocator
â	â	O X
)
â	â	X Y
;
â	â	Y Z
*
ä	ä	 
listData
ä	ä	 
=
ä	ä	 
new
ä	ä	 
UnsafePtrList
ä	ä	 )
(
ä	ä	) *
initialCapacity
ä	ä	* 9
,
ä	ä	9 :
	allocator
ä	ä	; D
,
ä	ä	D E
options
ä	ä	F M
)
ä	ä	M N
;
ä	ä	N O
return
ã	ã	 
listData
ã	ã	 
;
ã	ã	 
}
å	å	 	
public
í	í	 
static
í	í	 
void
í	í	 
Destroy
í	í	 "
(
í	í	" #
UnsafePtrList
í	í	# 0
*
í	í	0 1
listData
í	í	2 :
)
í	í	: ;
{
ì	ì	 	

UnsafeList
î	î	 
.
î	î	 
	CheckNull
î	î	  
(
î	î	  !
listData
î	î	! )
)
î	î	) *
;
î	î	* +
var
ï	ï	 
	allocator
ï	ï	 
=
ï	ï	 
listData
ï	ï	 $
->
ï	ï	$ &
ListData
ï	ï	& .
(
ï	ï	. /
)
ï	ï	/ 0
.
ï	ï	0 1
	Allocator
ï	ï	1 :
.
ï	ï	: ;
Value
ï	ï	; @
==
ï	ï	A C
AllocatorManager
ï	ï	D T
.
ï	ï	T U
Invalid
ï	ï	U \
.
ï	ï	\ ]
Value
ï	ï	] b
?
ñ	ñ	 
AllocatorManager
ñ	ñ	 "
.
ñ	ñ	" #

Persistent
ñ	ñ	# -
:
ó	ó	 
listData
ó	ó	 
->
ó	ó	 
ListData
ó	ó	 $
(
ó	ó	$ %
)
ó	ó	% &
.
ó	ó	& '
	Allocator
ó	ó	' 0
;
ò	ò	 
listData
ô	ô	 
->
ô	ô	 
Dispose
ô	ô	 
(
ô	ô	 
)
ô	ô	 
;
ô	ô	  
AllocatorManager
ö	ö	 
.
ö	ö	 
Free
ö	ö	 !
(
ö	ö	! "
	allocator
ö	ö	" +
,
ö	ö	+ ,
listData
ö	ö	- 5
)
ö	ö	5 6
;
ö	ö	6 7
}
õ	õ	 	
public
°	°	 
bool
°	°	 
IsEmpty
°	°	 
=>
°	°	 
!
°	°	  
	IsCreated
°	°	  )
||
°	°	* ,
Length
°	°	- 3
==
°	°	4 6
$num
°	°	7 8
;
°	°	8 9
public
∞	∞	 
bool
∞	∞	 
	IsCreated
∞	∞	 
=>
∞	∞	  
Ptr
∞	∞	! $
!=
∞	∞	% '
null
∞	∞	( ,
;
∞	∞	, -
public
µ	µ	 
void
µ	µ	 
Dispose
µ	µ	 
(
µ	µ	 
)
µ	µ	 
{
∂	∂	 	
this
∑	∑	 
.
∑	∑	 
ListData
∑	∑	 
(
∑	∑	 
)
∑	∑	 
.
∑	∑	 
Dispose
∑	∑	 #
(
∑	∑	# $
)
∑	∑	$ %
;
∑	∑	% &
}
∏	∏	 	
[
≈	≈	 	 
NotBurstCompatible
≈	≈		 
]≈	≈	ú ù
public
∆	∆	 
	JobHandle
∆	∆	 
Dispose
∆	∆	  
(
∆	∆	  !
	JobHandle
∆	∆	! *
	inputDeps
∆	∆	+ 4
)
∆	∆	4 5
{
«	«	 	
return
»	»	 
this
»	»	 
.
»	»	 
ListData
»	»	  
(
»	»	  !
)
»	»	! "
.
»	»	" #
Dispose
»	»	# *
(
»	»	* +
	inputDeps
»	»	+ 4
)
»	»	4 5
;
»	»	5 6
}
…	…	 	
public
œ	œ	 
void
œ	œ	 
Clear
œ	œ	 
(
œ	œ	 
)
œ	œ	 
{
–	–	 	
this
—	—	 
.
—	—	 
ListData
—	—	 
(
—	—	 
)
—	—	 
.
—	—	 
Clear
—	—	 !
(
—	—	! "
)
—	—	" #
;
—	—	# $
}
“	“	 	
public
Ÿ	Ÿ	 
void
Ÿ	Ÿ	 
Resize
Ÿ	Ÿ	 
(
Ÿ	Ÿ	 
int
Ÿ	Ÿ	 
length
Ÿ	Ÿ	 %
,
Ÿ	Ÿ	% & 
NativeArrayOptions
Ÿ	Ÿ	' 9
options
Ÿ	Ÿ	: A
=
Ÿ	Ÿ	B C 
NativeArrayOptions
Ÿ	Ÿ	D V
.
Ÿ	Ÿ	V W!
UninitializedMemory
Ÿ	Ÿ	W j
)
Ÿ	Ÿ	j k
{
⁄	⁄	 	
this
€	€	 
.
€	€	 
ListData
€	€	 
(
€	€	 
)
€	€	 
.
€	€	 
Resize
€	€	 "
<
€	€	" #
IntPtr
€	€	# )
>
€	€	) *
(
€	€	* +
length
€	€	+ 1
,
€	€	1 2
options
€	€	3 :
)
€	€	: ;
;
€	€	; <
}
‹	‹	 	
public
‚	‚	 
void
‚	‚	 
SetCapacity
‚	‚	 
(
‚	‚	  
int
‚	‚	  #
capacity
‚	‚	$ ,
)
‚	‚	, -
{
„	„	 	
this
‰	‰	 
.
‰	‰	 
ListData
‰	‰	 
(
‰	‰	 
)
‰	‰	 
.
‰	‰	 
SetCapacity
‰	‰	 '
<
‰	‰	' (
IntPtr
‰	‰	( .
>
‰	‰	. /
(
‰	‰	/ 0
capacity
‰	‰	0 8
)
‰	‰	8 9
;
‰	‰	9 :
}
Â	Â	 	
public
Í	Í	 
void
Í	Í	 

TrimExcess
Í	Í	 
(
Í	Í	 
)
Í	Í	  
{
Î	Î	 	
this
Ï	Ï	 
.
Ï	Ï	 
ListData
Ï	Ï	 
(
Ï	Ï	 
)
Ï	Ï	 
.
Ï	Ï	 

TrimExcess
Ï	Ï	 &
<
Ï	Ï	& '
IntPtr
Ï	Ï	' -
>
Ï	Ï	- .
(
Ï	Ï	. /
)
Ï	Ï	/ 0
;
Ï	Ï	0 1
}
Ì	Ì	 	
public
Ù	Ù	 
int
Ù	Ù	 
IndexOf
Ù	Ù	 
(
Ù	Ù	 
void
Ù	Ù	 
*
Ù	Ù	  
value
Ù	Ù	! &
)
Ù	Ù	& '
{
ı	ı	 	
for
ˆ	ˆ	 
(
ˆ	ˆ	 
int
ˆ	ˆ	 
i
ˆ	ˆ	 
=
ˆ	ˆ	 
$num
ˆ	ˆ	 
;
ˆ	ˆ	 
i
ˆ	ˆ	 
<
ˆ	ˆ	 
Length
ˆ	ˆ	  &
;
ˆ	ˆ	& '
++
ˆ	ˆ	( *
i
ˆ	ˆ	* +
)
ˆ	ˆ	+ ,
{
˜	˜	 
if
¯	¯	 
(
¯	¯	 
Ptr
¯	¯	 
[
¯	¯	 
i
¯	¯	 
]
¯	¯	 
==
¯	¯	 
value
¯	¯	 #
)
¯	¯	# $
return
¯	¯	% +
i
¯	¯	, -
;
¯	¯	- .
}
˘	˘	 
return
˚	˚	 
-
˚	˚	 
$num
˚	˚	 
;
˚	˚	 
}
¸	¸	 	
public
É
É
 
bool
É
É
 
Contains
É
É
 
(
É
É
 
void
É
É
 !
*
É
É
! "
value
É
É
# (
)
É
É
( )
{
Ñ
Ñ
 	
return
Ö
Ö
 
IndexOf
Ö
Ö
 
(
Ö
Ö
 
value
Ö
Ö
  
)
Ö
Ö
  !
!=
Ö
Ö
" $
-
Ö
Ö
% &
$num
Ö
Ö
& '
;
Ö
Ö
' (
}
Ü
Ü
 	
public
è
è
 
void
è
è
 
AddNoResize
è
è
 
(
è
è
  
void
è
è
  $
*
è
è
$ %
value
è
è
& +
)
è
è
+ ,
{
ê
ê
 	
this
ë
ë
 
.
ë
ë
 
ListData
ë
ë
 
(
ë
ë
 
)
ë
ë
 
.
ë
ë
 
AddNoResize
ë
ë
 '
(
ë
ë
' (
(
ë
ë
( )
IntPtr
ë
ë
) /
)
ë
ë
/ 0
value
ë
ë
0 5
)
ë
ë
5 6
;
ë
ë
6 7
}
í
í
 	
public
ú
ú
 
void
ú
ú
 
AddRangeNoResize
ú
ú
 $
(
ú
ú
$ %
void
ú
ú
% )
*
ú
ú
) *
*
ú
ú
* +
ptr
ú
ú
, /
,
ú
ú
/ 0
int
ú
ú
1 4
length
ú
ú
5 ;
)
ú
ú
; <
{
ù
ù
 	
this
û
û
 
.
û
û
 
ListData
û
û
 
(
û
û
 
)
û
û
 
.
û
û
 
AddRangeNoResize
û
û
 ,
<
û
û
, -
IntPtr
û
û
- 3
>
û
û
3 4
(
û
û
4 5
ptr
û
û
5 8
,
û
û
8 9
length
û
û
: @
)
û
û
@ A
;
û
û
A B
}
ü
ü
 	
public
®
®
 
void
®
®
 
AddRangeNoResize
®
®
 $
(
®
®
$ %
UnsafePtrList
®
®
% 2
list
®
®
3 7
)
®
®
7 8
{
©
©
 	
this
™
™
 
.
™
™
 
ListData
™
™
 
(
™
™
 
)
™
™
 
.
™
™
 
AddRangeNoResize
™
™
 ,
<
™
™
, -
IntPtr
™
™
- 3
>
™
™
3 4
(
™
™
4 5
list
™
™
5 9
.
™
™
9 :
Ptr
™
™
: =
,
™
™
= >
list
™
™
? C
.
™
™
C D
Length
™
™
D J
)
™
™
J K
;
™
™
K L
}
´
´
 	
public
±
±
 
void
±
±
 
Add
±
±
 
(
±
±
 
in
±
±
 
IntPtr
±
±
 !
value
±
±
" '
)
±
±
' (
{
≤
≤
 	
this
≥
≥
 
.
≥
≥
 
ListData
≥
≥
 
(
≥
≥
 
)
≥
≥
 
.
≥
≥
 
Add
≥
≥
 
(
≥
≥
  
value
≥
≥
  %
)
≥
≥
% &
;
≥
≥
& '
}
¥
¥
 	
public
∫
∫
 
void
∫
∫
 
Add
∫
∫
 
(
∫
∫
 
void
∫
∫
 
*
∫
∫
 
value
∫
∫
 #
)
∫
∫
# $
{
ª
ª
 	
this
º
º
 
.
º
º
 
ListData
º
º
 
(
º
º
 
)
º
º
 
.
º
º
 
Add
º
º
 
(
º
º
  
(
º
º
  !
IntPtr
º
º
! '
)
º
º
' (
value
º
º
( -
)
º
º
- .
;
º
º
. /
}
Ω
Ω
 	
public
ƒ
ƒ
 
void
ƒ
ƒ
 
AddRange
ƒ
ƒ
 
(
ƒ
ƒ
 
void
ƒ
ƒ
 !
*
ƒ
ƒ
! "
ptr
ƒ
ƒ
# &
,
ƒ
ƒ
& '
int
ƒ
ƒ
( +
length
ƒ
ƒ
, 2
)
ƒ
ƒ
2 3
{
≈
≈
 	
this
∆
∆
 
.
∆
∆
 
ListData
∆
∆
 
(
∆
∆
 
)
∆
∆
 
.
∆
∆
 
AddRange
∆
∆
 $
<
∆
∆
$ %
IntPtr
∆
∆
% +
>
∆
∆
+ ,
(
∆
∆
, -
ptr
∆
∆
- 0
,
∆
∆
0 1
length
∆
∆
2 8
)
∆
∆
8 9
;
∆
∆
9 :
}
«
«
 	
public
Õ
Õ
 
void
Õ
Õ
 
AddRange
Õ
Õ
 
(
Õ
Õ
 
UnsafePtrList
Õ
Õ
 *
list
Õ
Õ
+ /
)
Õ
Õ
/ 0
{
Œ
Œ
 	
this
œ
œ
 
.
œ
œ
 
ListData
œ
œ
 
(
œ
œ
 
)
œ
œ
 
.
œ
œ
 
AddRange
œ
œ
 $
<
œ
œ
$ %
IntPtr
œ
œ
% +
>
œ
œ
+ ,
(
œ
œ
, -
list
œ
œ
- 1
.
œ
œ
1 2
ListData
œ
œ
2 :
(
œ
œ
: ;
)
œ
œ
; <
)
œ
œ
< =
;
œ
œ
= >
}
–
–
 	
public
Ÿ
Ÿ
 
void
Ÿ
Ÿ
 %
InsertRangeWithBeginEnd
Ÿ
Ÿ
 +
(
Ÿ
Ÿ
+ ,
int
Ÿ
Ÿ
, /
begin
Ÿ
Ÿ
0 5
,
Ÿ
Ÿ
5 6
int
Ÿ
Ÿ
7 :
end
Ÿ
Ÿ
; >
)
Ÿ
Ÿ
> ?
{
⁄
⁄
 	
this
€
€
 
.
€
€
 
ListData
€
€
 
(
€
€
 
)
€
€
 
.
€
€
 %
InsertRangeWithBeginEnd
€
€
 3
<
€
€
3 4
IntPtr
€
€
4 :
>
€
€
: ;
(
€
€
; <
begin
€
€
< A
,
€
€
A B
end
€
€
C F
)
€
€
F G
;
€
€
G H
}
‹
‹
 	
public
„
„
 
void
„
„
 
RemoveAtSwapBack
„
„
 $
(
„
„
$ %
int
„
„
% (
index
„
„
) .
)
„
„
. /
{
‰
‰
 	
this
Â
Â
 
.
Â
Â
 
ListData
Â
Â
 
(
Â
Â
 
)
Â
Â
 
.
Â
Â
 
RemoveAtSwapBack
Â
Â
 ,
<
Â
Â
, -
IntPtr
Â
Â
- 3
>
Â
Â
3 4
(
Â
Â
4 5
index
Â
Â
5 :
)
Â
Â
: ;
;
Â
Â
; <
}
Ê
Ê
 	
public


 
void


 -
RemoveRangeSwapBackWithBeginEnd


 3
(


3 4
int


4 7
begin


8 =
,


= >
int


? B
end


C F
)


F G
{
Ò
Ò
 	
this
Ú
Ú
 
.
Ú
Ú
 
ListData
Ú
Ú
 
(
Ú
Ú
 
)
Ú
Ú
 
.
Ú
Ú
 -
RemoveRangeSwapBackWithBeginEnd
Ú
Ú
 ;
<
Ú
Ú
; <
IntPtr
Ú
Ú
< B
>
Ú
Ú
B C
(
Ú
Ú
C D
begin
Ú
Ú
D I
,
Ú
Ú
I J
end
Ú
Ú
K N
)
Ú
Ú
N O
;
Ú
Ú
O P
}
Û
Û
 	
public
˛
˛
 
void
˛
˛
 
RemoveAt
˛
˛
 
(
˛
˛
 
int
˛
˛
  
index
˛
˛
! &
)
˛
˛
& '
{
ˇ
ˇ
 	
this
ÄÄ 
.
ÄÄ 
ListData
ÄÄ 
(
ÄÄ 
)
ÄÄ 
.
ÄÄ 
RemoveAt
ÄÄ $
<
ÄÄ$ %
IntPtr
ÄÄ% +
>
ÄÄ+ ,
(
ÄÄ, -
index
ÄÄ- 2
)
ÄÄ2 3
;
ÄÄ3 4
}
ÅÅ 	
public
èè 
void
èè %
RemoveRangeWithBeginEnd
èè +
(
èè+ ,
int
èè, /
begin
èè0 5
,
èè5 6
int
èè7 :
end
èè; >
)
èè> ?
{
êê 	
this
ëë 
.
ëë 
ListData
ëë 
(
ëë 
)
ëë 
.
ëë %
RemoveRangeWithBeginEnd
ëë 3
<
ëë3 4
IntPtr
ëë4 :
>
ëë: ;
(
ëë; <
begin
ëë< A
,
ëëA B
end
ëëC F
)
ëëF G
;
ëëG H
}
íí 	
IEnumerator
öö 
IEnumerable
öö 
.
öö  
GetEnumerator
öö  -
(
öö- .
)
öö. /
{
õõ 	
throw
úú 
new
úú %
NotImplementedException
úú -
(
úú- .
)
úú. /
;
úú/ 0
}
ùù 	
IEnumerator
•• 
<
•• 
IntPtr
•• 
>
•• 
IEnumerable
•• '
<
••' (
IntPtr
••( .
>
••. /
.
••/ 0
GetEnumerator
••0 =
(
••= >
)
••> ?
{
¶¶ 	
throw
ßß 
new
ßß %
NotImplementedException
ßß -
(
ßß- .
)
ßß. /
;
ßß/ 0
}
®® 	
public
ÆÆ 
ParallelReader
ÆÆ 
AsParallelReader
ÆÆ .
(
ÆÆ. /
)
ÆÆ/ 0
{
ØØ 	
return
∞∞ 
new
∞∞ 
ParallelReader
∞∞ %
(
∞∞% &
Ptr
∞∞& )
,
∞∞) *
Length
∞∞+ 1
)
∞∞1 2
;
∞∞2 3
}
±± 	
public
∂∂ 
unsafe
∂∂ 
struct
∂∂ 
ParallelReader
∂∂ +
{
∑∑ 	
[
ªª /
!NativeDisableUnsafePtrRestriction
ªª .
]
ªª. /
public
ºº 
readonly
ºº 
void
ºº  
*
ºº  !
*
ºº! "
Ptr
ºº# &
;
ºº& '
public
¡¡ 
readonly
¡¡ 
int
¡¡ 
Length
¡¡  &
;
¡¡& '
internal
√√ 
ParallelReader
√√ #
(
√√# $
void
√√$ (
*
√√( )
*
√√) *
ptr
√√+ .
,
√√. /
int
√√0 3
length
√√4 :
)
√√: ;
{
ƒƒ 
Ptr
≈≈ 
=
≈≈ 
ptr
≈≈ 
;
≈≈ 
Length
∆∆ 
=
∆∆ 
length
∆∆ 
;
∆∆  
}
«« 
public
ŒŒ 
int
ŒŒ 
IndexOf
ŒŒ 
(
ŒŒ 
void
ŒŒ #
*
ŒŒ# $
value
ŒŒ% *
)
ŒŒ* +
{
œœ 
for
–– 
(
–– 
int
–– 
i
–– 
=
–– 
$num
–– 
;
–– 
i
––  !
<
––" #
Length
––$ *
;
––* +
++
––, .
i
––. /
)
––/ 0
{
—— 
if
““ 
(
““ 
Ptr
““ 
[
““ 
i
““ 
]
““ 
==
““ !
value
““" '
)
““' (
return
““) /
i
““0 1
;
““1 2
}
”” 
return
’’ 
-
’’ 
$num
’’ 
;
’’ 
}
÷÷ 
public
›› 
bool
›› 
Contains
››  
(
››  !
void
››! %
*
››% &
value
››' ,
)
››, -
{
ﬁﬁ 
return
ﬂﬂ 
IndexOf
ﬂﬂ 
(
ﬂﬂ 
value
ﬂﬂ $
)
ﬂﬂ$ %
!=
ﬂﬂ& (
-
ﬂﬂ) *
$num
ﬂﬂ* +
;
ﬂﬂ+ ,
}
‡‡ 
}
·· 	
public
ÁÁ 
ParallelWriter
ÁÁ 
AsParallelWriter
ÁÁ .
(
ÁÁ. /
)
ÁÁ/ 0
{
ËË 	
return
ÈÈ 
new
ÈÈ 
ParallelWriter
ÈÈ %
(
ÈÈ% &
Ptr
ÈÈ& )
,
ÈÈ) *
(
ÈÈ+ ,

UnsafeList
ÈÈ, 6
*
ÈÈ6 7
)
ÈÈ7 8
UnsafeUtility
ÈÈ8 E
.
ÈÈE F
	AddressOf
ÈÈF O
(
ÈÈO P
ref
ÈÈP S
this
ÈÈT X
)
ÈÈX Y
)
ÈÈY Z
;
ÈÈZ [
}
ÍÍ 	
public
ÔÔ 
unsafe
ÔÔ 
struct
ÔÔ 
ParallelWriter
ÔÔ +
{
 	
[
ÙÙ /
!NativeDisableUnsafePtrRestriction
ÙÙ .
]
ÙÙ. /
public
ıı 
readonly
ıı 
void
ıı  
*
ıı  !
Ptr
ıı" %
;
ıı% &
[
˙˙ /
!NativeDisableUnsafePtrRestriction
˙˙ .
]
˙˙. /
public
˚˚ 

UnsafeList
˚˚ 
*
˚˚ 
ListData
˚˚ '
;
˚˚' (
internal
˝˝ 
unsafe
˝˝ 
ParallelWriter
˝˝ *
(
˝˝* +
void
˝˝+ /
*
˝˝/ 0
ptr
˝˝1 4
,
˝˝4 5

UnsafeList
˝˝6 @
*
˝˝@ A
listData
˝˝B J
)
˝˝J K
{
˛˛ 
Ptr
ˇˇ 
=
ˇˇ 
ptr
ˇˇ 
;
ˇˇ 
ListData
ÄÄ 
=
ÄÄ 
listData
ÄÄ #
;
ÄÄ# $
}
ÅÅ 
public
ää 
void
ää 
AddNoResize
ää #
(
ää# $
void
ää$ (
*
ää( )
value
ää* /
)
ää/ 0
{
ãã 
ListData
åå 
->
åå 
AddNoResize
åå %
(
åå% &
(
åå& '
IntPtr
åå' -
)
åå- .
value
åå. 3
)
åå3 4
;
åå4 5
}
çç 
public
óó 
void
óó 
AddRangeNoResize
óó (
(
óó( )
void
óó) -
*
óó- .
*
óó. /
ptr
óó0 3
,
óó3 4
int
óó5 8
length
óó9 ?
)
óó? @
{
òò 
ListData
ôô 
->
ôô 
AddRangeNoResize
ôô *
<
ôô* +
IntPtr
ôô+ 1
>
ôô1 2
(
ôô2 3
ptr
ôô3 6
,
ôô6 7
length
ôô8 >
)
ôô> ?
;
ôô? @
}
öö 
public
££ 
void
££ 
AddRangeNoResize
££ (
(
££( )
UnsafePtrList
££) 6
list
££7 ;
)
££; <
{
§§ 
ListData
•• 
->
•• 
AddRangeNoResize
•• *
<
••* +
IntPtr
••+ 1
>
••1 2
(
••2 3
list
••3 7
.
••7 8
Ptr
••8 ;
,
••; <
list
••= A
.
••A B
Length
••B H
)
••H I
;
••I J
}
¶¶ 
}
ßß 	
}
®® 
internal
™™ 
static
™™ 
class
™™ %
UnsafePtrListExtensions
™™ 1
{
´´ 
public
¨¨ 
static
¨¨ 
ref
¨¨ 

UnsafeList
¨¨ $
ListData
¨¨% -
(
¨¨- .
ref
¨¨. 1
this
¨¨2 6
UnsafePtrList
¨¨7 D
from
¨¨E I
)
¨¨I J
=>
¨¨K M
ref
¨¨N Q
UnsafeUtility
¨¨R _
.
¨¨_ `
As
¨¨` b
<
¨¨b c
UnsafePtrList
¨¨c p
,
¨¨p q

UnsafeList
¨¨r |
>
¨¨| }
(
¨¨} ~
ref¨¨~ Å
from¨¨Ç Ü
)¨¨Ü á
;¨¨á à
}
≠≠ 
internal
ØØ 
sealed
ØØ 
class
ØØ $
UnsafePtrListDebugView
ØØ 0
{
∞∞ 
UnsafePtrList
±± 
Data
±± 
;
±± 
public
≥≥ $
UnsafePtrListDebugView
≥≥ %
(
≥≥% &
UnsafePtrList
≥≥& 3
data
≥≥4 8
)
≥≥8 9
{
¥¥ 	
Data
µµ 
=
µµ 
data
µµ 
;
µµ 
}
∂∂ 	
public
∏∏ 
unsafe
∏∏ 
IntPtr
∏∏ 
[
∏∏ 
]
∏∏ 
Items
∏∏ $
{
ππ 	
get
∫∫ 
{
ªª 
IntPtr
ºº 
[
ºº 
]
ºº 
result
ºº 
=
ºº  !
new
ºº" %
IntPtr
ºº& ,
[
ºº, -
Data
ºº- 1
.
ºº1 2
Length
ºº2 8
]
ºº8 9
;
ºº9 :
for
ææ 
(
ææ 
var
ææ 
i
ææ 
=
ææ 
$num
ææ 
;
ææ 
i
ææ  !
<
ææ" #
result
ææ$ *
.
ææ* +
Length
ææ+ 1
;
ææ1 2
++
ææ3 5
i
ææ5 6
)
ææ6 7
{
øø 
result
¿¿ 
[
¿¿ 
i
¿¿ 
]
¿¿ 
=
¿¿ 
(
¿¿  !
IntPtr
¿¿! '
)
¿¿' (
Data
¿¿( ,
.
¿¿, -
Ptr
¿¿- 0
[
¿¿0 1
i
¿¿1 2
]
¿¿2 3
;
¿¿3 4
}
¡¡ 
return
√√ 
result
√√ 
;
√√ 
}
ƒƒ 
}
≈≈ 	
}
∆∆ 
[
«« 
Obsolete
«« 
(
«« 
$str
«« N
)
««N O
]
««O P
sealed
»» 

class
»» "
WordStorageDebugView
»» %
{
…… 
WordStorage
   
m_wordStorage
   !
;
  ! "
public
ÃÃ "
WordStorageDebugView
ÃÃ #
(
ÃÃ# $
WordStorage
ÃÃ$ /
wordStorage
ÃÃ0 ;
)
ÃÃ; <
{
ÕÕ 	
m_wordStorage
ŒŒ 
=
ŒŒ 
wordStorage
ŒŒ '
;
ŒŒ' (
}
œœ 	
public
—— !
FixedString128Bytes
—— "
[
——" #
]
——# $
Table
——% *
{
““ 	
get
”” 
{
‘‘ 
var
’’ 
table
’’ 
=
’’ 
new
’’ !
FixedString128Bytes
’’  3
[
’’3 4
m_wordStorage
’’4 A
.
’’A B
Entries
’’B I
]
’’I J
;
’’J K
for
÷÷ 
(
÷÷ 
var
÷÷ 
i
÷÷ 
=
÷÷ 
$num
÷÷ 
;
÷÷ 
i
÷÷  !
<
÷÷" #
m_wordStorage
÷÷$ 1
.
÷÷1 2
Entries
÷÷2 9
;
÷÷9 :
++
÷÷; =
i
÷÷= >
)
÷÷> ?
m_wordStorage
◊◊ !
.
◊◊! "
GetFixedString
◊◊" 0
(
◊◊0 1
i
◊◊1 2
,
◊◊2 3
ref
◊◊4 7
table
◊◊8 =
[
◊◊= >
i
◊◊> ?
]
◊◊? @
)
◊◊@ A
;
◊◊A B
return
ÿÿ 
table
ÿÿ 
;
ÿÿ 
}
ŸŸ 
}
⁄⁄ 	
}
€€ 
[
›› 
Obsolete
›› 
(
›› 
$str
›› O
)
››O P
]
››P Q
sealed
ﬁﬁ 

class
ﬁﬁ 
WordStorageStatic
ﬁﬁ "
{
ﬂﬂ 
private
‡‡ 
WordStorageStatic
‡‡ !
(
‡‡! "
)
‡‡" #
{
·· 	
}
‚‚ 	
public
„„ 
struct
„„ 
Thing
„„ 
{
‰‰ 	
public
ÂÂ 
WordStorage
ÂÂ 
Data
ÂÂ #
;
ÂÂ# $
}
ÊÊ 	
public
ÁÁ 
static
ÁÁ 
Thing
ÁÁ 
Ref
ÁÁ 
=
ÁÁ  !
default
ÁÁ" )
;
ÁÁ) *
}
ËË 
[
ÌÌ 
Obsolete
ÌÌ 
(
ÌÌ 
$str
ÌÌ N
)
ÌÌN O
]
ÌÌO P
[
ÓÓ 
DebuggerTypeProxy
ÓÓ 
(
ÓÓ 
typeof
ÓÓ 
(
ÓÓ "
WordStorageDebugView
ÓÓ 2
)
ÓÓ2 3
)
ÓÓ3 4
]
ÓÓ4 5
public
ÔÔ 

struct
ÔÔ 
WordStorage
ÔÔ 
{
 
struct
ÒÒ 
Entry
ÒÒ 
{
ÚÚ 	
public
ÛÛ 
int
ÛÛ 
offset
ÛÛ 
;
ÛÛ 
public
ÙÙ 
int
ÙÙ 
length
ÙÙ 
;
ÙÙ 
}
ıı 	
NativeArray
˜˜ 
<
˜˜ 
byte
˜˜ 
>
˜˜ 
buffer
˜˜  
;
˜˜  !
NativeArray
¯¯ 
<
¯¯ 
Entry
¯¯ 
>
¯¯ 
entry
¯¯  
;
¯¯  ! 
NativeMultiHashMap
˘˘ 
<
˘˘ 
int
˘˘ 
,
˘˘ 
int
˘˘  #
>
˘˘# $
hash
˘˘% )
;
˘˘) *
int
˙˙ 
chars
˙˙ 
;
˙˙ 
int
˚˚ 
entries
˚˚ 
;
˚˚ 
[
ÄÄ 	 
NotBurstCompatible
ÄÄ	 
]
ÄÄ, -
public
ÅÅ 
static
ÅÅ 
ref
ÅÅ 
WordStorage
ÅÅ %
Instance
ÅÅ& .
{
ÇÇ 	
get
ÉÉ 
{
ÑÑ 

Initialize
ÖÖ 
(
ÖÖ 
)
ÖÖ 
;
ÖÖ 
return
ÜÜ 
ref
ÜÜ 
WordStorageStatic
ÜÜ ,
.
ÜÜ, -
Ref
ÜÜ- 0
.
ÜÜ0 1
Data
ÜÜ1 5
;
ÜÜ5 6
}
áá 
}
àà 	
const
ää 
int
ää 
kMaxEntries
ää 
=
ää 
$num
ää  "
<<
ää# %
$num
ää& (
;
ää( )
const
ãã 
int
ãã 
	kMaxChars
ãã 
=
ãã 
kMaxEntries
ãã )
*
ãã* +
$num
ãã, /
;
ãã/ 0
public
êê 
const
êê 
int
êê 
kMaxCharsPerEntry
êê *
=
êê+ ,
$num
êê- 1
;
êê1 2
public
ïï 
int
ïï 
Entries
ïï 
=>
ïï 
entries
ïï %
;
ïï% &
[
öö 	 
NotBurstCompatible
öö	 
]
öö, -
public
õõ 
static
õõ 
void
õõ 

Initialize
õõ %
(
õõ% &
)
õõ& '
{
úú 	
if
ùù 
(
ùù 
WordStorageStatic
ùù !
.
ùù! "
Ref
ùù" %
.
ùù% &
Data
ùù& *
.
ùù* +
buffer
ùù+ 1
.
ùù1 2
	IsCreated
ùù2 ;
)
ùù; <
return
ûû 
;
ûû 
WordStorageStatic
üü 
.
üü 
Ref
üü !
.
üü! "
Data
üü" &
.
üü& '
buffer
üü' -
=
üü. /
new
üü0 3
NativeArray
üü4 ?
<
üü? @
byte
üü@ D
>
üüD E
(
üüE F
	kMaxChars
üüF O
,
üüO P
	Allocator
üüQ Z
.
üüZ [

Persistent
üü[ e
)
üüe f
;
üüf g
WordStorageStatic
†† 
.
†† 
Ref
†† !
.
††! "
Data
††" &
.
††& '
entry
††' ,
=
††- .
new
††/ 2
NativeArray
††3 >
<
††> ?
Entry
††? D
>
††D E
(
††E F
kMaxEntries
††F Q
,
††Q R
	Allocator
††S \
.
††\ ]

Persistent
††] g
)
††g h
;
††h i
WordStorageStatic
°° 
.
°° 
Ref
°° !
.
°°! "
Data
°°" &
.
°°& '
hash
°°' +
=
°°, -
new
°°. 1 
NativeMultiHashMap
°°2 D
<
°°D E
int
°°E H
,
°°H I
int
°°J M
>
°°M N
(
°°N O
kMaxEntries
°°O Z
,
°°Z [
	Allocator
°°\ e
.
°°e f

Persistent
°°f p
)
°°p q
;
°°q r
Clear
¢¢ 
(
¢¢ 
)
¢¢ 
;
¢¢ 
	AppDomain
•• 
.
•• 
CurrentDomain
•• #
.
••# $
DomainUnload
••$ 0
+=
••1 3
(
••4 5
_
••5 6
,
••6 7
__
••8 :
)
••: ;
=>
••< >
{
••? @
Shutdown
••A I
(
••I J
)
••J K
;
••K L
}
••M N
;
••N O
	AppDomain
®® 
.
®® 
CurrentDomain
®® #
.
®®# $
ProcessExit
®®$ /
+=
®®0 2
(
®®3 4
_
®®4 5
,
®®5 6
__
®®7 9
)
®®9 :
=>
®®; =
{
®®> ?
Shutdown
®®@ H
(
®®H I
)
®®I J
;
®®J K
}
®®L M
;
®®M N
}
™™ 	
[
ØØ 	 
NotBurstCompatible
ØØ	 
]
ØØ, -
public
∞∞ 
static
∞∞ 
void
∞∞ 
Shutdown
∞∞ #
(
∞∞# $
)
∞∞$ %
{
±± 	
if
≤≤ 
(
≤≤ 
!
≤≤ 
WordStorageStatic
≤≤ "
.
≤≤" #
Ref
≤≤# &
.
≤≤& '
Data
≤≤' +
.
≤≤+ ,
buffer
≤≤, 2
.
≤≤2 3
	IsCreated
≤≤3 <
)
≤≤< =
return
≥≥ 
;
≥≥ 
WordStorageStatic
¥¥ 
.
¥¥ 
Ref
¥¥ !
.
¥¥! "
Data
¥¥" &
.
¥¥& '
buffer
¥¥' -
.
¥¥- .
Dispose
¥¥. 5
(
¥¥5 6
)
¥¥6 7
;
¥¥7 8
WordStorageStatic
µµ 
.
µµ 
Ref
µµ !
.
µµ! "
Data
µµ" &
.
µµ& '
entry
µµ' ,
.
µµ, -
Dispose
µµ- 4
(
µµ4 5
)
µµ5 6
;
µµ6 7
WordStorageStatic
∂∂ 
.
∂∂ 
Ref
∂∂ !
.
∂∂! "
Data
∂∂" &
.
∂∂& '
hash
∂∂' +
.
∂∂+ ,
Dispose
∂∂, 3
(
∂∂3 4
)
∂∂4 5
;
∂∂5 6
WordStorageStatic
∑∑ 
.
∑∑ 
Ref
∑∑ !
.
∑∑! "
Data
∑∑" &
=
∑∑' (
default
∑∑) 0
;
∑∑0 1
}
∏∏ 	
[
ΩΩ 	 
NotBurstCompatible
ΩΩ	 
]
ΩΩ, -
public
ææ 
static
ææ 
void
ææ 
Clear
ææ  
(
ææ  !
)
ææ! "
{
øø 	

Initialize
¿¿ 
(
¿¿ 
)
¿¿ 
;
¿¿ 
WordStorageStatic
¡¡ 
.
¡¡ 
Ref
¡¡ !
.
¡¡! "
Data
¡¡" &
.
¡¡& '
chars
¡¡' ,
=
¡¡- .
$num
¡¡/ 0
;
¡¡0 1
WordStorageStatic
¬¬ 
.
¬¬ 
Ref
¬¬ !
.
¬¬! "
Data
¬¬" &
.
¬¬& '
entries
¬¬' .
=
¬¬/ 0
$num
¬¬1 2
;
¬¬2 3
WordStorageStatic
√√ 
.
√√ 
Ref
√√ !
.
√√! "
Data
√√" &
.
√√& '
hash
√√' +
.
√√+ ,
Clear
√√, 1
(
√√1 2
)
√√2 3
;
√√3 4
var
ƒƒ 
temp
ƒƒ 
=
ƒƒ 
new
ƒƒ  
FixedString32Bytes
ƒƒ -
(
ƒƒ- .
)
ƒƒ. /
;
ƒƒ/ 0
WordStorageStatic
≈≈ 
.
≈≈ 
Ref
≈≈ !
.
≈≈! "
Data
≈≈" &
.
≈≈& '
GetOrCreateIndex
≈≈' 7
(
≈≈7 8
ref
≈≈8 ;
temp
≈≈< @
)
≈≈@ A
;
≈≈A B
}
∆∆ 	
[
ÀÀ 	 
NotBurstCompatible
ÀÀ	 
]
ÀÀ, -
public
ÃÃ 
static
ÃÃ 
void
ÃÃ 
Setup
ÃÃ  
(
ÃÃ  !
)
ÃÃ! "
{
ÕÕ 	
Clear
ŒŒ 
(
ŒŒ 
)
ŒŒ 
;
ŒŒ 
}
œœ 	
public
◊◊ 
unsafe
◊◊ 
void
◊◊ 
GetFixedString
◊◊ )
<
◊◊) *
T
◊◊* +
>
◊◊+ ,
(
◊◊, -
int
◊◊- 0
index
◊◊1 6
,
◊◊6 7
ref
◊◊8 ;
T
◊◊< =
temp
◊◊> B
)
◊◊B C
where
ÿÿ 
T
ÿÿ 
:
ÿÿ 

IUTF8Bytes
ÿÿ 
,
ÿÿ 
INativeList
ÿÿ )
<
ÿÿ) *
byte
ÿÿ* .
>
ÿÿ. /
{
ŸŸ 	
Assert
⁄⁄ 
.
⁄⁄ 
IsTrue
⁄⁄ 
(
⁄⁄ 
index
⁄⁄ 
<
⁄⁄  !
entries
⁄⁄" )
)
⁄⁄) *
;
⁄⁄* +
var
€€ 
e
€€ 
=
€€ 
entry
€€ 
[
€€ 
index
€€ 
]
€€  
;
€€  !
Assert
‹‹ 
.
‹‹ 
IsTrue
‹‹ 
(
‹‹ 
e
‹‹ 
.
‹‹ 
length
‹‹ "
<=
‹‹# %
kMaxCharsPerEntry
‹‹& 7
)
‹‹7 8
;
‹‹8 9
temp
›› 
.
›› 
Length
›› 
=
›› 
e
›› 
.
›› 
length
›› "
;
››" #
UnsafeUtility
ﬁﬁ 
.
ﬁﬁ 
MemCpy
ﬁﬁ  
(
ﬁﬁ  !
temp
ﬁﬁ! %
.
ﬁﬁ% &
GetUnsafePtr
ﬁﬁ& 2
(
ﬁﬁ2 3
)
ﬁﬁ3 4
,
ﬁﬁ4 5
(
ﬁﬁ6 7
byte
ﬁﬁ7 ;
*
ﬁﬁ; <
)
ﬁﬁ< =
buffer
ﬁﬁ= C
.
ﬁﬁC D
GetUnsafePtr
ﬁﬁD P
(
ﬁﬁP Q
)
ﬁﬁQ R
+
ﬁﬁS T
e
ﬁﬁU V
.
ﬁﬁV W
offset
ﬁﬁW ]
,
ﬁﬁ] ^
temp
ﬁﬁ_ c
.
ﬁﬁc d
Length
ﬁﬁd j
)
ﬁﬁj k
;
ﬁﬁk l
}
ﬂﬂ 	
public
ËË 
int
ËË ,
GetIndexFromHashAndFixedString
ËË 1
<
ËË1 2
T
ËË2 3
>
ËË3 4
(
ËË4 5
int
ËË5 8
h
ËË9 :
,
ËË: ;
ref
ËË< ?
T
ËË@ A
temp
ËËB F
)
ËËF G
where
ÈÈ 
T
ÈÈ 
:
ÈÈ 

IUTF8Bytes
ÈÈ 
,
ÈÈ 
INativeList
ÈÈ )
<
ÈÈ) *
byte
ÈÈ* .
>
ÈÈ. /
{
ÍÍ 	
Assert
ÎÎ 
.
ÎÎ 
IsTrue
ÎÎ 
(
ÎÎ 
temp
ÎÎ 
.
ÎÎ 
Length
ÎÎ %
<=
ÎÎ& (
kMaxCharsPerEntry
ÎÎ) :
)
ÎÎ: ;
;
ÎÎ; <
int
ÏÏ 
	itemIndex
ÏÏ 
;
ÏÏ (
NativeMultiHashMapIterator
ÌÌ &
<
ÌÌ& '
int
ÌÌ' *
>
ÌÌ* +
iter
ÌÌ, 0
;
ÌÌ0 1
if
ÓÓ 
(
ÓÓ 
hash
ÓÓ 
.
ÓÓ 
TryGetFirstValue
ÓÓ %
(
ÓÓ% &
h
ÓÓ& '
,
ÓÓ' (
out
ÓÓ) ,
	itemIndex
ÓÓ- 6
,
ÓÓ6 7
out
ÓÓ8 ;
iter
ÓÓ< @
)
ÓÓ@ A
)
ÓÓA B
{
ÔÔ 
do
 
{
ÒÒ 
var
ÚÚ 
e
ÚÚ 
=
ÚÚ 
entry
ÚÚ !
[
ÚÚ! "
	itemIndex
ÚÚ" +
]
ÚÚ+ ,
;
ÚÚ, -
Assert
ÛÛ 
.
ÛÛ 
IsTrue
ÛÛ !
(
ÛÛ! "
e
ÛÛ" #
.
ÛÛ# $
length
ÛÛ$ *
<=
ÛÛ+ -
kMaxCharsPerEntry
ÛÛ. ?
)
ÛÛ? @
;
ÛÛ@ A
if
ÙÙ 
(
ÙÙ 
e
ÙÙ 
.
ÙÙ 
length
ÙÙ  
==
ÙÙ! #
temp
ÙÙ$ (
.
ÙÙ( )
Length
ÙÙ) /
)
ÙÙ/ 0
{
ıı 
int
ˆˆ 
matches
ˆˆ #
;
ˆˆ# $
for
˜˜ 
(
˜˜ 
matches
˜˜ $
=
˜˜% &
$num
˜˜' (
;
˜˜( )
matches
˜˜* 1
<
˜˜2 3
e
˜˜4 5
.
˜˜5 6
length
˜˜6 <
;
˜˜< =
++
˜˜> @
matches
˜˜@ G
)
˜˜G H
if
¯¯ 
(
¯¯  
temp
¯¯  $
[
¯¯$ %
matches
¯¯% ,
]
¯¯, -
!=
¯¯. 0
buffer
¯¯1 7
[
¯¯7 8
e
¯¯8 9
.
¯¯9 :
offset
¯¯: @
+
¯¯A B
matches
¯¯C J
]
¯¯J K
)
¯¯K L
break
˘˘  %
;
˘˘% &
if
˙˙ 
(
˙˙ 
matches
˙˙ #
==
˙˙$ &
temp
˙˙' +
.
˙˙+ ,
Length
˙˙, 2
)
˙˙2 3
return
˚˚ "
	itemIndex
˚˚# ,
;
˚˚, -
}
¸¸ 
}
˝˝ 
while
˝˝ 
(
˝˝ 
hash
˝˝ 
.
˝˝ 
TryGetNextValue
˝˝ -
(
˝˝- .
out
˝˝. 1
	itemIndex
˝˝2 ;
,
˝˝; <
ref
˝˝= @
iter
˝˝A E
)
˝˝E F
)
˝˝F G
;
˝˝G H
}
˛˛ 
return
ˇˇ 
-
ˇˇ 
$num
ˇˇ 
;
ˇˇ 
}
ÄÄ 	
public
àà 
bool
àà 
Contains
àà 
<
àà 
T
àà 
>
àà 
(
àà  
ref
àà  #
T
àà$ %
value
àà& +
)
àà+ ,
where
ââ 
T
ââ 
:
ââ 

IUTF8Bytes
ââ 
,
ââ 
INativeList
ââ )
<
ââ) *
byte
ââ* .
>
ââ. /
{
ää 	
int
ãã 
h
ãã 
=
ãã 
value
ãã 
.
ãã 
GetHashCode
ãã %
(
ãã% &
)
ãã& '
;
ãã' (
return
åå ,
GetIndexFromHashAndFixedString
åå 1
(
åå1 2
h
åå2 3
,
åå3 4
ref
åå5 8
value
åå9 >
)
åå> ?
!=
åå@ B
-
ååC D
$num
ååD E
;
ååE F
}
çç 	
[
îî 	 
NotBurstCompatible
îî	 
]
îî, -
public
ïï 
unsafe
ïï 
bool
ïï 
Contains
ïï #
(
ïï# $
string
ïï$ *
value
ïï+ 0
)
ïï0 1
{
ññ 	!
FixedString512Bytes
óó 
temp
óó  $
=
óó% &
value
óó' ,
;
óó, -
return
òò 
Contains
òò 
(
òò 
ref
òò 
temp
òò  $
)
òò$ %
;
òò% &
}
ôô 	
public
°° 
int
°° 
GetOrCreateIndex
°° #
<
°°# $
T
°°$ %
>
°°% &
(
°°& '
ref
°°' *
T
°°+ ,
value
°°- 2
)
°°2 3
where
¢¢ 
T
¢¢ 
:
¢¢ 

IUTF8Bytes
¢¢ 
,
¢¢ 
INativeList
¢¢ )
<
¢¢) *
byte
¢¢* .
>
¢¢. /
{
££ 	
int
§§ 
h
§§ 
=
§§ 
value
§§ 
.
§§ 
GetHashCode
§§ %
(
§§% &
)
§§& '
;
§§' (
var
•• 
	itemIndex
•• 
=
•• ,
GetIndexFromHashAndFixedString
•• :
(
••: ;
h
••; <
,
••< =
ref
••> A
value
••B G
)
••G H
;
••H I
if
¶¶ 
(
¶¶ 
	itemIndex
¶¶ 
!=
¶¶ 
-
¶¶ 
$num
¶¶ 
)
¶¶  
return
ßß 
	itemIndex
ßß  
;
ßß  !
Assert
®® 
.
®® 
IsTrue
®® 
(
®® 
entries
®® !
<
®®" #
kMaxEntries
®®$ /
)
®®/ 0
;
®®0 1
Assert
©© 
.
©© 
IsTrue
©© 
(
©© 
chars
©© 
+
©©  !
value
©©" '
.
©©' (
Length
©©( .
<=
©©/ 1
	kMaxChars
©©2 ;
)
©©; <
;
©©< =
var
™™ 
o
™™ 
=
™™ 
chars
™™ 
;
™™ 
var
´´ 
l
´´ 
=
´´ 
(
´´ 
ushort
´´ 
)
´´ 
value
´´ !
.
´´! "
Length
´´" (
;
´´( )
for
¨¨ 
(
¨¨ 
var
¨¨ 
i
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨ 
i
¨¨ 
<
¨¨ 
l
¨¨  !
;
¨¨! "
++
¨¨# %
i
¨¨% &
)
¨¨& '
buffer
≠≠ 
[
≠≠ 
chars
≠≠ 
++
≠≠ 
]
≠≠ 
=
≠≠  !
value
≠≠" '
[
≠≠' (
i
≠≠( )
]
≠≠) *
;
≠≠* +
entry
ÆÆ 
[
ÆÆ 
entries
ÆÆ 
]
ÆÆ 
=
ÆÆ 
new
ÆÆ  
Entry
ÆÆ! &
{
ÆÆ' (
offset
ÆÆ) /
=
ÆÆ0 1
o
ÆÆ2 3
,
ÆÆ3 4
length
ÆÆ5 ;
=
ÆÆ< =
l
ÆÆ> ?
}
ÆÆ@ A
;
ÆÆA B
hash
ØØ 
.
ØØ 
Add
ØØ 
(
ØØ 
h
ØØ 
,
ØØ 
entries
ØØ 
)
ØØ  
;
ØØ  !
return
∞∞ 
entries
∞∞ 
++
∞∞ 
;
∞∞ 
}
±± 	
}
≤≤ 
[
¬¬ 
Obsolete
¬¬ 
(
¬¬ 
$str
¬¬ N
)
¬¬N O
]
¬¬O P
public
√√ 

struct
√√ 
Words
√√ 
{
ƒƒ 
int
≈≈ 
Index
≈≈ 
;
≈≈ 
public
ÃÃ 
void
ÃÃ 
ToFixedString
ÃÃ !
<
ÃÃ! "
T
ÃÃ" #
>
ÃÃ# $
(
ÃÃ$ %
ref
ÃÃ% (
T
ÃÃ) *
value
ÃÃ+ 0
)
ÃÃ0 1
where
ÕÕ 
T
ÕÕ 
:
ÕÕ 

IUTF8Bytes
ÕÕ 
,
ÕÕ 
INativeList
ÕÕ )
<
ÕÕ) *
byte
ÕÕ* .
>
ÕÕ. /
{
ŒŒ 	
WordStorage
œœ 
.
œœ 
Instance
œœ  
.
œœ  !
GetFixedString
œœ! /
(
œœ/ 0
Index
œœ0 5
,
œœ5 6
ref
œœ7 :
value
œœ; @
)
œœ@ A
;
œœA B
}
–– 	
public
÷÷ 
override
÷÷ 
string
÷÷ 
ToString
÷÷ '
(
÷÷' (
)
÷÷( )
{
◊◊ 	!
FixedString512Bytes
ÿÿ 
temp
ÿÿ  $
=
ÿÿ% &
default
ÿÿ' .
;
ÿÿ. /
ToFixedString
ŸŸ 
(
ŸŸ 
ref
ŸŸ 
temp
ŸŸ "
)
ŸŸ" #
;
ŸŸ# $
return
⁄⁄ 
temp
⁄⁄ 
.
⁄⁄ 
ToString
⁄⁄  
(
⁄⁄  !
)
⁄⁄! "
;
⁄⁄" #
}
€€ 	
public
‚‚ 
void
‚‚ 
SetFixedString
‚‚ "
<
‚‚" #
T
‚‚# $
>
‚‚$ %
(
‚‚% &
ref
‚‚& )
T
‚‚* +
value
‚‚, 1
)
‚‚1 2
where
„„ 
T
„„ 
:
„„ 

IUTF8Bytes
„„ 
,
„„ 
INativeList
„„ )
<
„„) *
byte
„„* .
>
„„. /
{
‰‰ 	
Index
ÂÂ 
=
ÂÂ 
WordStorage
ÂÂ 
.
ÂÂ  
Instance
ÂÂ  (
.
ÂÂ( )
GetOrCreateIndex
ÂÂ) 9
(
ÂÂ9 :
ref
ÂÂ: =
value
ÂÂ> C
)
ÂÂC D
;
ÂÂD E
}
ÊÊ 	
public
ÏÏ 
unsafe
ÏÏ 
void
ÏÏ 
	SetString
ÏÏ $
(
ÏÏ$ %
string
ÏÏ% +
value
ÏÏ, 1
)
ÏÏ1 2
{
ÌÌ 	!
FixedString512Bytes
ÓÓ 
temp
ÓÓ  $
=
ÓÓ% &
value
ÓÓ' ,
;
ÓÓ, -
SetFixedString
ÔÔ 
(
ÔÔ 
ref
ÔÔ 
temp
ÔÔ #
)
ÔÔ# $
;
ÔÔ$ %
}
 	
}
ÒÒ 
[
ˇˇ 
Obsolete
ˇˇ 
(
ˇˇ 
$str
ˇˇ N
)
ˇˇN O
]
ˇˇO P
public
ÄÄ 

struct
ÄÄ 
NumberedWords
ÄÄ 
{
ÅÅ 
int
ÇÇ 
Index
ÇÇ 
;
ÇÇ 
int
ÉÉ 
Suffix
ÉÉ 
;
ÉÉ 
const
ÖÖ 
int
ÖÖ )
kPositiveNumericSuffixShift
ÖÖ -
=
ÖÖ. /
$num
ÖÖ0 1
;
ÖÖ1 2
const
ÜÜ 
int
ÜÜ (
kPositiveNumericSuffixBits
ÜÜ ,
=
ÜÜ- .
$num
ÜÜ/ 1
;
ÜÜ1 2
const
áá 
int
áá '
kMaxPositiveNumericSuffix
áá +
=
áá, -
(
áá. /
$num
áá/ 0
<<
áá1 3(
kPositiveNumericSuffixBits
áá4 N
)
ááN O
-
ááP Q
$num
ááR S
;
ááS T
const
àà 
int
àà (
kPositiveNumericSuffixMask
àà ,
=
àà- .
(
àà/ 0
$num
àà0 1
<<
àà2 4(
kPositiveNumericSuffixBits
àà5 O
)
ààO P
-
ààQ R
$num
ààS T
;
ààT U
const
ää 
int
ää !
kLeadingZeroesShift
ää %
=
ää& '
$num
ää( *
;
ää* +
const
ãã 
int
ãã  
kLeadingZeroesBits
ãã $
=
ãã% &
$num
ãã' (
;
ãã( )
const
åå 
int
åå 
kMaxLeadingZeroes
åå #
=
åå$ %
(
åå& '
$num
åå' (
<<
åå) + 
kLeadingZeroesBits
åå, >
)
åå> ?
-
åå@ A
$num
ååB C
;
ååC D
const
çç 
int
çç  
kLeadingZeroesMask
çç $
=
çç% &
(
çç' (
$num
çç( )
<<
çç* , 
kLeadingZeroesBits
çç- ?
)
çç? @
-
ççA B
$num
ççC D
;
ççD E
int
èè 
LeadingZeroes
èè 
{
êê 	
get
ëë 
=>
ëë 
(
ëë 
Suffix
ëë 
>>
ëë !
kLeadingZeroesShift
ëë 1
)
ëë1 2
&
ëë3 4 
kLeadingZeroesMask
ëë5 G
;
ëëG H
set
íí 
{
ìì 
Suffix
îî 
&=
îî 
~
îî 
(
îî  
kLeadingZeroesMask
îî .
<<
îî/ 1!
kLeadingZeroesShift
îî2 E
)
îîE F
;
îîF G
Suffix
ïï 
|=
ïï 
(
ïï 
value
ïï  
&
ïï! " 
kLeadingZeroesMask
ïï# 5
)
ïï5 6
<<
ïï7 9!
kLeadingZeroesShift
ïï: M
;
ïïM N
}
ññ 
}
óó 	
int
ôô #
PositiveNumericSuffix
ôô !
{
öö 	
get
õõ 
=>
õõ 
(
õõ 
Suffix
õõ 
>>
õõ )
kPositiveNumericSuffixShift
õõ 9
)
õõ9 :
&
õõ; <(
kPositiveNumericSuffixMask
õõ= W
;
õõW X
set
úú 
{
ùù 
Suffix
ûû 
&=
ûû 
~
ûû 
(
ûû (
kPositiveNumericSuffixMask
ûû 6
<<
ûû7 9)
kPositiveNumericSuffixShift
ûû: U
)
ûûU V
;
ûûV W
Suffix
üü 
|=
üü 
(
üü 
value
üü  
&
üü! "(
kPositiveNumericSuffixMask
üü# =
)
üü= >
<<
üü? A)
kPositiveNumericSuffixShift
üüB ]
;
üü] ^
}
†† 
}
°° 	
bool
££ &
HasPositiveNumericSuffix
££ %
=>
££& (#
PositiveNumericSuffix
££) >
!=
££? A
$num
££B C
;
££C D
[
•• 	 
NotBurstCompatible
••	 
]
••, -
string
¶¶ 
	NewString
¶¶ 
(
¶¶ 
char
¶¶ 
c
¶¶ 
,
¶¶  
int
¶¶! $
count
¶¶% *
)
¶¶* +
{
ßß 	
char
®® 
[
®® 
]
®® 
temp
®® 
=
®® 
new
®® 
char
®® "
[
®®" #
count
®®# (
]
®®( )
;
®®) *
for
©© 
(
©© 
var
©© 
i
©© 
=
©© 
$num
©© 
;
©© 
i
©© 
<
©© 
count
©©  %
;
©©% &
++
©©' )
i
©©) *
)
©©* +
temp
™™ 
[
™™ 
i
™™ 
]
™™ 
=
™™ 
c
™™ 
;
™™ 
return
´´ 
new
´´ 
string
´´ 
(
´´ 
temp
´´ "
,
´´" #
$num
´´$ %
,
´´% &
count
´´' ,
)
´´, -
;
´´- .
}
¨¨ 	
[
¥¥ 	 
NotBurstCompatible
¥¥	 
]
¥¥, -
public
µµ 
int
µµ 
ToFixedString
µµ  
<
µµ  !
T
µµ! "
>
µµ" #
(
µµ# $
ref
µµ$ '
T
µµ( )
result
µµ* 0
)
µµ0 1
where
∂∂ 
T
∂∂ 
:
∂∂ 

IUTF8Bytes
∂∂ 
,
∂∂ 
INativeList
∂∂ )
<
∂∂) *
byte
∂∂* .
>
∂∂. /
{
∑∑ 	
unsafe
∏∏ 
{
ππ 
var
∫∫ #
positiveNumericSuffix
∫∫ )
=
∫∫* +#
PositiveNumericSuffix
∫∫, A
;
∫∫A B
var
ªª 
leadingZeroes
ªª !
=
ªª" #
LeadingZeroes
ªª$ 1
;
ªª1 2
WordStorage
ΩΩ 
.
ΩΩ 
Instance
ΩΩ $
.
ΩΩ$ %
GetFixedString
ΩΩ% 3
(
ΩΩ3 4
Index
ΩΩ4 9
,
ΩΩ9 :
ref
ΩΩ; >
result
ΩΩ? E
)
ΩΩE F
;
ΩΩF G
if
ææ 
(
ææ #
positiveNumericSuffix
ææ (
==
ææ) +
$num
ææ, -
&&
ææ. 0
leadingZeroes
ææ1 >
==
ææ? A
$num
ææB C
)
ææC D
return
øø 
$num
øø 
;
øø 
const
¬¬ 
int
¬¬ 
maximumDigits
¬¬ '
=
¬¬( )
kMaxLeadingZeroes
¬¬* ;
+
¬¬< =
$num
¬¬> @
;
¬¬@ A
var
√√ 
buffer
√√ 
=
√√ 

stackalloc
√√ '
byte
√√( ,
[
√√, -
maximumDigits
√√- :
]
√√: ;
;
√√; <
var
ƒƒ 

firstDigit
ƒƒ 
=
ƒƒ  
maximumDigits
ƒƒ! .
;
ƒƒ. /
while
≈≈ 
(
≈≈ #
positiveNumericSuffix
≈≈ +
>
≈≈, -
$num
≈≈. /
)
≈≈/ 0
{
∆∆ 
buffer
«« 
[
«« 
--
«« 

firstDigit
«« '
]
««' (
=
««) *
(
««+ ,
byte
««, 0
)
««0 1
(
««1 2
$char
««2 5
+
««6 7#
positiveNumericSuffix
««8 M
%
««N O
$num
««P R
)
««R S
;
««S T#
positiveNumericSuffix
»» )
/=
»»* ,
$num
»»- /
;
»»/ 0
}
…… 
while
   
(
   
leadingZeroes
   #
--
  # %
>
  & '
$num
  ( )
)
  ) *
buffer
ÀÀ 
[
ÀÀ 
--
ÀÀ 

firstDigit
ÀÀ '
]
ÀÀ' (
=
ÀÀ) *
(
ÀÀ+ ,
byte
ÀÀ, 0
)
ÀÀ0 1
$char
ÀÀ1 4
;
ÀÀ4 5
var
ŒŒ 
dest
ŒŒ 
=
ŒŒ 
result
ŒŒ !
.
ŒŒ! "
GetUnsafePtr
ŒŒ" .
(
ŒŒ. /
)
ŒŒ/ 0
+
ŒŒ1 2
result
ŒŒ3 9
.
ŒŒ9 :
Length
ŒŒ: @
;
ŒŒ@ A
result
œœ 
.
œœ 
Length
œœ 
+=
œœ  
maximumDigits
œœ! .
-
œœ/ 0

firstDigit
œœ1 ;
;
œœ; <
while
–– 
(
–– 

firstDigit
––  
<
––! "
maximumDigits
––# 0
)
––0 1
*
—— 
dest
—— 
++
—— 
=
—— 
buffer
—— $
[
——$ %

firstDigit
——% /
++
——/ 1
]
——1 2
;
——2 3
return
““ 
$num
““ 
;
““ 
}
”” 
}
‘‘ 	
[
⁄⁄ 	 
NotBurstCompatible
⁄⁄	 
]
⁄⁄, -
public
€€ 
override
€€ 
string
€€ 
ToString
€€ '
(
€€' (
)
€€( )
{
‹‹ 	!
FixedString512Bytes
›› 
temp
››  $
=
››% &
default
››' .
;
››. /
ToFixedString
ﬁﬁ 
(
ﬁﬁ 
ref
ﬁﬁ 
temp
ﬁﬁ "
)
ﬁﬁ" #
;
ﬁﬁ# $
return
ﬂﬂ 
temp
ﬂﬂ 
.
ﬂﬂ 
ToString
ﬂﬂ  
(
ﬂﬂ  !
)
ﬂﬂ! "
;
ﬂﬂ" #
}
‡‡ 	
bool
‚‚ 
IsDigit
‚‚ 
(
‚‚ 
byte
‚‚ 
b
‚‚ 
)
‚‚ 
{
„„ 	
return
‰‰ 
b
‰‰ 
>=
‰‰ 
$char
‰‰ 
&&
‰‰ 
b
‰‰  
<=
‰‰! #
$char
‰‰$ '
;
‰‰' (
}
ÂÂ 	
[
ÏÏ 	 
NotBurstCompatible
ÏÏ	 
]
ÏÏ, -
public
ÌÌ 
void
ÌÌ 
	SetString
ÌÌ 
<
ÌÌ 
T
ÌÌ 
>
ÌÌ  
(
ÌÌ  !
ref
ÌÌ! $
T
ÌÌ% &
value
ÌÌ' ,
)
ÌÌ, -
where
ÓÓ 
T
ÓÓ 
:
ÓÓ 

IUTF8Bytes
ÓÓ 
,
ÓÓ 
INativeList
ÓÓ )
<
ÓÓ) *
byte
ÓÓ* .
>
ÓÓ. /
{
ÔÔ 	
int
 
beginningOfDigits
 !
=
" #
value
$ )
.
) *
Length
* 0
;
0 1
while
ıı 
(
ıı 
beginningOfDigits
ıı $
>
ıı% &
$num
ıı' (
&&
ıı) +
IsDigit
ıı, 3
(
ıı3 4
value
ıı4 9
[
ıı9 :
beginningOfDigits
ıı: K
-
ııL M
$num
ııN O
]
ııO P
)
ııP Q
)
ııQ R
--
ˆˆ 
beginningOfDigits
ˆˆ #
;
ˆˆ# $
var
˙˙ .
 beginningOfPositiveNumericSuffix
˙˙ 0
=
˙˙1 2
beginningOfDigits
˙˙3 D
;
˙˙D E
while
˚˚ 
(
˚˚ .
 beginningOfPositiveNumericSuffix
˚˚ 3
<
˚˚4 5
value
˚˚6 ;
.
˚˚; <
Length
˚˚< B
&&
˚˚C E
value
˚˚F K
[
˚˚K L.
 beginningOfPositiveNumericSuffix
˚˚L l
]
˚˚l m
==
˚˚n p
$char
˚˚q t
)
˚˚t u
++
¸¸ .
 beginningOfPositiveNumericSuffix
¸¸ 2
;
¸¸2 3
var
ÅÅ 
leadingZeroes
ÅÅ 
=
ÅÅ .
 beginningOfPositiveNumericSuffix
ÅÅ  @
-
ÅÅA B
beginningOfDigits
ÅÅC T
;
ÅÅT U
if
ÇÇ 
(
ÇÇ 
leadingZeroes
ÇÇ 
>
ÇÇ 
kMaxLeadingZeroes
ÇÇ  1
)
ÇÇ1 2
{
ÉÉ 
var
ÑÑ !
excessLeadingZeroes
ÑÑ '
=
ÑÑ( )
leadingZeroes
ÑÑ* 7
-
ÑÑ8 9
kMaxLeadingZeroes
ÑÑ: K
;
ÑÑK L
beginningOfDigits
ÖÖ !
+=
ÖÖ" $!
excessLeadingZeroes
ÖÖ% 8
;
ÖÖ8 9
leadingZeroes
ÜÜ 
-=
ÜÜ  !
excessLeadingZeroes
ÜÜ! 4
;
ÜÜ4 5
}
áá #
PositiveNumericSuffix
ãã !
=
ãã" #
$num
ãã$ %
;
ãã% &
{
åå 
int
çç 
number
çç 
=
çç 
$num
çç 
;
çç 
for
éé 
(
éé 
var
éé 
i
éé 
=
éé .
 beginningOfPositiveNumericSuffix
éé =
;
éé= >
i
éé? @
<
ééA B
value
ééC H
.
ééH I
Length
ééI O
;
ééO P
++
ééQ S
i
ééS T
)
ééT U
{
èè 
number
êê 
*=
êê 
$num
êê  
;
êê  !
number
ëë 
+=
ëë 
value
ëë #
[
ëë# $
i
ëë$ %
]
ëë% &
-
ëë' (
$char
ëë) ,
;
ëë, -
}
íí 
if
óó 
(
óó 
number
óó 
<=
óó '
kMaxPositiveNumericSuffix
óó 7
)
óó7 8#
PositiveNumericSuffix
òò )
=
òò* +
number
òò, 2
;
òò2 3
else
ôô 
{
öö 
beginningOfDigits
õõ %
=
õõ& '
value
õõ( -
.
õõ- .
Length
õõ. 4
;
õõ4 5
leadingZeroes
úú !
=
úú" #
$num
úú$ %
;
úú% &
}
ùù 
}
ûû 
LeadingZeroes
¢¢ 
=
¢¢ 
leadingZeroes
¢¢ )
;
¢¢) *
var
•• 
	truncated
•• 
=
•• 
value
•• !
;
••! "
int
¶¶ 
length
¶¶ 
=
¶¶ 
	truncated
¶¶ "
.
¶¶" #
Length
¶¶# )
;
¶¶) *
if
ßß 
(
ßß 
beginningOfDigits
ßß !
!=
ßß" $
	truncated
ßß% .
.
ßß. /
Length
ßß/ 5
)
ßß5 6
	truncated
®® 
.
®® 
Length
®®  
=
®®! "
beginningOfDigits
®®# 4
;
®®4 5
unsafe
¨¨ 
{
≠≠ 
Index
ÆÆ 
=
ÆÆ 
WordStorage
ÆÆ #
.
ÆÆ# $
Instance
ÆÆ$ ,
.
ÆÆ, -
GetOrCreateIndex
ÆÆ- =
(
ÆÆ= >
ref
ÆÆ> A
	truncated
ÆÆB K
)
ÆÆK L
;
ÆÆL M
}
ØØ 
}
∞∞ 	
[
∂∂ 	 
NotBurstCompatible
∂∂	 
]
∂∂, -
public
∑∑ 
void
∑∑ 
	SetString
∑∑ 
(
∑∑ 
string
∑∑ $
value
∑∑% *
)
∑∑* +
{
∏∏ 	!
FixedString512Bytes
ππ 
temp
ππ  $
=
ππ% &
value
ππ' ,
;
ππ, -
	SetString
∫∫ 
(
∫∫ 
ref
∫∫ 
temp
∫∫ 
)
∫∫ 
;
∫∫  
}
ªª 	
}
ºº 
}ΩΩ ˇ1
oC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeNotBurstCompatible.cs
	namespace 	
Unity
 
. 
Collections 
. 
NotBurstCompatible .
{ 
public 

static 
class 

Extensions "
{ 
[ 	
NotBurstCompatible	 
] 
public 
static 
T 
[ 
] 
ToArray !
<! "
T" #
># $
($ %
this% )
NativeHashSet* 7
<7 8
T8 9
>9 :
set; >
)> ?
where 
T 
: 
	unmanaged 
,  

IEquatable! +
<+ ,
T, -
>- .
{ 	
var 
array 
= 
set 
. 
ToNativeArray )
() *
	Allocator* 3
.3 4
TempJob4 ;
); <
;< =
var 
managed 
= 
array 
.  
ToArray  '
(' (
)( )
;) *
array 
. 
Dispose 
( 
) 
; 
return 
managed 
; 
} 	
[## 	
NotBurstCompatible##	 
]## 
public$$ 
static$$ 
T$$ 
[$$ 
]$$ 

ToArrayNBC$$ $
<$$$ %
T$$% &
>$$& '
($$' (
this$$( ,

NativeList$$- 7
<$$7 8
T$$8 9
>$$9 :
list$$; ?
)$$? @
where%% 
T%% 
:%% 
	unmanaged%% 
{&& 	
return'' 
list'' 
.'' 
AsArray'' 
(''  
)''  !
.''! "
ToArray''" )
('') *
)''* +
;''+ ,
}(( 	
[00 	
NotBurstCompatible00	 
]00 
public11 
static11 
void11 
CopyFromNBC11 &
<11& '
T11' (
>11( )
(11) *
this11* .

NativeList11/ 9
<119 :
T11: ;
>11; <
list11= A
,11A B
T11C D
[11D E
]11E F
array11G L
)11L M
where22 
T22 
:22 
	unmanaged22 
{33 	
list44 
.44 
Clear44 
(44 
)44 
;44 
list55 
.55 
Resize55 
(55 
array55 
.55 
Length55 $
,55$ %
NativeArrayOptions55& 8
.558 9
UninitializedMemory559 L
)55L M
;55M N
NativeArray66 
<66 
T66 
>66 
na66 
=66 
list66  $
.66$ %
AsArray66% ,
(66, -
)66- .
;66. /
na77 
.77 
CopyFrom77 
(77 
array77 
)77 
;77 
}88 	
[CC 	
BurstCompatibleCC	 
(CC  
GenericTypeArgumentsCC -
=CC. /
newCC0 3
[CC3 4
]CC4 5
{CC6 7
typeofCC8 >
(CC> ?
intCC? B
)CCB C
,CCC D
typeofCCE K
(CCK L
intCCL O
)CCO P
}CCQ R
)CCR S
]CCS T
[DD 	
ObsoleteDD	 
(DD 
$str	DD à
,
DDà â
false
DDä è
)
DDè ê
]
DDê ë
publicEE 
staticEE 
(EE 
NativeArrayEE "
<EE" #
TKeyEE# '
>EE' (
,EE( )
intEE* -
)EE- . 
GetUniqueKeyArrayNBCEE/ C
<EEC D
TKeyEED H
,EEH I
TValueEEJ P
>EEP Q
(EEQ R
thisEER V
UnsafeMultiHashMapEEW i
<EEi j
TKeyEEj n
,EEn o
TValueEEp v
>EEv w
hashmapEEx 
,	EE Ä
AllocatorManager
EEÅ ë
.
EEë í
AllocatorHandle
EEí °
	allocator
EE¢ ´
)
EE´ ¨
whereFF 
TKeyFF 
:FF 
structFF 
,FF 

IEquatableFF '
<FF' (
TKeyFF( ,
>FF, -
,FF- .
IComparableFF/ :
<FF: ;
TKeyFF; ?
>FF? @
whereGG 
TValueGG 
:GG 
structGG 
=>GG  
hashmapGG! (
.GG( )
GetUniqueKeyArrayGG) :
(GG: ;
	allocatorGG; D
)GGD E
;GGE F
[QQ 	
BurstCompatibleQQ	 
(QQ  
GenericTypeArgumentsQQ -
=QQ. /
newQQ0 3
[QQ3 4
]QQ4 5
{QQ6 7
typeofQQ8 >
(QQ> ?
intQQ? B
)QQB C
,QQC D
typeofQQE K
(QQK L
intQQL O
)QQO P
}QQQ R
)QQR S
]QQS T
[RR 	
ObsoleteRR	 
(RR 
$str	RR à
,
RRà â
false
RRä è
)
RRè ê
]
RRê ë
publicSS 
staticSS 
(SS 
NativeArraySS "
<SS" #
TKeySS# '
>SS' (
,SS( )
intSS* -
)SS- . 
GetUniqueKeyArrayNBCSS/ C
<SSC D
TKeySSD H
,SSH I
TValueSSJ P
>SSP Q
(SSQ R
thisSSR V
NativeMultiHashMapSSW i
<SSi j
TKeySSj n
,SSn o
TValueSSp v
>SSv w
hashmapSSx 
,	SS Ä
AllocatorManager
SSÅ ë
.
SSë í
AllocatorHandle
SSí °
	allocator
SS¢ ´
)
SS´ ¨
whereTT 
TKeyTT 
:TT 
structTT 
,TT  

IEquatableTT! +
<TT+ ,
TKeyTT, 0
>TT0 1
,TT1 2
IComparableTT3 >
<TT> ?
TKeyTT? C
>TTC D
whereUU 
TValueUU 
:UU 
structUU !
=>UU" $
hashmapUU% ,
.UU, -
GetUniqueKeyArrayUU- >
(UU> ?
	allocatorUU? H
)UUH I
;UUI J
}WW 
}XX ‹Â
jC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\RewindableAllocator.cs
	namespace		 	
Unity		
 
.		 
Collections		 
{

 
struct 

Spinner 
{ 
int 
m_value 
; 
public 
void 
Lock 
( 
) 
{ 	
while 
( 
$num 
!= 
Interlocked #
.# $
CompareExchange$ 3
(3 4
ref4 7
m_value8 ?
,? @
$numA B
,B C
$numD E
)E F
)F G
{ 
} 
Interlocked 
. 
MemoryBarrier %
(% &
)& '
;' (
} 	
public 
void 
Unlock 
( 
) 
{ 	
Interlocked 
. 
MemoryBarrier %
(% &
)& '
;' (
while 
( 
$num 
!= 
Interlocked #
.# $
CompareExchange$ 3
(3 4
ref4 7
m_value8 ?
,? @
$numA B
,B C
$numD E
)E F
)F G
{ 
} 
} 	
} 
internal 
struct 
UnmanagedArray "
<" #
T# $
>$ %
:& '
IDisposable( 3
where4 9
T: ;
:< =
	unmanaged> G
{ 
IntPtr   
	m_pointer   
;   
int!! 
m_length!! 
;!! 
AllocatorManager"" 
."" 
AllocatorHandle"" (
m_allocator"") 4
;""4 5
public## 
UnmanagedArray## 
(## 
int## !
length##" (
,##( )
AllocatorManager##* :
.##: ;
AllocatorHandle##; J
	allocator##K T
)##T U
{$$ 	
unsafe%% 
{&& 
	m_pointer'' 
='' 
('' 
IntPtr'' #
)''# $
Memory''$ *
.''* +
	Unmanaged''+ 4
.''4 5
Array''5 :
.'': ;
Allocate''; C
<''C D
T''D E
>''E F
(''F G
length''G M
,''M N
	allocator''O X
)''X Y
;''Y Z
}(( 
m_length)) 
=)) 
length)) 
;)) 
m_allocator** 
=** 
	allocator** #
;**# $
}++ 	
public,, 
void,, 
Dispose,, 
(,, 
),, 
{-- 	
unsafe.. 
{// 
Memory00 
.00 
	Unmanaged00  
.00  !
Free00! %
(00% &
(00& '
T00' (
*00( )
)00) *
	m_pointer00* 3
,003 4
	Allocator005 >
.00> ?

Persistent00? I
)00I J
;00J K
}11 
}22 	
public33 
unsafe33 
T33 
*33 
GetUnsafePointer33 )
(33) *
)33* +
{44 	
return55 
(55 
T55 
*55 
)55 
	m_pointer55  
;55  !
}66 	
public77 
ref77 
T77 
this77 
[77 
int77 
index77 #
]77# $
{88 	
get99 
{99 
unsafe99 
{99 
return99 !
ref99" %
(99& '
(99' (
T99( )
*99) *
)99* +
	m_pointer99+ 4
)994 5
[995 6
index996 ;
]99; <
;99< =
}99> ?
}99@ A
}:: 	
};; 
[AA 
BurstCompileAA 
]AA 
publicBB 

structBB 
RewindableAllocatorBB %
:BB& '
AllocatorManagerBB( 8
.BB8 9

IAllocatorBB9 C
{CC 
[DD 	
BurstCompatibleDD	 
]DD 
internalEE 
unsafeEE 
structEE 
MemoryBlockEE *
:EE+ ,
IDisposableEE- 8
{FF 	
publicGG 
constGG 
intGG 
kMaximumAlignmentGG .
=GG/ 0
$numGG1 6
;GG6 7
publicHH 
byteHH 
*HH 
	m_pointerHH "
;HH" #
publicII 
longII 
m_bytesII 
;II  
publicJJ 
longJJ 
	m_currentJJ !
;JJ! "
publicKK 
longKK 
m_allocationsKK %
;KK% &
publicLL 
MemoryBlockLL 
(LL 
longLL #
bytesLL$ )
)LL) *
{MM 
	m_pointerNN 
=NN 
(NN 
byteNN !
*NN! "
)NN" #
MemoryNN# )
.NN) *
	UnmanagedNN* 3
.NN3 4
AllocateNN4 <
(NN< =
bytesNN= B
,NNB C
kMaximumAlignmentNND U
,NNU V
	AllocatorNNW `
.NN` a

PersistentNNa k
)NNk l
;NNl m
m_bytesOO 
=OO 
bytesOO 
;OO  
	m_currentPP 
=PP 
$numPP 
;PP 
m_allocationsQQ 
=QQ 
$numQQ  !
;QQ! "
}RR 
publicSS 
voidSS 
RewindSS 
(SS 
)SS  
{TT 
	m_currentUU 
=UU 
$numUU 
;UU 
m_allocationsVV 
=VV 
$numVV  !
;VV! "
}WW 
publicXX 
voidXX 
DisposeXX 
(XX  
)XX  !
{YY 
MemoryZZ 
.ZZ 
	UnmanagedZZ  
.ZZ  !
FreeZZ! %
(ZZ% &
	m_pointerZZ& /
,ZZ/ 0
	AllocatorZZ1 :
.ZZ: ;

PersistentZZ; E
)ZZE F
;ZZF G
	m_pointer[[ 
=[[ 
null[[  
;[[  !
m_bytes\\ 
=\\ 
$num\\ 
;\\ 
	m_current]] 
=]] 
$num]] 
;]] 
m_allocations^^ 
=^^ 
$num^^  !
;^^! "
}__ 
publicaa 
intaa 
TryAllocateaa "
(aa" #
refaa# &
AllocatorManageraa' 7
.aa7 8
Blockaa8 =
blockaa> C
)aaC D
{bb 
vardd 
	alignmentdd 
=dd 
mathdd  $
.dd$ %
maxdd% (
(dd( )
JobsUtilitydd) 4
.dd4 5
CacheLineSizedd5 B
,ddB C
blockddD I
.ddI J
	AlignmentddJ S
)ddS T
;ddT U
varee 
extraee 
=ee 
	alignmentee %
!=ee& (
JobsUtilityee) 4
.ee4 5
CacheLineSizeee5 B
?eeC D
$numeeE F
:eeG H
$numeeI J
;eeJ K
varff 
cachelineMaskff !
=ff" #
JobsUtilityff$ /
.ff/ 0
CacheLineSizeff0 =
-ff> ?
$numff@ A
;ffA B
ifgg 
(gg 
extragg 
==gg 
$numgg 
)gg 
{hh 
	alignmentii 
=ii 
(ii  !
	alignmentii! *
+ii+ ,
cachelineMaskii- :
)ii: ;
&ii< =
~ii> ?
cachelineMaskii? L
;iiL M
}jj 
varnn 
masknn 
=nn 
	alignmentnn $
-nn% &
$numnn' )
;nn) *
varoo 
sizeoo 
=oo 
(oo 
blockoo !
.oo! "
Bytesoo" '
+oo( )
extraoo* /
*oo0 1
	alignmentoo2 ;
+oo< =
maskoo> B
)ooB C
&ooD E
~ooF G
maskooG K
;ooK L
varpp 
beginpp 
=pp 
Interlockedpp '
.pp' (
Addpp( +
(pp+ ,
refpp, /
	m_currentpp0 9
,pp9 :
sizepp; ?
)pp? @
-ppA B
sizeppC G
;ppG H
beginqq 
=qq 
(qq 
beginqq 
+qq  
maskqq! %
)qq% &
&qq' (
~qq) *
maskqq* .
;qq. /
ifrr 
(rr 
beginrr 
+rr 
blockrr !
.rr! "
Bytesrr" '
>rr( )
m_bytesrr* 1
)rr1 2
returnss 
AllocatorManagerss +
.ss+ , 
kErrorBufferOverflowss, @
;ss@ A
blocktt 
.tt 
Rangett 
.tt 
Pointertt #
=tt$ %
(tt& '
IntPtrtt' -
)tt- .
(tt. /
	m_pointertt/ 8
+tt9 :
begintt; @
)tt@ A
;ttA B
blockuu 
.uu 
AllocatedItemsuu $
=uu% &
blockuu' ,
.uu, -
Rangeuu- 2
.uu2 3
Itemsuu3 8
;uu8 9
Interlockedvv 
.vv 
	Incrementvv %
(vv% &
refvv& )
m_allocationsvv* 7
)vv7 8
;vv8 9
returnww 
AllocatorManagerww '
.ww' (

kErrorNoneww( 2
;ww2 3
}xx 
publiczz 
boolzz 
Containszz  
(zz  !
IntPtrzz! '
ptrzz( +
)zz+ ,
{{{ 
unsafe|| 
{}} 
void~~ 
*~~ 
pointer~~ !
=~~" #
(~~$ %
void~~% )
*~~) *
)~~* +
ptr~~+ .
;~~. /
return 
( 
pointer #
>=$ &
	m_pointer' 0
)0 1
&&2 4
(5 6
pointer6 =
<> ?
	m_pointer@ I
+J K
	m_currentL U
)U V
;V W
}
ÄÄ 
}
ÅÅ 
}
ÇÇ 	
;
ÇÇ	 

Spinner
ÑÑ 
	m_spinner
ÑÑ 
;
ÑÑ 
AllocatorManager
ÖÖ 
.
ÖÖ 
AllocatorHandle
ÖÖ (
m_handle
ÖÖ) 1
;
ÖÖ1 2
UnmanagedArray
ÜÜ 
<
ÜÜ 
MemoryBlock
ÜÜ "
>
ÜÜ" #
m_block
ÜÜ$ +
;
ÜÜ+ ,
int
áá 
m_best
áá 
;
áá 
int
àà 
m_last
àà 
;
àà 
int
ââ 
m_used
ââ 
;
ââ 
bool
ää 
m_enableBlockFree
ää 
;
ää 
public
êê 
void
êê 

Initialize
êê 
(
êê 
int
êê " 
initialSizeInBytes
êê# 5
,
êê5 6
bool
êê7 ;
enableBlockFree
êê< K
=
êêL M
false
êêN S
)
êêS T
{
ëë 	
	m_spinner
íí 
=
íí 
default
íí 
;
íí  
m_block
ìì 
=
ìì 
new
ìì 
UnmanagedArray
ìì (
<
ìì( )
MemoryBlock
ìì) 4
>
ìì4 5
(
ìì5 6
$num
ìì6 8
,
ìì8 9
	Allocator
ìì: C
.
ììC D

Persistent
ììD N
)
ììN O
;
ììO P
m_block
îî 
[
îî 
$num
îî 
]
îî 
=
îî 
new
îî 
MemoryBlock
îî (
(
îî( ) 
initialSizeInBytes
îî) ;
)
îî; <
;
îî< =
m_last
ïï 
=
ïï 
m_used
ïï 
=
ïï 
m_best
ïï $
=
ïï% &
$num
ïï' (
;
ïï( )
m_enableBlockFree
ññ 
=
ññ 
enableBlockFree
ññ  /
;
ññ/ 0
}
óó 	
public
úú 
bool
úú 
EnableBlockFree
úú #
{
ùù 	
get
ûû 
=>
ûû 
m_enableBlockFree
ûû $
;
ûû$ %
set
üü 
=>
üü 
m_enableBlockFree
üü $
=
üü% &
value
üü' ,
;
üü, -
}
†† 	
public
•• 
int
•• 
BlocksAllocated
•• "
=>
••# %
(
••& '
int
••' *
)
••* +
(
••+ ,
m_last
••, 2
+
••3 4
$num
••5 6
)
••6 7
;
••7 8
public
™™ 
int
™™  
InitialSizeInBytes
™™ %
=>
™™& (
(
™™) *
int
™™* -
)
™™- .
(
™™. /
m_block
™™/ 6
[
™™6 7
$num
™™7 8
]
™™8 9
.
™™9 :
m_bytes
™™: A
)
™™A B
;
™™B C
public
∞∞ 
void
∞∞ 
Rewind
∞∞ 
(
∞∞ 
)
∞∞ 
{
±± 	
if
≤≤ 
(
≤≤ 
JobsUtility
≤≤ 
.
≤≤ 
IsExecutingJob
≤≤ *
)
≤≤* +
throw
≥≥ 
new
≥≥ '
InvalidOperationException
≥≥ 3
(
≥≥3 4
$str
≥≥4 i
)
≥≥i j
;
≥≥j k
m_handle
¥¥ 
.
¥¥ 
Rewind
¥¥ 
(
¥¥ 
)
¥¥ 
;
¥¥ 
while
µµ 
(
µµ 
m_last
µµ 
>
µµ 
m_used
µµ "
)
µµ" #
m_block
∂∂ 
[
∂∂ 
m_last
∂∂ 
--
∂∂  
]
∂∂  !
.
∂∂! "
Dispose
∂∂" )
(
∂∂) *
)
∂∂* +
;
∂∂+ ,
while
∑∑ 
(
∑∑ 
m_used
∑∑ 
>
∑∑ 
$num
∑∑ 
)
∑∑ 
m_block
∏∏ 
[
∏∏ 
m_used
∏∏ 
--
∏∏  
]
∏∏  !
.
∏∏! "
Rewind
∏∏" (
(
∏∏( )
)
∏∏) *
;
∏∏* +
m_block
ππ 
[
ππ 
$num
ππ 
]
ππ 
.
ππ 
Rewind
ππ 
(
ππ 
)
ππ 
;
ππ  
}
∫∫ 	
public
øø 
void
øø 
Dispose
øø 
(
øø 
)
øø 
{
¿¿ 	
if
¡¡ 
(
¡¡ 
JobsUtility
¡¡ 
.
¡¡ 
IsExecutingJob
¡¡ *
)
¡¡* +
throw
¬¬ 
new
¬¬ '
InvalidOperationException
¬¬ 3
(
¬¬3 4
$str
¬¬4 j
)
¬¬j k
;
¬¬k l
m_used
√√ 
=
√√ 
$num
√√ 
;
√√ 
Rewind
ƒƒ 
(
ƒƒ 
)
ƒƒ 
;
ƒƒ 
m_block
≈≈ 
[
≈≈ 
$num
≈≈ 
]
≈≈ 
.
≈≈ 
Dispose
≈≈ 
(
≈≈ 
)
≈≈  
;
≈≈  !
m_block
∆∆ 
.
∆∆ 
Dispose
∆∆ 
(
∆∆ 
)
∆∆ 
;
∆∆ 
m_last
«« 
=
«« 
m_used
«« 
=
«« 
m_best
«« $
=
««% &
$num
««' (
;
««( )
}
»» 	
[
ÕÕ 	 
NotBurstCompatible
ÕÕ	 
]
ÕÕ 
public
ŒŒ 
AllocatorManager
ŒŒ 
.
ŒŒ  
TryFunction
ŒŒ  +
Function
ŒŒ, 4
=>
ŒŒ5 7
Try
ŒŒ8 ;
;
ŒŒ; <
public
’’ 
int
’’ 
Try
’’ 
(
’’ 
ref
’’ 
AllocatorManager
’’ +
.
’’+ ,
Block
’’, 1
block
’’2 7
)
’’7 8
{
÷÷ 	
if
◊◊ 
(
◊◊ 
block
◊◊ 
.
◊◊ 
Range
◊◊ 
.
◊◊ 
Pointer
◊◊ #
==
◊◊$ &
IntPtr
◊◊' -
.
◊◊- .
Zero
◊◊. 2
)
◊◊2 3
{
ÿÿ 
var
⁄⁄ 
error
⁄⁄ 
=
⁄⁄ 
m_block
⁄⁄ #
[
⁄⁄# $
m_best
⁄⁄$ *
]
⁄⁄* +
.
⁄⁄+ ,
TryAllocate
⁄⁄, 7
(
⁄⁄7 8
ref
⁄⁄8 ;
block
⁄⁄< A
)
⁄⁄A B
;
⁄⁄B C
if
€€ 
(
€€ 
error
€€ 
==
€€ 
AllocatorManager
€€ -
.
€€- .

kErrorNone
€€. 8
)
€€8 9
return
‹‹ 
error
‹‹  
;
‹‹  !
	m_spinner
ﬁﬁ 
.
ﬁﬁ 
Lock
ﬁﬁ 
(
ﬁﬁ 
)
ﬁﬁ  
;
ﬁﬁ  !
int
ﬂﬂ 
best
ﬂﬂ 
;
ﬂﬂ 
for
‡‡ 
(
‡‡ 
best
‡‡ 
=
‡‡ 
$num
‡‡ 
;
‡‡ 
best
‡‡ #
<=
‡‡$ &
m_last
‡‡' -
;
‡‡- .
++
‡‡/ 1
best
‡‡1 5
)
‡‡5 6
{
·· 
error
‚‚ 
=
‚‚ 
m_block
‚‚ #
[
‚‚# $
best
‚‚$ (
]
‚‚( )
.
‚‚) *
TryAllocate
‚‚* 5
(
‚‚5 6
ref
‚‚6 9
block
‚‚: ?
)
‚‚? @
;
‚‚@ A
if
„„ 
(
„„ 
error
„„ 
==
„„  
AllocatorManager
„„! 1
.
„„1 2

kErrorNone
„„2 <
)
„„< =
{
‰‰ 
m_used
ÂÂ 
=
ÂÂ  
best
ÂÂ! %
>
ÂÂ& '
m_used
ÂÂ( .
?
ÂÂ/ 0
best
ÂÂ1 5
:
ÂÂ6 7
m_used
ÂÂ8 >
;
ÂÂ> ?
m_best
ÊÊ 
=
ÊÊ  
best
ÊÊ! %
;
ÊÊ% &
	m_spinner
ÁÁ !
.
ÁÁ! "
Unlock
ÁÁ" (
(
ÁÁ( )
)
ÁÁ) *
;
ÁÁ* +
return
ËË 
error
ËË $
;
ËË$ %
}
ÈÈ 
}
ÍÍ 
var
ÏÏ 
bytes
ÏÏ 
=
ÏÏ 
math
ÏÏ  
.
ÏÏ  !
max
ÏÏ! $
(
ÏÏ$ %
m_block
ÏÏ% ,
[
ÏÏ, -
$num
ÏÏ- .
]
ÏÏ. /
.
ÏÏ/ 0
m_bytes
ÏÏ0 7
<<
ÏÏ8 :
best
ÏÏ; ?
,
ÏÏ? @
math
ÏÏA E
.
ÏÏE F
ceilpow2
ÏÏF N
(
ÏÏN O
block
ÏÏO T
.
ÏÏT U
Bytes
ÏÏU Z
)
ÏÏZ [
)
ÏÏ[ \
;
ÏÏ\ ]
m_block
ÌÌ 
[
ÌÌ 
best
ÌÌ 
]
ÌÌ 
=
ÌÌ 
new
ÌÌ  #
MemoryBlock
ÌÌ$ /
(
ÌÌ/ 0
bytes
ÌÌ0 5
)
ÌÌ5 6
;
ÌÌ6 7
error
ÓÓ 
=
ÓÓ 
m_block
ÓÓ 
[
ÓÓ  
best
ÓÓ  $
]
ÓÓ$ %
.
ÓÓ% &
TryAllocate
ÓÓ& 1
(
ÓÓ1 2
ref
ÓÓ2 5
block
ÓÓ6 ;
)
ÓÓ; <
;
ÓÓ< =
m_best
ÔÔ 
=
ÔÔ 
best
ÔÔ 
;
ÔÔ 
m_used
 
=
 
best
 
;
 
m_last
ÒÒ 
=
ÒÒ 
best
ÒÒ 
;
ÒÒ 
	m_spinner
ÚÚ 
.
ÚÚ 
Unlock
ÚÚ  
(
ÚÚ  !
)
ÚÚ! "
;
ÚÚ" #
return
ÛÛ 
error
ÛÛ 
;
ÛÛ 
}
ÙÙ 
if
˜˜ 
(
˜˜ 
block
˜˜ 
.
˜˜ 
Range
˜˜ 
.
˜˜ 
Items
˜˜ !
==
˜˜" $
$num
˜˜% &
)
˜˜& '
{
¯¯ 
if
˘˘ 
(
˘˘ 
m_enableBlockFree
˘˘ %
)
˘˘% &
{
˙˙ 
	m_spinner
˚˚ 
.
˚˚ 
Lock
˚˚ "
(
˚˚" #
)
˚˚# $
;
˚˚$ %
if
¸¸ 
(
¸¸ 
m_block
¸¸ 
[
¸¸  
m_best
¸¸  &
]
¸¸& '
.
¸¸' (
Contains
¸¸( 0
(
¸¸0 1
block
¸¸1 6
.
¸¸6 7
Range
¸¸7 <
.
¸¸< =
Pointer
¸¸= D
)
¸¸D E
)
¸¸E F
if
˝˝ 
(
˝˝ 
$num
˝˝ 
==
˝˝  
Interlocked
˝˝! ,
.
˝˝, -
	Decrement
˝˝- 6
(
˝˝6 7
ref
˝˝7 :
m_block
˝˝; B
[
˝˝B C
m_best
˝˝C I
]
˝˝I J
.
˝˝J K
m_allocations
˝˝K X
)
˝˝X Y
)
˝˝Y Z
m_block
˛˛ #
[
˛˛# $
m_best
˛˛$ *
]
˛˛* +
.
˛˛+ ,
Rewind
˛˛, 2
(
˛˛2 3
)
˛˛3 4
;
˛˛4 5
	m_spinner
ˇˇ 
.
ˇˇ 
Unlock
ˇˇ $
(
ˇˇ$ %
)
ˇˇ% &
;
ˇˇ& '
}
ÄÄ 
return
ÅÅ 
$num
ÅÅ 
;
ÅÅ 
}
ÇÇ 
return
ÑÑ 
-
ÑÑ 
$num
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
[
áá 	
BurstCompile
áá	 
]
áá 
[
àà 	!
MonoPInvokeCallback
àà	 
(
àà 
typeof
àà #
(
àà# $
AllocatorManager
àà$ 4
.
àà4 5
TryFunction
àà5 @
)
àà@ A
)
ààA B
]
ààB C
internal
ââ 
static
ââ 
int
ââ 
Try
ââ 
(
ââ  
IntPtr
ââ  &
state
ââ' ,
,
ââ, -
ref
ââ. 1
AllocatorManager
ââ2 B
.
ââB C
Block
ââC H
block
ââI N
)
ââN O
{
ää 	
unsafe
ãã 
{
ãã 
return
ãã 
(
ãã 
(
ãã !
RewindableAllocator
ãã 1
*
ãã1 2
)
ãã2 3
state
ãã3 8
)
ãã8 9
->
ãã9 ;
Try
ãã; >
(
ãã> ?
ref
ãã? B
block
ããC H
)
ããH I
;
ããI J
}
ããK L
}
åå 	
public
ìì 
AllocatorManager
ìì 
.
ìì  
AllocatorHandle
ìì  /
Handle
ìì0 6
{
ìì7 8
get
ìì9 <
{
ìì= >
return
ìì? E
m_handle
ììF N
;
ììN O
}
ììP Q
set
ììR U
{
ììV W
m_handle
ììX `
=
ììa b
value
ììc h
;
ììh i
}
ììj k
}
ììl m
public
ôô 
	Allocator
ôô 
ToAllocator
ôô $
{
ôô% &
get
ôô' *
{
ôô+ ,
return
ôô- 3
m_handle
ôô4 <
.
ôô< =
ToAllocator
ôô= H
;
ôôH I
}
ôôJ K
}
ôôL M
public
üü 
bool
üü 
IsCustomAllocator
üü %
{
üü& '
get
üü( +
{
üü, -
return
üü. 4
m_handle
üü5 =
.
üü= >
IsCustomAllocator
üü> O
;
üüO P
}
üüQ R
}
üüS T
[
™™ 	
BurstCompatible
™™	 
(
™™ "
GenericTypeArguments
™™ -
=
™™. /
new
™™0 3
[
™™3 4
]
™™4 5
{
™™6 7
typeof
™™8 >
(
™™> ?
int
™™? B
)
™™B C
}
™™D E
)
™™E F
]
™™F G
public
´´ 
NativeArray
´´ 
<
´´ 
T
´´ 
>
´´ !
AllocateNativeArray
´´ 1
<
´´1 2
T
´´2 3
>
´´3 4
(
´´4 5
int
´´5 8
length
´´9 ?
)
´´? @
where
´´A F
T
´´G H
:
´´I J
struct
´´K Q
{
¨¨ 	
var
≠≠ 
	container
≠≠ 
=
≠≠ 
new
≠≠ 
NativeArray
≠≠  +
<
≠≠+ ,
T
≠≠, -
>
≠≠- .
(
≠≠. /
)
≠≠/ 0
;
≠≠0 1
unsafe
ÆÆ 
{
ØØ 
	container
∞∞ 
.
∞∞ 
m_Buffer
∞∞ "
=
∞∞# $
this
∞∞% )
.
∞∞) *
AllocateStruct
∞∞* 8
(
∞∞8 9
default
∞∞9 @
(
∞∞@ A
T
∞∞A B
)
∞∞B C
,
∞∞C D
length
∞∞E K
)
∞∞K L
;
∞∞L M
}
±± 
	container
≤≤ 
.
≤≤ 
m_Length
≤≤ 
=
≤≤  
length
≤≤! '
;
≤≤' (
	container
≥≥ 
.
≥≥ 
m_AllocatorLabel
≥≥ &
=
≥≥' (
	Allocator
≥≥) 2
.
≥≥2 3
None
≥≥3 7
;
≥≥7 8
	container
µµ 
.
µµ 

m_MinIndex
µµ  
=
µµ! "
$num
µµ# $
;
µµ$ %
	container
∂∂ 
.
∂∂ 

m_MaxIndex
∂∂  
=
∂∂! "
length
∂∂# )
-
∂∂* +
$num
∂∂, -
;
∂∂- .
	container
∑∑ 
.
∑∑ 
m_Safety
∑∑ 
=
∑∑  
CollectionHelper
∑∑! 1
.
∑∑1 2 
CreateSafetyHandle
∑∑2 D
(
∑∑D E
ToAllocator
∑∑E P
)
∑∑P Q
;
∑∑Q R
	container
∫∫ 
.
∫∫ 
m_DisposeSentinel
∫∫ '
=
∫∫( )
null
∫∫* .
;
∫∫. /
CollectionHelper
ºº 
.
ºº 
SetStaticSafetyId
ºº .
<
ºº. /
NativeArray
ºº/ :
<
ºº: ;
T
ºº; <
>
ºº< =
>
ºº= >
(
ºº> ?
ref
ºº? B
	container
ººC L
.
ººL M
m_Safety
ººM U
,
ººU V
ref
ººW Z#
NativeArrayExtensions
ºº[ p
.
ººp q"
NativeArrayStaticIdººq Ñ
<ººÑ Ö
TººÖ Ü
>ººÜ á
.ººá à 
s_staticSafetyIdººà ò
.ººò ô
Dataººô ù
)ººù û
;ººû ü
Handle
ΩΩ 
.
ΩΩ 
AddSafetyHandle
ΩΩ "
(
ΩΩ" #
	container
ΩΩ# ,
.
ΩΩ, -
m_Safety
ΩΩ- 5
)
ΩΩ5 6
;
ΩΩ6 7
return
øø 
	container
øø 
;
øø 
}
¿¿ 	
[
ÃÃ 	
BurstCompatible
ÃÃ	 
(
ÃÃ "
GenericTypeArguments
ÃÃ -
=
ÃÃ. /
new
ÃÃ0 3
[
ÃÃ3 4
]
ÃÃ4 5
{
ÃÃ6 7
typeof
ÃÃ8 >
(
ÃÃ> ?
int
ÃÃ? B
)
ÃÃB C
}
ÃÃD E
)
ÃÃE F
]
ÃÃF G
public
ÕÕ 

NativeList
ÕÕ 
<
ÕÕ 
T
ÕÕ 
>
ÕÕ  
AllocateNativeList
ÕÕ /
<
ÕÕ/ 0
T
ÕÕ0 1
>
ÕÕ1 2
(
ÕÕ2 3
int
ÕÕ3 6
capacity
ÕÕ7 ?
)
ÕÕ? @
where
ÕÕA F
T
ÕÕG H
:
ÕÕI J
	unmanaged
ÕÕK T
{
ŒŒ 	
var
œœ 
	container
œœ 
=
œœ 
new
œœ 

NativeList
œœ  *
<
œœ* +
T
œœ+ ,
>
œœ, -
(
œœ- .
)
œœ. /
;
œœ/ 0
unsafe
–– 
{
—— 
	container
““ 
.
““ 

m_ListData
““ $
=
““% &
this
““' +
.
““+ ,
Allocate
““, 4
(
““4 5
default
““5 <
(
““< =

UnsafeList
““= G
<
““G H
T
““H I
>
““I J
)
““J K
,
““K L
$num
““M N
)
““N O
;
““O P
	container
”” 
.
”” 

m_ListData
”” $
->
””$ &
Ptr
””& )
=
””* +
this
””, 0
.
””0 1
Allocate
””1 9
(
””9 :
default
””: A
(
””A B
T
””B C
)
””C D
,
””D E
capacity
””F N
)
””N O
;
””O P
	container
‘‘ 
.
‘‘ 

m_ListData
‘‘ $
->
‘‘$ &

m_capacity
‘‘& 0
=
‘‘1 2
capacity
‘‘3 ;
;
‘‘; <
	container
’’ 
.
’’ 

m_ListData
’’ $
->
’’$ &
m_length
’’& .
=
’’/ 0
$num
’’1 2
;
’’2 3
	container
÷÷ 
.
÷÷ 

m_ListData
÷÷ $
->
÷÷$ &
	Allocator
÷÷& /
=
÷÷0 1
	Allocator
÷÷2 ;
.
÷÷; <
None
÷÷< @
;
÷÷@ A
}
◊◊ 
	container
ÿÿ 
.
ÿÿ #
m_DeprecatedAllocator
ÿÿ +
=
ÿÿ, -
	Allocator
ÿÿ. 7
.
ÿÿ7 8
None
ÿÿ8 <
;
ÿÿ< =
	container
⁄⁄ 
.
⁄⁄ 
m_Safety
⁄⁄ 
=
⁄⁄  
CollectionHelper
⁄⁄! 1
.
⁄⁄1 2 
CreateSafetyHandle
⁄⁄2 D
(
⁄⁄D E
ToAllocator
⁄⁄E P
)
⁄⁄P Q
;
⁄⁄Q R
	container
›› 
.
›› 
m_DisposeSentinel
›› '
=
››( )
null
››* .
;
››. /
CollectionHelper
ﬂﬂ 
.
ﬂﬂ 
SetStaticSafetyId
ﬂﬂ .
<
ﬂﬂ. /

NativeList
ﬂﬂ/ 9
<
ﬂﬂ9 :
T
ﬂﬂ: ;
>
ﬂﬂ; <
>
ﬂﬂ< =
(
ﬂﬂ= >
ref
ﬂﬂ> A
	container
ﬂﬂB K
.
ﬂﬂK L
m_Safety
ﬂﬂL T
,
ﬂﬂT U
ref
ﬂﬂV Y

NativeList
ﬂﬂZ d
<
ﬂﬂd e
T
ﬂﬂe f
>
ﬂﬂf g
.
ﬂﬂg h
s_staticSafetyId
ﬂﬂh x
.
ﬂﬂx y
Data
ﬂﬂy }
)
ﬂﬂ} ~
;
ﬂﬂ~  
AtomicSafetyHandle
‡‡ 
.
‡‡ 4
&SetBumpSecondaryVersionOnScheduleWrite
‡‡ E
(
‡‡E F
	container
‡‡F O
.
‡‡O P
m_Safety
‡‡P X
,
‡‡X Y
true
‡‡Z ^
)
‡‡^ _
;
‡‡_ `
Handle
·· 
.
·· 
AddSafetyHandle
·· "
(
··" #
	container
··# ,
.
··, -
m_Safety
··- 5
)
··5 6
;
··6 7
return
„„ 
	container
„„ 
;
„„ 
}
‰‰ 	
}
ÂÂ 
}ÊÊ Õ
oC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\BurstCompatibleAttribute.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[		 
AttributeUsage		 
(		 
AttributeTargets		 $
.		$ %
Class		% *
|		+ ,
AttributeTargets		- =
.		= >
Struct		> D
|		E F
AttributeTargets		G W
.		W X
Method		X ^
|		_ `
AttributeTargets		a q
.		q r
Property		r z
|		{ |
AttributeTargets			} ç
.
		ç é
Constructor
		é ô
,
		ô ö
AllowMultiple
		õ ®
=
		© ™
true
		´ Ø
)
		Ø ∞
]
		∞ ±
public

 

class

 $
BurstCompatibleAttribute

 )
:

* +
	Attribute

, 5
{ 
public 
enum (
BurstCompatibleCompileTarget 0
{ 	
Player 
, 
Editor 
, 
PlayerAndEditor 
} 	
public-- 
Type-- 
[-- 
]--  
GenericTypeArguments-- *
{--+ ,
get--- 0
;--0 1
set--2 5
;--5 6
}--7 8
public22 
string22 
RequiredUnityDefine22 )
=22* +
null22, 0
;220 1
publicKK (
BurstCompatibleCompileTargetKK +
CompileTargetKK, 9
=KK: ;(
BurstCompatibleCompileTargetKK< X
.KKX Y
PlayerKKY _
;KK_ `
}LL 
[PP 
AttributeUsagePP 
(PP 
AttributeTargetsPP $
.PP$ %
MethodPP% +
|PP, -
AttributeTargetsPP. >
.PP> ?
PropertyPP? G
|PPH I
AttributeTargetsPPJ Z
.PPZ [
ConstructorPP[ f
)PPf g
]PPg h
publicQQ 

classQQ '
NotBurstCompatibleAttributeQQ ,
:QQ- .
	AttributeQQ/ 8
{RR 
}SS 
}TT ‰Õ
aC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeList.cs
	namespace 	
Unity
 
. 
Collections 
{ 
public 

	interface 

IIndexable 
<  
T  !
>! "
where# (
T) *
:+ ,
struct- 3
{ 
int 
Length 
{ 
get 
; 
set 
; 
}  
ref 
T 
	ElementAt 
( 
int 
index !
)! "
;" #
} 
public%% 

	interface%% 
INativeList%%  
<%%  !
T%%! "
>%%" #
:%%$ %

IIndexable%%& 0
<%%0 1
T%%1 2
>%%2 3
where%%4 9
T%%: ;
:%%< =
struct%%> D
{&& 
int,, 
Capacity,, 
{,, 
get,, 
;,, 
set,, 
;,,  
},,! "
bool22 
IsEmpty22 
{22 
get22 
;22 
}22 
T:: 	
this::
 
[:: 
int:: 
index:: 
]:: 
{:: 
get:: 
;::  
set::! $
;::$ %
}::& '
void@@ 
Clear@@ 
(@@ 
)@@ 
;@@ 
}AA 
[HH 
StructLayoutHH 
(HH 

LayoutKindHH 
.HH 

SequentialHH '
)HH' (
]HH( )
[II 
NativeContainerII 
]II 
[JJ 
DebuggerDisplayJJ 
(JJ 
$strJJ (
)JJ( )
]JJ) *
[KK 
DebuggerTypeProxyKK 
(KK 
typeofKK 
(KK 
NativeListDebugViewKK 1
<KK1 2
>KK2 3
)KK3 4
)KK4 5
]KK5 6
[LL 
BurstCompatibleLL 
(LL  
GenericTypeArgumentsLL )
=LL* +
newLL, /
[LL0 1
]LL1 2
{LL3 4
typeofLL5 ;
(LL; <
intLL< ?
)LL? @
}LLA B
)LLB C
]LLC D
publicMM 

unsafeMM 
structMM 

NativeListMM #
<MM# $
TMM$ %
>MM% &
:NN 	
INativeDisposableNN
 
,OO 	
INativeListOO
 
<OO 
TOO 
>OO 
,PP 	
IEnumerablePP
 
<PP 
TPP 
>PP 
whereQQ 
TQQ 
:QQ 
	unmanagedQQ 
{RR 
internalTT 
AtomicSafetyHandleTT #
m_SafetyTT$ ,
;TT, -
internalUU 
intUU 
m_SafetyIndexHintUU &
;UU& '
internalVV 
staticVV 
readonlyVV  
SharedStaticVV! -
<VV- .
intVV. 1
>VV1 2
s_staticSafetyIdVV3 C
=VVD E
SharedStaticVVF R
<VVR S
intVVS V
>VVV W
.VVW X
GetOrCreateVVX c
<VVc d

NativeListVVd n
<VVn o
TVVo p
>VVp q
>VVq r
(VVr s
)VVs t
;VVt u
[ZZ 	.
"NativeSetClassTypeToNullOnScheduleZZ	 +
]ZZ+ ,
internal[[ 
DisposeSentinel[[  
m_DisposeSentinel[[! 2
;[[2 3
[^^ 	-
!NativeDisableUnsafePtrRestriction^^	 *
]^^* +
internal__ 

UnsafeList__ 
<__ 
T__ 
>__ 
*__ 

m_ListData__  *
;__* +
internalcc 
AllocatorManagercc !
.cc! "
AllocatorHandlecc" 1!
m_DeprecatedAllocatorcc2 G
;ccG H
publicii 

NativeListii 
(ii 
AllocatorManagerii *
.ii* +
AllocatorHandleii+ :
	allocatorii; D
)iiD E
:jj 
thisjj 
(jj 
$numjj 
,jj 
	allocatorjj 
,jj  
$numjj! "
)jj" #
{kk 	
}ll 	
publicss 

NativeListss 
(ss 
intss 
initialCapacityss -
,ss- .
AllocatorManagerss/ ?
.ss? @
AllocatorHandless@ O
	allocatorssP Y
)ssY Z
:tt 
thistt 
(tt 
initialCapacitytt "
,tt" #
	allocatortt$ -
,tt- .
$numtt/ 0
)tt0 1
{uu 	
}vv 	
[xx 	
BurstCompatiblexx	 
(xx  
GenericTypeArgumentsxx -
=xx. /
newxx0 3
[xx4 5
]xx5 6
{xx7 8
typeofxx9 ?
(xx? @
AllocatorManagerxx@ P
.xxP Q
AllocatorHandlexxQ `
)xx` a
}xxb c
)xxc d
]xxd e
internalyy 
voidyy 

Initializeyy  
<yy  !
Uyy! "
>yy" #
(yy# $
intyy$ '
initialCapacityyy( 7
,yy7 8
refyy9 <
Uyy= >
	allocatoryy? H
,yyH I
intyyJ M%
disposeSentinelStackDepthyyN g
)yyg h
whereyyi n
Uyyo p
:yyq r
	unmanagedyys |
,yy| }
AllocatorManager	yy~ é
.
yyé è

IAllocator
yyè ô
{zz 	
var{{ 
	totalSize{{ 
={{ 
sizeof{{ "
({{" #
T{{# $
){{$ %
*{{& '
({{( )
long{{) -
){{- .
initialCapacity{{. =
;{{= >
CollectionHelper}} 
.}} 
CheckAllocator}} +
(}}+ ,
	allocator}}, 5
.}}5 6
Handle}}6 <
)}}< =
;}}= > 
CheckInitialCapacity~~  
(~~  !
initialCapacity~~! 0
)~~0 1
;~~1 2
CollectionHelper 
. 
CheckIsUnmanaged -
<- .
T. /
>/ 0
(0 1
)1 2
;2 3
CheckTotalSize
ÄÄ 
(
ÄÄ 
initialCapacity
ÄÄ *
,
ÄÄ* +
	totalSize
ÄÄ, 5
)
ÄÄ5 6
;
ÄÄ6 7
if
ÖÖ 
(
ÖÖ 
	allocator
ÖÖ 
.
ÖÖ 
IsCustomAllocator
ÖÖ +
)
ÖÖ+ ,
{
ÜÜ 
m_Safety
áá 
=
áá  
AtomicSafetyHandle
áá -
.
áá- .
Create
áá. 4
(
áá4 5
)
áá5 6
;
áá6 7
m_DisposeSentinel
àà !
=
àà" #
null
àà$ (
;
àà( )
}
ââ 
else
ää 
{
ãã 
DisposeSentinel
åå 
.
åå  
Create
åå  &
(
åå& '
out
åå' *
m_Safety
åå+ 3
,
åå3 4
out
åå5 8
m_DisposeSentinel
åå9 J
,
ååJ K'
disposeSentinelStackDepth
ååL e
,
ååe f
	allocator
ååg p
.
ååp q
ToAllocator
ååq |
)
åå| }
;
åå} ~
}
çç 
CollectionHelper
êê 
.
êê 
SetStaticSafetyId
êê .
<
êê. /

NativeList
êê/ 9
<
êê9 :
T
êê: ;
>
êê; <
>
êê< =
(
êê= >
ref
êê> A
m_Safety
êêB J
,
êêJ K
ref
êêL O
s_staticSafetyId
êêP `
.
êê` a
Data
êêa e
)
êêe f
;
êêf g
m_SafetyIndexHint
íí 
=
íí 
(
íí  !
	allocator
íí! *
.
íí* +
Handle
íí+ 1
)
íí1 2
.
íí2 3
AddSafetyHandle
íí3 B
(
ííB C
m_Safety
ííC K
)
ííK L
;
ííL M

m_ListData
îî 
=
îî 

UnsafeList
îî #
<
îî# $
T
îî$ %
>
îî% &
.
îî& '
Create
îî' -
(
îî- .
initialCapacity
îî. =
,
îî= >
ref
îî? B
	allocator
îîC L
)
îîL M
;
îîM N#
m_DeprecatedAllocator
ïï !
=
ïï" #
	allocator
ïï$ -
.
ïï- .
Handle
ïï. 4
;
ïï4 5 
AtomicSafetyHandle
òò 
.
òò 4
&SetBumpSecondaryVersionOnScheduleWrite
òò E
(
òòE F
m_Safety
òòF N
,
òòN O
true
òòP T
)
òòT U
;
òòU V
}
öö 	
[
úú 	
BurstCompatible
úú	 
(
úú "
GenericTypeArguments
úú -
=
úú. /
new
úú0 3
[
úú4 5
]
úú5 6
{
úú7 8
typeof
úú9 ?
(
úú? @
AllocatorManager
úú@ P
.
úúP Q
AllocatorHandle
úúQ `
)
úú` a
}
úúb c
)
úúc d
]
úúd e
internal
ùù 
static
ùù 

NativeList
ùù "
<
ùù" #
T
ùù# $
>
ùù$ %
New
ùù& )
<
ùù) *
U
ùù* +
>
ùù+ ,
(
ùù, -
int
ùù- 0
initialCapacity
ùù1 @
,
ùù@ A
ref
ùùB E
U
ùùF G
	allocator
ùùH Q
,
ùùQ R
int
ùùS V'
disposeSentinelStackDepth
ùùW p
)
ùùp q
where
ùùr w
U
ùùx y
:
ùùz {
	unmanagedùù| Ö
,ùùÖ Ü 
AllocatorManagerùùá ó
.ùùó ò

IAllocatorùùò ¢
{
ûû 	
var
üü 

nativelist
üü 
=
üü 
new
üü  

NativeList
üü! +
<
üü+ ,
T
üü, -
>
üü- .
(
üü. /
)
üü/ 0
;
üü0 1

nativelist
†† 
.
†† 

Initialize
†† !
(
††! "
initialCapacity
††" 1
,
††1 2
ref
††3 6
	allocator
††7 @
,
††@ A'
disposeSentinelStackDepth
††B [
)
††[ \
;
††\ ]
return
°° 

nativelist
°° 
;
°° 
}
¢¢ 	
[
§§ 	
BurstCompatible
§§	 
(
§§ "
GenericTypeArguments
§§ -
=
§§. /
new
§§0 3
[
§§4 5
]
§§5 6
{
§§7 8
typeof
§§9 ?
(
§§? @
AllocatorManager
§§@ P
.
§§P Q
AllocatorHandle
§§Q `
)
§§` a
}
§§b c
)
§§c d
]
§§d e
internal
•• 
static
•• 

NativeList
•• "
<
••" #
T
••# $
>
••$ %
New
••& )
<
••) *
U
••* +
>
••+ ,
(
••, -
int
••- 0
initialCapacity
••1 @
,
••@ A
ref
••B E
U
••F G
	allocator
••H Q
)
••Q R
where
••S X
U
••Y Z
:
••[ \
	unmanaged
••] f
,
••f g
AllocatorManager
••h x
.
••x y

IAllocator••y É
{
¶¶ 	
return
ßß 
New
ßß 
(
ßß 
initialCapacity
ßß &
,
ßß& '
ref
ßß( +
	allocator
ßß, 5
,
ßß5 6
$num
ßß7 8
)
ßß8 9
;
ßß9 :
}
®® 	

NativeList
™™ 
(
™™ 
int
™™ 
initialCapacity
™™ &
,
™™& '
AllocatorManager
™™( 8
.
™™8 9
AllocatorHandle
™™9 H
	allocator
™™I R
,
™™R S
int
™™T W'
disposeSentinelStackDepth
™™X q
)
™™q r
{
´´ 	
this
¨¨ 
=
¨¨ 
default
¨¨ 
;
¨¨ 
AllocatorManager
≠≠ 
.
≠≠ 
AllocatorHandle
≠≠ ,
temp
≠≠- 1
=
≠≠2 3
	allocator
≠≠4 =
;
≠≠= >

Initialize
ÆÆ 
(
ÆÆ 
initialCapacity
ÆÆ &
,
ÆÆ& '
ref
ÆÆ( +
temp
ÆÆ, 0
,
ÆÆ0 1'
disposeSentinelStackDepth
ÆÆ2 K
)
ÆÆK L
;
ÆÆL M
}
ØØ 	
public
∑∑ 
T
∑∑ 
this
∑∑ 
[
∑∑ 
int
∑∑ 
index
∑∑ 
]
∑∑  
{
∏∏ 	
get
ππ 
{
∫∫  
AtomicSafetyHandle
ºº "
.
ºº" #
CheckReadAndThrow
ºº# 4
(
ºº4 5
m_Safety
ºº5 =
)
ºº= >
;
ºº> ?
return
ææ 
(
ææ 
*
ææ 

m_ListData
ææ #
)
ææ# $
[
ææ$ %
index
ææ% *
]
ææ* +
;
ææ+ ,
}
øø 
set
¿¿ 
{
¡¡  
AtomicSafetyHandle
√√ "
.
√√" # 
CheckWriteAndThrow
√√# 5
(
√√5 6
m_Safety
√√6 >
)
√√> ?
;
√√? @
(
≈≈ 
*
≈≈ 

m_ListData
≈≈ 
)
≈≈ 
[
≈≈ 
index
≈≈ #
]
≈≈# $
=
≈≈% &
value
≈≈' ,
;
≈≈, -
}
∆∆ 
}
«« 	
public
œœ 
ref
œœ 
T
œœ 
	ElementAt
œœ 
(
œœ 
int
œœ "
index
œœ# (
)
œœ( )
{
–– 	 
AtomicSafetyHandle
““ 
.
““  
CheckWriteAndThrow
““ 1
(
““1 2
m_Safety
““2 :
)
““: ;
;
““; <
return
‘‘ 
ref
‘‘ 

m_ListData
‘‘ !
->
‘‘! #
	ElementAt
‘‘# ,
(
‘‘, -
index
‘‘- 2
)
‘‘2 3
;
‘‘3 4
}
’’ 	
public
ﬁﬁ 
int
ﬁﬁ 
Length
ﬁﬁ 
{
ﬂﬂ 	
get
‡‡ 
{
··  
AtomicSafetyHandle
„„ "
.
„„" #
CheckReadAndThrow
„„# 4
(
„„4 5
m_Safety
„„5 =
)
„„= >
;
„„> ?
return
ÂÂ 
CollectionHelper
ÂÂ '
.
ÂÂ' (
AssumePositive
ÂÂ( 6
(
ÂÂ6 7

m_ListData
ÂÂ7 A
->
ÂÂA C
Length
ÂÂC I
)
ÂÂI J
;
ÂÂJ K
}
ÊÊ 
set
ËË 
{
ÈÈ 

m_ListData
ÍÍ 
->
ÍÍ 
Resize
ÍÍ "
(
ÍÍ" #
value
ÍÍ# (
,
ÍÍ( ) 
NativeArrayOptions
ÍÍ* <
.
ÍÍ< =
ClearMemory
ÍÍ= H
)
ÍÍH I
;
ÍÍI J
}
ÎÎ 
}
ÏÏ 	
public
ÙÙ 
int
ÙÙ 
Capacity
ÙÙ 
{
ıı 	
get
ˆˆ 
{
˜˜  
AtomicSafetyHandle
˘˘ "
.
˘˘" #
CheckReadAndThrow
˘˘# 4
(
˘˘4 5
m_Safety
˘˘5 =
)
˘˘= >
;
˘˘> ?
return
˚˚ 

m_ListData
˚˚ !
->
˚˚! #
Capacity
˚˚# +
;
˚˚+ ,
}
¸¸ 
set
˛˛ 
{
ˇˇ  
AtomicSafetyHandle
ÅÅ "
.
ÅÅ" #/
!CheckWriteAndBumpSecondaryVersion
ÅÅ# D
(
ÅÅD E
m_Safety
ÅÅE M
)
ÅÅM N
;
ÅÅN O

m_ListData
ÉÉ 
->
ÉÉ 
Capacity
ÉÉ $
=
ÉÉ% &
value
ÉÉ' ,
;
ÉÉ, -
}
ÑÑ 
}
ÖÖ 	
public
åå 

UnsafeList
åå 
<
åå 
T
åå 
>
åå 
*
åå 
GetUnsafeList
åå +
(
åå+ ,
)
åå, -
=>
åå. 0

m_ListData
åå1 ;
;
åå; <
public
ññ 
void
ññ 
AddNoResize
ññ 
(
ññ  
T
ññ  !
value
ññ" '
)
ññ' (
{
óó 	 
AtomicSafetyHandle
ôô 
.
ôô  
CheckWriteAndThrow
ôô 1
(
ôô1 2
m_Safety
ôô2 :
)
ôô: ;
;
ôô; <

m_ListData
õõ 
->
õõ 
AddNoResize
õõ #
(
õõ# $
value
õõ$ )
)
õõ) *
;
õõ* +
}
úú 	
public
ßß 
void
ßß 
AddRangeNoResize
ßß $
(
ßß$ %
void
ßß% )
*
ßß) *
ptr
ßß+ .
,
ßß. /
int
ßß0 3
count
ßß4 9
)
ßß9 :
{
®® 	 
AtomicSafetyHandle
™™ 
.
™™  
CheckWriteAndThrow
™™ 1
(
™™1 2
m_Safety
™™2 :
)
™™: ;
;
™™; <
CheckArgPositive
¨¨ 
(
¨¨ 
count
¨¨ "
)
¨¨" #
;
¨¨# $

m_ListData
≠≠ 
->
≠≠ 
AddRangeNoResize
≠≠ (
(
≠≠( )
ptr
≠≠) ,
,
≠≠, -
count
≠≠. 3
)
≠≠3 4
;
≠≠4 5
}
ÆÆ 	
public
∏∏ 
void
∏∏ 
AddRangeNoResize
∏∏ $
(
∏∏$ %

NativeList
∏∏% /
<
∏∏/ 0
T
∏∏0 1
>
∏∏1 2
list
∏∏3 7
)
∏∏7 8
{
ππ 	 
AtomicSafetyHandle
ªª 
.
ªª  
CheckWriteAndThrow
ªª 1
(
ªª1 2
m_Safety
ªª2 :
)
ªª: ;
;
ªª; <

m_ListData
ΩΩ 
->
ΩΩ 
AddRangeNoResize
ΩΩ (
(
ΩΩ( )
*
ΩΩ) *
list
ΩΩ* .
.
ΩΩ. /

m_ListData
ΩΩ/ 9
)
ΩΩ9 :
;
ΩΩ: ;
}
ææ 	
public
«« 
void
«« 
Add
«« 
(
«« 
in
«« 
T
«« 
value
«« "
)
««" #
{
»» 	 
AtomicSafetyHandle
   
.
   /
!CheckWriteAndBumpSecondaryVersion
   @
(
  @ A
m_Safety
  A I
)
  I J
;
  J K

m_ListData
ÃÃ 
->
ÃÃ 
Add
ÃÃ 
(
ÃÃ 
value
ÃÃ !
)
ÃÃ! "
;
ÃÃ" #
}
ÕÕ 	
public
◊◊ 
void
◊◊ 
AddRange
◊◊ 
(
◊◊ 
NativeArray
◊◊ (
<
◊◊( )
T
◊◊) *
>
◊◊* +
array
◊◊, 1
)
◊◊1 2
{
ÿÿ 	
AddRange
ŸŸ 
(
ŸŸ 
array
ŸŸ 
.
ŸŸ "
GetUnsafeReadOnlyPtr
ŸŸ /
(
ŸŸ/ 0
)
ŸŸ0 1
,
ŸŸ1 2
array
ŸŸ3 8
.
ŸŸ8 9
Length
ŸŸ9 ?
)
ŸŸ? @
;
ŸŸ@ A
}
⁄⁄ 	
public
‚‚ 
void
‚‚ 
AddRange
‚‚ 
(
‚‚ 
void
‚‚ !
*
‚‚! "
ptr
‚‚# &
,
‚‚& '
int
‚‚( +
count
‚‚, 1
)
‚‚1 2
{
„„ 	 
AtomicSafetyHandle
ÂÂ 
.
ÂÂ /
!CheckWriteAndBumpSecondaryVersion
ÂÂ @
(
ÂÂ@ A
m_Safety
ÂÂA I
)
ÂÂI J
;
ÂÂJ K
CheckArgPositive
ÁÁ 
(
ÁÁ 
count
ÁÁ "
)
ÁÁ" #
;
ÁÁ# $

m_ListData
ËË 
->
ËË 
AddRange
ËË  
(
ËË  !
ptr
ËË! $
,
ËË$ %
CollectionHelper
ËË& 6
.
ËË6 7
AssumePositive
ËË7 E
(
ËËE F
count
ËËF K
)
ËËK L
)
ËËL M
;
ËËM N
}
ÈÈ 	
public
˝˝ 
void
˝˝ %
InsertRangeWithBeginEnd
˝˝ +
(
˝˝+ ,
int
˝˝, /
begin
˝˝0 5
,
˝˝5 6
int
˝˝7 :
end
˝˝; >
)
˝˝> ?
{
˛˛ 	 
AtomicSafetyHandle
ÄÄ 
.
ÄÄ /
!CheckWriteAndBumpSecondaryVersion
ÄÄ @
(
ÄÄ@ A
m_Safety
ÄÄA I
)
ÄÄI J
;
ÄÄJ K

m_ListData
ÇÇ 
->
ÇÇ %
InsertRangeWithBeginEnd
ÇÇ /
(
ÇÇ/ 0
CollectionHelper
ÇÇ0 @
.
ÇÇ@ A
AssumePositive
ÇÇA O
(
ÇÇO P
begin
ÇÇP U
)
ÇÇU V
,
ÇÇV W
CollectionHelper
ÇÇX h
.
ÇÇh i
AssumePositive
ÇÇi w
(
ÇÇw x
end
ÇÇx {
)
ÇÇ{ |
)
ÇÇ| }
;
ÇÇ} ~
}
ÉÉ 	
public
ãã 
void
ãã 
RemoveAtSwapBack
ãã $
(
ãã$ %
int
ãã% (
index
ãã) .
)
ãã. /
{
åå 	 
AtomicSafetyHandle
éé 
.
éé /
!CheckWriteAndBumpSecondaryVersion
éé @
(
éé@ A
m_Safety
ééA I
)
ééI J
;
ééJ K

m_ListData
êê 
->
êê 
RemoveAtSwapBack
êê (
(
êê( )
CollectionHelper
êê) 9
.
êê9 :
AssumePositive
êê: H
(
êêH I
index
êêI N
)
êêN O
)
êêO P
;
êêP Q
}
ëë 	
public
üü 
void
üü !
RemoveRangeSwapBack
üü '
(
üü' (
int
üü( +
index
üü, 1
,
üü1 2
int
üü3 6
count
üü7 <
)
üü< =
{
†† 	 
AtomicSafetyHandle
¢¢ 
.
¢¢ /
!CheckWriteAndBumpSecondaryVersion
¢¢ @
(
¢¢@ A
m_Safety
¢¢A I
)
¢¢I J
;
¢¢J K

m_ListData
§§ 
->
§§ !
RemoveRangeSwapBack
§§ +
(
§§+ ,
CollectionHelper
§§, <
.
§§< =
AssumePositive
§§= K
(
§§K L
index
§§L Q
)
§§Q R
,
§§R S
CollectionHelper
§§T d
.
§§d e
AssumePositive
§§e s
(
§§s t
count
§§t y
)
§§y z
)
§§z {
;
§§{ |
}
•• 	
[
¥¥ 	
Obsolete
¥¥	 
(
¥¥ 
$str¥¥ ó
,¥¥ó ò
false¥¥ô û
)¥¥û ü
]¥¥ü †
public
µµ 
void
µµ -
RemoveRangeSwapBackWithBeginEnd
µµ 3
(
µµ3 4
int
µµ4 7
begin
µµ8 =
,
µµ= >
int
µµ? B
end
µµC F
)
µµF G
{
∂∂ 	 
AtomicSafetyHandle
∏∏ 
.
∏∏ /
!CheckWriteAndBumpSecondaryVersion
∏∏ @
(
∏∏@ A
m_Safety
∏∏A I
)
∏∏I J
;
∏∏J K

m_ListData
∫∫ 
->
∫∫ -
RemoveRangeSwapBackWithBeginEnd
∫∫ 7
(
∫∫7 8
CollectionHelper
∫∫8 H
.
∫∫H I
AssumePositive
∫∫I W
(
∫∫W X
begin
∫∫X ]
)
∫∫] ^
,
∫∫^ _
CollectionHelper
∫∫` p
.
∫∫p q
AssumePositive
∫∫q 
(∫∫ Ä
end∫∫Ä É
)∫∫É Ñ
)∫∫Ñ Ö
;∫∫Ö Ü
}
ªª 	
public
≈≈ 
void
≈≈ 
RemoveAt
≈≈ 
(
≈≈ 
int
≈≈  
index
≈≈! &
)
≈≈& '
{
∆∆ 	 
AtomicSafetyHandle
»» 
.
»» /
!CheckWriteAndBumpSecondaryVersion
»» @
(
»»@ A
m_Safety
»»A I
)
»»I J
;
»»J K

m_ListData
   
->
   
RemoveAt
    
(
    !
CollectionHelper
  ! 1
.
  1 2
AssumePositive
  2 @
(
  @ A
index
  A F
)
  F G
)
  G H
;
  H I
}
ÀÀ 	
public
ÿÿ 
void
ÿÿ 
RemoveRange
ÿÿ 
(
ÿÿ  
int
ÿÿ  #
index
ÿÿ$ )
,
ÿÿ) *
int
ÿÿ+ .
count
ÿÿ/ 4
)
ÿÿ4 5
{
ŸŸ 	 
AtomicSafetyHandle
€€ 
.
€€ /
!CheckWriteAndBumpSecondaryVersion
€€ @
(
€€@ A
m_Safety
€€A I
)
€€I J
;
€€J K

m_ListData
›› 
->
›› 
RemoveRange
›› #
(
››# $
index
››$ )
,
››) *
count
››+ 0
)
››0 1
;
››1 2
}
ﬁﬁ 	
[
ÍÍ 	
Obsolete
ÍÍ	 
(
ÍÍ 
$strÍÍ á
,ÍÍá à
falseÍÍâ é
)ÍÍé è
]ÍÍè ê
public
ÎÎ 
void
ÎÎ %
RemoveRangeWithBeginEnd
ÎÎ +
(
ÎÎ+ ,
int
ÎÎ, /
begin
ÎÎ0 5
,
ÎÎ5 6
int
ÎÎ7 :
end
ÎÎ; >
)
ÎÎ> ?
{
ÏÏ 	 
AtomicSafetyHandle
ÓÓ 
.
ÓÓ /
!CheckWriteAndBumpSecondaryVersion
ÓÓ @
(
ÓÓ@ A
m_Safety
ÓÓA I
)
ÓÓI J
;
ÓÓJ K

m_ListData
 
->
 %
RemoveRangeWithBeginEnd
 /
(
/ 0
begin
0 5
,
5 6
end
7 :
)
: ;
;
; <
}
ÒÒ 	
public
˜˜ 
bool
˜˜ 
IsEmpty
˜˜ 
=>
˜˜ 
!
˜˜  
	IsCreated
˜˜  )
||
˜˜* ,
Length
˜˜- 3
==
˜˜4 6
$num
˜˜7 8
;
˜˜8 9
public
˝˝ 
bool
˝˝ 
	IsCreated
˝˝ 
=>
˝˝  

m_ListData
˝˝! +
!=
˝˝, .
null
˝˝/ 3
;
˝˝3 4
public
ÇÇ 
void
ÇÇ 
Dispose
ÇÇ 
(
ÇÇ 
)
ÇÇ 
{
ÉÉ 	#
m_DeprecatedAllocator
ÖÖ !
.
ÖÖ! "#
TryRemoveSafetyHandle
ÖÖ" 7
(
ÖÖ7 8
m_Safety
ÖÖ8 @
,
ÖÖ@ A
m_SafetyIndexHint
ÖÖB S
)
ÖÖS T
;
ÖÖT U
DisposeSentinel
ââ 
.
ââ 
Dispose
ââ #
(
ââ# $
ref
ââ$ '
m_Safety
ââ( 0
,
ââ0 1
ref
ââ2 5
m_DisposeSentinel
ââ6 G
)
ââG H
;
ââH I

UnsafeList
åå 
<
åå 
T
åå 
>
åå 
.
åå 
Destroy
åå !
(
åå! "

m_ListData
åå" ,
)
åå, -
;
åå- .

m_ListData
çç 
=
çç 
null
çç 
;
çç 
}
éé 	
[
ïï 	
BurstCompatible
ïï	 
(
ïï "
GenericTypeArguments
ïï -
=
ïï. /
new
ïï0 3
[
ïï3 4
]
ïï4 5
{
ïï6 7
typeof
ïï8 >
(
ïï> ?
AllocatorManager
ïï? O
.
ïïO P
AllocatorHandle
ïïP _
)
ïï_ `
}
ïïa b
)
ïïb c
]
ïïc d
internal
ññ 
void
ññ 
Dispose
ññ 
<
ññ 
U
ññ 
>
ññ  
(
ññ  !
ref
ññ! $
U
ññ% &
	allocator
ññ' 0
)
ññ0 1
where
ññ2 7
U
ññ8 9
:
ññ: ;
	unmanaged
ññ< E
,
ññE F
AllocatorManager
ññG W
.
ññW X

IAllocator
ññX b
{
óó 	 
CheckHandleMatches
ôô 
(
ôô 
	allocator
ôô (
.
ôô( )
Handle
ôô) /
)
ôô/ 0
;
ôô0 1#
m_DeprecatedAllocator
öö !
.
öö! "#
TryRemoveSafetyHandle
öö" 7
(
öö7 8
m_Safety
öö8 @
,
öö@ A
m_SafetyIndexHint
ööB S
)
ööS T
;
ööT U
DisposeSentinel
ûû 
.
ûû 
Dispose
ûû #
(
ûû# $
ref
ûû$ '
m_Safety
ûû( 0
,
ûû0 1
ref
ûû2 5
m_DisposeSentinel
ûû6 G
)
ûûG H
;
ûûH I

UnsafeList
°° 
<
°° 
T
°° 
>
°° 
.
°° 
Destroy
°° !
(
°°! "

m_ListData
°°" ,
,
°°, -
ref
°°. 1
	allocator
°°2 ;
)
°°; <
;
°°< =

m_ListData
¢¢ 
=
¢¢ 
null
¢¢ 
;
¢¢ 
}
££ 	
[
™™ 	 
NotBurstCompatible
™™	 
]™™ú ù
public
´´ 
	JobHandle
´´ 
Dispose
´´  
(
´´  !
	JobHandle
´´! *
	inputDeps
´´+ 4
)
´´4 5
{
¨¨ 	
DisposeSentinel
¥¥ 
.
¥¥ 
Clear
¥¥ !
(
¥¥! "
ref
¥¥" %
m_DisposeSentinel
¥¥& 7
)
¥¥7 8
;
¥¥8 9
var
∑∑ 
	jobHandle
∑∑ 
=
∑∑ 
new
∑∑ "
NativeListDisposeJob
∑∑  4
{
∑∑5 6
Data
∑∑7 ;
=
∑∑< =
new
∑∑> A
NativeListDispose
∑∑B S
{
∑∑T U

m_ListData
∑∑V `
=
∑∑a b
(
∑∑c d
UntypedUnsafeList
∑∑d u
*
∑∑u v
)
∑∑v w

m_ListData∑∑w Å
,∑∑Å Ç
m_Safety∑∑É ã
=∑∑å ç
m_Safety∑∑é ñ
}∑∑ó ò
}∑∑ô ö
.∑∑ö õ
Schedule∑∑õ £
(∑∑£ §
	inputDeps∑∑§ ≠
)∑∑≠ Æ
;∑∑Æ Ø 
AtomicSafetyHandle
ππ 
.
ππ 
Release
ππ &
(
ππ& '
m_Safety
ππ' /
)
ππ/ 0
;
ππ0 1

m_ListData
ΩΩ 
=
ΩΩ 
null
ΩΩ 
;
ΩΩ 
return
øø 
	jobHandle
øø 
;
øø 
}
¿¿ 	
public
∆∆ 
void
∆∆ 
Clear
∆∆ 
(
∆∆ 
)
∆∆ 
{
«« 	 
AtomicSafetyHandle
…… 
.
…… /
!CheckWriteAndBumpSecondaryVersion
…… @
(
……@ A
m_Safety
……A I
)
……I J
;
……J K

m_ListData
ÀÀ 
->
ÀÀ 
Clear
ÀÀ 
(
ÀÀ 
)
ÀÀ 
;
ÀÀ  
}
ÃÃ 	
public
”” 
static
”” 
implicit
”” 
operator
”” '
NativeArray
””( 3
<
””3 4
T
””4 5
>
””5 6
(
””6 7

NativeList
””7 A
<
””A B
T
””B C
>
””C D

nativeList
””E O
)
””O P
{
‘‘ 	
return
’’ 

nativeList
’’ 
.
’’ 
AsArray
’’ %
(
’’% &
)
’’& '
;
’’' (
}
÷÷ 	
public
‹‹ 
NativeArray
‹‹ 
<
‹‹ 
T
‹‹ 
>
‹‹ 
AsArray
‹‹ %
(
‹‹% &
)
‹‹& '
{
›› 	 
AtomicSafetyHandle
ﬂﬂ 
.
ﬂﬂ 2
$CheckGetSecondaryDataPointerAndThrow
ﬂﬂ C
(
ﬂﬂC D
m_Safety
ﬂﬂD L
)
ﬂﬂL M
;
ﬂﬂM N
var
‡‡ 
arraySafety
‡‡ 
=
‡‡ 
m_Safety
‡‡ &
;
‡‡& ' 
AtomicSafetyHandle
·· 
.
·· !
UseSecondaryVersion
·· 2
(
··2 3
ref
··3 6
arraySafety
··7 B
)
··B C
;
··C D
var
„„ 
array
„„ 
=
„„ &
NativeArrayUnsafeUtility
„„ 0
.
„„0 1.
 ConvertExistingDataToNativeArray
„„1 Q
<
„„Q R
T
„„R S
>
„„S T
(
„„T U

m_ListData
„„U _
->
„„_ a
Ptr
„„a d
,
„„d e

m_ListData
„„f p
->
„„p r
Length
„„r x
,
„„x y
	Allocator„„z É
.„„É Ñ
None„„Ñ à
)„„à â
;„„â ä&
NativeArrayUnsafeUtility
ÊÊ $
.
ÊÊ$ %#
SetAtomicSafetyHandle
ÊÊ% :
(
ÊÊ: ;
ref
ÊÊ; >
array
ÊÊ? D
,
ÊÊD E
arraySafety
ÊÊF Q
)
ÊÊQ R
;
ÊÊR S
return
ËË 
array
ËË 
;
ËË 
}
ÈÈ 	
public
∫∫ 
NativeArray
∫∫ 
<
∫∫ 
T
∫∫ 
>
∫∫  
AsDeferredJobArray
∫∫ 0
(
∫∫0 1
)
∫∫1 2
{
ªª 	 
AtomicSafetyHandle
ΩΩ 
.
ΩΩ !
CheckExistsAndThrow
ΩΩ 2
(
ΩΩ2 3
m_Safety
ΩΩ3 ;
)
ΩΩ; <
;
ΩΩ< =
byte
øø 
*
øø 
buffer
øø 
=
øø 
(
øø 
byte
øø  
*
øø  !
)
øø! "

m_ListData
øø" ,
;
øø, -
buffer
¬¬ 
+=
¬¬ 
$num
¬¬ 
;
¬¬ 
var
√√ 
array
√√ 
=
√√ &
NativeArrayUnsafeUtility
√√ 0
.
√√0 1.
 ConvertExistingDataToNativeArray
√√1 Q
<
√√Q R
T
√√R S
>
√√S T
(
√√T U
buffer
√√U [
,
√√[ \
$num
√√] ^
,
√√^ _
	Allocator
√√` i
.
√√i j
Invalid
√√j q
)
√√q r
;
√√r s&
NativeArrayUnsafeUtility
∆∆ $
.
∆∆$ %#
SetAtomicSafetyHandle
∆∆% :
(
∆∆: ;
ref
∆∆; >
array
∆∆? D
,
∆∆D E
m_Safety
∆∆F N
)
∆∆N O
;
∆∆O P
return
…… 
array
…… 
;
…… 
}
   	
[
–– 	 
NotBurstCompatible
––	 
]
––, -
public
”” 
T
”” 
[
”” 
]
”” 
ToArray
”” 
(
”” 
)
”” 
=>
””  
NotBurstCompatible
””  2
.
””2 3

Extensions
””3 =
.
””= >

ToArrayNBC
””> H
(
””H I
this
””I M
)
””M N
;
””N O
public
⁄⁄ 
NativeArray
⁄⁄ 
<
⁄⁄ 
T
⁄⁄ 
>
⁄⁄ 
ToArray
⁄⁄ %
(
⁄⁄% &
AllocatorManager
⁄⁄& 6
.
⁄⁄6 7
AllocatorHandle
⁄⁄7 F
	allocator
⁄⁄G P
)
⁄⁄P Q
{
€€ 	
NativeArray
‹‹ 
<
‹‹ 
T
‹‹ 
>
‹‹ 
result
‹‹ !
=
‹‹" #
CollectionHelper
‹‹$ 4
.
‹‹4 5
CreateNativeArray
‹‹5 F
<
‹‹F G
T
‹‹G H
>
‹‹H I
(
‹‹I J
Length
‹‹J P
,
‹‹P Q
	allocator
‹‹R [
,
‹‹[ \ 
NativeArrayOptions
‹‹] o
.
‹‹o p"
UninitializedMemory‹‹p É
)‹‹É Ñ
;‹‹Ñ Ö
result
›› 
.
›› 
CopyFrom
›› 
(
›› 
this
››  
)
››  !
;
››! "
return
ﬁﬁ 
result
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 	
public
ÂÂ 
NativeArray
ÂÂ 
<
ÂÂ 
T
ÂÂ 
>
ÂÂ 
.
ÂÂ 

Enumerator
ÂÂ (
GetEnumerator
ÂÂ) 6
(
ÂÂ6 7
)
ÂÂ7 8
{
ÊÊ 	
var
ÁÁ 
array
ÁÁ 
=
ÁÁ 
AsArray
ÁÁ 
(
ÁÁ  
)
ÁÁ  !
;
ÁÁ! "
return
ËË 
new
ËË 
NativeArray
ËË "
<
ËË" #
T
ËË# $
>
ËË$ %
.
ËË% &

Enumerator
ËË& 0
(
ËË0 1
ref
ËË1 4
array
ËË5 :
)
ËË: ;
;
ËË; <
}
ÈÈ 	
IEnumerator
 
IEnumerable
 
.
  
GetEnumerator
  -
(
- .
)
. /
{
ÒÒ 	
throw
ÚÚ 
new
ÚÚ %
NotImplementedException
ÚÚ -
(
ÚÚ- .
)
ÚÚ. /
;
ÚÚ/ 0
}
ÛÛ 	
IEnumerator
˙˙ 
<
˙˙ 
T
˙˙ 
>
˙˙ 
IEnumerable
˙˙ "
<
˙˙" #
T
˙˙# $
>
˙˙$ %
.
˙˙% &
GetEnumerator
˙˙& 3
(
˙˙3 4
)
˙˙4 5
{
˚˚ 	
throw
¸¸ 
new
¸¸ %
NotImplementedException
¸¸ -
(
¸¸- .
)
¸¸. /
;
¸¸/ 0
}
˝˝ 	
[
ÑÑ 	 
NotBurstCompatible
ÑÑ	 
]
ÑÑ, -
[
ÖÖ 	
Obsolete
ÖÖ	 
(
ÖÖ 
$strÖÖ Ö
,ÖÖÖ Ü
falseÖÖá å
)ÖÖå ç
]ÖÖç é
public
ÜÜ 
void
ÜÜ 
CopyFrom
ÜÜ 
(
ÜÜ 
T
ÜÜ 
[
ÜÜ 
]
ÜÜ  
array
ÜÜ! &
)
ÜÜ& '
=>
ÜÜ( * 
NotBurstCompatible
ÜÜ+ =
.
ÜÜ= >

Extensions
ÜÜ> H
.
ÜÜH I
CopyFromNBC
ÜÜI T
(
ÜÜT U
this
ÜÜU Y
,
ÜÜY Z
array
ÜÜ[ `
)
ÜÜ` a
;
ÜÜa b
public
çç 
void
çç 
CopyFrom
çç 
(
çç 
NativeArray
çç (
<
çç( )
T
çç) *
>
çç* +
array
çç, 1
)
çç1 2
{
éé 	
Clear
èè 
(
èè 
)
èè 
;
èè 
Resize
êê 
(
êê 
array
êê 
.
êê 
Length
êê 
,
êê   
NativeArrayOptions
êê! 3
.
êê3 4!
UninitializedMemory
êê4 G
)
êêG H
;
êêH I
NativeArray
ëë 
<
ëë 
T
ëë 
>
ëë 
	thisArray
ëë $
=
ëë% &
AsArray
ëë' .
(
ëë. /
)
ëë/ 0
;
ëë0 1
	thisArray
íí 
.
íí 
CopyFrom
íí 
(
íí 
array
íí $
)
íí$ %
;
íí% &
}
ìì 	
public
öö 
void
öö 
Resize
öö 
(
öö 
int
öö 
length
öö %
,
öö% & 
NativeArrayOptions
öö' 9
options
öö: A
)
ööA B
{
õõ 	 
AtomicSafetyHandle
ùù 
.
ùù /
!CheckWriteAndBumpSecondaryVersion
ùù @
(
ùù@ A
m_Safety
ùùA I
)
ùùI J
;
ùùJ K 
AtomicSafetyHandle
ûû 
.
ûû 
CheckReadAndThrow
ûû 0
(
ûû0 1
m_Safety
ûû1 9
)
ûû9 :
;
ûû: ;

m_ListData
†† 
->
†† 
Resize
†† 
(
†† 
length
†† %
,
††% &
options
††' .
)
††. /
;
††/ 0
}
°° 	
public
®® 
void
®® !
ResizeUninitialized
®® '
(
®®' (
int
®®( +
length
®®, 2
)
®®2 3
{
©© 	
Resize
™™ 
(
™™ 
length
™™ 
,
™™  
NativeArrayOptions
™™ -
.
™™- .!
UninitializedMemory
™™. A
)
™™A B
;
™™B C
}
´´ 	
public
±± 
void
±± 
SetCapacity
±± 
(
±±  
int
±±  #
capacity
±±$ ,
)
±±, -
{
≤≤ 	

m_ListData
≥≥ 
->
≥≥ 
SetCapacity
≥≥ #
(
≥≥# $
capacity
≥≥$ ,
)
≥≥, -
;
≥≥- .
}
¥¥ 	
public
ππ 
void
ππ 

TrimExcess
ππ 
(
ππ 
)
ππ  
{
∫∫ 	

m_ListData
ªª 
->
ªª 

TrimExcess
ªª "
(
ªª" #
)
ªª# $
;
ªª$ %
}
ºº 	
public
¬¬ 
NativeArray
¬¬ 
<
¬¬ 
T
¬¬ 
>
¬¬ 
.
¬¬ 
ReadOnly
¬¬ &
AsParallelReader
¬¬' 7
(
¬¬7 8
)
¬¬8 9
{
√√ 	
return
≈≈ 
new
≈≈ 
NativeArray
≈≈ "
<
≈≈" #
T
≈≈# $
>
≈≈$ %
.
≈≈% &
ReadOnly
≈≈& .
(
≈≈. /

m_ListData
≈≈/ 9
->
≈≈9 ;
Ptr
≈≈; >
,
≈≈> ?

m_ListData
≈≈@ J
->
≈≈J L
Length
≈≈L R
,
≈≈R S
ref
≈≈T W
m_Safety
≈≈X `
)
≈≈` a
;
≈≈a b
}
…… 	
public
œœ 
ParallelWriter
œœ 
AsParallelWriter
œœ .
(
œœ. /
)
œœ/ 0
{
–– 	
return
““ 
new
““ 
ParallelWriter
““ %
(
““% &

m_ListData
““& 0
,
““0 1
ref
““2 5
m_Safety
““6 >
)
““> ?
;
““? @
}
÷÷ 	
[
ﬁﬁ 	
NativeContainer
ﬁﬁ	 
]
ﬁﬁ 
[
ﬂﬂ 	.
 NativeContainerIsAtomicWriteOnly
ﬂﬂ	 )
]
ﬂﬂ) *
[
‡‡ 	
BurstCompatible
‡‡	 
(
‡‡ "
GenericTypeArguments
‡‡ -
=
‡‡. /
new
‡‡0 3
[
‡‡4 5
]
‡‡5 6
{
‡‡7 8
typeof
‡‡9 ?
(
‡‡? @
int
‡‡@ C
)
‡‡C D
}
‡‡E F
)
‡‡F G
]
‡‡G H
public
·· 
unsafe
·· 
struct
·· 
ParallelWriter
·· +
{
‚‚ 	
public
ÊÊ 
readonly
ÊÊ 
void
ÊÊ  
*
ÊÊ  !
Ptr
ÊÊ" %
=>
ÊÊ& (
ListData
ÊÊ) 1
->
ÊÊ1 3
Ptr
ÊÊ3 6
;
ÊÊ6 7
[
ÏÏ /
!NativeDisableUnsafePtrRestriction
ÏÏ .
]
ÏÏ. /
public
ÌÌ 

UnsafeList
ÌÌ 
<
ÌÌ 
T
ÌÌ 
>
ÌÌ  
*
ÌÌ  !
ListData
ÌÌ" *
;
ÌÌ* +
internal
  
AtomicSafetyHandle
 '
m_Safety
( 0
;
0 1
internal
ÒÒ 
static
ÒÒ 
readonly
ÒÒ $
SharedStatic
ÒÒ% 1
<
ÒÒ1 2
int
ÒÒ2 5
>
ÒÒ5 6
s_staticSafetyId
ÒÒ7 G
=
ÒÒH I
SharedStatic
ÒÒJ V
<
ÒÒV W
int
ÒÒW Z
>
ÒÒZ [
.
ÒÒ[ \
GetOrCreate
ÒÒ\ g
<
ÒÒg h
ParallelWriter
ÒÒh v
>
ÒÒv w
(
ÒÒw x
)
ÒÒx y
;
ÒÒy z
[
ÛÛ 
BurstCompatible
ÛÛ 
(
ÛÛ 
CompileTarget
ÛÛ *
=
ÛÛ+ ,&
BurstCompatibleAttribute
ÛÛ- E
.
ÛÛE F*
BurstCompatibleCompileTarget
ÛÛF b
.
ÛÛb c
Editor
ÛÛc i
)
ÛÛi j
]
ÛÛj k
internal
ÙÙ 
unsafe
ÙÙ 
ParallelWriter
ÙÙ *
(
ÙÙ* +

UnsafeList
ÙÙ+ 5
<
ÙÙ5 6
T
ÙÙ6 7
>
ÙÙ7 8
*
ÙÙ8 9
listData
ÙÙ: B
,
ÙÙB C
ref
ÙÙD G 
AtomicSafetyHandle
ÙÙH Z
safety
ÙÙ[ a
)
ÙÙa b
{
ıı 
ListData
ˆˆ 
=
ˆˆ 
listData
ˆˆ #
;
ˆˆ# $
m_Safety
˜˜ 
=
˜˜ 
safety
˜˜ !
;
˜˜! "
CollectionHelper
¯¯  
.
¯¯  !
SetStaticSafetyId
¯¯! 2
<
¯¯2 3
ParallelWriter
¯¯3 A
>
¯¯A B
(
¯¯B C
ref
¯¯C F
m_Safety
¯¯G O
,
¯¯O P
ref
¯¯Q T
s_staticSafetyId
¯¯U e
.
¯¯e f
Data
¯¯f j
)
¯¯j k
;
¯¯k l
}
˘˘ 
public
ââ 
void
ââ 
AddNoResize
ââ #
(
ââ# $
T
ââ$ %
value
ââ& +
)
ââ+ ,
{
ää  
AtomicSafetyHandle
åå "
.
åå" # 
CheckWriteAndThrow
åå# 5
(
åå5 6
m_Safety
åå6 >
)
åå> ?
;
åå? @
var
éé 
idx
éé 
=
éé 
Interlocked
éé %
.
éé% &
	Increment
éé& /
(
éé/ 0
ref
éé0 3
ListData
éé4 <
->
éé< >
m_length
éé> F
)
ééF G
-
ééH I
$num
ééJ K
;
ééK L%
CheckSufficientCapacity
èè '
(
èè' (
ListData
èè( 0
->
èè0 2
Capacity
èè2 :
,
èè: ;
idx
èè< ?
+
èè@ A
$num
èèB C
)
èèC D
;
èèD E
UnsafeUtility
ëë 
.
ëë 
WriteArrayElement
ëë /
(
ëë/ 0
ListData
ëë0 8
->
ëë8 :
Ptr
ëë: =
,
ëë= >
idx
ëë? B
,
ëëB C
value
ëëD I
)
ëëI J
;
ëëJ K
}
íí 
public
ùù 
void
ùù 
AddRangeNoResize
ùù (
(
ùù( )
void
ùù) -
*
ùù- .
ptr
ùù/ 2
,
ùù2 3
int
ùù4 7
count
ùù8 =
)
ùù= >
{
ûû 
CheckArgPositive
üü  
(
üü  !
count
üü! &
)
üü& '
;
üü' ( 
AtomicSafetyHandle
¢¢ "
.
¢¢" # 
CheckWriteAndThrow
¢¢# 5
(
¢¢5 6
m_Safety
¢¢6 >
)
¢¢> ?
;
¢¢? @
var
§§ 
idx
§§ 
=
§§ 
Interlocked
§§ %
.
§§% &
Add
§§& )
(
§§) *
ref
§§* -
ListData
§§. 6
->
§§6 8
m_length
§§8 @
,
§§@ A
count
§§B G
)
§§G H
-
§§I J
count
§§K P
;
§§P Q%
CheckSufficientCapacity
•• '
(
••' (
ListData
••( 0
->
••0 2
Capacity
••2 :
,
••: ;
idx
••< ?
+
••@ A
count
••B G
)
••G H
;
••H I
var
ßß 
sizeOf
ßß 
=
ßß 
sizeof
ßß #
(
ßß# $
T
ßß$ %
)
ßß% &
;
ßß& '
void
®® 
*
®® 
dst
®® 
=
®® 
(
®® 
byte
®® !
*
®®! "
)
®®" #
ListData
®®# +
->
®®+ -
Ptr
®®- 0
+
®®1 2
idx
®®3 6
*
®®7 8
sizeOf
®®9 ?
;
®®? @
UnsafeUtility
©© 
.
©© 
MemCpy
©© $
(
©©$ %
dst
©©% (
,
©©( )
ptr
©©* -
,
©©- .
count
©©/ 4
*
©©5 6
sizeOf
©©7 =
)
©©= >
;
©©> ?
}
™™ 
public
¥¥ 
void
¥¥ 
AddRangeNoResize
¥¥ (
(
¥¥( )

UnsafeList
¥¥) 3
<
¥¥3 4
T
¥¥4 5
>
¥¥5 6
list
¥¥7 ;
)
¥¥; <
{
µµ 
AddRangeNoResize
∂∂  
(
∂∂  !
list
∂∂! %
.
∂∂% &
Ptr
∂∂& )
,
∂∂) *
list
∂∂+ /
.
∂∂/ 0
Length
∂∂0 6
)
∂∂6 7
;
∂∂7 8
}
∑∑ 
public
¡¡ 
void
¡¡ 
AddRangeNoResize
¡¡ (
(
¡¡( )

NativeList
¡¡) 3
<
¡¡3 4
T
¡¡4 5
>
¡¡5 6
list
¡¡7 ;
)
¡¡; <
{
¬¬ 
AddRangeNoResize
√√  
(
√√  !
*
√√! "
list
√√" &
.
√√& '

m_ListData
√√' 1
)
√√1 2
;
√√2 3
}
ƒƒ 
}
≈≈ 	
[
«« 	
Conditional
««	 
(
«« 
$str
«« 6
)
««6 7
]
««7 8
static
»» 
void
»» "
CheckInitialCapacity
»» (
(
»»( )
int
»») ,
initialCapacity
»»- <
)
»»< =
{
…… 	
if
   
(
   
initialCapacity
   
<
    !
$num
  " #
)
  # $
throw
ÀÀ 
new
ÀÀ )
ArgumentOutOfRangeException
ÀÀ 5
(
ÀÀ5 6
nameof
ÀÀ6 <
(
ÀÀ< =
initialCapacity
ÀÀ= L
)
ÀÀL M
,
ÀÀM N
$str
ÀÀO f
)
ÀÀf g
;
ÀÀg h
}
ÃÃ 	
[
ŒŒ 	
Conditional
ŒŒ	 
(
ŒŒ 
$str
ŒŒ 6
)
ŒŒ6 7
]
ŒŒ7 8
static
œœ 
void
œœ 
CheckTotalSize
œœ "
(
œœ" #
int
œœ# &
initialCapacity
œœ' 6
,
œœ6 7
long
œœ8 <
	totalSize
œœ= F
)
œœF G
{
–– 	
if
‘‘ 
(
‘‘ 
	totalSize
‘‘ 
>
‘‘ 
int
‘‘ 
.
‘‘  
MaxValue
‘‘  (
)
‘‘( )
throw
’’ 
new
’’ )
ArgumentOutOfRangeException
’’ 5
(
’’5 6
nameof
’’6 <
(
’’< =
initialCapacity
’’= L
)
’’L M
,
’’M N
$"
’’O Q
$str
’’Q t
{
’’t u
int
’’u x
.
’’x y
MaxValue’’y Å
}’’Å Ç
$str’’Ç à
"’’à â
)’’â ä
;’’ä ã
}
÷÷ 	
[
ÿÿ 	
Conditional
ÿÿ	 
(
ÿÿ 
$str
ÿÿ 6
)
ÿÿ6 7
]
ÿÿ7 8
static
ŸŸ 
void
ŸŸ %
CheckSufficientCapacity
ŸŸ +
(
ŸŸ+ ,
int
ŸŸ, /
capacity
ŸŸ0 8
,
ŸŸ8 9
int
ŸŸ: =
length
ŸŸ> D
)
ŸŸD E
{
⁄⁄ 	
if
€€ 
(
€€ 
capacity
€€ 
<
€€ 
length
€€ !
)
€€! "
throw
‹‹ 
new
‹‹ 
	Exception
‹‹ #
(
‹‹# $
$"
‹‹$ &
$str
‹‹& -
{
‹‹- .
length
‹‹. 4
}
‹‹4 5
$str
‹‹5 P
{
‹‹P Q
capacity
‹‹Q Y
}
‹‹Y Z
"
‹‹Z [
)
‹‹[ \
;
‹‹\ ]
}
›› 	
[
ﬂﬂ 	
Conditional
ﬂﬂ	 
(
ﬂﬂ 
$str
ﬂﬂ 6
)
ﬂﬂ6 7
]
ﬂﬂ7 8
static
‡‡ 
void
‡‡ 
CheckIndexInRange
‡‡ %
(
‡‡% &
int
‡‡& )
value
‡‡* /
,
‡‡/ 0
int
‡‡1 4
length
‡‡5 ;
)
‡‡; <
{
·· 	
if
‚‚ 
(
‚‚ 
value
‚‚ 
<
‚‚ 
$num
‚‚ 
)
‚‚ 
throw
„„ 
new
„„ &
IndexOutOfRangeException
„„ 2
(
„„2 3
$"
„„3 5
$str
„„5 ;
{
„„; <
value
„„< A
}
„„A B
$str
„„B T
"
„„T U
)
„„U V
;
„„V W
if
ÂÂ 
(
ÂÂ 
(
ÂÂ 
uint
ÂÂ 
)
ÂÂ 
value
ÂÂ 
>=
ÂÂ 
(
ÂÂ  
uint
ÂÂ  $
)
ÂÂ$ %
length
ÂÂ% +
)
ÂÂ+ ,
throw
ÊÊ 
new
ÊÊ &
IndexOutOfRangeException
ÊÊ 2
(
ÊÊ2 3
$"
ÊÊ3 5
$str
ÊÊ5 ;
{
ÊÊ; <
value
ÊÊ< A
}
ÊÊA B
$str
ÊÊB e
{
ÊÊe f
length
ÊÊf l
}
ÊÊl m
$str
ÊÊm v
"
ÊÊv w
)
ÊÊw x
;
ÊÊx y
}
ÁÁ 	
[
ÈÈ 	
Conditional
ÈÈ	 
(
ÈÈ 
$str
ÈÈ 6
)
ÈÈ6 7
]
ÈÈ7 8
static
ÍÍ 
void
ÍÍ 
CheckArgPositive
ÍÍ $
(
ÍÍ$ %
int
ÍÍ% (
value
ÍÍ) .
)
ÍÍ. /
{
ÎÎ 	
if
ÏÏ 
(
ÏÏ 
value
ÏÏ 
<
ÏÏ 
$num
ÏÏ 
)
ÏÏ 
throw
ÌÌ 
new
ÌÌ )
ArgumentOutOfRangeException
ÌÌ 5
(
ÌÌ5 6
$"
ÌÌ6 8
$str
ÌÌ8 >
{
ÌÌ> ?
value
ÌÌ? D
}
ÌÌD E
$str
ÌÌE W
"
ÌÌW X
)
ÌÌX Y
;
ÌÌY Z
}
ÓÓ 	
[
 	
Conditional
	 
(
 
$str
 6
)
6 7
]
7 8
void
ÒÒ  
CheckHandleMatches
ÒÒ 
(
ÒÒ  
AllocatorManager
ÒÒ  0
.
ÒÒ0 1
AllocatorHandle
ÒÒ1 @
handle
ÒÒA G
)
ÒÒG H
{
ÚÚ 	
if
ÛÛ 
(
ÛÛ 

m_ListData
ÛÛ 
==
ÛÛ 
null
ÛÛ !
)
ÛÛ! "
throw
ÙÙ 
new
ÙÙ )
ArgumentOutOfRangeException
ÙÙ 5
(
ÙÙ5 6
$"
ÙÙ6 8
$str
ÙÙ8 I
{
ÙÙI J
handle
ÙÙJ P
}
ÙÙP Q
$strÙÙQ É
"ÙÙÉ Ñ
)ÙÙÑ Ö
;ÙÙÖ Ü
if
ıı 
(
ıı 

m_ListData
ıı 
->
ıı 
	Allocator
ıı $
.
ıı$ %
Index
ıı% *
!=
ıı+ -
handle
ıı. 4
.
ıı4 5
Index
ıı5 :
)
ıı: ;
throw
ˆˆ 
new
ˆˆ )
ArgumentOutOfRangeException
ˆˆ 5
(
ˆˆ5 6
$"
ˆˆ6 8
$str
ˆˆ8 I
{
ˆˆI J
handle
ˆˆJ P
}
ˆˆP Q
$strˆˆQ ã
"ˆˆã å
)ˆˆå ç
;ˆˆç é
if
˜˜ 
(
˜˜ 

m_ListData
˜˜ 
->
˜˜ 
	Allocator
˜˜ $
.
˜˜$ %
Version
˜˜% ,
!=
˜˜- /
handle
˜˜0 6
.
˜˜6 7
Version
˜˜7 >
)
˜˜> ?
throw
¯¯ 
new
¯¯ )
ArgumentOutOfRangeException
¯¯ 5
(
¯¯5 6
$"
¯¯6 8
$str
¯¯8 I
{
¯¯I J
handle
¯¯J P
}
¯¯P Q
$str¯¯Q å
"¯¯å ç
)¯¯ç é
;¯¯é è
}
˘˘ 	
}
˙˙ 
[
¸¸ 
NativeContainer
¸¸ 
]
¸¸ 
[
˝˝ 
BurstCompatible
˝˝ 
]
˝˝ 
internal
˛˛ 
unsafe
˛˛ 
struct
˛˛ 
NativeListDispose
˛˛ ,
{
ˇˇ 
[
ÄÄ 	/
!NativeDisableUnsafePtrRestriction
ÄÄ	 *
]
ÄÄ* +
public
ÅÅ 
UntypedUnsafeList
ÅÅ  
*
ÅÅ  !

m_ListData
ÅÅ" ,
;
ÅÅ, -
internal
ÑÑ  
AtomicSafetyHandle
ÑÑ #
m_Safety
ÑÑ$ ,
;
ÑÑ, -
public
áá 
void
áá 
Dispose
áá 
(
áá 
)
áá 
{
àà 	
var
ââ 
listData
ââ 
=
ââ 
(
ââ 

UnsafeList
ââ &
<
ââ& '
int
ââ' *
>
ââ* +
*
ââ+ ,
)
ââ, -

m_ListData
ââ- 7
;
ââ7 8

UnsafeList
ää 
<
ää 
int
ää 
>
ää 
.
ää 
Destroy
ää #
(
ää# $
listData
ää$ ,
)
ää, -
;
ää- .
}
ãã 	
}
åå 
[
éé 
BurstCompile
éé 
]
éé 
[
èè 
BurstCompatible
èè 
]
èè 
internal
êê 
unsafe
êê 
struct
êê "
NativeListDisposeJob
êê /
:
êê0 1
IJob
êê2 6
{
ëë 
internal
íí 
NativeListDispose
íí "
Data
íí# '
;
íí' (
public
îî 
void
îî 
Execute
îî 
(
îî 
)
îî 
{
ïï 	
Data
ññ 
.
ññ 
Dispose
ññ 
(
ññ 
)
ññ 
;
ññ 
}
óó 	
}
òò 
sealed
öö 

class
öö !
NativeListDebugView
öö $
<
öö$ %
T
öö% &
>
öö& '
where
öö( -
T
öö. /
:
öö0 1
	unmanaged
öö2 ;
{
õõ 

NativeList
úú 
<
úú 
T
úú 
>
úú 
m_Array
úú 
;
úú 
public
ûû !
NativeListDebugView
ûû "
(
ûû" #

NativeList
ûû# -
<
ûû- .
T
ûû. /
>
ûû/ 0
array
ûû1 6
)
ûû6 7
{
üü 	
m_Array
†† 
=
†† 
array
†† 
;
†† 
}
°° 	
public
££ 
T
££ 
[
££ 
]
££ 
Items
££ 
=>
££ 
m_Array
££ #
.
££# $
AsArray
££$ +
(
££+ ,
)
££, -
.
££- .
ToArray
££. 5
(
££5 6
)
££6 7
;
££7 8
}
§§ 
}•• 
	namespaceßß 	
Unity
ßß
 
.
ßß 
Collections
ßß 
.
ßß 
LowLevel
ßß $
.
ßß$ %
Unsafe
ßß% +
{®® 
[
¨¨ 
BurstCompatible
¨¨ 
]
¨¨ 
public
≠≠ 

unsafe
≠≠ 
static
≠≠ 
class
≠≠ %
NativeListUnsafeUtility
≠≠ 6
{
ÆÆ 
[
∂∂ 	
BurstCompatible
∂∂	 
(
∂∂ "
GenericTypeArguments
∂∂ -
=
∂∂. /
new
∂∂0 3
[
∂∂4 5
]
∂∂5 6
{
∂∂7 8
typeof
∂∂9 ?
(
∂∂? @
int
∂∂@ C
)
∂∂C D
}
∂∂E F
)
∂∂F G
]
∂∂G H
public
∑∑ 
static
∑∑ 
void
∑∑ 
*
∑∑ 
GetUnsafePtr
∑∑ (
<
∑∑( )
T
∑∑) *
>
∑∑* +
(
∑∑+ ,
this
∑∑, 0

NativeList
∑∑1 ;
<
∑∑; <
T
∑∑< =
>
∑∑= >
list
∑∑? C
)
∑∑C D
where
∑∑E J
T
∑∑K L
:
∑∑M N
	unmanaged
∑∑O X
{
∏∏ 	 
AtomicSafetyHandle
∫∫ 
.
∫∫  
CheckWriteAndThrow
∫∫ 1
(
∫∫1 2
list
∫∫2 6
.
∫∫6 7
m_Safety
∫∫7 ?
)
∫∫? @
;
∫∫@ A
return
ºº 
list
ºº 
.
ºº 

m_ListData
ºº "
->
ºº" $
Ptr
ºº$ '
;
ºº' (
}
ΩΩ 	
[
∆∆ 	
BurstCompatible
∆∆	 
(
∆∆ "
GenericTypeArguments
∆∆ -
=
∆∆. /
new
∆∆0 3
[
∆∆4 5
]
∆∆5 6
{
∆∆7 8
typeof
∆∆9 ?
(
∆∆? @
int
∆∆@ C
)
∆∆C D
}
∆∆E F
)
∆∆F G
]
∆∆G H
public
«« 
static
«« 
unsafe
«« 
void
«« !
*
««! ""
GetUnsafeReadOnlyPtr
««# 7
<
««7 8
T
««8 9
>
««9 :
(
««: ;
this
««; ?

NativeList
««@ J
<
««J K
T
««K L
>
««L M
list
««N R
)
««R S
where
««T Y
T
««Z [
:
««\ ]
	unmanaged
««^ g
{
»» 	 
AtomicSafetyHandle
   
.
   
CheckReadAndThrow
   0
(
  0 1
list
  1 5
.
  5 6
m_Safety
  6 >
)
  > ?
;
  ? @
return
ÃÃ 
list
ÃÃ 
.
ÃÃ 

m_ListData
ÃÃ "
->
ÃÃ" $
Ptr
ÃÃ$ '
;
ÃÃ' (
}
ÕÕ 	
[
⁄⁄ 	
BurstCompatible
⁄⁄	 
(
⁄⁄ "
GenericTypeArguments
⁄⁄ -
=
⁄⁄. /
new
⁄⁄0 3
[
⁄⁄4 5
]
⁄⁄5 6
{
⁄⁄7 8
typeof
⁄⁄9 ?
(
⁄⁄? @
int
⁄⁄@ C
)
⁄⁄C D
}
⁄⁄E F
,
⁄⁄F G!
RequiredUnityDefine
⁄⁄H [
=
⁄⁄\ ]
$str
⁄⁄^ 
,⁄⁄ Ä
CompileTarget⁄⁄Å é
=⁄⁄è ê(
BurstCompatibleAttribute⁄⁄ë ©
.⁄⁄© ™,
BurstCompatibleCompileTarget⁄⁄™ ∆
.⁄⁄∆ «
Editor⁄⁄« Õ
)⁄⁄Õ Œ
]⁄⁄Œ œ
public
€€ 
static
€€  
AtomicSafetyHandle
€€ (#
GetAtomicSafetyHandle
€€) >
<
€€> ?
T
€€? @
>
€€@ A
(
€€A B
ref
€€B E

NativeList
€€F P
<
€€P Q
T
€€Q R
>
€€R S
list
€€T X
)
€€X Y
where
€€Z _
T
€€` a
:
€€b c
	unmanaged
€€d m
{
‹‹ 	
return
›› 
list
›› 
.
›› 
m_Safety
››  
;
››  !
}
ﬁﬁ 	
[
ÈÈ 	
BurstCompatible
ÈÈ	 
(
ÈÈ "
GenericTypeArguments
ÈÈ -
=
ÈÈ. /
new
ÈÈ0 3
[
ÈÈ4 5
]
ÈÈ5 6
{
ÈÈ7 8
typeof
ÈÈ9 ?
(
ÈÈ? @
int
ÈÈ@ C
)
ÈÈC D
}
ÈÈE F
)
ÈÈF G
]
ÈÈG H
public
ÍÍ 
static
ÍÍ 
void
ÍÍ 
*
ÍÍ -
GetInternalListDataPtrUnchecked
ÍÍ ;
<
ÍÍ; <
T
ÍÍ< =
>
ÍÍ= >
(
ÍÍ> ?
ref
ÍÍ? B

NativeList
ÍÍC M
<
ÍÍM N
T
ÍÍN O
>
ÍÍO P
list
ÍÍQ U
)
ÍÍU V
where
ÍÍW \
T
ÍÍ] ^
:
ÍÍ_ `
	unmanaged
ÍÍa j
{
ÎÎ 	
return
ÏÏ 
list
ÏÏ 
.
ÏÏ 

m_ListData
ÏÏ "
;
ÏÏ" #
}
ÌÌ 	
}
ÓÓ 
}ÔÔ úô
bC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeQueue.cs
	namespace

 	
Unity


 
.

 
Collections

 
{ 
unsafe 

struct "
NativeQueueBlockHeader (
{ 
public "
NativeQueueBlockHeader %
*% &
m_NextBlock' 2
;2 3
public 
int 

m_NumItems 
; 
} 
[ 
StructLayout 
( 

LayoutKind 
. 

Sequential '
)' (
]( )
[ 
BurstCompatible 
] 
internal 
unsafe 
struct $
NativeQueueBlockPoolData 3
{ 
internal 
IntPtr 
m_FirstBlock $
;$ %
internal 
int 
m_NumBlocks  
;  !
internal 
int 
m_MaxBlocks  
;  !
internal 
const 
int 
m_BlockSize &
=' (
$num) +
*, -
$num. 2
;2 3
internal 
int 
m_AllocLock  
;  !
public "
NativeQueueBlockHeader %
*% &
AllocateBlock' 4
(4 5
)5 6
{ 	
while%% 
(%% 
Interlocked%% 
.%% 
CompareExchange%% .
(%%. /
ref%%/ 2
m_AllocLock%%3 >
,%%> ?
$num%%@ A
,%%A B
$num%%C D
)%%D E
!=%%F H
$num%%I J
)%%J K
{&& 
}'' "
NativeQueueBlockHeader)) "
*))" #

checkBlock))$ .
=))/ 0
())1 2"
NativeQueueBlockHeader))2 H
*))H I
)))I J
m_FirstBlock))J V
;))V W"
NativeQueueBlockHeader** "
***" #
block**$ )
;**) *
do,, 
{-- 
block.. 
=.. 

checkBlock.. "
;.." #
if// 
(// 
block// 
==// 
null// !
)//! "
{00 
Interlocked11 
.11  
Exchange11  (
(11( )
ref11) ,
m_AllocLock11- 8
,118 9
$num11: ;
)11; <
;11< =
Interlocked22 
.22  
	Increment22  )
(22) *
ref22* -
m_NumBlocks22. 9
)229 :
;22: ;
block33 
=33 
(33 "
NativeQueueBlockHeader33 3
*333 4
)334 5
Memory335 ;
.33; <
	Unmanaged33< E
.33E F
Allocate33F N
(33N O
m_BlockSize33O Z
,33Z [
$num33\ ^
,33^ _
	Allocator33` i
.33i j

Persistent33j t
)33t u
;33u v
return44 
block44  
;44  !
}55 

checkBlock77 
=77 
(77 "
NativeQueueBlockHeader77 4
*774 5
)775 6
Interlocked776 A
.77A B
CompareExchange77B Q
(77Q R
ref77R U
m_FirstBlock77V b
,77b c
(77d e
IntPtr77e k
)77k l
block77l q
->77q s
m_NextBlock77s ~
,77~ 
(
77Ä Å
IntPtr
77Å á
)
77á à
block
77à ç
)
77ç é
;
77é è
}88 
while99 
(99 

checkBlock99 
!=99  
block99! &
)99& '
;99' (
Interlocked;; 
.;; 
Exchange;;  
(;;  !
ref;;! $
m_AllocLock;;% 0
,;;0 1
$num;;2 3
);;3 4
;;;4 5
return== 
block== 
;== 
}>> 	
public@@ 
void@@ 
	FreeBlock@@ 
(@@ "
NativeQueueBlockHeader@@ 4
*@@4 5
block@@6 ;
)@@; <
{AA 	
ifBB 
(BB 
m_NumBlocksBB 
>BB 
m_MaxBlocksBB )
)BB) *
{CC 
ifDD 
(DD 
InterlockedDD 
.DD  
	DecrementDD  )
(DD) *
refDD* -
m_NumBlocksDD. 9
)DD9 :
+DD; <
$numDD= >
>DD? @
m_MaxBlocksDDA L
)DDL M
{EE 
MemoryFF 
.FF 
	UnmanagedFF $
.FF$ %
FreeFF% )
(FF) *
blockFF* /
,FF/ 0
	AllocatorFF1 :
.FF: ;

PersistentFF; E
)FFE F
;FFF G
returnGG 
;GG 
}HH 
InterlockedJJ 
.JJ 
	IncrementJJ %
(JJ% &
refJJ& )
m_NumBlocksJJ* 5
)JJ5 6
;JJ6 7
}KK "
NativeQueueBlockHeaderMM "
*MM" #

checkBlockMM$ .
=MM/ 0
(MM1 2"
NativeQueueBlockHeaderMM2 H
*MMH I
)MMI J
m_FirstBlockMMJ V
;MMV W"
NativeQueueBlockHeaderNN "
*NN" #
nextPtrNN$ +
;NN+ ,
doPP 
{QQ 
nextPtrRR 
=RR 

checkBlockRR $
;RR$ %
blockSS 
->SS 
m_NextBlockSS "
=SS# $

checkBlockSS% /
;SS/ 0

checkBlockTT 
=TT 
(TT "
NativeQueueBlockHeaderTT 4
*TT4 5
)TT5 6
InterlockedTT6 A
.TTA B
CompareExchangeTTB Q
(TTQ R
refTTR U
m_FirstBlockTTV b
,TTb c
(TTd e
IntPtrTTe k
)TTk l
blockTTl q
,TTq r
(TTs t
IntPtrTTt z
)TTz {

checkBlock	TT{ Ö
)
TTÖ Ü
;
TTÜ á
}UU 
whileVV 
(VV 

checkBlockVV 
!=VV  
nextPtrVV! (
)VV( )
;VV) *
}WW 	
}XX 
internalZZ 
unsafeZZ 
classZZ  
NativeQueueBlockPoolZZ .
{[[ 
static\\ 
readonly\\ 
SharedStatic\\ $
<\\$ %
IntPtr\\% +
>\\+ ,
Data\\- 1
=\\2 3
SharedStatic\\4 @
<\\@ A
IntPtr\\A G
>\\G H
.\\H I
GetOrCreate\\I T
<\\T U 
NativeQueueBlockPool\\U i
>\\i j
(\\j k
)\\k l
;\\l m
internal^^ 
static^^ $
NativeQueueBlockPoolData^^ 0
*^^0 1
GetQueueBlockPool^^2 C
(^^C D
)^^D E
{__ 	
var`` 
pData`` 
=`` 
(`` $
NativeQueueBlockPoolData`` 1
*``1 2
*``2 3
)``3 4
Data``4 8
.``8 9
UnsafeDataPointer``9 J
;``J K
varaa 
dataaa 
=aa 
*aa 
pDataaa 
;aa 
ifcc 
(cc 
datacc 
==cc 
nullcc 
)cc 
{dd 
dataee 
=ee 
(ee $
NativeQueueBlockPoolDataee 0
*ee0 1
)ee1 2
Memoryee2 8
.ee8 9
	Unmanagedee9 B
.eeB C
AllocateeeC K
(eeK L
UnsafeUtilityeeL Y
.eeY Z
SizeOfeeZ `
<ee` a$
NativeQueueBlockPoolDataeea y
>eey z
(eez {
)ee{ |
,ee| }
$numee~ 
,	ee Ä
	Allocator
eeÅ ä
.
eeä ã

Persistent
eeã ï
)
eeï ñ
;
eeñ ó
*ff 
pDataff 
=ff 
dataff 
;ff 
datagg 
->gg 
m_NumBlocksgg !
=gg" #
datagg$ (
->gg( *
m_MaxBlocksgg* 5
=gg6 7
$numgg8 ;
;gg; <
datahh 
->hh 
m_AllocLockhh !
=hh" #
$numhh$ %
;hh% &"
NativeQueueBlockHeaderjj &
*jj& '
prevjj( ,
=jj- .
nulljj/ 3
;jj3 4
forll 
(ll 
intll 
ill 
=ll 
$numll 
;ll 
ill  !
<ll" #
datall$ (
->ll( *
m_MaxBlocksll* 5
;ll5 6
++ll7 9
ill9 :
)ll: ;
{mm "
NativeQueueBlockHeadernn *
*nn* +
blocknn, 1
=nn2 3
(nn4 5"
NativeQueueBlockHeadernn5 K
*nnK L
)nnL M
MemorynnM S
.nnS T
	UnmanagednnT ]
.nn] ^
Allocatenn^ f
(nnf g$
NativeQueueBlockPoolDatanng 
.	nn Ä
m_BlockSize
nnÄ ã
,
nnã å
$num
nnç è
,
nnè ê
	Allocator
nnë ö
.
nnö õ

Persistent
nnõ •
)
nn• ¶
;
nn¶ ß
blockoo 
->oo 
m_NextBlockoo &
=oo' (
prevoo) -
;oo- .
prevpp 
=pp 
blockpp  
;pp  !
}qq 
datarr 
->rr 
m_FirstBlockrr "
=rr# $
(rr% &
IntPtrrr& ,
)rr, -
prevrr- 1
;rr1 2#
AppDomainOnDomainUnloadtt '
(tt' (
)tt( )
;tt) *
}uu 
returnvv 
datavv 
;vv 
}ww 	
[yy 	
BurstDiscardyy	 
]yy 
staticzz 
voidzz #
AppDomainOnDomainUnloadzz +
(zz+ ,
)zz, -
{{{ 	
	AppDomain}} 
.}} 
CurrentDomain}} #
.}}# $
DomainUnload}}$ 0
+=}}1 3
OnDomainUnload}}4 B
;}}B C
} 	
static
ÇÇ 
void
ÇÇ 
OnDomainUnload
ÇÇ "
(
ÇÇ" #
object
ÇÇ# )
sender
ÇÇ* 0
,
ÇÇ0 1
	EventArgs
ÇÇ2 ;
e
ÇÇ< =
)
ÇÇ= >
{
ÉÉ 	
var
ÑÑ 
pData
ÑÑ 
=
ÑÑ 
(
ÑÑ &
NativeQueueBlockPoolData
ÑÑ 1
*
ÑÑ1 2
*
ÑÑ2 3
)
ÑÑ3 4
Data
ÑÑ4 8
.
ÑÑ8 9
UnsafeDataPointer
ÑÑ9 J
;
ÑÑJ K
var
ÖÖ 
data
ÖÖ 
=
ÖÖ 
*
ÖÖ 
pData
ÖÖ 
;
ÖÖ 
while
áá 
(
áá 
data
áá 
->
áá 
m_FirstBlock
áá %
!=
áá& (
IntPtr
áá) /
.
áá/ 0
Zero
áá0 4
)
áá4 5
{
àà $
NativeQueueBlockHeader
ââ &
*
ââ& '
block
ââ( -
=
ââ. /
(
ââ0 1$
NativeQueueBlockHeader
ââ1 G
*
ââG H
)
ââH I
data
ââI M
->
ââM O
m_FirstBlock
ââO [
;
ââ[ \
data
ää 
->
ää 
m_FirstBlock
ää "
=
ää# $
(
ää% &
IntPtr
ää& ,
)
ää, -
block
ää- 2
->
ää2 4
m_NextBlock
ää4 ?
;
ää? @
Memory
ãã 
.
ãã 
	Unmanaged
ãã  
.
ãã  !
Free
ãã! %
(
ãã% &
block
ãã& +
,
ãã+ ,
	Allocator
ãã- 6
.
ãã6 7

Persistent
ãã7 A
)
ããA B
;
ããB C
--
åå 
data
åå 
->
åå 
m_NumBlocks
åå #
;
åå# $
}
çç 
Memory
éé 
.
éé 
	Unmanaged
éé 
.
éé 
Free
éé !
(
éé! "
data
éé" &
,
éé& '
	Allocator
éé( 1
.
éé1 2

Persistent
éé2 <
)
éé< =
;
éé= >
*
èè 
pData
èè 
=
èè 
null
èè 
;
èè 
}
êê 	
}
íí 
[
îî 
StructLayout
îî 
(
îî 

LayoutKind
îî 
.
îî 

Sequential
îî '
)
îî' (
]
îî( )
[
ïï 
BurstCompatible
ïï 
]
ïï 
internal
ññ 
unsafe
ññ 
struct
ññ 
NativeQueueData
ññ *
{
óó 
public
òò 
IntPtr
òò 
m_FirstBlock
òò "
;
òò" #
public
ôô 
IntPtr
ôô 
m_LastBlock
ôô !
;
ôô! "
public
öö 
int
öö 

m_MaxItems
öö 
;
öö 
public
õõ 
int
õõ 
m_CurrentRead
õõ  
;
õõ  !
public
úú 
byte
úú 
*
úú $
m_CurrentWriteBlockTLS
úú +
;
úú+ ,
internal
ûû $
NativeQueueBlockHeader
ûû '
*
ûû' (%
GetCurrentWriteBlockTLS
ûû) @
(
ûû@ A
int
ûûA D
threadIndex
ûûE P
)
ûûP Q
{
üü 	
var
†† 
data
†† 
=
†† 
(
†† $
NativeQueueBlockHeader
†† .
*
††. /
*
††/ 0
)
††0 1
&
††1 2$
m_CurrentWriteBlockTLS
††2 H
[
††H I
threadIndex
††I T
*
††U V
JobsUtility
††W b
.
††b c
CacheLineSize
††c p
]
††p q
;
††q r
return
°° 
*
°° 
data
°° 
;
°° 
}
¢¢ 	
internal
§§ 
void
§§ %
SetCurrentWriteBlockTLS
§§ -
(
§§- .
int
§§. 1
threadIndex
§§2 =
,
§§= >$
NativeQueueBlockHeader
§§? U
*
§§U V
currentWriteBlock
§§W h
)
§§h i
{
•• 	
var
¶¶ 
data
¶¶ 
=
¶¶ 
(
¶¶ $
NativeQueueBlockHeader
¶¶ .
*
¶¶. /
*
¶¶/ 0
)
¶¶0 1
&
¶¶1 2$
m_CurrentWriteBlockTLS
¶¶2 H
[
¶¶H I
threadIndex
¶¶I T
*
¶¶U V
JobsUtility
¶¶W b
.
¶¶b c
CacheLineSize
¶¶c p
]
¶¶p q
;
¶¶q r
*
ßß 
data
ßß 
=
ßß 
currentWriteBlock
ßß %
;
ßß% &
}
®® 	
[
™™ 	
BurstCompatible
™™	 
(
™™ "
GenericTypeArguments
™™ -
=
™™. /
new
™™0 3
[
™™4 5
]
™™5 6
{
™™7 8
typeof
™™9 ?
(
™™? @
int
™™@ C
)
™™C D
}
™™E F
)
™™F G
]
™™G H
public
´´ 
static
´´ $
NativeQueueBlockHeader
´´ ,
*
´´, -"
AllocateWriteBlockMT
´´. B
<
´´B C
T
´´C D
>
´´D E
(
´´E F
NativeQueueData
´´F U
*
´´U V
data
´´W [
,
´´[ \&
NativeQueueBlockPoolData
´´] u
*
´´u v
pool
´´w {
,
´´{ |
int´´} Ä
threadIndex´´Å å
)´´å ç
where´´é ì
T´´î ï
:´´ñ ó
struct´´ò û
{
¨¨ 	$
NativeQueueBlockHeader
≠≠ "
*
≠≠" #
currentWriteBlock
≠≠$ 5
=
≠≠6 7
data
≠≠8 <
->
≠≠< >%
GetCurrentWriteBlockTLS
≠≠> U
(
≠≠U V
threadIndex
≠≠V a
)
≠≠a b
;
≠≠b c
if
ØØ 
(
ØØ 
currentWriteBlock
ØØ !
!=
ØØ" $
null
ØØ% )
&&
∞∞ 
currentWriteBlock
∞∞ $
->
∞∞$ &

m_NumItems
∞∞& 0
==
∞∞1 3
data
∞∞4 8
->
∞∞8 :

m_MaxItems
∞∞: D
)
∞∞D E
{
±± 
currentWriteBlock
≤≤ !
=
≤≤" #
null
≤≤$ (
;
≤≤( )
}
≥≥ 
if
µµ 
(
µµ 
currentWriteBlock
µµ !
==
µµ" $
null
µµ% )
)
µµ) *
{
∂∂ 
currentWriteBlock
∑∑ !
=
∑∑" #
pool
∑∑$ (
->
∑∑( *
AllocateBlock
∑∑* 7
(
∑∑7 8
)
∑∑8 9
;
∑∑9 :
currentWriteBlock
∏∏ !
->
∏∏! #
m_NextBlock
∏∏# .
=
∏∏/ 0
null
∏∏1 5
;
∏∏5 6
currentWriteBlock
ππ !
->
ππ! #

m_NumItems
ππ# -
=
ππ. /
$num
ππ0 1
;
ππ1 2$
NativeQueueBlockHeader
∫∫ &
*
∫∫& '
prevLast
∫∫( 0
=
∫∫1 2
(
∫∫3 4$
NativeQueueBlockHeader
∫∫4 J
*
∫∫J K
)
∫∫K L
Interlocked
∫∫L W
.
∫∫W X
Exchange
∫∫X `
(
∫∫` a
ref
∫∫a d
data
∫∫e i
->
∫∫i k
m_LastBlock
∫∫k v
,
∫∫v w
(
∫∫x y
IntPtr
∫∫y 
)∫∫ Ä!
currentWriteBlock∫∫Ä ë
)∫∫ë í
;∫∫í ì
if
ºº 
(
ºº 
prevLast
ºº 
==
ºº 
null
ºº  $
)
ºº$ %
{
ΩΩ 
data
ææ 
->
ææ 
m_FirstBlock
ææ &
=
ææ' (
(
ææ) *
IntPtr
ææ* 0
)
ææ0 1
currentWriteBlock
ææ1 B
;
ææB C
}
øø 
else
¿¿ 
{
¡¡ 
prevLast
¬¬ 
->
¬¬ 
m_NextBlock
¬¬ )
=
¬¬* +
currentWriteBlock
¬¬, =
;
¬¬= >
}
√√ 
data
≈≈ 
->
≈≈ %
SetCurrentWriteBlockTLS
≈≈ -
(
≈≈- .
threadIndex
≈≈. 9
,
≈≈9 :
currentWriteBlock
≈≈; L
)
≈≈L M
;
≈≈M N
}
∆∆ 
return
»» 
currentWriteBlock
»» $
;
»»$ %
}
…… 	
[
ÀÀ 	
BurstCompatible
ÀÀ	 
(
ÀÀ "
GenericTypeArguments
ÀÀ -
=
ÀÀ. /
new
ÀÀ0 3
[
ÀÀ4 5
]
ÀÀ5 6
{
ÀÀ7 8
typeof
ÀÀ9 ?
(
ÀÀ? @
int
ÀÀ@ C
)
ÀÀC D
}
ÀÀE F
)
ÀÀF G
]
ÀÀG H
public
ÃÃ 
unsafe
ÃÃ 
static
ÃÃ 
void
ÃÃ !
AllocateQueue
ÃÃ" /
<
ÃÃ/ 0
T
ÃÃ0 1
>
ÃÃ1 2
(
ÃÃ2 3
AllocatorManager
ÃÃ3 C
.
ÃÃC D
AllocatorHandle
ÃÃD S
label
ÃÃT Y
,
ÃÃY Z
out
ÃÃ[ ^
NativeQueueData
ÃÃ_ n
*
ÃÃn o
outBuf
ÃÃp v
)
ÃÃv w
where
ÃÃx }
T
ÃÃ~ 
:ÃÃÄ Å
structÃÃÇ à
{
ÕÕ 	
var
ŒŒ 
queueDataSize
ŒŒ 
=
ŒŒ 
CollectionHelper
ŒŒ  0
.
ŒŒ0 1
Align
ŒŒ1 6
(
ŒŒ6 7
UnsafeUtility
ŒŒ7 D
.
ŒŒD E
SizeOf
ŒŒE K
<
ŒŒK L
NativeQueueData
ŒŒL [
>
ŒŒ[ \
(
ŒŒ\ ]
)
ŒŒ] ^
,
ŒŒ^ _
JobsUtility
ŒŒ` k
.
ŒŒk l
CacheLineSize
ŒŒl y
)
ŒŒy z
;
ŒŒz {
var
–– 
data
–– 
=
–– 
(
–– 
NativeQueueData
–– '
*
––' (
)
––( )
Memory
––) /
.
––/ 0
	Unmanaged
––0 9
.
––9 :
Allocate
––: B
(
––B C
queueDataSize
—— 
+
““ 
JobsUtility
““ 
.
““ 
CacheLineSize
““ +
*
““, -
JobsUtility
““. 9
.
““9 :
MaxJobThreadCount
““: K
,
”” 
JobsUtility
”” 
.
”” 
CacheLineSize
”” +
,
‘‘ 
label
‘‘ 
)
’’ 
;
’’ 
data
◊◊ 
->
◊◊ $
m_CurrentWriteBlockTLS
◊◊ (
=
◊◊) *
(
◊◊+ ,
(
◊◊, -
(
◊◊- .
byte
◊◊. 2
*
◊◊2 3
)
◊◊3 4
data
◊◊4 8
)
◊◊8 9
+
◊◊: ;
queueDataSize
◊◊< I
)
◊◊I J
;
◊◊J K
data
ŸŸ 
->
ŸŸ 
m_FirstBlock
ŸŸ 
=
ŸŸ  
IntPtr
ŸŸ! '
.
ŸŸ' (
Zero
ŸŸ( ,
;
ŸŸ, -
data
⁄⁄ 
->
⁄⁄ 
m_LastBlock
⁄⁄ 
=
⁄⁄ 
IntPtr
⁄⁄  &
.
⁄⁄& '
Zero
⁄⁄' +
;
⁄⁄+ ,
data
€€ 
->
€€ 

m_MaxItems
€€ 
=
€€ 
(
€€  &
NativeQueueBlockPoolData
€€  8
.
€€8 9
m_BlockSize
€€9 D
-
€€E F
UnsafeUtility
€€G T
.
€€T U
SizeOf
€€U [
<
€€[ \$
NativeQueueBlockHeader
€€\ r
>
€€r s
(
€€s t
)
€€t u
)
€€u v
/
€€w x
UnsafeUtility€€y Ü
.€€Ü á
SizeOf€€á ç
<€€ç é
T€€é è
>€€è ê
(€€ê ë
)€€ë í
;€€í ì
data
›› 
->
›› 
m_CurrentRead
›› 
=
››  !
$num
››" #
;
››# $
for
ﬁﬁ 
(
ﬁﬁ 
int
ﬁﬁ 
threadIndex
ﬁﬁ  
=
ﬁﬁ! "
$num
ﬁﬁ# $
;
ﬁﬁ$ %
threadIndex
ﬁﬁ& 1
<
ﬁﬁ2 3
JobsUtility
ﬁﬁ4 ?
.
ﬁﬁ? @
MaxJobThreadCount
ﬁﬁ@ Q
;
ﬁﬁQ R
++
ﬁﬁS U
threadIndex
ﬁﬁU `
)
ﬁﬁ` a
{
ﬂﬂ 
data
‡‡ 
->
‡‡ %
SetCurrentWriteBlockTLS
‡‡ -
(
‡‡- .
threadIndex
‡‡. 9
,
‡‡9 :
null
‡‡; ?
)
‡‡? @
;
‡‡@ A
}
·· 
outBuf
„„ 
=
„„ 
data
„„ 
;
„„ 
}
‰‰ 	
public
ÊÊ 
unsafe
ÊÊ 
static
ÊÊ 
void
ÊÊ !
DeallocateQueue
ÊÊ" 1
(
ÊÊ1 2
NativeQueueData
ÊÊ2 A
*
ÊÊA B
data
ÊÊC G
,
ÊÊG H&
NativeQueueBlockPoolData
ÊÊI a
*
ÊÊa b
pool
ÊÊc g
,
ÊÊg h
AllocatorManager
ÊÊi y
.
ÊÊy z
AllocatorHandleÊÊz â

allocationÊÊä î
)ÊÊî ï
{
ÁÁ 	$
NativeQueueBlockHeader
ËË "
*
ËË" #

firstBlock
ËË$ .
=
ËË/ 0
(
ËË1 2$
NativeQueueBlockHeader
ËË2 H
*
ËËH I
)
ËËI J
data
ËËJ N
->
ËËN P
m_FirstBlock
ËËP \
;
ËË\ ]
while
ÍÍ 
(
ÍÍ 

firstBlock
ÍÍ 
!=
ÍÍ  
null
ÍÍ! %
)
ÍÍ% &
{
ÎÎ $
NativeQueueBlockHeader
ÏÏ &
*
ÏÏ& '
next
ÏÏ( ,
=
ÏÏ- .

firstBlock
ÏÏ/ 9
->
ÏÏ9 ;
m_NextBlock
ÏÏ; F
;
ÏÏF G
pool
ÌÌ 
->
ÌÌ 
	FreeBlock
ÌÌ 
(
ÌÌ  

firstBlock
ÌÌ  *
)
ÌÌ* +
;
ÌÌ+ ,

firstBlock
ÓÓ 
=
ÓÓ 
next
ÓÓ !
;
ÓÓ! "
}
ÔÔ 
Memory
ÒÒ 
.
ÒÒ 
	Unmanaged
ÒÒ 
.
ÒÒ 
Free
ÒÒ !
(
ÒÒ! "
data
ÒÒ" &
,
ÒÒ& '

allocation
ÒÒ( 2
)
ÒÒ2 3
;
ÒÒ3 4
}
ÚÚ 	
}
ÛÛ 
[
˘˘ 
StructLayout
˘˘ 
(
˘˘ 

LayoutKind
˘˘ 
.
˘˘ 

Sequential
˘˘ '
)
˘˘' (
]
˘˘( )
[
˙˙ 
NativeContainer
˙˙ 
]
˙˙ 
[
˚˚ 
BurstCompatible
˚˚ 
(
˚˚ "
GenericTypeArguments
˚˚ )
=
˚˚* +
new
˚˚, /
[
˚˚0 1
]
˚˚1 2
{
˚˚3 4
typeof
˚˚5 ;
(
˚˚; <
int
˚˚< ?
)
˚˚? @
}
˚˚A B
)
˚˚B C
]
˚˚C D
public
¸¸ 

unsafe
¸¸ 
struct
¸¸ 
NativeQueue
¸¸ $
<
¸¸$ %
T
¸¸% &
>
¸¸& '
:
˝˝ 	
INativeDisposable
˝˝
 
where
˛˛ 
T
˛˛ 
:
˛˛ 
struct
˛˛ 
{
ˇˇ 
[
ÄÄ 	/
!NativeDisableUnsafePtrRestriction
ÄÄ	 *
]
ÄÄ* +
NativeQueueData
ÅÅ 
*
ÅÅ 
m_Buffer
ÅÅ !
;
ÅÅ! "
[
ÉÉ 	/
!NativeDisableUnsafePtrRestriction
ÉÉ	 *
]
ÉÉ* +&
NativeQueueBlockPoolData
ÑÑ  
*
ÑÑ  !
m_QueuePool
ÑÑ" -
;
ÑÑ- . 
AtomicSafetyHandle
áá 
m_Safety
áá #
;
áá# $
static
ââ 
readonly
ââ 
SharedStatic
ââ $
<
ââ$ %
int
ââ% (
>
ââ( )
s_staticSafetyId
ââ* :
=
ââ; <
SharedStatic
ââ= I
<
ââI J
int
ââJ M
>
ââM N
.
ââN O
GetOrCreate
ââO Z
<
ââZ [
NativeQueue
ââ[ f
<
ââf g
T
ââg h
>
ââh i
>
ââi j
(
ââj k
)
ââk l
;
ââl m
[
çç 	0
"NativeSetClassTypeToNullOnSchedule
çç	 +
]
çç+ ,
DisposeSentinel
éé 
m_DisposeSentinel
éé )
;
éé) *
AllocatorManager
íí 
.
íí 
AllocatorHandle
íí (
m_AllocatorLabel
íí) 9
;
íí9 :
public
òò 
NativeQueue
òò 
(
òò 
AllocatorManager
òò +
.
òò+ ,
AllocatorHandle
òò, ;
	allocator
òò< E
)
òòE F
{
ôô 	
CollectionHelper
öö 
.
öö 
CheckIsUnmanaged
öö -
<
öö- .
T
öö. /
>
öö/ 0
(
öö0 1
)
öö1 2
;
öö2 3
m_QueuePool
úú 
=
úú "
NativeQueueBlockPool
úú .
.
úú. /
GetQueueBlockPool
úú/ @
(
úú@ A
)
úúA B
;
úúB C
m_AllocatorLabel
ùù 
=
ùù 
	allocator
ùù (
;
ùù( )
NativeQueueData
üü 
.
üü 
AllocateQueue
üü )
<
üü) *
T
üü* +
>
üü+ ,
(
üü, -
	allocator
üü- 6
,
üü6 7
out
üü8 ;
m_Buffer
üü< D
)
üüD E
;
üüE F
if
•• 
(
•• 
	allocator
•• 
.
•• 
IsCustomAllocator
•• +
)
••+ ,
{
¶¶ 
m_Safety
ßß 
=
ßß  
AtomicSafetyHandle
ßß -
.
ßß- .
Create
ßß. 4
(
ßß4 5
)
ßß5 6
;
ßß6 7
m_DisposeSentinel
®® !
=
®®" #
null
®®$ (
;
®®( )
}
©© 
else
™™ 
{
´´ 
DisposeSentinel
¨¨ 
.
¨¨  
Create
¨¨  &
(
¨¨& '
out
¨¨' *
m_Safety
¨¨+ 3
,
¨¨3 4
out
¨¨5 8
m_DisposeSentinel
¨¨9 J
,
¨¨J K
$num
¨¨L M
,
¨¨M N
	allocator
¨¨O X
.
¨¨X Y
ToAllocator
¨¨Y d
)
¨¨d e
;
¨¨e f
}
≠≠ 
CollectionHelper
∞∞ 
.
∞∞ 
SetStaticSafetyId
∞∞ .
<
∞∞. /
NativeQueue
∞∞/ :
<
∞∞: ;
T
∞∞; <
>
∞∞< =
>
∞∞= >
(
∞∞> ?
ref
∞∞? B
m_Safety
∞∞C K
,
∞∞K L
ref
∞∞M P
s_staticSafetyId
∞∞Q a
.
∞∞a b
Data
∞∞b f
)
∞∞f g
;
∞∞g h
}
≤≤ 	
public
∏∏ 
bool
∏∏ 
IsEmpty
∏∏ 
(
∏∏ 
)
∏∏ 
{
ππ 	
if
∫∫ 
(
∫∫ 
!
∫∫ 
	IsCreated
∫∫ 
)
∫∫ 
{
ªª 
return
ºº 
true
ºº 
;
ºº 
}
ΩΩ 
	CheckRead
øø 
(
øø 
)
øø 
;
øø 
int
¡¡ 
count
¡¡ 
=
¡¡ 
$num
¡¡ 
;
¡¡ 
var
¬¬ 
currentRead
¬¬ 
=
¬¬ 
m_Buffer
¬¬ &
->
¬¬& (
m_CurrentRead
¬¬( 5
;
¬¬5 6
for
ƒƒ 
(
ƒƒ $
NativeQueueBlockHeader
ƒƒ '
*
ƒƒ' (
block
ƒƒ) .
=
ƒƒ/ 0
(
ƒƒ1 2$
NativeQueueBlockHeader
ƒƒ2 H
*
ƒƒH I
)
ƒƒI J
m_Buffer
ƒƒJ R
->
ƒƒR T
m_FirstBlock
ƒƒT `
;
≈≈ 
block
≈≈ 
!=
≈≈ 
null
≈≈ #
;
∆∆ 
block
∆∆ 
=
∆∆ 
block
∆∆ #
->
∆∆# %
m_NextBlock
∆∆% 0
)
«« 
{
»» 
count
…… 
+=
…… 
block
…… 
->
……  

m_NumItems
……  *
;
……* +
if
ÀÀ 
(
ÀÀ 
count
ÀÀ 
>
ÀÀ 
currentRead
ÀÀ '
)
ÀÀ' (
{
ÃÃ 
return
ÕÕ 
false
ÕÕ  
;
ÕÕ  !
}
ŒŒ 
}
œœ 
return
—— 
count
—— 
==
—— 
currentRead
—— '
;
——' (
}
““ 	
public
⁄⁄ 
int
⁄⁄ 
Count
⁄⁄ 
{
€€ 	
get
‹‹ 
{
›› 
	CheckRead
ﬁﬁ 
(
ﬁﬁ 
)
ﬁﬁ 
;
ﬁﬁ 
int
‡‡ 
count
‡‡ 
=
‡‡ 
$num
‡‡ 
;
‡‡ 
for
‚‚ 
(
‚‚ $
NativeQueueBlockHeader
‚‚ +
*
‚‚+ ,
block
‚‚- 2
=
‚‚3 4
(
‚‚5 6$
NativeQueueBlockHeader
‚‚6 L
*
‚‚L M
)
‚‚M N
m_Buffer
‚‚N V
->
‚‚V X
m_FirstBlock
‚‚X d
;
„„ 
block
„„ 
!=
„„ 
null
„„  $
;
‰‰ 
block
‰‰ 
=
‰‰ 
block
‰‰ $
->
‰‰$ &
m_NextBlock
‰‰& 1
)
ÂÂ 
{
ÊÊ 
count
ÁÁ 
+=
ÁÁ 
block
ÁÁ "
->
ÁÁ" $

m_NumItems
ÁÁ$ .
;
ÁÁ. /
}
ËË 
return
ÍÍ 
count
ÍÍ 
-
ÍÍ 
m_Buffer
ÍÍ '
->
ÍÍ' )
m_CurrentRead
ÍÍ) 6
;
ÍÍ6 7
}
ÎÎ 
}
ÏÏ 	
internal
ÓÓ 
static
ÓÓ 
int
ÓÓ (
PersistentMemoryBlockCount
ÓÓ 6
{
ÔÔ 	
get
 
{
 
return
 "
NativeQueueBlockPool
 -
.
- .
GetQueueBlockPool
. ?
(
? @
)
@ A
->
A C
m_MaxBlocks
C N
;
N O
}
P Q
set
ÒÒ 
{
ÒÒ 
Interlocked
ÒÒ 
.
ÒÒ 
Exchange
ÒÒ &
(
ÒÒ& '
ref
ÒÒ' *"
NativeQueueBlockPool
ÒÒ+ ?
.
ÒÒ? @
GetQueueBlockPool
ÒÒ@ Q
(
ÒÒQ R
)
ÒÒR S
->
ÒÒS U
m_MaxBlocks
ÒÒU `
,
ÒÒ` a
value
ÒÒb g
)
ÒÒg h
;
ÒÒh i
}
ÒÒj k
}
ÚÚ 	
internal
ÙÙ 
static
ÙÙ 
int
ÙÙ 
MemoryBlockSize
ÙÙ +
{
ıı 	
get
ˆˆ 
{
ˆˆ 
return
ˆˆ &
NativeQueueBlockPoolData
ˆˆ 1
.
ˆˆ1 2
m_BlockSize
ˆˆ2 =
;
ˆˆ= >
}
ˆˆ? @
}
˜˜ 	
public
˝˝ 
T
˝˝ 
Peek
˝˝ 
(
˝˝ 
)
˝˝ 
{
˛˛ 	
CheckReadNotEmpty
ˇˇ 
(
ˇˇ 
)
ˇˇ 
;
ˇˇ  $
NativeQueueBlockHeader
ÅÅ "
*
ÅÅ" #

firstBlock
ÅÅ$ .
=
ÅÅ/ 0
(
ÅÅ1 2$
NativeQueueBlockHeader
ÅÅ2 H
*
ÅÅH I
)
ÅÅI J
m_Buffer
ÅÅJ R
->
ÅÅR T
m_FirstBlock
ÅÅT `
;
ÅÅ` a
return
ÇÇ 
UnsafeUtility
ÇÇ  
.
ÇÇ  !
ReadArrayElement
ÇÇ! 1
<
ÇÇ1 2
T
ÇÇ2 3
>
ÇÇ3 4
(
ÇÇ4 5

firstBlock
ÇÇ5 ?
+
ÇÇ@ A
$num
ÇÇB C
,
ÇÇC D
m_Buffer
ÇÇE M
->
ÇÇM O
m_CurrentRead
ÇÇO \
)
ÇÇ\ ]
;
ÇÇ] ^
}
ÉÉ 	
public
ââ 
void
ââ 
Enqueue
ââ 
(
ââ 
T
ââ 
value
ââ #
)
ââ# $
{
ää 	

CheckWrite
ãã 
(
ãã 
)
ãã 
;
ãã $
NativeQueueBlockHeader
çç "
*
çç" #

writeBlock
çç$ .
=
çç/ 0
NativeQueueData
çç1 @
.
çç@ A"
AllocateWriteBlockMT
ççA U
<
ççU V
T
ççV W
>
ççW X
(
ççX Y
m_Buffer
ççY a
,
çça b
m_QueuePool
ççc n
,
ççn o
$num
ççp q
)
ççq r
;
ççr s
UnsafeUtility
éé 
.
éé 
WriteArrayElement
éé +
(
éé+ ,

writeBlock
éé, 6
+
éé7 8
$num
éé9 :
,
éé: ;

writeBlock
éé< F
->
ééF H

m_NumItems
ééH R
,
ééR S
value
ééT Y
)
ééY Z
;
ééZ [
++
èè 

writeBlock
èè 
->
èè 

m_NumItems
èè $
;
èè$ %
}
êê 	
public
óó 
T
óó 
Dequeue
óó 
(
óó 
)
óó 
{
òò 	
if
ôô 
(
ôô 
!
ôô 

TryDequeue
ôô 
(
ôô 
out
ôô 
T
ôô  !
item
ôô" &
)
ôô& '
)
ôô' (
{
öö 

ThrowEmpty
õõ 
(
õõ 
)
õõ 
;
õõ 
}
úú 
return
ûû 
item
ûû 
;
ûû 
}
üü 	
public
¶¶ 
bool
¶¶ 

TryDequeue
¶¶ 
(
¶¶ 
out
¶¶ "
T
¶¶# $
item
¶¶% )
)
¶¶) *
{
ßß 	

CheckWrite
®® 
(
®® 
)
®® 
;
®® $
NativeQueueBlockHeader
™™ "
*
™™" #

firstBlock
™™$ .
=
™™/ 0
(
™™1 2$
NativeQueueBlockHeader
™™2 H
*
™™H I
)
™™I J
m_Buffer
™™J R
->
™™R T
m_FirstBlock
™™T `
;
™™` a
if
¨¨ 
(
¨¨ 

firstBlock
¨¨ 
==
¨¨ 
null
¨¨ "
)
¨¨" #
{
≠≠ 
item
ÆÆ 
=
ÆÆ 
default
ÆÆ 
(
ÆÆ 
T
ÆÆ  
)
ÆÆ  !
;
ÆÆ! "
return
ØØ 
false
ØØ 
;
ØØ 
}
∞∞ 
var
≤≤ 
currentRead
≤≤ 
=
≤≤ 
m_Buffer
≤≤ &
->
≤≤& (
m_CurrentRead
≤≤( 5
++
≤≤5 7
;
≤≤7 8
item
≥≥ 
=
≥≥ 
UnsafeUtility
≥≥  
.
≥≥  !
ReadArrayElement
≥≥! 1
<
≥≥1 2
T
≥≥2 3
>
≥≥3 4
(
≥≥4 5

firstBlock
≥≥5 ?
+
≥≥@ A
$num
≥≥B C
,
≥≥C D
currentRead
≥≥E P
)
≥≥P Q
;
≥≥Q R
if
µµ 
(
µµ 
m_Buffer
µµ 
->
µµ 
m_CurrentRead
µµ '
>=
µµ( *

firstBlock
µµ+ 5
->
µµ5 7

m_NumItems
µµ7 A
)
µµA B
{
∂∂ 
m_Buffer
∑∑ 
->
∑∑ 
m_CurrentRead
∑∑ '
=
∑∑( )
$num
∑∑* +
;
∑∑+ ,
m_Buffer
∏∏ 
->
∏∏ 
m_FirstBlock
∏∏ &
=
∏∏' (
(
∏∏) *
IntPtr
∏∏* 0
)
∏∏0 1

firstBlock
∏∏1 ;
->
∏∏; =
m_NextBlock
∏∏= H
;
∏∏H I
if
∫∫ 
(
∫∫ 
m_Buffer
∫∫ 
->
∫∫ 
m_FirstBlock
∫∫ *
==
∫∫+ -
IntPtr
∫∫. 4
.
∫∫4 5
Zero
∫∫5 9
)
∫∫9 :
{
ªª 
m_Buffer
ºº 
->
ºº 
m_LastBlock
ºº )
=
ºº* +
IntPtr
ºº, 2
.
ºº2 3
Zero
ºº3 7
;
ºº7 8
}
ΩΩ 
for
øø 
(
øø 
int
øø 
threadIndex
øø $
=
øø% &
$num
øø' (
;
øø( )
threadIndex
øø* 5
<
øø6 7
JobsUtility
øø8 C
.
øøC D
MaxJobThreadCount
øøD U
;
øøU V
++
øøW Y
threadIndex
øøY d
)
øød e
{
¿¿ 
if
¡¡ 
(
¡¡ 
m_Buffer
¡¡  
->
¡¡  "%
GetCurrentWriteBlockTLS
¡¡" 9
(
¡¡9 :
threadIndex
¡¡: E
)
¡¡E F
==
¡¡G I

firstBlock
¡¡J T
)
¡¡T U
{
¬¬ 
m_Buffer
√√  
->
√√  "%
SetCurrentWriteBlockTLS
√√" 9
(
√√9 :
threadIndex
√√: E
,
√√E F
null
√√G K
)
√√K L
;
√√L M
}
ƒƒ 
}
≈≈ 
m_QueuePool
«« 
->
«« 
	FreeBlock
«« &
(
««& '

firstBlock
««' 1
)
««1 2
;
««2 3
}
»» 
return
   
true
   
;
   
}
ÀÀ 	
public
”” 
NativeArray
”” 
<
”” 
T
”” 
>
”” 
ToArray
”” %
(
””% &
AllocatorManager
””& 6
.
””6 7
AllocatorHandle
””7 F
	allocator
””G P
)
””P Q
{
‘‘ 	
	CheckRead
’’ 
(
’’ 
)
’’ 
;
’’ $
NativeQueueBlockHeader
◊◊ "
*
◊◊" #

firstBlock
◊◊$ .
=
◊◊/ 0
(
◊◊1 2$
NativeQueueBlockHeader
◊◊2 H
*
◊◊H I
)
◊◊I J
m_Buffer
◊◊J R
->
◊◊R T
m_FirstBlock
◊◊T `
;
◊◊` a
var
ÿÿ 
outputArray
ÿÿ 
=
ÿÿ 
CollectionHelper
ÿÿ .
.
ÿÿ. /
CreateNativeArray
ÿÿ/ @
<
ÿÿ@ A
T
ÿÿA B
>
ÿÿB C
(
ÿÿC D
Count
ÿÿD I
,
ÿÿI J
	allocator
ÿÿK T
)
ÿÿT U
;
ÿÿU V$
NativeQueueBlockHeader
⁄⁄ "
*
⁄⁄" #
currentBlock
⁄⁄$ 0
=
⁄⁄1 2

firstBlock
⁄⁄3 =
;
⁄⁄= >
var
€€ 
arrayPtr
€€ 
=
€€ 
(
€€ 
byte
€€  
*
€€  !
)
€€! "
outputArray
€€" -
.
€€- .
GetUnsafePtr
€€. :
(
€€: ;
)
€€; <
;
€€< =
int
‹‹ 
size
‹‹ 
=
‹‹ 
UnsafeUtility
‹‹ $
.
‹‹$ %
SizeOf
‹‹% +
<
‹‹+ ,
T
‹‹, -
>
‹‹- .
(
‹‹. /
)
‹‹/ 0
;
‹‹0 1
int
›› 
	dstOffset
›› 
=
›› 
$num
›› 
;
›› 
int
ﬁﬁ 
	srcOffset
ﬁﬁ 
=
ﬁﬁ 
m_Buffer
ﬁﬁ $
->
ﬁﬁ$ &
m_CurrentRead
ﬁﬁ& 3
*
ﬁﬁ4 5
size
ﬁﬁ6 :
;
ﬁﬁ: ;
int
ﬂﬂ 
srcOffsetElements
ﬂﬂ !
=
ﬂﬂ" #
m_Buffer
ﬂﬂ$ ,
->
ﬂﬂ, .
m_CurrentRead
ﬂﬂ. ;
;
ﬂﬂ; <
while
‡‡ 
(
‡‡ 
currentBlock
‡‡ 
!=
‡‡  "
null
‡‡# '
)
‡‡' (
{
·· 
int
‚‚ 
bytesToCopy
‚‚ 
=
‚‚  !
(
‚‚" #
currentBlock
‚‚# /
->
‚‚/ 1

m_NumItems
‚‚1 ;
-
‚‚< =
srcOffsetElements
‚‚> O
)
‚‚O P
*
‚‚Q R
size
‚‚S W
;
‚‚W X
UnsafeUtility
„„ 
.
„„ 
MemCpy
„„ $
(
„„$ %
arrayPtr
„„% -
+
„„. /
	dstOffset
„„0 9
,
„„9 :
(
„„; <
byte
„„< @
*
„„@ A
)
„„A B
(
„„B C
currentBlock
„„C O
+
„„P Q
$num
„„R S
)
„„S T
+
„„U V
	srcOffset
„„W `
,
„„` a
bytesToCopy
„„b m
)
„„m n
;
„„n o
	srcOffset
‰‰ 
=
‰‰ 
srcOffsetElements
‰‰ -
=
‰‰. /
$num
‰‰0 1
;
‰‰1 2
	dstOffset
ÂÂ 
+=
ÂÂ 
bytesToCopy
ÂÂ (
;
ÂÂ( )
currentBlock
ÊÊ 
=
ÊÊ 
currentBlock
ÊÊ +
->
ÊÊ+ -
m_NextBlock
ÊÊ- 8
;
ÊÊ8 9
}
ÁÁ 
return
ÈÈ 
outputArray
ÈÈ 
;
ÈÈ 
}
ÍÍ 	
public
 
void
 
Clear
 
(
 
)
 
{
ÒÒ 	

CheckWrite
ÚÚ 
(
ÚÚ 
)
ÚÚ 
;
ÚÚ $
NativeQueueBlockHeader
ÙÙ "
*
ÙÙ" #

firstBlock
ÙÙ$ .
=
ÙÙ/ 0
(
ÙÙ1 2$
NativeQueueBlockHeader
ÙÙ2 H
*
ÙÙH I
)
ÙÙI J
m_Buffer
ÙÙJ R
->
ÙÙR T
m_FirstBlock
ÙÙT `
;
ÙÙ` a
while
ˆˆ 
(
ˆˆ 

firstBlock
ˆˆ 
!=
ˆˆ  
null
ˆˆ! %
)
ˆˆ% &
{
˜˜ $
NativeQueueBlockHeader
¯¯ &
*
¯¯& '
next
¯¯( ,
=
¯¯- .

firstBlock
¯¯/ 9
->
¯¯9 ;
m_NextBlock
¯¯; F
;
¯¯F G
m_QueuePool
˘˘ 
->
˘˘ 
	FreeBlock
˘˘ &
(
˘˘& '

firstBlock
˘˘' 1
)
˘˘1 2
;
˘˘2 3

firstBlock
˙˙ 
=
˙˙ 
next
˙˙ !
;
˙˙! "
}
˚˚ 
m_Buffer
˝˝ 
->
˝˝ 
m_FirstBlock
˝˝ "
=
˝˝# $
IntPtr
˝˝% +
.
˝˝+ ,
Zero
˝˝, 0
;
˝˝0 1
m_Buffer
˛˛ 
->
˛˛ 
m_LastBlock
˛˛ !
=
˛˛" #
IntPtr
˛˛$ *
.
˛˛* +
Zero
˛˛+ /
;
˛˛/ 0
m_Buffer
ˇˇ 
->
ˇˇ 
m_CurrentRead
ˇˇ #
=
ˇˇ$ %
$num
ˇˇ& '
;
ˇˇ' (
for
ÅÅ 
(
ÅÅ 
int
ÅÅ 
threadIndex
ÅÅ  
=
ÅÅ! "
$num
ÅÅ# $
;
ÅÅ$ %
threadIndex
ÅÅ& 1
<
ÅÅ2 3
JobsUtility
ÅÅ4 ?
.
ÅÅ? @
MaxJobThreadCount
ÅÅ@ Q
;
ÅÅQ R
++
ÅÅS U
threadIndex
ÅÅU `
)
ÅÅ` a
{
ÇÇ 
m_Buffer
ÉÉ 
->
ÉÉ %
SetCurrentWriteBlockTLS
ÉÉ 1
(
ÉÉ1 2
threadIndex
ÉÉ2 =
,
ÉÉ= >
null
ÉÉ? C
)
ÉÉC D
;
ÉÉD E
}
ÑÑ 
}
ÖÖ 	
public
ãã 
bool
ãã 
	IsCreated
ãã 
=>
ãã  
m_Buffer
ãã! )
!=
ãã* ,
null
ãã- 1
;
ãã1 2
public
êê 
void
êê 
Dispose
êê 
(
êê 
)
êê 
{
ëë 	
DisposeSentinel
ññ 
.
ññ 
Dispose
ññ #
(
ññ# $
ref
ññ$ '
m_Safety
ññ( 0
,
ññ0 1
ref
ññ2 5
m_DisposeSentinel
ññ6 G
)
ññG H
;
ññH I
NativeQueueData
ôô 
.
ôô 
DeallocateQueue
ôô +
(
ôô+ ,
m_Buffer
ôô, 4
,
ôô4 5
m_QueuePool
ôô6 A
,
ôôA B
m_AllocatorLabel
ôôC S
)
ôôS T
;
ôôT U
m_Buffer
öö 
=
öö 
null
öö 
;
öö 
}
õõ 	
[
¢¢ 	 
NotBurstCompatible
¢¢	 
]¢¢ú ù
public
££ 
	JobHandle
££ 
Dispose
££  
(
££  !
	JobHandle
££! *
	inputDeps
££+ 4
)
££4 5
{
§§ 	
DisposeSentinel
¨¨ 
.
¨¨ 
Clear
¨¨ !
(
¨¨! "
ref
¨¨" %
m_DisposeSentinel
¨¨& 7
)
¨¨7 8
;
¨¨8 9
var
ÆÆ 
	jobHandle
ÆÆ 
=
ÆÆ 
new
ÆÆ #
NativeQueueDisposeJob
ÆÆ  5
{
ÆÆ6 7
Data
ÆÆ8 <
=
ÆÆ= >
new
ÆÆ? B 
NativeQueueDispose
ÆÆC U
{
ÆÆV W
m_Buffer
ÆÆX `
=
ÆÆa b
m_Buffer
ÆÆc k
,
ÆÆk l
m_QueuePool
ÆÆm x
=
ÆÆy z
m_QueuePoolÆÆ{ Ü
,ÆÆÜ á 
m_AllocatorLabelÆÆà ò
=ÆÆô ö 
m_AllocatorLabelÆÆõ ´
,ÆÆ´ ¨
m_SafetyÆÆ≠ µ
=ÆÆ∂ ∑
m_SafetyÆÆ∏ ¿
}ÆÆ¡ ¬
}ÆÆ√ ƒ
.ÆÆƒ ≈
ScheduleÆÆ≈ Õ
(ÆÆÕ Œ
	inputDepsÆÆŒ ◊
)ÆÆ◊ ÿ
;ÆÆÿ Ÿ 
AtomicSafetyHandle
∞∞ 
.
∞∞ 
Release
∞∞ &
(
∞∞& '
m_Safety
∞∞' /
)
∞∞/ 0
;
∞∞0 1
m_Buffer
¥¥ 
=
¥¥ 
null
¥¥ 
;
¥¥ 
return
∂∂ 
	jobHandle
∂∂ 
;
∂∂ 
}
∑∑ 	
public
ΩΩ 
ParallelWriter
ΩΩ 
AsParallelWriter
ΩΩ .
(
ΩΩ. /
)
ΩΩ/ 0
{
ææ 	
ParallelWriter
øø 
writer
øø !
;
øø! "
writer
¬¬ 
.
¬¬ 
m_Safety
¬¬ 
=
¬¬ 
m_Safety
¬¬ &
;
¬¬& '
CollectionHelper
√√ 
.
√√ 
SetStaticSafetyId
√√ .
<
√√. /
ParallelWriter
√√/ =
>
√√= >
(
√√> ?
ref
√√? B
writer
√√C I
.
√√I J
m_Safety
√√J R
,
√√R S
ref
√√T W
ParallelWriter
√√X f
.
√√f g
s_staticSafetyId
√√g w
.
√√w x
Data
√√x |
)
√√| }
;
√√} ~
writer
≈≈ 
.
≈≈ 
m_Buffer
≈≈ 
=
≈≈ 
m_Buffer
≈≈ &
;
≈≈& '
writer
∆∆ 
.
∆∆ 
m_QueuePool
∆∆ 
=
∆∆  
m_QueuePool
∆∆! ,
;
∆∆, -
writer
«« 
.
«« 
m_ThreadIndex
««  
=
««! "
$num
««# $
;
««$ %
return
…… 
writer
…… 
;
…… 
}
   	
[
““ 	
NativeContainer
““	 
]
““ 
[
”” 	.
 NativeContainerIsAtomicWriteOnly
””	 )
]
””) *
[
‘‘ 	
BurstCompatible
‘‘	 
(
‘‘ "
GenericTypeArguments
‘‘ -
=
‘‘. /
new
‘‘0 3
[
‘‘4 5
]
‘‘5 6
{
‘‘7 8
typeof
‘‘9 ?
(
‘‘? @
int
‘‘@ C
)
‘‘C D
}
‘‘E F
)
‘‘F G
]
‘‘G H
public
’’ 
unsafe
’’ 
struct
’’ 
ParallelWriter
’’ +
{
÷÷ 	
[
◊◊ /
!NativeDisableUnsafePtrRestriction
◊◊ .
]
◊◊. /
internal
ÿÿ 
NativeQueueData
ÿÿ $
*
ÿÿ$ %
m_Buffer
ÿÿ& .
;
ÿÿ. /
[
⁄⁄ /
!NativeDisableUnsafePtrRestriction
⁄⁄ .
]
⁄⁄. /
internal
€€ &
NativeQueueBlockPoolData
€€ -
*
€€- .
m_QueuePool
€€/ :
;
€€: ;
internal
ﬁﬁ  
AtomicSafetyHandle
ﬁﬁ '
m_Safety
ﬁﬁ( 0
;
ﬁﬁ0 1
internal
ﬂﬂ 
static
ﬂﬂ 
readonly
ﬂﬂ $
SharedStatic
ﬂﬂ% 1
<
ﬂﬂ1 2
int
ﬂﬂ2 5
>
ﬂﬂ5 6
s_staticSafetyId
ﬂﬂ7 G
=
ﬂﬂH I
SharedStatic
ﬂﬂJ V
<
ﬂﬂV W
int
ﬂﬂW Z
>
ﬂﬂZ [
.
ﬂﬂ[ \
GetOrCreate
ﬂﬂ\ g
<
ﬂﬂg h
ParallelWriter
ﬂﬂh v
>
ﬂﬂv w
(
ﬂﬂw x
)
ﬂﬂx y
;
ﬂﬂy z
[
·· "
NativeSetThreadIndex
·· !
]
··! "
internal
‚‚ 
int
‚‚ 
m_ThreadIndex
‚‚ &
;
‚‚& '
public
ËË 
void
ËË 
Enqueue
ËË 
(
ËË  
T
ËË  !
value
ËË" '
)
ËË' (
{
ÈÈ  
AtomicSafetyHandle
ÎÎ "
.
ÎÎ" # 
CheckWriteAndThrow
ÎÎ# 5
(
ÎÎ5 6
m_Safety
ÎÎ6 >
)
ÎÎ> ?
;
ÎÎ? @$
NativeQueueBlockHeader
ÌÌ &
*
ÌÌ& '

writeBlock
ÌÌ( 2
=
ÌÌ3 4
NativeQueueData
ÌÌ5 D
.
ÌÌD E"
AllocateWriteBlockMT
ÌÌE Y
<
ÌÌY Z
T
ÌÌZ [
>
ÌÌ[ \
(
ÌÌ\ ]
m_Buffer
ÌÌ] e
,
ÌÌe f
m_QueuePool
ÌÌg r
,
ÌÌr s
m_ThreadIndexÌÌt Å
)ÌÌÅ Ç
;ÌÌÇ É
UnsafeUtility
ÓÓ 
.
ÓÓ 
WriteArrayElement
ÓÓ /
(
ÓÓ/ 0

writeBlock
ÓÓ0 :
+
ÓÓ; <
$num
ÓÓ= >
,
ÓÓ> ?

writeBlock
ÓÓ@ J
->
ÓÓJ L

m_NumItems
ÓÓL V
,
ÓÓV W
value
ÓÓX ]
)
ÓÓ] ^
;
ÓÓ^ _
++
ÔÔ 

writeBlock
ÔÔ 
->
ÔÔ 

m_NumItems
ÔÔ (
;
ÔÔ( )
}
 
}
ÒÒ 	
[
ÛÛ 	
Conditional
ÛÛ	 
(
ÛÛ 
$str
ÛÛ 6
)
ÛÛ6 7
]
ÛÛ7 8
void
ÙÙ 
	CheckRead
ÙÙ 
(
ÙÙ 
)
ÙÙ 
{
ıı 	 
AtomicSafetyHandle
˜˜ 
.
˜˜ 
CheckReadAndThrow
˜˜ 0
(
˜˜0 1
m_Safety
˜˜1 9
)
˜˜9 :
;
˜˜: ;
}
˘˘ 	
[
˚˚ 	
Conditional
˚˚	 
(
˚˚ 
$str
˚˚ 6
)
˚˚6 7
]
˚˚7 8
void
¸¸ 
CheckReadNotEmpty
¸¸ 
(
¸¸ 
)
¸¸  
{
˝˝ 	
	CheckRead
˛˛ 
(
˛˛ 
)
˛˛ 
;
˛˛ 
if
ÄÄ 
(
ÄÄ 
m_Buffer
ÄÄ 
->
ÄÄ 
m_FirstBlock
ÄÄ &
==
ÄÄ' )
(
ÄÄ* +
IntPtr
ÄÄ+ 1
)
ÄÄ1 2
$num
ÄÄ2 3
)
ÄÄ3 4
{
ÅÅ 

ThrowEmpty
ÇÇ 
(
ÇÇ 
)
ÇÇ 
;
ÇÇ 
}
ÉÉ 
}
ÑÑ 	
[
ÜÜ 	
Conditional
ÜÜ	 
(
ÜÜ 
$str
ÜÜ 6
)
ÜÜ6 7
]
ÜÜ7 8
void
áá 

CheckWrite
áá 
(
áá 
)
áá 
{
àà 	 
AtomicSafetyHandle
ää 
.
ää  
CheckWriteAndThrow
ää 1
(
ää1 2
m_Safety
ää2 :
)
ää: ;
;
ää; <
}
åå 	
[
éé 	
Conditional
éé	 
(
éé 
$str
éé 6
)
éé6 7
]
éé7 8
static
èè 
void
èè 

ThrowEmpty
èè 
(
èè 
)
èè  
{
êê 	
throw
ëë 
new
ëë '
InvalidOperationException
ëë /
(
ëë/ 0
$str
ëë0 U
)
ëëU V
;
ëëV W
}
íí 	
}
ìì 
[
ïï 
NativeContainer
ïï 
]
ïï 
[
ññ 
BurstCompatible
ññ 
]
ññ 
internal
óó 
unsafe
óó 
struct
óó  
NativeQueueDispose
óó -
{
òò 
[
ôô 	/
!NativeDisableUnsafePtrRestriction
ôô	 *
]
ôô* +
internal
öö 
NativeQueueData
öö  
*
öö  !
m_Buffer
öö" *
;
öö* +
[
úú 	/
!NativeDisableUnsafePtrRestriction
úú	 *
]
úú* +
internal
ùù &
NativeQueueBlockPoolData
ùù )
*
ùù) *
m_QueuePool
ùù+ 6
;
ùù6 7
internal
üü 
AllocatorManager
üü !
.
üü! "
AllocatorHandle
üü" 1
m_AllocatorLabel
üü2 B
;
üüB C
internal
¢¢  
AtomicSafetyHandle
¢¢ #
m_Safety
¢¢$ ,
;
¢¢, -
public
•• 
void
•• 
Dispose
•• 
(
•• 
)
•• 
{
¶¶ 	
NativeQueueData
ßß 
.
ßß 
DeallocateQueue
ßß +
(
ßß+ ,
m_Buffer
ßß, 4
,
ßß4 5
m_QueuePool
ßß6 A
,
ßßA B
m_AllocatorLabel
ßßC S
)
ßßS T
;
ßßT U
}
®® 	
}
©© 
[
´´ 
BurstCompile
´´ 
]
´´ 
struct
¨¨ 
#
NativeQueueDisposeJob
¨¨  
:
¨¨! "
IJob
¨¨# '
{
≠≠ 
public
ÆÆ  
NativeQueueDispose
ÆÆ !
Data
ÆÆ" &
;
ÆÆ& '
public
∞∞ 
void
∞∞ 
Execute
∞∞ 
(
∞∞ 
)
∞∞ 
{
±± 	
Data
≤≤ 
.
≤≤ 
Dispose
≤≤ 
(
≤≤ 
)
≤≤ 
;
≤≤ 
}
≥≥ 	
}
¥¥ 
}µµ ïâ
fC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeRingQueue.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{ 
[ 
BurstCompatible 
] 
internal		 
struct		 
RingControl		 
{

 
internal 
RingControl 
( 
int  
capacity! )
)) *
{ 	
Capacity 
= 
capacity 
;  
Current 
= 
$num 
; 
Write 
= 
$num 
; 
Read 
= 
$num 
; 
} 	
internal 
void 
Reset 
( 
) 
{ 	
Current 
= 
$num 
; 
Write 
= 
$num 
; 
Read 
= 
$num 
; 
} 	
internal 
int 
Distance 
( 
int !
from" &
,& '
int( +
to, .
). /
{ 	
var 
diff 
= 
to 
- 
from  
;  !
return 
diff 
< 
$num 
? 
Capacity &
-' (
math) -
.- .
abs. 1
(1 2
diff2 6
)6 7
:8 9
diff: >
;> ?
} 	
internal   
int   
	Available   
(   
)    
{!! 	
return"" 
Distance"" 
("" 
Read""  
,""  !
Current""" )
)"") *
;""* +
}## 	
internal%% 
int%% 
Reserve%% 
(%% 
int%%  
count%%! &
)%%& '
{&& 	
var'' 
dist'' 
='' 
Distance'' 
(''  
Write''  %
,''% &
Read''' +
)''+ ,
-''- .
$num''/ 0
;''0 1
var(( 
maxCount(( 
=(( 
dist(( 
<((  !
$num((" #
?(($ %
Capacity((& .
-((/ 0
$num((1 2
:((3 4
dist((5 9
;((9 :
var)) 
absCount)) 
=)) 
math)) 
.))  
abs))  #
())# $
count))$ )
)))) *
;))* +
var** 
test** 
=** 
absCount** 
-**  !
maxCount**" *
;*** +
count++ 
=++ 
test++ 
<++ 
$num++ 
?++ 
count++ $
:++% &
maxCount++' /
;++/ 0
Write,, 
=,, 
(,, 
Write,, 
+,, 
count,, "
),," #
%,,$ %
Capacity,,& .
;,,. /
return.. 
count.. 
;.. 
}// 	
internal11 
int11 
Commit11 
(11 
int11 
count11  %
)11% &
{22 	
var33 
maxCount33 
=33 
Distance33 #
(33# $
Current33$ +
,33+ ,
Write33- 2
)332 3
;333 4
var44 
absCount44 
=44 
math44 
.44  
abs44  #
(44# $
count44$ )
)44) *
;44* +
var55 
test55 
=55 
absCount55 
-55  !
maxCount55" *
;55* +
count66 
=66 
test66 
<66 
$num66 
?66 
count66 $
:66% &
maxCount66' /
;66/ 0
Current77 
=77 
(77 
Current77 
+77  
count77! &
)77& '
%77( )
Capacity77* 2
;772 3
return99 
count99 
;99 
}:: 	
internal<< 
int<< 
Consume<< 
(<< 
int<<  
count<<! &
)<<& '
{== 	
var>> 
maxCount>> 
=>> 
Distance>> #
(>># $
Read>>$ (
,>>( )
Current>>* 1
)>>1 2
;>>2 3
var?? 
absCount?? 
=?? 
math?? 
.??  
abs??  #
(??# $
count??$ )
)??) *
;??* +
var@@ 
test@@ 
=@@ 
absCount@@ 
-@@  !
maxCount@@" *
;@@* +
countAA 
=AA 
testAA 
<AA 
$numAA 
?AA 
countAA $
:AA% &
maxCountAA' /
;AA/ 0
ReadBB 
=BB 
(BB 
ReadBB 
+BB 
countBB  
)BB  !
%BB" #
CapacityBB$ ,
;BB, -
returnDD 
countDD 
;DD 
}EE 	
internalGG 
intGG 
LengthGG 
=>GG 
DistanceGG '
(GG' (
ReadGG( ,
,GG, -
WriteGG. 3
)GG3 4
;GG4 5
internalII 
readonlyII 
intII 
CapacityII &
;II& '
internalJJ 
intJJ 
CurrentJJ 
;JJ 
internalKK 
intKK 
WriteKK 
;KK 
internalLL 
intLL 
ReadLL 
;LL 
}MM 
[SS 
DebuggerDisplaySS 
(SS 
$strSS m
)SSm n
]SSn o
[TT 
DebuggerTypeProxyTT 
(TT 
typeofTT 
(TT $
UnsafeRingQueueDebugViewTT 6
<TT6 7
>TT7 8
)TT8 9
)TT9 :
]TT: ;
[UU 
BurstCompatibleUU 
(UU  
GenericTypeArgumentsUU )
=UU* +
newUU, /
[UU0 1
]UU1 2
{UU3 4
typeofUU5 ;
(UU; <
intUU< ?
)UU? @
}UUA B
)UUB C
]UUC D
publicVV 

unsafeVV 
structVV 
UnsafeRingQueueVV (
<VV( )
TVV) *
>VV* +
:WW 	
INativeDisposableWW
 
whereXX 
TXX 
:XX 
	unmanagedXX 
{YY 
[^^ 	-
!NativeDisableUnsafePtrRestriction^^	 *
]^^* +
public__ 
T__ 
*__ 
Ptr__ 
;__ 
publicee 
AllocatorManageree 
.ee  
AllocatorHandleee  /
	Allocatoree0 9
;ee9 :
internalgg 
RingControlgg 
Controlgg $
;gg$ %
publicmm 
boolmm 
IsEmptymm 
=>mm 
!mm  
	IsCreatedmm  )
||mm* ,
Lengthmm- 3
==mm4 6
$nummm7 8
;mm8 9
publicss 
intss 
Lengthss 
=>ss 
Controlss $
.ss$ %
Lengthss% +
;ss+ ,
publicyy 
intyy 
Capacityyy 
=>yy 
Controlyy &
.yy& '
Capacityyy' /
;yy/ 0
public
ÄÄ 
UnsafeRingQueue
ÄÄ 
(
ÄÄ 
T
ÄÄ  
*
ÄÄ  !
ptr
ÄÄ" %
,
ÄÄ% &
int
ÄÄ' *
capacity
ÄÄ+ 3
)
ÄÄ3 4
{
ÅÅ 	
Ptr
ÇÇ 
=
ÇÇ 
ptr
ÇÇ 
;
ÇÇ 
	Allocator
ÉÉ 
=
ÉÉ 
AllocatorManager
ÉÉ (
.
ÉÉ( )
None
ÉÉ) -
;
ÉÉ- .
Control
ÑÑ 
=
ÑÑ 
new
ÑÑ 
RingControl
ÑÑ %
(
ÑÑ% &
capacity
ÑÑ& .
)
ÑÑ. /
;
ÑÑ/ 0
}
ÖÖ 	
public
çç 
UnsafeRingQueue
çç 
(
çç 
int
çç "
capacity
çç# +
,
çç+ ,
AllocatorManager
çç- =
.
çç= >
AllocatorHandle
çç> M
	allocator
ççN W
,
ççW X 
NativeArrayOptions
ççY k
options
ççl s
=
ççt u!
NativeArrayOptionsççv à
.ççà â
ClearMemoryççâ î
)ççî ï
{
éé 	
capacity
èè 
+=
èè 
$num
èè 
;
èè 
	Allocator
ëë 
=
ëë 
	allocator
ëë !
;
ëë! "
Control
íí 
=
íí 
new
íí 
RingControl
íí %
(
íí% &
capacity
íí& .
)
íí. /
;
íí/ 0
var
ìì 
sizeInBytes
ìì 
=
ìì 
capacity
ìì &
*
ìì' (
UnsafeUtility
ìì) 6
.
ìì6 7
SizeOf
ìì7 =
<
ìì= >
T
ìì> ?
>
ìì? @
(
ìì@ A
)
ììA B
;
ììB C
Ptr
îî 
=
îî 
(
îî 
T
îî 
*
îî 
)
îî 
Memory
îî 
.
îî 
	Unmanaged
îî &
.
îî& '
Allocate
îî' /
(
îî/ 0
sizeInBytes
îî0 ;
,
îî; <
$num
îî= ?
,
îî? @
	allocator
îîA J
)
îîJ K
;
îîK L
if
ññ 
(
ññ 
options
ññ 
==
ññ  
NativeArrayOptions
ññ -
.
ññ- .
ClearMemory
ññ. 9
)
ññ9 :
{
óó 
UnsafeUtility
òò 
.
òò 
MemClear
òò &
(
òò& '
Ptr
òò' *
,
òò* +
sizeInBytes
òò, 7
)
òò7 8
;
òò8 9
}
ôô 
}
öö 	
public
†† 
bool
†† 
	IsCreated
†† 
=>
††  
Ptr
††! $
!=
††% '
null
††( ,
;
††, -
public
•• 
void
•• 
Dispose
•• 
(
•• 
)
•• 
{
¶¶ 	
if
ßß 
(
ßß 
CollectionHelper
ßß  
.
ßß  !
ShouldDeallocate
ßß! 1
(
ßß1 2
	Allocator
ßß2 ;
)
ßß; <
)
ßß< =
{
®® 
Memory
©© 
.
©© 
	Unmanaged
©©  
.
©©  !
Free
©©! %
(
©©% &
Ptr
©©& )
,
©©) *
	Allocator
©©+ 4
)
©©4 5
;
©©5 6
	Allocator
™™ 
=
™™ 
AllocatorManager
™™ ,
.
™™, -
Invalid
™™- 4
;
™™4 5
}
´´ 
Ptr
≠≠ 
=
≠≠ 
null
≠≠ 
;
≠≠ 
}
ÆÆ 	
[
µµ 	 
NotBurstCompatible
µµ	 
]µµú ù
public
∂∂ 
	JobHandle
∂∂ 
Dispose
∂∂  
(
∂∂  !
	JobHandle
∂∂! *
	inputDeps
∂∂+ 4
)
∂∂4 5
{
∑∑ 	
if
∏∏ 
(
∏∏ 
CollectionHelper
∏∏  
.
∏∏  !
ShouldDeallocate
∏∏! 1
(
∏∏1 2
	Allocator
∏∏2 ;
)
∏∏; <
)
∏∏< =
{
ππ 
var
∫∫ 
	jobHandle
∫∫ 
=
∫∫ 
new
∫∫  #
UnsafeDisposeJob
∫∫$ 4
{
∫∫5 6
Ptr
∫∫7 :
=
∫∫; <
Ptr
∫∫= @
,
∫∫@ A
	Allocator
∫∫B K
=
∫∫L M
	Allocator
∫∫N W
}
∫∫X Y
.
∫∫Y Z
Schedule
∫∫Z b
(
∫∫b c
	inputDeps
∫∫c l
)
∫∫l m
;
∫∫m n
Ptr
ºº 
=
ºº 
null
ºº 
;
ºº 
	Allocator
ΩΩ 
=
ΩΩ 
AllocatorManager
ΩΩ ,
.
ΩΩ, -
Invalid
ΩΩ- 4
;
ΩΩ4 5
return
øø 
	jobHandle
øø  
;
øø  !
}
¿¿ 
Ptr
¬¬ 
=
¬¬ 
null
¬¬ 
;
¬¬ 
return
ƒƒ 
	inputDeps
ƒƒ 
;
ƒƒ 
}
≈≈ 	
public
ÕÕ 
bool
ÕÕ 

TryEnqueue
ÕÕ 
(
ÕÕ 
T
ÕÕ  
value
ÕÕ! &
)
ÕÕ& '
{
ŒŒ 	
if
œœ 
(
œœ 
$num
œœ 
!=
œœ 
Control
œœ 
.
œœ 
Reserve
œœ $
(
œœ$ %
$num
œœ% &
)
œœ& '
)
œœ' (
{
–– 
return
—— 
false
—— 
;
—— 
}
““ 
Ptr
‘‘ 
[
‘‘ 
Control
‘‘ 
.
‘‘ 
Current
‘‘ 
]
‘‘  
=
‘‘! "
value
‘‘# (
;
‘‘( )
Control
’’ 
.
’’ 
Commit
’’ 
(
’’ 
$num
’’ 
)
’’ 
;
’’ 
return
◊◊ 
true
◊◊ 
;
◊◊ 
}
ÿÿ 	
[
⁄⁄ 	
Conditional
⁄⁄	 
(
⁄⁄ 
$str
⁄⁄ 6
)
⁄⁄6 7
]
⁄⁄7 8
static
€€ 
void
€€ 
ThrowQueueFull
€€ "
(
€€" #
)
€€# $
{
‹‹ 	
throw
›› 
new
›› '
InvalidOperationException
›› /
(
››/ 0
$str
››0 T
)
››T U
;
››U V
}
ﬁﬁ 	
public
ÂÂ 
void
ÂÂ 
Enqueue
ÂÂ 
(
ÂÂ 
T
ÂÂ 
value
ÂÂ #
)
ÂÂ# $
{
ÊÊ 	
if
ÁÁ 
(
ÁÁ 
!
ÁÁ 

TryEnqueue
ÁÁ 
(
ÁÁ 
value
ÁÁ !
)
ÁÁ! "
)
ÁÁ" #
{
ËË 
ThrowQueueFull
ÈÈ 
(
ÈÈ 
)
ÈÈ  
;
ÈÈ  !
}
ÍÍ 
}
ÎÎ 	
public
ÛÛ 
bool
ÛÛ 

TryDequeue
ÛÛ 
(
ÛÛ 
out
ÛÛ "
T
ÛÛ# $
item
ÛÛ% )
)
ÛÛ) *
{
ÙÙ 	
item
ıı 
=
ıı 
Ptr
ıı 
[
ıı 
Control
ıı 
.
ıı 
Read
ıı #
]
ıı# $
;
ıı$ %
return
ˆˆ 
$num
ˆˆ 
==
ˆˆ 
Control
ˆˆ 
.
ˆˆ  
Consume
ˆˆ  '
(
ˆˆ' (
$num
ˆˆ( )
)
ˆˆ) *
;
ˆˆ* +
}
˜˜ 	
[
˘˘ 	
Conditional
˘˘	 
(
˘˘ 
$str
˘˘ 6
)
˘˘6 7
]
˘˘7 8
static
˙˙ 
void
˙˙ 
ThrowQueueEmpty
˙˙ #
(
˙˙# $
)
˙˙$ %
{
˚˚ 	
throw
¸¸ 
new
¸¸ '
InvalidOperationException
¸¸ /
(
¸¸/ 0
$str
¸¸0 W
)
¸¸W X
;
¸¸X Y
}
˝˝ 	
public
ÑÑ 
T
ÑÑ 
Dequeue
ÑÑ 
(
ÑÑ 
)
ÑÑ 
{
ÖÖ 	
if
ÜÜ 
(
ÜÜ 
!
ÜÜ 

TryDequeue
ÜÜ 
(
ÜÜ 
out
ÜÜ 
T
ÜÜ  !
item
ÜÜ" &
)
ÜÜ& '
)
ÜÜ' (
{
áá 
ThrowQueueEmpty
àà 
(
àà  
)
àà  !
;
àà! "
}
ââ 
return
ãã 
item
ãã 
;
ãã 
}
åå 	
}
çç 
internal
èè 
sealed
èè 
class
èè &
UnsafeRingQueueDebugView
èè 2
<
èè2 3
T
èè3 4
>
èè4 5
where
êê 
T
êê 
:
êê 
	unmanaged
êê 
{
ëë 
UnsafeRingQueue
íí 
<
íí 
T
íí 
>
íí 
Data
íí 
;
íí  
public
îî &
UnsafeRingQueueDebugView
îî '
(
îî' (
UnsafeRingQueue
îî( 7
<
îî7 8
T
îî8 9
>
îî9 :
data
îî; ?
)
îî? @
{
ïï 	
Data
ññ 
=
ññ 
data
ññ 
;
ññ 
}
óó 	
public
ôô 
unsafe
ôô 
T
ôô 
[
ôô 
]
ôô 
Items
ôô 
{
öö 	
get
õõ 
{
úú 
T
ùù 
[
ùù 
]
ùù 
result
ùù 
=
ùù 
new
ùù  
T
ùù! "
[
ùù" #
Data
ùù# '
.
ùù' (
Length
ùù( .
]
ùù. /
;
ùù/ 0
var
üü 
read
üü 
=
üü 
Data
üü 
.
üü  
Control
üü  '
.
üü' (
Read
üü( ,
;
üü, -
var
†† 
capacity
†† 
=
†† 
Data
†† #
.
††# $
Control
††$ +
.
††+ ,
Capacity
††, 4
;
††4 5
for
¢¢ 
(
¢¢ 
var
¢¢ 
i
¢¢ 
=
¢¢ 
$num
¢¢ 
;
¢¢ 
i
¢¢  !
<
¢¢" #
result
¢¢$ *
.
¢¢* +
Length
¢¢+ 1
;
¢¢1 2
++
¢¢3 5
i
¢¢5 6
)
¢¢6 7
{
££ 
result
§§ 
[
§§ 
i
§§ 
]
§§ 
=
§§ 
Data
§§  $
.
§§$ %
Ptr
§§% (
[
§§( )
(
§§) *
read
§§* .
+
§§/ 0
i
§§1 2
)
§§2 3
%
§§4 5
capacity
§§6 >
]
§§> ?
;
§§? @
}
•• 
return
ßß 
result
ßß 
;
ßß 
}
®® 
}
©© 	
}
™™ 
}´´ ’…
cC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeStream.cs
	namespace 	
Unity
 
. 
Collections 
{		 
[!! 
NativeContainer!! 
]!! 
["" 
BurstCompatible"" 
]"" 
public## 

unsafe## 
struct## 
NativeStream## %
:##& '
IDisposable##( 3
{$$ 
UnsafeStream%% 
m_Stream%% 
;%% 
AtomicSafetyHandle(( 
m_Safety(( #
;((# $
internal)) 
static)) 
readonly))  
SharedStatic))! -
<))- .
int)). 1
>))1 2
s_staticSafetyId))3 C
=))D E
SharedStatic))F R
<))R S
int))S V
>))V W
.))W X
GetOrCreate))X c
<))c d
NativeStream))d p
>))p q
())q r
)))r s
;))s t
[-- 	.
"NativeSetClassTypeToNullOnSchedule--	 +
]--+ ,
DisposeSentinel.. 
m_DisposeSentinel.. )
;..) *
public88 
NativeStream88 
(88 
int88 
bufferCount88  +
,88+ ,
AllocatorManager88- =
.88= >
AllocatorHandle88> M
	allocator88N W
)88W X
{99 	
AllocateBlock:: 
(:: 
out:: 
this:: "
,::" #
	allocator::$ -
)::- .
;::. /
m_Stream;; 
.;; 
AllocateForEach;; $
(;;$ %
bufferCount;;% 0
);;0 1
;;;1 2
}<< 	
[KK 	
NotBurstCompatibleKK	 
]
KKú ù
publicLL 
staticLL 
	JobHandleLL 
ScheduleConstructLL  1
<LL1 2
TLL2 3
>LL3 4
(LL4 5
outLL5 8
NativeStreamLL9 E
streamLLF L
,LLL M

NativeListLLN X
<LLX Y
TLLY Z
>LLZ [
bufferCountLL\ g
,LLg h
	JobHandleLLi r

dependencyLLs }
,LL} ~
AllocatorManager	LL è
.
LLè ê
AllocatorHandle
LLê ü
	allocator
LL† ©
)
LL© ™
whereMM 
TMM 
:MM 
	unmanagedMM 
{NN 	
AllocateBlockOO 
(OO 
outOO 
streamOO $
,OO$ %
	allocatorOO& /
)OO/ 0
;OO0 1
varPP 
jobDataPP 
=PP 
newPP 
ConstructJobListPP .
{PP/ 0
ListPP1 5
=PP6 7
(PP8 9
UntypedUnsafeListPP9 J
*PPJ K
)PPK L
bufferCountPPL W
.PPW X
GetUnsafeListPPX e
(PPe f
)PPf g
,PPg h
	ContainerPPi r
=PPs t
streamPPu {
}PP| }
;PP} ~
returnQQ 
jobDataQQ 
.QQ 
ScheduleQQ #
(QQ# $

dependencyQQ$ .
)QQ. /
;QQ/ 0
}RR 	
[bb 	
NotBurstCompatiblebb	 
]
bbú ù
publiccc 
staticcc 
	JobHandlecc 
ScheduleConstructcc  1
(cc1 2
outcc2 5
NativeStreamcc6 B
streamccC I
,ccI J
NativeArrayccK V
<ccV W
intccW Z
>ccZ [
bufferCountcc\ g
,ccg h
	JobHandlecci r

dependencyccs }
,cc} ~
AllocatorManager	cc è
.
ccè ê
AllocatorHandle
ccê ü
	allocator
cc† ©
)
cc© ™
{dd 	
AllocateBlockee 
(ee 
outee 
streamee $
,ee$ %
	allocatoree& /
)ee/ 0
;ee0 1
varff 
jobDataff 
=ff 
newff 
ConstructJobff *
{ff+ ,
Lengthff- 3
=ff4 5
bufferCountff6 A
,ffA B
	ContainerffC L
=ffM N
streamffO U
}ffV W
;ffW X
returngg 
jobDatagg 
.gg 
Schedulegg #
(gg# $

dependencygg$ .
)gg. /
;gg/ 0
}hh 	
publicnn 
boolnn 
IsEmptynn 
(nn 
)nn 
{oo 	
CheckReadAccesspp 
(pp 
)pp 
;pp 
returnqq 
m_Streamqq 
.qq 
IsEmptyqq #
(qq# $
)qq$ %
;qq% &
}rr 	
publicyy 
boolyy 
	IsCreatedyy 
=>yy  
m_Streamyy! )
.yy) *
	IsCreatedyy* 3
;yy3 4
public 
int 
ForEachCount 
{
ÄÄ 	
get
ÅÅ 
{
ÇÇ 
CheckReadAccess
ÉÉ 
(
ÉÉ  
)
ÉÉ  !
;
ÉÉ! "
return
ÑÑ 
m_Stream
ÑÑ 
.
ÑÑ  
ForEachCount
ÑÑ  ,
;
ÑÑ, -
}
ÖÖ 
}
ÜÜ 	
public
åå 
Reader
åå 
AsReader
åå 
(
åå 
)
åå  
{
çç 	
return
éé 
new
éé 
Reader
éé 
(
éé 
ref
éé !
this
éé" &
)
éé& '
;
éé' (
}
èè 	
public
ïï 
Writer
ïï 
AsWriter
ïï 
(
ïï 
)
ïï  
{
ññ 	
return
óó 
new
óó 
Writer
óó 
(
óó 
ref
óó !
this
óó" &
)
óó& '
;
óó' (
}
òò 	
public
üü 
int
üü 
Count
üü 
(
üü 
)
üü 
{
†† 	
CheckReadAccess
°° 
(
°° 
)
°° 
;
°° 
return
¢¢ 
m_Stream
¢¢ 
.
¢¢ 
Count
¢¢ !
(
¢¢! "
)
¢¢" #
;
¢¢# $
}
££ 	
[
ØØ 	
BurstCompatible
ØØ	 
(
ØØ "
GenericTypeArguments
ØØ -
=
ØØ. /
new
ØØ0 3
[
ØØ4 5
]
ØØ5 6
{
ØØ7 8
typeof
ØØ9 ?
(
ØØ? @
int
ØØ@ C
)
ØØC D
}
ØØE F
)
ØØF G
]
ØØG H
public
∞∞ 
NativeArray
∞∞ 
<
∞∞ 
T
∞∞ 
>
∞∞ 
ToNativeArray
∞∞ +
<
∞∞+ ,
T
∞∞, -
>
∞∞- .
(
∞∞. /
AllocatorManager
∞∞/ ?
.
∞∞? @
AllocatorHandle
∞∞@ O
	allocator
∞∞P Y
)
∞∞Y Z
where
∞∞[ `
T
∞∞a b
:
∞∞c d
struct
∞∞e k
{
±± 	
CheckReadAccess
≤≤ 
(
≤≤ 
)
≤≤ 
;
≤≤ 
return
≥≥ 
m_Stream
≥≥ 
.
≥≥ 
ToNativeArray
≥≥ )
<
≥≥) *
T
≥≥* +
>
≥≥+ ,
(
≥≥, -
	allocator
≥≥- 6
)
≥≥6 7
;
≥≥7 8
}
¥¥ 	
public
ππ 
void
ππ 
Dispose
ππ 
(
ππ 
)
ππ 
{
∫∫ 	
DisposeSentinel
øø 
.
øø 
Dispose
øø #
(
øø# $
ref
øø$ '
m_Safety
øø( 0
,
øø0 1
ref
øø2 5
m_DisposeSentinel
øø6 G
)
øøG H
;
øøH I
m_Stream
¬¬ 
.
¬¬ 
Dispose
¬¬ 
(
¬¬ 
)
¬¬ 
;
¬¬ 
}
√√ 	
[
   	 
NotBurstCompatible
  	 
]  ú ù
public
ÀÀ 
	JobHandle
ÀÀ 
Dispose
ÀÀ  
(
ÀÀ  !
	JobHandle
ÀÀ! *
	inputDeps
ÀÀ+ 4
)
ÀÀ4 5
{
ÃÃ 	
DisposeSentinel
‘‘ 
.
‘‘ 
Clear
‘‘ !
(
‘‘! "
ref
‘‘" %
m_DisposeSentinel
‘‘& 7
)
‘‘7 8
;
‘‘8 9
var
◊◊ 
	jobHandle
◊◊ 
=
◊◊ 
m_Stream
◊◊ $
.
◊◊$ %
Dispose
◊◊% ,
(
◊◊, -
	inputDeps
◊◊- 6
)
◊◊6 7
;
◊◊7 8 
AtomicSafetyHandle
⁄⁄ 
.
⁄⁄ 
Release
⁄⁄ &
(
⁄⁄& '
m_Safety
⁄⁄' /
)
⁄⁄/ 0
;
⁄⁄0 1
return
‹‹ 
	jobHandle
‹‹ 
;
‹‹ 
}
›› 	
[
ﬂﬂ 	
BurstCompile
ﬂﬂ	 
]
ﬂﬂ 
struct
‡‡ 
ConstructJobList
‡‡ 
:
‡‡  !
IJob
‡‡" &
{
·· 	
public
‚‚ 
NativeStream
‚‚ 
	Container
‚‚  )
;
‚‚) *
[
‰‰ 
ReadOnly
‰‰ 
]
‰‰ 
[
ÂÂ /
!NativeDisableUnsafePtrRestriction
ÂÂ .
]
ÂÂ. /
public
ÊÊ 
UntypedUnsafeList
ÊÊ $
*
ÊÊ$ %
List
ÊÊ& *
;
ÊÊ* +
public
ËË 
void
ËË 
Execute
ËË 
(
ËË  
)
ËË  !
{
ÈÈ 
	Container
ÍÍ 
.
ÍÍ 
AllocateForEach
ÍÍ )
(
ÍÍ) *
List
ÍÍ* .
->
ÍÍ. 0
m_length
ÍÍ0 8
)
ÍÍ8 9
;
ÍÍ9 :
}
ÎÎ 
}
ÏÏ 	
[
ÓÓ 	
BurstCompile
ÓÓ	 
]
ÓÓ 
struct
ÔÔ 
ConstructJob
ÔÔ 
:
ÔÔ 
IJob
ÔÔ "
{
 	
public
ÒÒ 
NativeStream
ÒÒ 
	Container
ÒÒ  )
;
ÒÒ) *
[
ÛÛ 
ReadOnly
ÛÛ 
]
ÛÛ 
public
ÙÙ 
NativeArray
ÙÙ 
<
ÙÙ 
int
ÙÙ "
>
ÙÙ" #
Length
ÙÙ$ *
;
ÙÙ* +
public
ˆˆ 
void
ˆˆ 
Execute
ˆˆ 
(
ˆˆ  
)
ˆˆ  !
{
˜˜ 
	Container
¯¯ 
.
¯¯ 
AllocateForEach
¯¯ )
(
¯¯) *
Length
¯¯* 0
[
¯¯0 1
$num
¯¯1 2
]
¯¯2 3
)
¯¯3 4
;
¯¯4 5
}
˘˘ 
}
˙˙ 	
static
¸¸ 
void
¸¸ 
AllocateBlock
¸¸ !
(
¸¸! "
out
¸¸" %
NativeStream
¸¸& 2
stream
¸¸3 9
,
¸¸9 :
AllocatorManager
¸¸; K
.
¸¸K L
AllocatorHandle
¸¸L [
	allocator
¸¸\ e
)
¸¸e f
{
˝˝ 	
CollectionHelper
˛˛ 
.
˛˛ 
CheckAllocator
˛˛ +
(
˛˛+ ,
	allocator
˛˛, 5
)
˛˛5 6
;
˛˛6 7
UnsafeStream
ÄÄ 
.
ÄÄ 
AllocateBlock
ÄÄ &
(
ÄÄ& '
out
ÄÄ' *
stream
ÄÄ+ 1
.
ÄÄ1 2
m_Stream
ÄÄ2 :
,
ÄÄ: ;
	allocator
ÄÄ< E
)
ÄÄE F
;
ÄÄF G
if
ÜÜ 
(
ÜÜ 
	allocator
ÜÜ 
.
ÜÜ 
IsCustomAllocator
ÜÜ +
)
ÜÜ+ ,
{
áá 
stream
àà 
.
àà 
m_Safety
àà 
=
àà  ! 
AtomicSafetyHandle
àà" 4
.
àà4 5
Create
àà5 ;
(
àà; <
)
àà< =
;
àà= >
stream
ââ 
.
ââ 
m_DisposeSentinel
ââ (
=
ââ) *
null
ââ+ /
;
ââ/ 0
}
ää 
else
ãã 
{
åå 
DisposeSentinel
çç 
.
çç  
Create
çç  &
(
çç& '
out
çç' *
stream
çç+ 1
.
çç1 2
m_Safety
çç2 :
,
çç: ;
out
çç< ?
stream
çç@ F
.
ççF G
m_DisposeSentinel
ççG X
,
ççX Y
$num
ççZ [
,
çç[ \
	allocator
çç] f
.
ççf g
ToAllocator
ççg r
)
ççr s
;
ççs t
}
éé 
CollectionHelper
ëë 
.
ëë 
SetStaticSafetyId
ëë .
(
ëë. /
ref
ëë/ 2
stream
ëë3 9
.
ëë9 :
m_Safety
ëë: B
,
ëëB C
ref
ëëD G
s_staticSafetyId
ëëH X
.
ëëX Y
Data
ëëY ]
,
ëë] ^
$str
ëë_ 
)ëë Ä
;ëëÄ Å
}
ìì 	
void
ïï 
AllocateForEach
ïï 
(
ïï 
int
ïï  
forEachCount
ïï! -
)
ïï- .
{
ññ 	.
 CheckForEachCountGreaterThanZero
òò ,
(
òò, -
forEachCount
òò- 9
)
òò9 :
;
òò: ;
Assert
ôô 
.
ôô 
IsTrue
ôô 
(
ôô 
m_Stream
ôô "
.
ôô" #
m_Block
ôô# *
->
ôô* ,
Ranges
ôô, 2
==
ôô3 5
null
ôô6 :
)
ôô: ;
;
ôô; <
Assert
öö 
.
öö 
AreEqual
öö 
(
öö 
$num
öö 
,
öö 
m_Stream
öö '
.
öö' (
m_Block
öö( /
->
öö/ 1

RangeCount
öö1 ;
)
öö; <
;
öö< =
Assert
õõ 
.
õõ 
AreNotEqual
õõ 
(
õõ 
$num
õõ  
,
õõ  !
m_Stream
õõ" *
.
õõ* +
m_Block
õõ+ 2
->
õõ2 4

BlockCount
õõ4 >
)
õõ> ?
;
õõ? @
m_Stream
ûû 
.
ûû 
AllocateForEach
ûû $
(
ûû$ %
forEachCount
ûû% 1
)
ûû1 2
;
ûû2 3
}
üü 	
[
¶¶ 	
NativeContainer
¶¶	 
]
¶¶ 
[
ßß 	;
-NativeContainerSupportsMinMaxWriteRestriction
ßß	 6
]
ßß6 7
[
®® 	
BurstCompatible
®®	 
]
®® 
public
©© 
unsafe
©© 
struct
©© 
Writer
©© #
{
™™ 	
UnsafeStream
´´ 
.
´´ 
Writer
´´ 
m_Writer
´´  (
;
´´( ) 
AtomicSafetyHandle
ÆÆ 
m_Safety
ÆÆ '
;
ÆÆ' (
internal
ØØ 
static
ØØ 
readonly
ØØ $
SharedStatic
ØØ% 1
<
ØØ1 2
int
ØØ2 5
>
ØØ5 6
s_staticSafetyId
ØØ7 G
=
ØØH I
SharedStatic
ØØJ V
<
ØØV W
int
ØØW Z
>
ØØZ [
.
ØØ[ \
GetOrCreate
ØØ\ g
<
ØØg h
Writer
ØØh n
>
ØØn o
(
ØØo p
)
ØØp q
;
ØØq r
int
±± 
m_Length
±± 
;
±± 
int
≥≥ 

m_MinIndex
≥≥ 
;
≥≥ 
int
¥¥ 

m_MaxIndex
¥¥ 
;
¥¥ 
[
∂∂ /
!NativeDisableUnsafePtrRestriction
∂∂ .
]
∂∂. /
void
∑∑ 
*
∑∑ 
m_PassByRefCheck
∑∑ "
;
∑∑" #
internal
∫∫ 
Writer
∫∫ 
(
∫∫ 
ref
∫∫ 
NativeStream
∫∫  ,
stream
∫∫- 3
)
∫∫3 4
{
ªª 
m_Writer
ºº 
=
ºº 
stream
ºº !
.
ºº! "
m_Stream
ºº" *
.
ºº* +
AsWriter
ºº+ 3
(
ºº3 4
)
ºº4 5
;
ºº5 6
m_Safety
øø 
=
øø 
stream
øø !
.
øø! "
m_Safety
øø" *
;
øø* +
CollectionHelper
¿¿  
.
¿¿  !
SetStaticSafetyId
¿¿! 2
(
¿¿2 3
ref
¿¿3 6
m_Safety
¿¿7 ?
,
¿¿? @
ref
¿¿A D
s_staticSafetyId
¿¿E U
.
¿¿U V
Data
¿¿V Z
,
¿¿Z [
$str¿¿\ É
)¿¿É Ñ
;¿¿Ñ Ö
m_Length
¡¡ 
=
¡¡ 
int
¡¡ 
.
¡¡ 
MaxValue
¡¡ '
;
¡¡' (

m_MinIndex
¬¬ 
=
¬¬ 
int
¬¬  
.
¬¬  !
MinValue
¬¬! )
;
¬¬) *

m_MaxIndex
√√ 
=
√√ 
int
√√  
.
√√  !
MinValue
√√! )
;
√√) *
m_PassByRefCheck
ƒƒ  
=
ƒƒ! "
null
ƒƒ# '
;
ƒƒ' (
}
∆∆ 
public
ÃÃ 
int
ÃÃ 
ForEachCount
ÃÃ #
{
ÕÕ 
get
ŒŒ 
{
œœ  
AtomicSafetyHandle
—— &
.
——& ' 
CheckWriteAndThrow
——' 9
(
——9 :
m_Safety
——: B
)
——B C
;
——C D
return
”” 
m_Writer
”” #
.
””# $
ForEachCount
””$ 0
;
””0 1
}
‘‘ 
}
’’ 
public
€€ 
void
€€ 
PatchMinMaxRange
€€ (
(
€€( )
int
€€) ,
foreEachIndex
€€- :
)
€€: ;
{
‹‹ 

m_MinIndex
ﬁﬁ 
=
ﬁﬁ 
foreEachIndex
ﬁﬁ *
;
ﬁﬁ* +

m_MaxIndex
ﬂﬂ 
=
ﬂﬂ 
foreEachIndex
ﬂﬂ *
;
ﬂﬂ* +
}
·· 
public
ÍÍ 
void
ÍÍ 
BeginForEachIndex
ÍÍ )
(
ÍÍ) *
int
ÍÍ* -
foreachIndex
ÍÍ. :
)
ÍÍ: ;
{
ÎÎ $
CheckBeginForEachIndex
ÌÌ &
(
ÌÌ& '
foreachIndex
ÌÌ' 3
)
ÌÌ3 4
;
ÌÌ4 5
m_Writer
ÓÓ 
.
ÓÓ 
BeginForEachIndex
ÓÓ *
(
ÓÓ* +
foreachIndex
ÓÓ+ 7
)
ÓÓ7 8
;
ÓÓ8 9
}
ÔÔ 
public
ıı 
void
ıı 
EndForEachIndex
ıı '
(
ıı' (
)
ıı( )
{
ˆˆ "
CheckEndForEachIndex
˜˜ $
(
˜˜$ %
)
˜˜% &
;
˜˜& '
m_Writer
¯¯ 
.
¯¯ 
EndForEachIndex
¯¯ (
(
¯¯( )
)
¯¯) *
;
¯¯* +
m_Writer
˚˚ 
.
˚˚ 
m_ForeachIndex
˚˚ '
=
˚˚( )
int
˚˚* -
.
˚˚- .
MinValue
˚˚. 6
;
˚˚6 7
}
˝˝ 
[
ÜÜ 
BurstCompatible
ÜÜ 
(
ÜÜ "
GenericTypeArguments
ÜÜ 1
=
ÜÜ2 3
new
ÜÜ4 7
[
ÜÜ8 9
]
ÜÜ9 :
{
ÜÜ; <
typeof
ÜÜ= C
(
ÜÜC D
int
ÜÜD G
)
ÜÜG H
}
ÜÜI J
)
ÜÜJ K
]
ÜÜK L
public
áá 
void
áá 
Write
áá 
<
áá 
T
áá 
>
áá  
(
áá  !
T
áá! "
value
áá# (
)
áá( )
where
áá* /
T
áá0 1
:
áá2 3
struct
áá4 :
{
àà 
ref
ââ 
T
ââ 
dst
ââ 
=
ââ 
ref
ââ 
Allocate
ââ  (
<
ââ( )
T
ââ) *
>
ââ* +
(
ââ+ ,
)
ââ, -
;
ââ- .
dst
ää 
=
ää 
value
ää 
;
ää 
}
ãã 
[
îî 
BurstCompatible
îî 
(
îî "
GenericTypeArguments
îî 1
=
îî2 3
new
îî4 7
[
îî8 9
]
îî9 :
{
îî; <
typeof
îî= C
(
îîC D
int
îîD G
)
îîG H
}
îîI J
)
îîJ K
]
îîK L
public
ïï 
ref
ïï 
T
ïï 
Allocate
ïï !
<
ïï! "
T
ïï" #
>
ïï# $
(
ïï$ %
)
ïï% &
where
ïï' ,
T
ïï- .
:
ïï/ 0
struct
ïï1 7
{
ññ 
CollectionHelper
óó  
.
óó  !
CheckIsUnmanaged
óó! 1
<
óó1 2
T
óó2 3
>
óó3 4
(
óó4 5
)
óó5 6
;
óó6 7
int
òò 
size
òò 
=
òò 
UnsafeUtility
òò (
.
òò( )
SizeOf
òò) /
<
òò/ 0
T
òò0 1
>
òò1 2
(
òò2 3
)
òò3 4
;
òò4 5
return
ôô 
ref
ôô 
UnsafeUtility
ôô (
.
ôô( )
AsRef
ôô) .
<
ôô. /
T
ôô/ 0
>
ôô0 1
(
ôô1 2
Allocate
ôô2 :
(
ôô: ;
size
ôô; ?
)
ôô? @
)
ôô@ A
;
ôôA B
}
öö 
public
££ 
byte
££ 
*
££ 
Allocate
££ !
(
££! "
int
££" %
size
££& *
)
££* +
{
§§ 
CheckAllocateSize
•• !
(
••! "
size
••" &
)
••& '
;
••' (
return
¶¶ 
m_Writer
¶¶ 
.
¶¶  
Allocate
¶¶  (
(
¶¶( )
size
¶¶) -
)
¶¶- .
;
¶¶. /
}
ßß 
[
©© 
Conditional
©© 
(
©© 
$str
©© :
)
©©: ;
]
©©; <
void
™™ $
CheckBeginForEachIndex
™™ '
(
™™' (
int
™™( +
foreachIndex
™™, 8
)
™™8 9
{
´´  
AtomicSafetyHandle
≠≠ "
.
≠≠" # 
CheckWriteAndThrow
≠≠# 5
(
≠≠5 6
m_Safety
≠≠6 >
)
≠≠> ?
;
≠≠? @
if
ØØ 
(
ØØ 
m_PassByRefCheck
ØØ $
==
ØØ% '
null
ØØ( ,
)
ØØ, -
{
∞∞ 
m_PassByRefCheck
±± $
=
±±% &
UnsafeUtility
±±' 4
.
±±4 5
	AddressOf
±±5 >
(
±±> ?
ref
±±? B
this
±±C G
)
±±G H
;
±±H I
}
≤≤ 
if
¥¥ 
(
¥¥ 
foreachIndex
¥¥  
<
¥¥! "

m_MinIndex
¥¥# -
||
¥¥. 0
foreachIndex
¥¥1 =
>
¥¥> ?

m_MaxIndex
¥¥@ J
)
¥¥J K
{
µµ 
if
ππ 
(
ππ 

m_MinIndex
ππ "
==
ππ# %
int
ππ& )
.
ππ) *
MinValue
ππ* 2
&&
ππ3 5

m_MaxIndex
ππ6 @
==
ππA C
int
ππD G
.
ππG H
MinValue
ππH P
)
ππP Q
{
∫∫ 

m_MinIndex
ªª "
=
ªª# $
$num
ªª% &
;
ªª& '

m_MaxIndex
ºº "
=
ºº# $
m_Writer
ºº% -
.
ºº- .
m_BlockStream
ºº. ;
->
ºº; =

RangeCount
ºº= G
-
ººH I
$num
ººJ K
;
ººK L
}
ΩΩ 
if
øø 
(
øø 
foreachIndex
øø $
<
øø% &

m_MinIndex
øø' 1
||
øø2 4
foreachIndex
øø5 A
>
øøB C

m_MaxIndex
øøD N
)
øøN O
{
¿¿ 
throw
¡¡ 
new
¡¡ !
ArgumentException
¡¡" 3
(
¡¡3 4
$"
¡¡4 6
$str
¡¡6 <
{
¡¡< =
foreachIndex
¡¡= I
}
¡¡I J
$str
¡¡J w
{
¡¡w x

m_MinIndex¡¡x Ç
}¡¡Ç É
$str¡¡É Ü
{¡¡Ü á

m_MaxIndex¡¡á ë
}¡¡ë í
$str¡¡í §
"¡¡§ •
)¡¡• ¶
;¡¡¶ ß
}
¬¬ 
}
√√ 
if
≈≈ 
(
≈≈ 
m_Writer
≈≈ 
.
≈≈ 
m_ForeachIndex
≈≈ +
!=
≈≈, .
int
≈≈/ 2
.
≈≈2 3
MinValue
≈≈3 ;
)
≈≈; <
{
∆∆ 
throw
«« 
new
«« 
ArgumentException
«« /
(
««/ 0
$"
««0 2
$str
««2 u
"
««u v
)
««v w
;
««w x
}
»» 
if
   
(
   
$num
   
!=
   
m_Writer
   !
.
  ! "
m_BlockStream
  " /
->
  / 1
Ranges
  1 7
[
  7 8
foreachIndex
  8 D
]
  D E
.
  E F
ElementCount
  F R
)
  R S
{
ÀÀ 
throw
ÃÃ 
new
ÃÃ 
ArgumentException
ÃÃ /
(
ÃÃ/ 0
$"
ÃÃ0 2
$str
ÃÃ2 p
{
ÃÃp q
foreachIndex
ÃÃq }
}
ÃÃ} ~
$strÃÃ~ Ä
"ÃÃÄ Å
)ÃÃÅ Ç
;ÃÃÇ É
}
ÕÕ 
Assert
œœ 
.
œœ 
IsTrue
œœ 
(
œœ 
foreachIndex
œœ *
>=
œœ+ -
$num
œœ. /
&&
œœ0 2
foreachIndex
œœ3 ?
<
œœ@ A
m_Writer
œœB J
.
œœJ K
m_BlockStream
œœK X
->
œœX Z

RangeCount
œœZ d
)
œœd e
;
œœe f
}
—— 
[
”” 
Conditional
”” 
(
”” 
$str
”” :
)
””: ;
]
””; <
void
‘‘ "
CheckEndForEachIndex
‘‘ %
(
‘‘% &
)
‘‘& '
{
’’  
AtomicSafetyHandle
◊◊ "
.
◊◊" # 
CheckWriteAndThrow
◊◊# 5
(
◊◊5 6
m_Safety
◊◊6 >
)
◊◊> ?
;
◊◊? @
if
ŸŸ 
(
ŸŸ 
m_Writer
ŸŸ 
.
ŸŸ 
m_ForeachIndex
ŸŸ +
==
ŸŸ, .
int
ŸŸ/ 2
.
ŸŸ2 3
MinValue
ŸŸ3 ;
)
ŸŸ; <
{
⁄⁄ 
throw
€€ 
new
€€ 
System
€€ $
.
€€$ %
ArgumentException
€€% 6
(
€€6 7
$str€€7 ô
)€€ô ö
;€€ö õ
}
‹‹ 
}
ﬁﬁ 
[
‡‡ 
Conditional
‡‡ 
(
‡‡ 
$str
‡‡ :
)
‡‡: ;
]
‡‡; <
void
·· 
CheckAllocateSize
·· "
(
··" #
int
··# &
size
··' +
)
··+ ,
{
‚‚  
AtomicSafetyHandle
‰‰ "
.
‰‰" # 
CheckWriteAndThrow
‰‰# 5
(
‰‰5 6
m_Safety
‰‰6 >
)
‰‰> ?
;
‰‰? @
if
ÊÊ 
(
ÊÊ 
m_PassByRefCheck
ÊÊ $
!=
ÊÊ% '
UnsafeUtility
ÊÊ( 5
.
ÊÊ5 6
	AddressOf
ÊÊ6 ?
(
ÊÊ? @
ref
ÊÊ@ C
this
ÊÊD H
)
ÊÊH I
)
ÊÊI J
{
ÁÁ 
throw
ËË 
new
ËË 
ArgumentException
ËË /
(
ËË/ 0
$str
ËË0 m
)
ËËm n
;
ËËn o
}
ÈÈ 
if
ÎÎ 
(
ÎÎ 
m_Writer
ÎÎ 
.
ÎÎ 
m_ForeachIndex
ÎÎ +
==
ÎÎ, .
int
ÎÎ/ 2
.
ÎÎ2 3
MinValue
ÎÎ3 ;
)
ÎÎ; <
{
ÏÏ 
throw
ÌÌ 
new
ÌÌ 
ArgumentException
ÌÌ /
(
ÌÌ/ 0
$str
ÌÌ0 t
)
ÌÌt u
;
ÌÌu v
}
ÓÓ 
if
 
(
 
size
 
>
 #
UnsafeStreamBlockData
 0
.
0 1
AllocationSize
1 ?
-
@ A
sizeof
B H
(
H I
void
I M
*
M N
)
N O
)
O P
{
ÒÒ 
throw
ÚÚ 
new
ÚÚ 
ArgumentException
ÚÚ /
(
ÚÚ/ 0
$str
ÚÚ0 N
)
ÚÚN O
;
ÚÚO P
}
ÛÛ 
}
ıı 
}
ˆˆ 	
[
˝˝ 	
NativeContainer
˝˝	 
]
˝˝ 
[
˛˛ 	'
NativeContainerIsReadOnly
˛˛	 "
]
˛˛" #
[
ˇˇ 	
BurstCompatible
ˇˇ	 
]
ˇˇ 
public
ÄÄ 
unsafe
ÄÄ 
struct
ÄÄ 
Reader
ÄÄ #
{
ÅÅ 	
UnsafeStream
ÇÇ 
.
ÇÇ 
Reader
ÇÇ 
m_Reader
ÇÇ  (
;
ÇÇ( )
int
ÖÖ 
m_RemainingBlocks
ÖÖ !
;
ÖÖ! "
internal
ÜÜ  
AtomicSafetyHandle
ÜÜ '
m_Safety
ÜÜ( 0
;
ÜÜ0 1
internal
áá 
static
áá 
readonly
áá $
SharedStatic
áá% 1
<
áá1 2
int
áá2 5
>
áá5 6
s_staticSafetyId
áá7 G
=
ááH I
SharedStatic
ááJ V
<
ááV W
int
ááW Z
>
ááZ [
.
áá[ \
GetOrCreate
áá\ g
<
áág h
Reader
ááh n
>
áán o
(
ááo p
)
ááp q
;
ááq r
internal
ää 
Reader
ää 
(
ää 
ref
ää 
NativeStream
ää  ,
stream
ää- 3
)
ää3 4
{
ãã 
m_Reader
åå 
=
åå 
stream
åå !
.
åå! "
m_Stream
åå" *
.
åå* +
AsReader
åå+ 3
(
åå3 4
)
åå4 5
;
åå5 6
m_RemainingBlocks
èè !
=
èè" #
$num
èè$ %
;
èè% &
m_Safety
êê 
=
êê 
stream
êê !
.
êê! "
m_Safety
êê" *
;
êê* +
CollectionHelper
ëë  
.
ëë  !
SetStaticSafetyId
ëë! 2
(
ëë2 3
ref
ëë3 6
m_Safety
ëë7 ?
,
ëë? @
ref
ëëA D
s_staticSafetyId
ëëE U
.
ëëU V
Data
ëëV Z
,
ëëZ [
$strëë\ É
)ëëÉ Ñ
;ëëÑ Ö
}
ìì 
public
ùù 
int
ùù 
BeginForEachIndex
ùù (
(
ùù( )
int
ùù) ,
foreachIndex
ùù- 9
)
ùù9 :
{
ûû $
CheckBeginForEachIndex
üü &
(
üü& '
foreachIndex
üü' 3
)
üü3 4
;
üü4 5
var
°°  
remainingItemCount
°° &
=
°°' (
m_Reader
°°) 1
.
°°1 2
BeginForEachIndex
°°2 C
(
°°C D
foreachIndex
°°D P
)
°°P Q
;
°°Q R
m_RemainingBlocks
§§ !
=
§§" #
m_Reader
§§$ ,
.
§§, -
m_BlockStream
§§- :
->
§§: <
Ranges
§§< B
[
§§B C
foreachIndex
§§C O
]
§§O P
.
§§P Q
NumberOfBlocks
§§Q _
;
§§_ `
if
•• 
(
•• 
m_RemainingBlocks
•• %
==
••& (
$num
••) *
)
••* +
{
¶¶ 
m_Reader
ßß 
.
ßß 
m_CurrentBlockEnd
ßß .
=
ßß/ 0
(
ßß1 2
byte
ßß2 6
*
ßß6 7
)
ßß7 8
m_Reader
ßß8 @
.
ßß@ A
m_CurrentBlock
ßßA O
+
ßßP Q
m_Reader
ßßR Z
.
ßßZ [
m_LastBlockSize
ßß[ j
;
ßßj k
}
®® 
return
´´  
remainingItemCount
´´ )
;
´´) *
}
¨¨ 
public
¥¥ 
void
¥¥ 
EndForEachIndex
¥¥ '
(
¥¥' (
)
¥¥( )
{
µµ 
m_Reader
∂∂ 
.
∂∂ 
EndForEachIndex
∂∂ (
(
∂∂( )
)
∂∂) *
;
∂∂* +"
CheckEndForEachIndex
∑∑ $
(
∑∑$ %
)
∑∑% &
;
∑∑& '
}
∏∏ 
public
ææ 
int
ææ 
ForEachCount
ææ #
{
øø 
get
¿¿ 
{
¡¡ 
	CheckRead
¬¬ 
(
¬¬ 
)
¬¬ 
;
¬¬  
return
√√ 
m_Reader
√√ #
.
√√# $
ForEachCount
√√$ 0
;
√√0 1
}
ƒƒ 
}
≈≈ 
public
ÀÀ 
int
ÀÀ  
RemainingItemCount
ÀÀ )
=>
ÀÀ* ,
m_Reader
ÀÀ- 5
.
ÀÀ5 6 
RemainingItemCount
ÀÀ6 H
;
ÀÀH I
public
”” 
byte
”” 
*
”” 
ReadUnsafePtr
”” &
(
””& '
int
””' *
size
””+ /
)
””/ 0
{
‘‘ 
CheckReadSize
’’ 
(
’’ 
size
’’ "
)
’’" #
;
’’# $
m_Reader
◊◊ 
.
◊◊ "
m_RemainingItemCount
◊◊ -
--
◊◊- /
;
◊◊/ 0
byte
ŸŸ 
*
ŸŸ 
ptr
ŸŸ 
=
ŸŸ 
m_Reader
ŸŸ $
.
ŸŸ$ %
m_CurrentPtr
ŸŸ% 1
;
ŸŸ1 2
m_Reader
⁄⁄ 
.
⁄⁄ 
m_CurrentPtr
⁄⁄ %
+=
⁄⁄& (
size
⁄⁄) -
;
⁄⁄- .
if
‹‹ 
(
‹‹ 
m_Reader
‹‹ 
.
‹‹ 
m_CurrentPtr
‹‹ )
>
‹‹* +
m_Reader
‹‹, 4
.
‹‹4 5
m_CurrentBlockEnd
‹‹5 F
)
‹‹F G
{
›› 
m_RemainingBlocks
‰‰ %
--
‰‰% '
;
‰‰' ((
CheckNotReadingOutOfBounds
ÊÊ .
(
ÊÊ. /
size
ÊÊ/ 3
)
ÊÊ3 4
;
ÊÊ4 5
m_Reader
ËË 
.
ËË 
m_CurrentBlock
ËË +
=
ËË, -
m_Reader
ËË. 6
.
ËË6 7
m_CurrentBlock
ËË7 E
->
ËËE G
Next
ËËG K
;
ËËK L
m_Reader
ÈÈ 
.
ÈÈ 
m_CurrentPtr
ÈÈ )
=
ÈÈ* +
m_Reader
ÈÈ, 4
.
ÈÈ4 5
m_CurrentBlock
ÈÈ5 C
->
ÈÈC E
Data
ÈÈE I
;
ÈÈI J
if
ÏÏ 
(
ÏÏ 
m_RemainingBlocks
ÏÏ )
<=
ÏÏ* ,
$num
ÏÏ- .
)
ÏÏ. /
{
ÌÌ 
m_Reader
ÓÓ  
.
ÓÓ  !
m_CurrentBlockEnd
ÓÓ! 2
=
ÓÓ3 4
(
ÓÓ5 6
byte
ÓÓ6 :
*
ÓÓ: ;
)
ÓÓ; <
m_Reader
ÓÓ< D
.
ÓÓD E
m_CurrentBlock
ÓÓE S
+
ÓÓT U
m_Reader
ÓÓV ^
.
ÓÓ^ _
m_LastBlockSize
ÓÓ_ n
;
ÓÓn o
}
ÔÔ 
else
 
{
ÒÒ 
m_Reader
ÚÚ  
.
ÚÚ  !
m_CurrentBlockEnd
ÚÚ! 2
=
ÚÚ3 4
(
ÚÚ5 6
byte
ÚÚ6 :
*
ÚÚ: ;
)
ÚÚ; <
m_Reader
ÚÚ< D
.
ÚÚD E
m_CurrentBlock
ÚÚE S
+
ÚÚT U#
UnsafeStreamBlockData
ÚÚV k
.
ÚÚk l
AllocationSize
ÚÚl z
;
ÚÚz {
}
ÛÛ 
ptr
˜˜ 
=
˜˜ 
m_Reader
˜˜ "
.
˜˜" #
m_CurrentPtr
˜˜# /
;
˜˜/ 0
m_Reader
¯¯ 
.
¯¯ 
m_CurrentPtr
¯¯ )
+=
¯¯* ,
size
¯¯- 1
;
¯¯1 2
}
˘˘ 
return
˚˚ 
ptr
˚˚ 
;
˚˚ 
}
¸¸ 
[
ÖÖ 
BurstCompatible
ÖÖ 
(
ÖÖ "
GenericTypeArguments
ÖÖ 1
=
ÖÖ2 3
new
ÖÖ4 7
[
ÖÖ8 9
]
ÖÖ9 :
{
ÖÖ; <
typeof
ÖÖ= C
(
ÖÖC D
int
ÖÖD G
)
ÖÖG H
}
ÖÖI J
)
ÖÖJ K
]
ÖÖK L
public
ÜÜ 
ref
ÜÜ 
T
ÜÜ 
Read
ÜÜ 
<
ÜÜ 
T
ÜÜ 
>
ÜÜ  
(
ÜÜ  !
)
ÜÜ! "
where
ÜÜ# (
T
ÜÜ) *
:
ÜÜ+ ,
struct
ÜÜ- 3
{
áá 
int
àà 
size
àà 
=
àà 
UnsafeUtility
àà (
.
àà( )
SizeOf
àà) /
<
àà/ 0
T
àà0 1
>
àà1 2
(
àà2 3
)
àà3 4
;
àà4 5
return
ââ 
ref
ââ 
UnsafeUtility
ââ (
.
ââ( )
AsRef
ââ) .
<
ââ. /
T
ââ/ 0
>
ââ0 1
(
ââ1 2
ReadUnsafePtr
ââ2 ?
(
ââ? @
size
ââ@ D
)
ââD E
)
ââE F
;
ââF G
}
ää 
[
íí 
BurstCompatible
íí 
(
íí "
GenericTypeArguments
íí 1
=
íí2 3
new
íí4 7
[
íí8 9
]
íí9 :
{
íí; <
typeof
íí= C
(
ííC D
int
ííD G
)
ííG H
}
ííI J
)
ííJ K
]
ííK L
public
ìì 
ref
ìì 
T
ìì 
Peek
ìì 
<
ìì 
T
ìì 
>
ìì  
(
ìì  !
)
ìì! "
where
ìì# (
T
ìì) *
:
ìì+ ,
struct
ìì- 3
{
îî 
int
ïï 
size
ïï 
=
ïï 
UnsafeUtility
ïï (
.
ïï( )
SizeOf
ïï) /
<
ïï/ 0
T
ïï0 1
>
ïï1 2
(
ïï2 3
)
ïï3 4
;
ïï4 5
CheckReadSize
ññ 
(
ññ 
size
ññ "
)
ññ" #
;
ññ# $
return
òò 
ref
òò 
m_Reader
òò #
.
òò# $
Peek
òò$ (
<
òò( )
T
òò) *
>
òò* +
(
òò+ ,
)
òò, -
;
òò- .
}
ôô 
public
üü 
int
üü 
Count
üü 
(
üü 
)
üü 
{
†† 
	CheckRead
°° 
(
°° 
)
°° 
;
°° 
return
¢¢ 
m_Reader
¢¢ 
.
¢¢  
Count
¢¢  %
(
¢¢% &
)
¢¢& '
;
¢¢' (
}
££ 
[
•• 
Conditional
•• 
(
•• 
$str
•• :
)
••: ;
]
••; <
void
¶¶ (
CheckNotReadingOutOfBounds
¶¶ +
(
¶¶+ ,
int
¶¶, /
size
¶¶0 4
)
¶¶4 5
{
ßß 
if
©© 
(
©© 
m_RemainingBlocks
©© %
<
©©& '
$num
©©( )
)
©©) *
throw
™™ 
new
™™ 
System
™™ $
.
™™$ %
ArgumentException
™™% 6
(
™™6 7
$str
™™7 N
)
™™N O
;
™™O P
if
¨¨ 
(
¨¨ 
m_RemainingBlocks
¨¨ %
==
¨¨& (
$num
¨¨) *
&&
¨¨+ -
size
¨¨. 2
+
¨¨3 4
sizeof
¨¨5 ;
(
¨¨; <
void
¨¨< @
*
¨¨@ A
)
¨¨A B
>
¨¨C D
m_Reader
¨¨E M
.
¨¨M N
m_LastBlockSize
¨¨N ]
)
¨¨] ^
throw
≠≠ 
new
≠≠ 
System
≠≠ $
.
≠≠$ %
ArgumentException
≠≠% 6
(
≠≠6 7
$str
≠≠7 N
)
≠≠N O
;
≠≠O P
}
ØØ 
[
±± 
Conditional
±± 
(
±± 
$str
±± :
)
±±: ;
]
±±; <
void
≤≤ 
	CheckRead
≤≤ 
(
≤≤ 
)
≤≤ 
{
≥≥  
AtomicSafetyHandle
µµ "
.
µµ" #
CheckReadAndThrow
µµ# 4
(
µµ4 5
m_Safety
µµ5 =
)
µµ= >
;
µµ> ?
}
∑∑ 
[
ππ 
Conditional
ππ 
(
ππ 
$str
ππ :
)
ππ: ;
]
ππ; <
void
∫∫ 
CheckReadSize
∫∫ 
(
∫∫ 
int
∫∫ "
size
∫∫# '
)
∫∫' (
{
ªª  
AtomicSafetyHandle
ΩΩ "
.
ΩΩ" #
CheckReadAndThrow
ΩΩ# 4
(
ΩΩ4 5
m_Safety
ΩΩ5 =
)
ΩΩ= >
;
ΩΩ> ?
Assert
øø 
.
øø 
IsTrue
øø 
(
øø 
size
øø "
<=
øø# %#
UnsafeStreamBlockData
øø& ;
.
øø; <
AllocationSize
øø< J
-
øøK L
(
øøM N
sizeof
øøN T
(
øøT U
void
øøU Y
*
øøY Z
)
øøZ [
)
øø[ \
)
øø\ ]
;
øø] ^
if
¿¿ 
(
¿¿ 
m_Reader
¿¿ 
.
¿¿ "
m_RemainingItemCount
¿¿ 1
<
¿¿2 3
$num
¿¿4 5
)
¿¿5 6
{
¡¡ 
throw
¬¬ 
new
¬¬ 
ArgumentException
¬¬ /
(
¬¬/ 0
$str
¬¬0 Z
)
¬¬Z [
;
¬¬[ \
}
√√ 
}
≈≈ 
[
«« 
Conditional
«« 
(
«« 
$str
«« :
)
««: ;
]
««; <
void
»» $
CheckBeginForEachIndex
»» '
(
»»' (
int
»»( +
forEachIndex
»», 8
)
»»8 9
{
……  
AtomicSafetyHandle
ÀÀ "
.
ÀÀ" #
CheckReadAndThrow
ÀÀ# 4
(
ÀÀ4 5
m_Safety
ÀÀ5 =
)
ÀÀ= >
;
ÀÀ> ?
if
ÕÕ 
(
ÕÕ 
(
ÕÕ 
uint
ÕÕ 
)
ÕÕ 
forEachIndex
ÕÕ &
>=
ÕÕ' )
(
ÕÕ* +
uint
ÕÕ+ /
)
ÕÕ/ 0
m_Reader
ÕÕ0 8
.
ÕÕ8 9
m_BlockStream
ÕÕ9 F
->
ÕÕF H

RangeCount
ÕÕH R
)
ÕÕR S
{
ŒŒ 
throw
œœ 
new
œœ 
System
œœ $
.
œœ$ %)
ArgumentOutOfRangeException
œœ% @
(
œœ@ A
nameof
œœA G
(
œœG H
forEachIndex
œœH T
)
œœT U
,
œœU V
$"
œœW Y
$str
œœY g
{
œœg h
forEachIndex
œœh t
}
œœt u
$strœœu ö
{œœö õ
m_Readerœœõ £
.œœ£ §
m_BlockStreamœœ§ ±
->œœ± ≥

RangeCountœœ≥ Ω
}œœΩ æ
"œœæ ø
)œœø ¿
;œœ¿ ¡
}
–– 
}
““ 
[
‘‘ 
Conditional
‘‘ 
(
‘‘ 
$str
‘‘ :
)
‘‘: ;
]
‘‘; <
void
’’ "
CheckEndForEachIndex
’’ %
(
’’% &
)
’’& '
{
÷÷ 
if
◊◊ 
(
◊◊ 
m_Reader
◊◊ 
.
◊◊ "
m_RemainingItemCount
◊◊ 1
!=
◊◊2 4
$num
◊◊5 6
)
◊◊6 7
{
ÿÿ 
throw
ŸŸ 
new
ŸŸ 
System
ŸŸ $
.
ŸŸ$ %
ArgumentException
ŸŸ% 6
(
ŸŸ6 7
$strŸŸ7 †
)ŸŸ† °
;ŸŸ° ¢
}
⁄⁄ 
if
‹‹ 
(
‹‹ 
m_Reader
‹‹ 
.
‹‹ 
m_CurrentBlockEnd
‹‹ .
!=
‹‹/ 1
m_Reader
‹‹2 :
.
‹‹: ;
m_CurrentPtr
‹‹; G
)
‹‹G H
{
›› 
throw
ﬁﬁ 
new
ﬁﬁ 
System
ﬁﬁ $
.
ﬁﬁ$ %
ArgumentException
ﬁﬁ% 6
(
ﬁﬁ6 7
$strﬁﬁ7 ü
)ﬁﬁü †
;ﬁﬁ† °
}
ﬂﬂ 
}
‡‡ 
}
·· 	
[
„„ 	
Conditional
„„	 
(
„„ 
$str
„„ 6
)
„„6 7
]
„„7 8
static
‰‰ 
void
‰‰ .
 CheckForEachCountGreaterThanZero
‰‰ 4
(
‰‰4 5
int
‰‰5 8
forEachCount
‰‰9 E
)
‰‰E F
{
ÂÂ 	
if
ÊÊ 
(
ÊÊ 
forEachCount
ÊÊ 
<=
ÊÊ 
$num
ÊÊ  !
)
ÊÊ! "
throw
ÁÁ 
new
ÁÁ 
ArgumentException
ÁÁ +
(
ÁÁ+ ,
$str
ÁÁ, F
,
ÁÁF G
$str
ÁÁH V
)
ÁÁV W
;
ÁÁW X
}
ËË 	
[
ÍÍ 	
Conditional
ÍÍ	 
(
ÍÍ 
$str
ÍÍ 6
)
ÍÍ6 7
]
ÍÍ7 8
void
ÎÎ 
CheckReadAccess
ÎÎ 
(
ÎÎ 
)
ÎÎ 
{
ÏÏ 	 
AtomicSafetyHandle
ÓÓ 
.
ÓÓ 
CheckReadAndThrow
ÓÓ 0
(
ÓÓ0 1
m_Safety
ÓÓ1 9
)
ÓÓ9 :
;
ÓÓ: ;
}
 	
}
ÒÒ 
}ÚÚ Æ÷
iC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeAppendBuffer.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{ 
[ 
BurstCompatible 
] 
public 

unsafe 
struct 
UnsafeAppendBuffer +
: 	
INativeDisposable
 
{ 
[ 	-
!NativeDisableUnsafePtrRestriction	 *
]* +
public 
byte 
* 
Ptr 
; 
public 
int 
Length 
; 
public## 
int## 
Capacity## 
;## 
public)) 
AllocatorManager)) 
.))  
AllocatorHandle))  /
	Allocator))0 9
;))9 :
public// 
readonly// 
int// 
	Alignment// %
;//% &
public77 
UnsafeAppendBuffer77 !
(77! "
int77" %
initialCapacity77& 5
,775 6
int777 :
	alignment77; D
,77D E
AllocatorManager77F V
.77V W
AllocatorHandle77W f
	allocator77g p
)77p q
{88 	
CheckAlignment99 
(99 
	alignment99 $
)99$ %
;99% &
	Alignment;; 
=;; 
	alignment;; !
;;;! "
	Allocator<< 
=<< 
	allocator<< !
;<<! "
Ptr== 
=== 
null== 
;== 
Length>> 
=>> 
$num>> 
;>> 
Capacity?? 
=?? 
$num?? 
;?? 
SetCapacityAA 
(AA 
initialCapacityAA '
)AA' (
;AA( )
}BB 	
publicKK 
UnsafeAppendBufferKK !
(KK! "
voidKK" &
*KK& '
ptrKK( +
,KK+ ,
intKK- 0
lengthKK1 7
)KK7 8
{LL 	
	AlignmentMM 
=MM 
$numMM 
;MM 
	AllocatorNN 
=NN 
AllocatorManagerNN (
.NN( )
NoneNN) -
;NN- .
PtrOO 
=OO 
(OO 
byteOO 
*OO 
)OO 
ptrOO 
;OO 
LengthPP 
=PP 
$numPP 
;PP 
CapacityQQ 
=QQ 
lengthQQ 
;QQ 
}RR 	
publicXX 
boolXX 
IsEmptyXX 
=>XX 
LengthXX %
==XX& (
$numXX) *
;XX* +
public^^ 
bool^^ 
	IsCreated^^ 
=>^^  
Ptr^^! $
!=^^% '
null^^( ,
;^^, -
publiccc 
voidcc 
Disposecc 
(cc 
)cc 
{dd 	
ifee 
(ee 
CollectionHelperee  
.ee  !
ShouldDeallocateee! 1
(ee1 2
	Allocatoree2 ;
)ee; <
)ee< =
{ff 
Memorygg 
.gg 
	Unmanagedgg  
.gg  !
Freegg! %
(gg% &
Ptrgg& )
,gg) *
	Allocatorgg+ 4
)gg4 5
;gg5 6
	Allocatorhh 
=hh 
AllocatorManagerhh ,
.hh, -
Invalidhh- 4
;hh4 5
}ii 
Ptrkk 
=kk 
nullkk 
;kk 
Lengthll 
=ll 
$numll 
;ll 
Capacitymm 
=mm 
$nummm 
;mm 
}nn 	
[uu 	
NotBurstCompatibleuu	 
]
uuú ù
publicvv 
	JobHandlevv 
Disposevv  
(vv  !
	JobHandlevv! *
	inputDepsvv+ 4
)vv4 5
{ww 	
ifxx 
(xx 
CollectionHelperxx  
.xx  !
ShouldDeallocatexx! 1
(xx1 2
	Allocatorxx2 ;
)xx; <
)xx< =
{yy 
varzz 
	jobHandlezz 
=zz 
newzz  #
UnsafeDisposeJobzz$ 4
{zz5 6
Ptrzz7 :
=zz; <
Ptrzz= @
,zz@ A
	AllocatorzzB K
=zzL M
	AllocatorzzN W
}zzX Y
.zzY Z
SchedulezzZ b
(zzb c
	inputDepszzc l
)zzl m
;zzm n
Ptr|| 
=|| 
null|| 
;|| 
	Allocator}} 
=}} 
AllocatorManager}} ,
.}}, -
Invalid}}- 4
;}}4 5
return 
	jobHandle  
;  !
}
ÄÄ 
Ptr
ÇÇ 
=
ÇÇ 
null
ÇÇ 
;
ÇÇ 
return
ÑÑ 
	inputDeps
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
public
ãã 
void
ãã 
Reset
ãã 
(
ãã 
)
ãã 
{
åå 	
Length
çç 
=
çç 
$num
çç 
;
çç 
}
éé 	
public
ïï 
void
ïï 
SetCapacity
ïï 
(
ïï  
int
ïï  #
capacity
ïï$ ,
)
ïï, -
{
ññ 	
if
óó 
(
óó 
capacity
óó 
<=
óó 
Capacity
óó $
)
óó$ %
{
òò 
return
ôô 
;
ôô 
}
öö 
capacity
úú 
=
úú 
math
úú 
.
úú 
max
úú 
(
úú  
$num
úú  "
,
úú" #
math
úú$ (
.
úú( )
ceilpow2
úú) 1
(
úú1 2
capacity
úú2 :
)
úú: ;
)
úú; <
;
úú< =
var
ûû 
newPtr
ûû 
=
ûû 
(
ûû 
byte
ûû 
*
ûû 
)
ûû  
Memory
ûû  &
.
ûû& '
	Unmanaged
ûû' 0
.
ûû0 1
Allocate
ûû1 9
(
ûû9 :
capacity
ûû: B
,
ûûB C
	Alignment
ûûD M
,
ûûM N
	Allocator
ûûO X
)
ûûX Y
;
ûûY Z
if
üü 
(
üü 
Ptr
üü 
!=
üü 
null
üü 
)
üü 
{
†† 
UnsafeUtility
°° 
.
°° 
MemCpy
°° $
(
°°$ %
newPtr
°°% +
,
°°+ ,
Ptr
°°- 0
,
°°0 1
Length
°°2 8
)
°°8 9
;
°°9 :
Memory
¢¢ 
.
¢¢ 
	Unmanaged
¢¢  
.
¢¢  !
Free
¢¢! %
(
¢¢% &
Ptr
¢¢& )
,
¢¢) *
	Allocator
¢¢+ 4
)
¢¢4 5
;
¢¢5 6
}
££ 
Ptr
•• 
=
•• 
newPtr
•• 
;
•• 
Capacity
¶¶ 
=
¶¶ 
capacity
¶¶ 
;
¶¶  
}
ßß 	
public
ÆÆ 
void
ÆÆ !
ResizeUninitialized
ÆÆ '
(
ÆÆ' (
int
ÆÆ( +
length
ÆÆ, 2
)
ÆÆ2 3
{
ØØ 	
SetCapacity
∞∞ 
(
∞∞ 
length
∞∞ 
)
∞∞ 
;
∞∞  
Length
±± 
=
±± 
length
±± 
;
±± 
}
≤≤ 	
[
ππ 	
BurstCompatible
ππ	 
(
ππ "
GenericTypeArguments
ππ -
=
ππ. /
new
ππ0 3
[
ππ4 5
]
ππ5 6
{
ππ7 8
typeof
ππ9 ?
(
ππ? @
int
ππ@ C
)
ππC D
}
ππE F
)
ππF G
]
ππG H
public
∫∫ 
void
∫∫ 
Add
∫∫ 
<
∫∫ 
T
∫∫ 
>
∫∫ 
(
∫∫ 
T
∫∫ 
value
∫∫ "
)
∫∫" #
where
∫∫$ )
T
∫∫* +
:
∫∫, -
struct
∫∫. 4
{
ªª 	
var
ºº 

structSize
ºº 
=
ºº 
UnsafeUtility
ºº *
.
ºº* +
SizeOf
ºº+ 1
<
ºº1 2
T
ºº2 3
>
ºº3 4
(
ºº4 5
)
ºº5 6
;
ºº6 7
SetCapacity
ææ 
(
ææ 
Length
ææ 
+
ææ  

structSize
ææ! +
)
ææ+ ,
;
ææ, -
UnsafeUtility
øø 
.
øø  
CopyStructureToPtr
øø ,
(
øø, -
ref
øø- 0
value
øø1 6
,
øø6 7
Ptr
øø8 ;
+
øø< =
Length
øø> D
)
øøD E
;
øøE F
Length
¿¿ 
+=
¿¿ 

structSize
¿¿  
;
¿¿  !
}
¡¡ 	
public
…… 
void
…… 
Add
…… 
(
…… 
void
…… 
*
…… 
ptr
…… !
,
……! "
int
……# &

structSize
……' 1
)
……1 2
{
   	
SetCapacity
ÀÀ 
(
ÀÀ 
Length
ÀÀ 
+
ÀÀ  

structSize
ÀÀ! +
)
ÀÀ+ ,
;
ÀÀ, -
UnsafeUtility
ÃÃ 
.
ÃÃ 
MemCpy
ÃÃ  
(
ÃÃ  !
Ptr
ÃÃ! $
+
ÃÃ% &
Length
ÃÃ' -
,
ÃÃ- .
ptr
ÃÃ/ 2
,
ÃÃ2 3

structSize
ÃÃ4 >
)
ÃÃ> ?
;
ÃÃ? @
Length
ÕÕ 
+=
ÕÕ 

structSize
ÕÕ  
;
ÕÕ  !
}
ŒŒ 	
[
◊◊ 	
BurstCompatible
◊◊	 
(
◊◊ "
GenericTypeArguments
◊◊ -
=
◊◊. /
new
◊◊0 3
[
◊◊4 5
]
◊◊5 6
{
◊◊7 8
typeof
◊◊9 ?
(
◊◊? @
int
◊◊@ C
)
◊◊C D
}
◊◊E F
)
◊◊F G
]
◊◊G H
public
ÿÿ 
void
ÿÿ 
AddArray
ÿÿ 
<
ÿÿ 
T
ÿÿ 
>
ÿÿ 
(
ÿÿ  
void
ÿÿ  $
*
ÿÿ$ %
ptr
ÿÿ& )
,
ÿÿ) *
int
ÿÿ+ .
length
ÿÿ/ 5
)
ÿÿ5 6
where
ÿÿ7 <
T
ÿÿ= >
:
ÿÿ? @
struct
ÿÿA G
{
ŸŸ 	
Add
⁄⁄ 
(
⁄⁄ 
length
⁄⁄ 
)
⁄⁄ 
;
⁄⁄ 
if
‹‹ 
(
‹‹ 
length
‹‹ 
!=
‹‹ 
$num
‹‹ 
)
‹‹ 
Add
›› 
(
›› 
ptr
›› 
,
›› 
length
›› 
*
››  !
UnsafeUtility
››" /
.
››/ 0
SizeOf
››0 6
<
››6 7
T
››7 8
>
››8 9
(
››9 :
)
››: ;
)
››; <
;
››< =
}
ﬁﬁ 	
[
ÂÂ 	
BurstCompatible
ÂÂ	 
(
ÂÂ "
GenericTypeArguments
ÂÂ -
=
ÂÂ. /
new
ÂÂ0 3
[
ÂÂ4 5
]
ÂÂ5 6
{
ÂÂ7 8
typeof
ÂÂ9 ?
(
ÂÂ? @
int
ÂÂ@ C
)
ÂÂC D
}
ÂÂE F
)
ÂÂF G
]
ÂÂG H
public
ÊÊ 
void
ÊÊ 
Add
ÊÊ 
<
ÊÊ 
T
ÊÊ 
>
ÊÊ 
(
ÊÊ 
NativeArray
ÊÊ &
<
ÊÊ& '
T
ÊÊ' (
>
ÊÊ( )
value
ÊÊ* /
)
ÊÊ/ 0
where
ÊÊ1 6
T
ÊÊ7 8
:
ÊÊ9 :
struct
ÊÊ; A
{
ÁÁ 	
Add
ËË 
(
ËË 
value
ËË 
.
ËË 
Length
ËË 
)
ËË 
;
ËË 
Add
ÈÈ 
(
ÈÈ &
NativeArrayUnsafeUtility
ÈÈ (
.
ÈÈ( )"
GetUnsafeReadOnlyPtr
ÈÈ) =
(
ÈÈ= >
value
ÈÈ> C
)
ÈÈC D
,
ÈÈD E
UnsafeUtility
ÈÈF S
.
ÈÈS T
SizeOf
ÈÈT Z
<
ÈÈZ [
T
ÈÈ[ \
>
ÈÈ\ ]
(
ÈÈ] ^
)
ÈÈ^ _
*
ÈÈ` a
value
ÈÈb g
.
ÈÈg h
Length
ÈÈh n
)
ÈÈn o
;
ÈÈo p
}
ÍÍ 	
[
ıı 	 
NotBurstCompatible
ıı	 
]
ıı, -
[
ˆˆ 	
Obsolete
ˆˆ	 
(
ˆˆ 
$strˆˆ ê
,ˆˆê ë
falseˆˆí ó
)ˆˆó ò
]ˆˆò ô
public
˜˜ 
void
˜˜ 
Add
˜˜ 
(
˜˜ 
string
˜˜ 
value
˜˜ $
)
˜˜$ %
=>
˜˜& ( 
NotBurstCompatible
˜˜) ;
.
˜˜; <

Extensions
˜˜< F
.
˜˜F G
AddNBC
˜˜G M
(
˜˜M N
ref
˜˜N Q
this
˜˜R V
,
˜˜V W
value
˜˜X ]
)
˜˜] ^
;
˜˜^ _
[
ˇˇ 	
BurstCompatible
ˇˇ	 
(
ˇˇ "
GenericTypeArguments
ˇˇ -
=
ˇˇ. /
new
ˇˇ0 3
[
ˇˇ4 5
]
ˇˇ5 6
{
ˇˇ7 8
typeof
ˇˇ9 ?
(
ˇˇ? @
int
ˇˇ@ C
)
ˇˇC D
}
ˇˇE F
)
ˇˇF G
]
ˇˇG H
public
ÄÄ 
T
ÄÄ 
Pop
ÄÄ 
<
ÄÄ 
T
ÄÄ 
>
ÄÄ 
(
ÄÄ 
)
ÄÄ 
where
ÄÄ 
T
ÄÄ  !
:
ÄÄ" #
struct
ÄÄ$ *
{
ÅÅ 	
int
ÇÇ 

structSize
ÇÇ 
=
ÇÇ 
UnsafeUtility
ÇÇ *
.
ÇÇ* +
SizeOf
ÇÇ+ 1
<
ÇÇ1 2
T
ÇÇ2 3
>
ÇÇ3 4
(
ÇÇ4 5
)
ÇÇ5 6
;
ÇÇ6 7
long
ÉÉ 
ptr
ÉÉ 
=
ÉÉ 
(
ÉÉ 
long
ÉÉ 
)
ÉÉ 
Ptr
ÉÉ  
;
ÉÉ  !
long
ÑÑ 
size
ÑÑ 
=
ÑÑ 
Length
ÑÑ 
;
ÑÑ 
long
ÖÖ 
addr
ÖÖ 
=
ÖÖ 
ptr
ÖÖ 
+
ÖÖ 
size
ÖÖ "
-
ÖÖ# $

structSize
ÖÖ% /
;
ÖÖ/ 0
var
áá 
data
áá 
=
áá 
UnsafeUtility
áá $
.
áá$ %
ReadArrayElement
áá% 5
<
áá5 6
T
áá6 7
>
áá7 8
(
áá8 9
(
áá9 :
void
áá: >
*
áá> ?
)
áá? @
addr
áá@ D
,
ááD E
$num
ááF G
)
ááG H
;
ááH I
Length
àà 
-=
àà 

structSize
àà  
;
àà  !
return
ââ 
data
ââ 
;
ââ 
}
ää 	
public
íí 
void
íí 
Pop
íí 
(
íí 
void
íí 
*
íí 
ptr
íí !
,
íí! "
int
íí# &

structSize
íí' 1
)
íí1 2
{
ìì 	
long
îî 
data
îî 
=
îî 
(
îî 
long
îî 
)
îî 
Ptr
îî !
;
îî! "
long
ïï 
size
ïï 
=
ïï 
Length
ïï 
;
ïï 
long
ññ 
addr
ññ 
=
ññ 
data
ññ 
+
ññ 
size
ññ #
-
ññ$ %

structSize
ññ& 0
;
ññ0 1
UnsafeUtility
òò 
.
òò 
MemCpy
òò  
(
òò  !
ptr
òò! $
,
òò$ %
(
òò& '
void
òò' +
*
òò+ ,
)
òò, -
addr
òò- 1
,
òò1 2

structSize
òò3 =
)
òò= >
;
òò> ?
Length
ôô 
-=
ôô 

structSize
ôô  
;
ôô  !
}
öö 	
[
†† 	 
NotBurstCompatible
††	 
]
††, -
[
°° 	
Obsolete
°°	 
(
°° 
$str°° î
,°°î ï
false°°ñ õ
)°°õ ú
]°°ú ù
public
¢¢ 
byte
¢¢ 
[
¢¢ 
]
¢¢ 
ToBytes
¢¢ 
(
¢¢ 
)
¢¢ 
=>
¢¢  " 
NotBurstCompatible
¢¢# 5
.
¢¢5 6

Extensions
¢¢6 @
.
¢¢@ A

ToBytesNBC
¢¢A K
(
¢¢K L
ref
¢¢L O
this
¢¢P T
)
¢¢T U
;
¢¢U V
public
®® 
Reader
®® 
AsReader
®® 
(
®® 
)
®®  
{
©© 	
return
™™ 
new
™™ 
Reader
™™ 
(
™™ 
ref
™™ !
this
™™" &
)
™™& '
;
™™' (
}
´´ 	
[
∞∞ 	
BurstCompatible
∞∞	 
]
∞∞ 
public
±± 
unsafe
±± 
struct
±± 
Reader
±± #
{
≤≤ 	
public
∑∑ 
readonly
∑∑ 
byte
∑∑  
*
∑∑  !
Ptr
∑∑" %
;
∑∑% &
public
ΩΩ 
readonly
ΩΩ 
int
ΩΩ 
Size
ΩΩ  $
;
ΩΩ$ %
public
√√ 
int
√√ 
Offset
√√ 
;
√√ 
public
…… 
Reader
…… 
(
…… 
ref
……  
UnsafeAppendBuffer
…… 0
buffer
……1 7
)
……7 8
{
   
Ptr
ÀÀ 
=
ÀÀ 
buffer
ÀÀ 
.
ÀÀ 
Ptr
ÀÀ  
;
ÀÀ  !
Size
ÃÃ 
=
ÃÃ 
buffer
ÃÃ 
.
ÃÃ 
Length
ÃÃ $
;
ÃÃ$ %
Offset
ÕÕ 
=
ÕÕ 
$num
ÕÕ 
;
ÕÕ 
}
ŒŒ 
public
÷÷ 
Reader
÷÷ 
(
÷÷ 
void
÷÷ 
*
÷÷ 
ptr
÷÷  #
,
÷÷# $
int
÷÷% (
length
÷÷) /
)
÷÷/ 0
{
◊◊ 
Ptr
ÿÿ 
=
ÿÿ 
(
ÿÿ 
byte
ÿÿ 
*
ÿÿ 
)
ÿÿ 
ptr
ÿÿ  
;
ÿÿ  !
Size
ŸŸ 
=
ŸŸ 
length
ŸŸ 
;
ŸŸ 
Offset
⁄⁄ 
=
⁄⁄ 
$num
⁄⁄ 
;
⁄⁄ 
}
€€ 
public
·· 
bool
·· 
EndOfBuffer
·· #
=>
··$ &
Offset
··' -
==
··. 0
Size
··1 5
;
··5 6
[
ÈÈ 
BurstCompatible
ÈÈ 
(
ÈÈ "
GenericTypeArguments
ÈÈ 1
=
ÈÈ2 3
new
ÈÈ4 7
[
ÈÈ8 9
]
ÈÈ9 :
{
ÈÈ; <
typeof
ÈÈ= C
(
ÈÈC D
int
ÈÈD G
)
ÈÈG H
}
ÈÈI J
)
ÈÈJ K
]
ÈÈK L
public
ÍÍ 
void
ÍÍ 
ReadNext
ÍÍ  
<
ÍÍ  !
T
ÍÍ! "
>
ÍÍ" #
(
ÍÍ# $
out
ÍÍ$ '
T
ÍÍ( )
value
ÍÍ* /
)
ÍÍ/ 0
where
ÍÍ1 6
T
ÍÍ7 8
:
ÍÍ9 :
struct
ÍÍ; A
{
ÎÎ 
var
ÏÏ 

structSize
ÏÏ 
=
ÏÏ  
UnsafeUtility
ÏÏ! .
.
ÏÏ. /
SizeOf
ÏÏ/ 5
<
ÏÏ5 6
T
ÏÏ6 7
>
ÏÏ7 8
(
ÏÏ8 9
)
ÏÏ9 :
;
ÏÏ: ;
CheckBounds
ÌÌ 
(
ÌÌ 

structSize
ÌÌ &
)
ÌÌ& '
;
ÌÌ' (
UnsafeUtility
ÔÔ 
.
ÔÔ  
CopyPtrToStructure
ÔÔ 0
<
ÔÔ0 1
T
ÔÔ1 2
>
ÔÔ2 3
(
ÔÔ3 4
Ptr
ÔÔ4 7
+
ÔÔ8 9
Offset
ÔÔ: @
,
ÔÔ@ A
out
ÔÔB E
value
ÔÔF K
)
ÔÔK L
;
ÔÔL M
Offset
 
+=
 

structSize
 $
;
$ %
}
ÒÒ 
[
˘˘ 
BurstCompatible
˘˘ 
(
˘˘ "
GenericTypeArguments
˘˘ 1
=
˘˘2 3
new
˘˘4 7
[
˘˘8 9
]
˘˘9 :
{
˘˘; <
typeof
˘˘= C
(
˘˘C D
int
˘˘D G
)
˘˘G H
}
˘˘I J
)
˘˘J K
]
˘˘K L
public
˙˙ 
T
˙˙ 
ReadNext
˙˙ 
<
˙˙ 
T
˙˙ 
>
˙˙  
(
˙˙  !
)
˙˙! "
where
˙˙# (
T
˙˙) *
:
˙˙+ ,
struct
˙˙- 3
{
˚˚ 
var
¸¸ 

structSize
¸¸ 
=
¸¸  
UnsafeUtility
¸¸! .
.
¸¸. /
SizeOf
¸¸/ 5
<
¸¸5 6
T
¸¸6 7
>
¸¸7 8
(
¸¸8 9
)
¸¸9 :
;
¸¸: ;
CheckBounds
˝˝ 
(
˝˝ 

structSize
˝˝ &
)
˝˝& '
;
˝˝' (
T
ˇˇ 
value
ˇˇ 
=
ˇˇ 
UnsafeUtility
ˇˇ '
.
ˇˇ' (
ReadArrayElement
ˇˇ( 8
<
ˇˇ8 9
T
ˇˇ9 :
>
ˇˇ: ;
(
ˇˇ; <
Ptr
ˇˇ< ?
+
ˇˇ@ A
Offset
ˇˇB H
,
ˇˇH I
$num
ˇˇJ K
)
ˇˇK L
;
ˇˇL M
Offset
ÄÄ 
+=
ÄÄ 

structSize
ÄÄ $
;
ÄÄ$ %
return
ÅÅ 
value
ÅÅ 
;
ÅÅ 
}
ÇÇ 
public
ää 
void
ää 
*
ää 
ReadNext
ää !
(
ää! "
int
ää" %

structSize
ää& 0
)
ää0 1
{
ãã 
CheckBounds
åå 
(
åå 

structSize
åå &
)
åå& '
;
åå' (
var
éé 
value
éé 
=
éé 
(
éé 
void
éé !
*
éé! "
)
éé" #
(
éé# $
(
éé$ %
IntPtr
éé% +
)
éé+ ,
Ptr
éé, /
+
éé0 1
Offset
éé2 8
)
éé8 9
;
éé9 :
Offset
èè 
+=
èè 

structSize
èè $
;
èè$ %
return
êê 
value
êê 
;
êê 
}
ëë 
[
öö 
BurstCompatible
öö 
(
öö "
GenericTypeArguments
öö 1
=
öö2 3
new
öö4 7
[
öö8 9
]
öö9 :
{
öö; <
typeof
öö= C
(
ööC D
int
ööD G
)
ööG H
}
ööI J
)
ööJ K
]
ööK L
public
õõ 
void
õõ 
ReadNext
õõ  
<
õõ  !
T
õõ! "
>
õõ" #
(
õõ# $
out
õõ$ '
NativeArray
õõ( 3
<
õõ3 4
T
õõ4 5
>
õõ5 6
value
õõ7 <
,
õõ< =
AllocatorManager
õõ> N
.
õõN O
AllocatorHandle
õõO ^
	allocator
õõ_ h
)
õõh i
where
õõj o
T
õõp q
:
õõr s
struct
õõt z
{
úú 
var
ùù 
length
ùù 
=
ùù 
ReadNext
ùù %
<
ùù% &
int
ùù& )
>
ùù) *
(
ùù* +
)
ùù+ ,
;
ùù, -
value
ûû 
=
ûû 
CollectionHelper
ûû (
.
ûû( )
CreateNativeArray
ûû) :
<
ûû: ;
T
ûû; <
>
ûû< =
(
ûû= >
length
ûû> D
,
ûûD E
	allocator
ûûF O
)
ûûO P
;
ûûP Q
var
üü 
size
üü 
=
üü 
length
üü !
*
üü" #
UnsafeUtility
üü$ 1
.
üü1 2
SizeOf
üü2 8
<
üü8 9
T
üü9 :
>
üü: ;
(
üü; <
)
üü< =
;
üü= >
if
†† 
(
†† 
size
†† 
>
†† 
$num
†† 
)
†† 
{
°° 
var
¢¢ 
ptr
¢¢ 
=
¢¢ 
ReadNext
¢¢ &
(
¢¢& '
size
¢¢' +
)
¢¢+ ,
;
¢¢, -
UnsafeUtility
££ !
.
££! "
MemCpy
££" (
(
££( )&
NativeArrayUnsafeUtility
££) A
.
££A B
GetUnsafePtr
££B N
(
££N O
value
££O T
)
££T U
,
££U V
ptr
££W Z
,
££Z [
size
££\ `
)
££` a
;
££a b
}
§§ 
}
•• 
[
±± 
BurstCompatible
±± 
(
±± "
GenericTypeArguments
±± 1
=
±±2 3
new
±±4 7
[
±±8 9
]
±±9 :
{
±±; <
typeof
±±= C
(
±±C D
int
±±D G
)
±±G H
}
±±I J
)
±±J K
]
±±K L
public
≤≤ 
void
≤≤ 
*
≤≤ 
ReadNextArray
≤≤ &
<
≤≤& '
T
≤≤' (
>
≤≤( )
(
≤≤) *
out
≤≤* -
int
≤≤. 1
length
≤≤2 8
)
≤≤8 9
where
≤≤: ?
T
≤≤@ A
:
≤≤B C
struct
≤≤D J
{
≥≥ 
length
¥¥ 
=
¥¥ 
ReadNext
¥¥ !
<
¥¥! "
int
¥¥" %
>
¥¥% &
(
¥¥& '
)
¥¥' (
;
¥¥( )
return
µµ 
(
µµ 
length
µµ 
==
µµ !
$num
µµ" #
)
µµ# $
?
µµ% &
null
µµ' +
:
µµ, -
ReadNext
µµ. 6
(
µµ6 7
length
µµ7 =
*
µµ> ?
UnsafeUtility
µµ@ M
.
µµM N
SizeOf
µµN T
<
µµT U
T
µµU V
>
µµV W
(
µµW X
)
µµX Y
)
µµY Z
;
µµZ [
}
∂∂ 
[
¬¬  
NotBurstCompatible
¬¬ 
]
¬¬0 1
[
√√ 
Obsolete
√√ 
(
√√ 
$str√√ ô
,√√ô ö
false√√õ †
)√√† °
]√√° ¢
public
ƒƒ 
void
ƒƒ 
ReadNext
ƒƒ  
(
ƒƒ  !
out
ƒƒ! $
string
ƒƒ% +
value
ƒƒ, 1
)
ƒƒ1 2
=>
ƒƒ3 5 
NotBurstCompatible
ƒƒ6 H
.
ƒƒH I

Extensions
ƒƒI S
.
ƒƒS T
ReadNextNBC
ƒƒT _
(
ƒƒ_ `
ref
ƒƒ` c
this
ƒƒd h
,
ƒƒh i
out
ƒƒj m
value
ƒƒn s
)
ƒƒs t
;
ƒƒt u
[
«« 
Conditional
«« 
(
«« 
$str
«« :
)
««: ;
]
««; <
void
»» 
CheckBounds
»» 
(
»» 
int
»»  

structSize
»»! +
)
»»+ ,
{
…… 
if
   
(
   
Offset
   
+
   

structSize
   '
>
  ( )
Size
  * .
)
  . /
{
ÀÀ 
throw
ÃÃ 
new
ÃÃ 
ArgumentException
ÃÃ /
(
ÃÃ/ 0
$"
ÃÃ0 2
$str
ÃÃ2 }
{
ÃÃ} ~
SizeÃÃ~ Ç
-ÃÃÉ Ñ
OffsetÃÃÖ ã
}ÃÃã å
$strÃÃå ò
{ÃÃò ô

structSizeÃÃô £
}ÃÃ£ §
"ÃÃ§ •
)ÃÃ• ¶
;ÃÃ¶ ß
}
ÕÕ 
}
ŒŒ 
}
œœ 	
[
—— 	
Conditional
——	 
(
—— 
$str
—— 6
)
——6 7
]
——7 8
static
““ 
void
““ 
CheckAlignment
““ "
(
““" #
int
““# &
	alignment
““' 0
)
““0 1
{
”” 	
var
‘‘ 
zeroAlignment
‘‘ 
=
‘‘ 
	alignment
‘‘  )
==
‘‘* ,
$num
‘‘- .
;
‘‘. /
var
’’ 
powTwoAlignment
’’ 
=
’’  !
(
’’" #
(
’’# $
	alignment
’’$ -
-
’’. /
$num
’’0 1
)
’’1 2
&
’’3 4
	alignment
’’5 >
)
’’> ?
==
’’@ B
$num
’’C D
;
’’D E
var
÷÷ 
validAlignment
÷÷ 
=
÷÷  
(
÷÷! "
!
÷÷" #
zeroAlignment
÷÷# 0
)
÷÷0 1
&&
÷÷2 4
powTwoAlignment
÷÷5 D
;
÷÷D E
if
ÿÿ 
(
ÿÿ 
!
ÿÿ 
validAlignment
ÿÿ 
)
ÿÿ  
{
ŸŸ 
throw
⁄⁄ 
new
⁄⁄ 
ArgumentException
⁄⁄ +
(
⁄⁄+ ,
$"
⁄⁄, .
$str
⁄⁄. u
{
⁄⁄u v
	alignment
⁄⁄v 
}⁄⁄ Ä
"⁄⁄Ä Å
)⁄⁄Å Ç
;⁄⁄Ç É
}
€€ 
}
‹‹ 	
}
›› 
}ﬁﬁ ï
eC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeBitArray.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{ 
[ 
DebuggerDisplay 
( 
$str A
)A B
]B C
[ 
DebuggerTypeProxy 
( 
typeof 
( #
UnsafeBitArrayDebugView 5
)5 6
)6 7
]7 8
[ 
BurstCompatible 
] 
public 

unsafe 
struct 
UnsafeBitArray '
: 	
INativeDisposable
 
{ 
[ 	-
!NativeDisableUnsafePtrRestriction	 *
]* +
public 
ulong 
* 
Ptr 
; 
public 
int 
Length 
; 
public%% 
AllocatorManager%% 
.%%  
AllocatorHandle%%  /
	Allocator%%0 9
;%%9 :
public-- 
unsafe-- 
UnsafeBitArray-- $
(--$ %
void--% )
*--) *
ptr--+ .
,--. /
int--0 3
sizeInBytes--4 ?
,--? @
AllocatorManager--A Q
.--Q R
AllocatorHandle--R a
	allocator--b k
=--l m
new--n q
AllocatorManager	--r Ç
.
--Ç É
AllocatorHandle
--É í
(
--í ì
)
--ì î
)
--î ï
{.. 	 
CheckSizeMultipleOf8//  
(//  !
sizeInBytes//! ,
)//, -
;//- .
Ptr00 
=00 
(00 
ulong00 
*00 
)00 
ptr00 
;00 
Length11 
=11 
sizeInBytes11  
*11! "
$num11# $
;11$ %
	Allocator22 
=22 
	allocator22 !
;22! "
}33 	
public;; 
UnsafeBitArray;; 
(;; 
int;; !
numBits;;" )
,;;) *
AllocatorManager;;+ ;
.;;; <
AllocatorHandle;;< K
	allocator;;L U
,;;U V
NativeArrayOptions;;W i
options;;j q
=;;r s
NativeArrayOptions	;;t Ü
.
;;Ü á
ClearMemory
;;á í
)
;;í ì
{<< 	
CollectionHelper== 
.== 
CheckAllocator== +
(==+ ,
	allocator==, 5
)==5 6
;==6 7
	Allocator>> 
=>> 
	allocator>> !
;>>! "
var?? 
sizeInBytes?? 
=?? 
Bitwise?? %
.??% &
AlignUp??& -
(??- .
numBits??. 5
,??5 6
$num??7 9
)??9 :
/??; <
$num??= >
;??> ?
Ptr@@ 
=@@ 
(@@ 
ulong@@ 
*@@ 
)@@ 
Memory@@  
.@@  !
	Unmanaged@@! *
.@@* +
Allocate@@+ 3
(@@3 4
sizeInBytes@@4 ?
,@@? @
$num@@A C
,@@C D
	allocator@@E N
)@@N O
;@@O P
LengthAA 
=AA 
numBitsAA 
;AA 
ifCC 
(CC 
optionsCC 
==CC 
NativeArrayOptionsCC -
.CC- .
ClearMemoryCC. 9
)CC9 :
{DD 
UnsafeUtilityEE 
.EE 
MemClearEE &
(EE& '
PtrEE' *
,EE* +
sizeInBytesEE, 7
)EE7 8
;EE8 9
}FF 
}GG 	
publicMM 
boolMM 
	IsCreatedMM 
=>MM  
PtrMM! $
!=MM% '
nullMM( ,
;MM, -
publicRR 
voidRR 
DisposeRR 
(RR 
)RR 
{SS 	
ifTT 
(TT 
CollectionHelperTT  
.TT  !
ShouldDeallocateTT! 1
(TT1 2
	AllocatorTT2 ;
)TT; <
)TT< =
{UU 
MemoryVV 
.VV 
	UnmanagedVV  
.VV  !
FreeVV! %
(VV% &
PtrVV& )
,VV) *
	AllocatorVV+ 4
)VV4 5
;VV5 6
	AllocatorWW 
=WW 
AllocatorManagerWW ,
.WW, -
InvalidWW- 4
;WW4 5
}XX 
PtrZZ 
=ZZ 
nullZZ 
;ZZ 
Length[[ 
=[[ 
$num[[ 
;[[ 
}\\ 	
[cc 	
NotBurstCompatiblecc	 
]
ccú ù
publicdd 
	JobHandledd 
Disposedd  
(dd  !
	JobHandledd! *
	inputDepsdd+ 4
)dd4 5
{ee 	
ifff 
(ff 
CollectionHelperff  
.ff  !
ShouldDeallocateff! 1
(ff1 2
	Allocatorff2 ;
)ff; <
)ff< =
{gg 
varhh 
	jobHandlehh 
=hh 
newhh  #
UnsafeDisposeJobhh$ 4
{hh5 6
Ptrhh7 :
=hh; <
Ptrhh= @
,hh@ A
	AllocatorhhB K
=hhL M
	AllocatorhhN W
}hhX Y
.hhY Z
SchedulehhZ b
(hhb c
	inputDepshhc l
)hhl m
;hhm n
Ptrjj 
=jj 
nulljj 
;jj 
	Allocatorkk 
=kk 
AllocatorManagerkk ,
.kk, -
Invalidkk- 4
;kk4 5
returnmm 
	jobHandlemm  
;mm  !
}nn 
Ptrpp 
=pp 
nullpp 
;pp 
returnrr 
	inputDepsrr 
;rr 
}ss 	
publicxx 
voidxx 
Clearxx 
(xx 
)xx 
{yy 	
varzz 
sizeInByteszz 
=zz 
Bitwisezz %
.zz% &
AlignUpzz& -
(zz- .
Lengthzz. 4
,zz4 5
$numzz6 8
)zz8 9
/zz: ;
$numzz< =
;zz= >
UnsafeUtility{{ 
.{{ 
MemClear{{ "
({{" #
Ptr{{# &
,{{& '
sizeInBytes{{( 3
){{3 4
;{{4 5
}|| 	
public
ÉÉ 
void
ÉÉ 
Set
ÉÉ 
(
ÉÉ 
int
ÉÉ 
pos
ÉÉ 
,
ÉÉ  
bool
ÉÉ! %
value
ÉÉ& +
)
ÉÉ+ ,
{
ÑÑ 	
	CheckArgs
ÖÖ 
(
ÖÖ 
pos
ÖÖ 
,
ÖÖ 
$num
ÖÖ 
)
ÖÖ 
;
ÖÖ 
var
áá 
idx
áá 
=
áá 
pos
áá 
>>
áá 
$num
áá 
;
áá 
var
àà 
shift
àà 
=
àà 
pos
àà 
&
àà 
$num
àà "
;
àà" #
var
ââ 
mask
ââ 
=
ââ 
$num
ââ 
<<
ââ 
shift
ââ #
;
ââ# $
var
ää 
bits
ää 
=
ää 
(
ää 
Ptr
ää 
[
ää 
idx
ää 
]
ää  
&
ää! "
~
ää# $
mask
ää$ (
)
ää( )
|
ää* +
(
ää, -
(
ää- .
ulong
ää. 3
)
ää3 4
-
ää4 5
Bitwise
ää5 <
.
ää< =
FromBool
ää= E
(
ääE F
value
ääF K
)
ääK L
&
ääM N
mask
ääO S
)
ääS T
;
ääT U
Ptr
ãã 
[
ãã 
idx
ãã 
]
ãã 
=
ãã 
bits
ãã 
;
ãã 
}
åå 	
public
ôô 
void
ôô 
SetBits
ôô 
(
ôô 
int
ôô 
pos
ôô  #
,
ôô# $
bool
ôô% )
value
ôô* /
,
ôô/ 0
int
ôô1 4
numBits
ôô5 <
)
ôô< =
{
öö 	
	CheckArgs
õõ 
(
õõ 
pos
õõ 
,
õõ 
numBits
õõ "
)
õõ" #
;
õõ# $
var
ùù 
end
ùù 
=
ùù 
math
ùù 
.
ùù 
min
ùù 
(
ùù 
pos
ùù "
+
ùù# $
numBits
ùù% ,
,
ùù, -
Length
ùù. 4
)
ùù4 5
;
ùù5 6
var
ûû 
idxB
ûû 
=
ûû 
pos
ûû 
>>
ûû 
$num
ûû 
;
ûû  
var
üü 
shiftB
üü 
=
üü 
pos
üü 
&
üü 
$num
üü #
;
üü# $
var
†† 
idxE
†† 
=
†† 
(
†† 
end
†† 
-
†† 
$num
†† 
)
††  
>>
††! #
$num
††$ %
;
††% &
var
°° 
shiftE
°° 
=
°° 
end
°° 
&
°° 
$num
°° #
;
°°# $
var
¢¢ 
maskB
¢¢ 
=
¢¢ 
$num
¢¢ ,
<<
¢¢- /
shiftB
¢¢0 6
;
¢¢6 7
var
££ 
maskE
££ 
=
££ 
$num
££ ,
>>
££- /
(
££0 1
$num
££1 3
-
££4 5
shiftE
££6 <
)
££< =
;
££= >
var
§§ 
orBits
§§ 
=
§§ 
(
§§ 
ulong
§§ 
)
§§  
-
§§  !
Bitwise
§§! (
.
§§( )
FromBool
§§) 1
(
§§1 2
value
§§2 7
)
§§7 8
;
§§8 9
var
•• 
orBitsB
•• 
=
•• 
maskB
•• 
&
••  !
orBits
••" (
;
••( )
var
¶¶ 
orBitsE
¶¶ 
=
¶¶ 
maskE
¶¶ 
&
¶¶  !
orBits
¶¶" (
;
¶¶( )
var
ßß 
cmaskB
ßß 
=
ßß 
~
ßß 
maskB
ßß 
;
ßß  
var
®® 
cmaskE
®® 
=
®® 
~
®® 
maskE
®® 
;
®®  
if
™™ 
(
™™ 
idxB
™™ 
==
™™ 
idxE
™™ 
)
™™ 
{
´´ 
var
¨¨ 
maskBE
¨¨ 
=
¨¨ 
maskB
¨¨ "
&
¨¨# $
maskE
¨¨% *
;
¨¨* +
var
≠≠ 
cmaskBE
≠≠ 
=
≠≠ 
~
≠≠ 
maskBE
≠≠ %
;
≠≠% &
var
ÆÆ 
orBitsBE
ÆÆ 
=
ÆÆ 
orBitsB
ÆÆ &
&
ÆÆ' (
orBitsE
ÆÆ) 0
;
ÆÆ0 1
Ptr
ØØ 
[
ØØ 
idxB
ØØ 
]
ØØ 
=
ØØ 
(
ØØ 
Ptr
ØØ  
[
ØØ  !
idxB
ØØ! %
]
ØØ% &
&
ØØ' (
cmaskBE
ØØ) 0
)
ØØ0 1
|
ØØ2 3
orBitsBE
ØØ4 <
;
ØØ< =
return
∞∞ 
;
∞∞ 
}
±± 
Ptr
≥≥ 
[
≥≥ 
idxB
≥≥ 
]
≥≥ 
=
≥≥ 
(
≥≥ 
Ptr
≥≥ 
[
≥≥ 
idxB
≥≥ !
]
≥≥! "
&
≥≥# $
cmaskB
≥≥% +
)
≥≥+ ,
|
≥≥- .
orBitsB
≥≥/ 6
;
≥≥6 7
for
µµ 
(
µµ 
var
µµ 
idx
µµ 
=
µµ 
idxB
µµ 
+
µµ  !
$num
µµ" #
;
µµ# $
idx
µµ% (
<
µµ) *
idxE
µµ+ /
;
µµ/ 0
++
µµ1 3
idx
µµ3 6
)
µµ6 7
{
∂∂ 
Ptr
∑∑ 
[
∑∑ 
idx
∑∑ 
]
∑∑ 
=
∑∑ 
orBits
∑∑ !
;
∑∑! "
}
∏∏ 
Ptr
∫∫ 
[
∫∫ 
idxE
∫∫ 
]
∫∫ 
=
∫∫ 
(
∫∫ 
Ptr
∫∫ 
[
∫∫ 
idxE
∫∫ !
]
∫∫! "
&
∫∫# $
cmaskE
∫∫% +
)
∫∫+ ,
|
∫∫- .
orBitsE
∫∫/ 6
;
∫∫6 7
}
ªª 	
public
ÀÀ 
void
ÀÀ 
SetBits
ÀÀ 
(
ÀÀ 
int
ÀÀ 
pos
ÀÀ  #
,
ÀÀ# $
ulong
ÀÀ% *
value
ÀÀ+ 0
,
ÀÀ0 1
int
ÀÀ2 5
numBits
ÀÀ6 =
=
ÀÀ> ?
$num
ÀÀ@ A
)
ÀÀA B
{
ÃÃ 	
CheckArgsUlong
ÕÕ 
(
ÕÕ 
pos
ÕÕ 
,
ÕÕ 
numBits
ÕÕ  '
)
ÕÕ' (
;
ÕÕ( )
var
œœ 
idxB
œœ 
=
œœ 
pos
œœ 
>>
œœ 
$num
œœ 
;
œœ  
var
–– 
shiftB
–– 
=
–– 
pos
–– 
&
–– 
$num
–– #
;
––# $
if
““ 
(
““ 
shiftB
““ 
+
““ 
numBits
““  
<=
““! #
$num
““$ &
)
““& '
{
”” 
var
‘‘ 
mask
‘‘ 
=
‘‘ 
$num
‘‘ /
>>
‘‘0 2
(
‘‘3 4
$num
‘‘4 6
-
‘‘7 8
numBits
‘‘9 @
)
‘‘@ A
;
‘‘A B
Ptr
’’ 
[
’’ 
idxB
’’ 
]
’’ 
=
’’ 
Bitwise
’’ #
.
’’# $
ReplaceBits
’’$ /
(
’’/ 0
Ptr
’’0 3
[
’’3 4
idxB
’’4 8
]
’’8 9
,
’’9 :
shiftB
’’; A
,
’’A B
mask
’’C G
,
’’G H
value
’’I N
)
’’N O
;
’’O P
return
◊◊ 
;
◊◊ 
}
ÿÿ 
var
⁄⁄ 
end
⁄⁄ 
=
⁄⁄ 
math
⁄⁄ 
.
⁄⁄ 
min
⁄⁄ 
(
⁄⁄ 
pos
⁄⁄ "
+
⁄⁄# $
numBits
⁄⁄% ,
,
⁄⁄, -
Length
⁄⁄. 4
)
⁄⁄4 5
;
⁄⁄5 6
var
€€ 
idxE
€€ 
=
€€ 
(
€€ 
end
€€ 
-
€€ 
$num
€€ 
)
€€  
>>
€€! #
$num
€€$ %
;
€€% &
var
‹‹ 
shiftE
‹‹ 
=
‹‹ 
end
‹‹ 
&
‹‹ 
$num
‹‹ #
;
‹‹# $
var
ﬁﬁ 
maskB
ﬁﬁ 
=
ﬁﬁ 
$num
ﬁﬁ ,
>>
ﬁﬁ- /
shiftB
ﬁﬁ0 6
;
ﬁﬁ6 7
Ptr
ﬂﬂ 
[
ﬂﬂ 
idxB
ﬂﬂ 
]
ﬂﬂ 
=
ﬂﬂ 
Bitwise
ﬂﬂ 
.
ﬂﬂ  
ReplaceBits
ﬂﬂ  +
(
ﬂﬂ+ ,
Ptr
ﬂﬂ, /
[
ﬂﬂ/ 0
idxB
ﬂﬂ0 4
]
ﬂﬂ4 5
,
ﬂﬂ5 6
shiftB
ﬂﬂ7 =
,
ﬂﬂ= >
maskB
ﬂﬂ? D
,
ﬂﬂD E
value
ﬂﬂF K
)
ﬂﬂK L
;
ﬂﬂL M
var
·· 
valueE
·· 
=
·· 
value
·· 
>>
·· !
(
··" #
$num
··# %
-
··& '
shiftB
··( .
)
··. /
;
··/ 0
var
‚‚ 
maskE
‚‚ 
=
‚‚ 
$num
‚‚ ,
>>
‚‚- /
(
‚‚0 1
$num
‚‚1 3
-
‚‚4 5
shiftE
‚‚6 <
)
‚‚< =
;
‚‚= >
Ptr
„„ 
[
„„ 
idxE
„„ 
]
„„ 
=
„„ 
Bitwise
„„ 
.
„„  
ReplaceBits
„„  +
(
„„+ ,
Ptr
„„, /
[
„„/ 0
idxE
„„0 4
]
„„4 5
,
„„5 6
$num
„„7 8
,
„„8 9
maskE
„„: ?
,
„„? @
valueE
„„A G
)
„„G H
;
„„H I
}
‰‰ 	
public
ÛÛ 
ulong
ÛÛ 
GetBits
ÛÛ 
(
ÛÛ 
int
ÛÛ  
pos
ÛÛ! $
,
ÛÛ$ %
int
ÛÛ& )
numBits
ÛÛ* 1
=
ÛÛ2 3
$num
ÛÛ4 5
)
ÛÛ5 6
{
ÙÙ 	
CheckArgsUlong
ıı 
(
ıı 
pos
ıı 
,
ıı 
numBits
ıı  '
)
ıı' (
;
ıı( )
var
˜˜ 
idxB
˜˜ 
=
˜˜ 
pos
˜˜ 
>>
˜˜ 
$num
˜˜ 
;
˜˜  
var
¯¯ 
shiftB
¯¯ 
=
¯¯ 
pos
¯¯ 
&
¯¯ 
$num
¯¯ #
;
¯¯# $
if
˙˙ 
(
˙˙ 
shiftB
˙˙ 
+
˙˙ 
numBits
˙˙  
<=
˙˙! #
$num
˙˙$ &
)
˙˙& '
{
˚˚ 
var
¸¸ 
mask
¸¸ 
=
¸¸ 
$num
¸¸ /
>>
¸¸0 2
(
¸¸3 4
$num
¸¸4 6
-
¸¸7 8
numBits
¸¸9 @
)
¸¸@ A
;
¸¸A B
return
˝˝ 
Bitwise
˝˝ 
.
˝˝ 
ExtractBits
˝˝ *
(
˝˝* +
Ptr
˝˝+ .
[
˝˝. /
idxB
˝˝/ 3
]
˝˝3 4
,
˝˝4 5
shiftB
˝˝6 <
,
˝˝< =
mask
˝˝> B
)
˝˝B C
;
˝˝C D
}
˛˛ 
var
ÄÄ 
end
ÄÄ 
=
ÄÄ 
math
ÄÄ 
.
ÄÄ 
min
ÄÄ 
(
ÄÄ 
pos
ÄÄ "
+
ÄÄ# $
numBits
ÄÄ% ,
,
ÄÄ, -
Length
ÄÄ. 4
)
ÄÄ4 5
;
ÄÄ5 6
var
ÅÅ 
idxE
ÅÅ 
=
ÅÅ 
(
ÅÅ 
end
ÅÅ 
-
ÅÅ 
$num
ÅÅ 
)
ÅÅ  
>>
ÅÅ! #
$num
ÅÅ$ %
;
ÅÅ% &
var
ÇÇ 
shiftE
ÇÇ 
=
ÇÇ 
end
ÇÇ 
&
ÇÇ 
$num
ÇÇ #
;
ÇÇ# $
var
ÑÑ 
maskB
ÑÑ 
=
ÑÑ 
$num
ÑÑ ,
>>
ÑÑ- /
shiftB
ÑÑ0 6
;
ÑÑ6 7
ulong
ÖÖ 
valueB
ÖÖ 
=
ÖÖ 
Bitwise
ÖÖ "
.
ÖÖ" #
ExtractBits
ÖÖ# .
(
ÖÖ. /
Ptr
ÖÖ/ 2
[
ÖÖ2 3
idxB
ÖÖ3 7
]
ÖÖ7 8
,
ÖÖ8 9
shiftB
ÖÖ: @
,
ÖÖ@ A
maskB
ÖÖB G
)
ÖÖG H
;
ÖÖH I
var
áá 
maskE
áá 
=
áá 
$num
áá ,
>>
áá- /
(
áá0 1
$num
áá1 3
-
áá4 5
shiftE
áá6 <
)
áá< =
;
áá= >
ulong
àà 
valueE
àà 
=
àà 
Bitwise
àà "
.
àà" #
ExtractBits
àà# .
(
àà. /
Ptr
àà/ 2
[
àà2 3
idxE
àà3 7
]
àà7 8
,
àà8 9
$num
àà: ;
,
àà; <
maskE
àà= B
)
ààB C
;
ààC D
return
ää 
(
ää 
valueE
ää 
<<
ää 
(
ää 
$num
ää !
-
ää" #
shiftB
ää$ *
)
ää* +
)
ää+ ,
|
ää- .
valueB
ää/ 5
;
ää5 6
}
ãã 	
public
ìì 
bool
ìì 
IsSet
ìì 
(
ìì 
int
ìì 
pos
ìì !
)
ìì! "
{
îî 	
	CheckArgs
ïï 
(
ïï 
pos
ïï 
,
ïï 
$num
ïï 
)
ïï 
;
ïï 
var
óó 
idx
óó 
=
óó 
pos
óó 
>>
óó 
$num
óó 
;
óó 
var
òò 
shift
òò 
=
òò 
pos
òò 
&
òò 
$num
òò "
;
òò" #
var
ôô 
mask
ôô 
=
ôô 
$num
ôô 
<<
ôô 
shift
ôô #
;
ôô# $
return
öö 
$num
öö 
!=
öö 
(
öö 
Ptr
öö 
[
öö 
idx
öö "
]
öö" #
&
öö$ %
mask
öö& *
)
öö* +
;
öö+ ,
}
õõ 	
internal
ùù 
void
ùù 
	CopyUlong
ùù 
(
ùù  
int
ùù  #
dstPos
ùù$ *
,
ùù* +
ref
ùù, /
UnsafeBitArray
ùù0 >
srcBitArray
ùù? J
,
ùùJ K
int
ùùL O
srcPos
ùùP V
,
ùùV W
int
ùùX [
numBits
ùù\ c
)
ùùc d
=>
ùùe g
SetBits
ùùh o
(
ùùo p
dstPos
ùùp v
,
ùùv w
srcBitArrayùùx É
.ùùÉ Ñ
GetBitsùùÑ ã
(ùùã å
srcPosùùå í
,ùùí ì
numBitsùùî õ
)ùùõ ú
,ùùú ù
numBitsùùû •
)ùù• ¶
;ùù¶ ß
public
¨¨ 
void
¨¨ 
Copy
¨¨ 
(
¨¨ 
int
¨¨ 
dstPos
¨¨ #
,
¨¨# $
int
¨¨% (
srcPos
¨¨) /
,
¨¨/ 0
int
¨¨1 4
numBits
¨¨5 <
)
¨¨< =
{
≠≠ 	
if
ÆÆ 
(
ÆÆ 
dstPos
ÆÆ 
==
ÆÆ 
srcPos
ÆÆ  
)
ÆÆ  !
{
ØØ 
return
∞∞ 
;
∞∞ 
}
±± 
Copy
≥≥ 
(
≥≥ 
dstPos
≥≥ 
,
≥≥ 
ref
≥≥ 
this
≥≥ !
,
≥≥! "
srcPos
≥≥# )
,
≥≥) *
numBits
≥≥+ 2
)
≥≥2 3
;
≥≥3 4
}
¥¥ 	
public
ƒƒ 
void
ƒƒ 
Copy
ƒƒ 
(
ƒƒ 
int
ƒƒ 
dstPos
ƒƒ #
,
ƒƒ# $
ref
ƒƒ% (
UnsafeBitArray
ƒƒ) 7
srcBitArray
ƒƒ8 C
,
ƒƒC D
int
ƒƒE H
srcPos
ƒƒI O
,
ƒƒO P
int
ƒƒQ T
numBits
ƒƒU \
)
ƒƒ\ ]
{
≈≈ 	
if
∆∆ 
(
∆∆ 
numBits
∆∆ 
==
∆∆ 
$num
∆∆ 
)
∆∆ 
{
«« 
return
»» 
;
»» 
}
…… 
CheckArgsCopy
ÀÀ 
(
ÀÀ 
ref
ÀÀ 
this
ÀÀ "
,
ÀÀ" #
dstPos
ÀÀ$ *
,
ÀÀ* +
ref
ÀÀ, /
srcBitArray
ÀÀ0 ;
,
ÀÀ; <
srcPos
ÀÀ= C
,
ÀÀC D
numBits
ÀÀE L
)
ÀÀL M
;
ÀÀM N
if
ÕÕ 
(
ÕÕ 
numBits
ÕÕ 
<=
ÕÕ 
$num
ÕÕ 
)
ÕÕ 
{
ŒŒ 
	CopyUlong
œœ 
(
œœ 
dstPos
œœ  
,
œœ  !
ref
œœ" %
srcBitArray
œœ& 1
,
œœ1 2
srcPos
œœ3 9
,
œœ9 :
numBits
œœ; B
)
œœB C
;
œœC D
}
–– 
else
—— 
if
—— 
(
—— 
numBits
—— 
<=
—— 
$num
——  #
)
——# $
{
““ 
	CopyUlong
”” 
(
”” 
dstPos
””  
,
””  !
ref
””" %
srcBitArray
””& 1
,
””1 2
srcPos
””3 9
,
””9 :
$num
””; =
)
””= >
;
””> ?
numBits
‘‘ 
-=
‘‘ 
$num
‘‘ 
;
‘‘ 
if
÷÷ 
(
÷÷ 
numBits
÷÷ 
>
÷÷ 
$num
÷÷ 
)
÷÷  
{
◊◊ 
	CopyUlong
ÿÿ 
(
ÿÿ 
dstPos
ÿÿ $
+
ÿÿ% &
$num
ÿÿ' )
,
ÿÿ) *
ref
ÿÿ+ .
srcBitArray
ÿÿ/ :
,
ÿÿ: ;
srcPos
ÿÿ< B
+
ÿÿC D
$num
ÿÿE G
,
ÿÿG H
numBits
ÿÿI P
)
ÿÿP Q
;
ÿÿQ R
}
ŸŸ 
}
⁄⁄ 
else
€€ 
if
€€ 
(
€€ 
(
€€ 
dstPos
€€ 
&
€€ 
$num
€€  
)
€€  !
==
€€" $
(
€€% &
srcPos
€€& ,
&
€€- .
$num
€€/ 0
)
€€0 1
)
€€1 2
{
‹‹ 
var
›› 
dstPosInBytes
›› !
=
››" #
CollectionHelper
››$ 4
.
››4 5
Align
››5 :
(
››: ;
dstPos
››; A
,
››A B
$num
››C D
)
››D E
>>
››F H
$num
››I J
;
››J K
var
ﬁﬁ 
srcPosInBytes
ﬁﬁ !
=
ﬁﬁ" #
CollectionHelper
ﬁﬁ$ 4
.
ﬁﬁ4 5
Align
ﬁﬁ5 :
(
ﬁﬁ: ;
srcPos
ﬁﬁ; A
,
ﬁﬁA B
$num
ﬁﬁC D
)
ﬁﬁD E
>>
ﬁﬁF H
$num
ﬁﬁI J
;
ﬁﬁJ K
var
ﬂﬂ 

numPreBits
ﬂﬂ 
=
ﬂﬂ  
dstPosInBytes
ﬂﬂ! .
*
ﬂﬂ/ 0
$num
ﬂﬂ1 2
-
ﬂﬂ3 4
dstPos
ﬂﬂ5 ;
;
ﬂﬂ; <
if
·· 
(
·· 

numPreBits
·· 
>
··  
$num
··! "
)
··" #
{
‚‚ 
	CopyUlong
„„ 
(
„„ 
dstPos
„„ $
,
„„$ %
ref
„„& )
srcBitArray
„„* 5
,
„„5 6
srcPos
„„7 =
,
„„= >

numPreBits
„„? I
)
„„I J
;
„„J K
}
‰‰ 
var
ÊÊ 
numBitsLeft
ÊÊ 
=
ÊÊ  !
numBits
ÊÊ" )
-
ÊÊ* +

numPreBits
ÊÊ, 6
;
ÊÊ6 7
var
ÁÁ 
numBytes
ÁÁ 
=
ÁÁ 
numBitsLeft
ÁÁ *
/
ÁÁ+ ,
$num
ÁÁ- .
;
ÁÁ. /
if
ÈÈ 
(
ÈÈ 
numBytes
ÈÈ 
>
ÈÈ 
$num
ÈÈ  
)
ÈÈ  !
{
ÍÍ 
unsafe
ÎÎ 
{
ÏÏ 
UnsafeUtility
ÌÌ %
.
ÌÌ% &
MemMove
ÌÌ& -
(
ÌÌ- .
(
ÌÌ. /
byte
ÌÌ/ 3
*
ÌÌ3 4
)
ÌÌ4 5
Ptr
ÌÌ5 8
+
ÌÌ9 :
dstPosInBytes
ÌÌ; H
,
ÌÌH I
(
ÌÌJ K
byte
ÌÌK O
*
ÌÌO P
)
ÌÌP Q
srcBitArray
ÌÌQ \
.
ÌÌ\ ]
Ptr
ÌÌ] `
+
ÌÌa b
srcPosInBytes
ÌÌc p
,
ÌÌp q
numBytes
ÌÌr z
)
ÌÌz {
;
ÌÌ{ |
}
ÓÓ 
}
ÔÔ 
var
ÒÒ 
numPostBits
ÒÒ 
=
ÒÒ  !
numBitsLeft
ÒÒ" -
&
ÒÒ. /
$num
ÒÒ0 1
;
ÒÒ1 2
if
ÛÛ 
(
ÛÛ 
numPostBits
ÛÛ 
>
ÛÛ  !
$num
ÛÛ" #
)
ÛÛ# $
{
ÙÙ 
	CopyUlong
ıı 
(
ıı 
(
ıı 
dstPosInBytes
ıı ,
+
ıı- .
numBytes
ıı/ 7
)
ıı7 8
*
ıı9 :
$num
ıı; <
,
ıı< =
ref
ıı> A
srcBitArray
ııB M
,
ııM N
(
ııO P
srcPosInBytes
ııP ]
+
ıı^ _
numBytes
ıı` h
)
ııh i
*
ııj k
$num
ııl m
,
ıım n
numPostBits
ııo z
)
ıız {
;
ıı{ |
}
ˆˆ 
}
˜˜ 
else
¯¯ 
{
˘˘ 
var
˙˙ 
dstPosAligned
˙˙ !
=
˙˙" #
CollectionHelper
˙˙$ 4
.
˙˙4 5
Align
˙˙5 :
(
˙˙: ;
dstPos
˙˙; A
,
˙˙A B
$num
˙˙C E
)
˙˙E F
;
˙˙F G
var
˚˚ 

numPreBits
˚˚ 
=
˚˚  
dstPosAligned
˚˚! .
-
˚˚/ 0
dstPos
˚˚1 7
;
˚˚7 8
if
˝˝ 
(
˝˝ 

numPreBits
˝˝ 
>
˝˝  
$num
˝˝! "
)
˝˝" #
{
˛˛ 
	CopyUlong
ˇˇ 
(
ˇˇ 
dstPos
ˇˇ $
,
ˇˇ$ %
ref
ˇˇ& )
srcBitArray
ˇˇ* 5
,
ˇˇ5 6
srcPos
ˇˇ7 =
,
ˇˇ= >

numPreBits
ˇˇ? I
)
ˇˇI J
;
ˇˇJ K
numBits
ÄÄ 
-=
ÄÄ 

numPreBits
ÄÄ )
;
ÄÄ) *
dstPos
ÅÅ 
+=
ÅÅ 

numPreBits
ÅÅ (
;
ÅÅ( )
srcPos
ÇÇ 
+=
ÇÇ 

numPreBits
ÇÇ (
;
ÇÇ( )
}
ÉÉ 
for
ÖÖ 
(
ÖÖ 
;
ÖÖ 
numBits
ÖÖ 
>=
ÖÖ !
$num
ÖÖ" $
;
ÖÖ$ %
numBits
ÖÖ& -
-=
ÖÖ. 0
$num
ÖÖ1 3
,
ÖÖ3 4
dstPos
ÖÖ5 ;
+=
ÖÖ< >
$num
ÖÖ? A
,
ÖÖA B
srcPos
ÖÖC I
+=
ÖÖJ L
$num
ÖÖM O
)
ÖÖO P
{
ÜÜ 
Ptr
áá 
[
áá 
dstPos
áá 
>>
áá !
$num
áá" #
]
áá# $
=
áá% &
srcBitArray
áá' 2
.
áá2 3
GetBits
áá3 :
(
áá: ;
srcPos
áá; A
,
ááA B
$num
ááC E
)
ááE F
;
ááF G
}
àà 
if
ää 
(
ää 
numBits
ää 
>
ää 
$num
ää 
)
ää  
{
ãã 
	CopyUlong
åå 
(
åå 
dstPos
åå $
,
åå$ %
ref
åå& )
srcBitArray
åå* 5
,
åå5 6
srcPos
åå7 =
,
åå= >
numBits
åå? F
)
ååF G
;
ååG H
}
çç 
}
éé 
}
èè 	
public
òò 
int
òò 
Find
òò 
(
òò 
int
òò 
pos
òò 
,
òò  
int
òò! $
numBits
òò% ,
)
òò, -
{
ôô 	
var
öö 
count
öö 
=
öö 
Length
öö 
-
öö  
pos
öö! $
;
öö$ %
CheckArgsPosCount
õõ 
(
õõ 
pos
õõ !
,
õõ! "
count
õõ# (
,
õõ( )
numBits
õõ* 1
)
õõ1 2
;
õõ2 3
return
úú 
Bitwise
úú 
.
úú 
Find
úú 
(
úú  
Ptr
úú  #
,
úú# $
pos
úú% (
,
úú( )
count
úú* /
,
úú/ 0
numBits
úú1 8
)
úú8 9
;
úú9 :
}
ùù 	
public
ßß 
int
ßß 
Find
ßß 
(
ßß 
int
ßß 
pos
ßß 
,
ßß  
int
ßß! $
count
ßß% *
,
ßß* +
int
ßß, /
numBits
ßß0 7
)
ßß7 8
{
®® 	
CheckArgsPosCount
©© 
(
©© 
pos
©© !
,
©©! "
count
©©# (
,
©©( )
numBits
©©* 1
)
©©1 2
;
©©2 3
return
™™ 
Bitwise
™™ 
.
™™ 
Find
™™ 
(
™™  
Ptr
™™  #
,
™™# $
pos
™™% (
,
™™( )
count
™™* /
,
™™/ 0
numBits
™™1 8
)
™™8 9
;
™™9 :
}
´´ 	
public
¥¥ 
bool
¥¥ 
TestNone
¥¥ 
(
¥¥ 
int
¥¥  
pos
¥¥! $
,
¥¥$ %
int
¥¥& )
numBits
¥¥* 1
=
¥¥2 3
$num
¥¥4 5
)
¥¥5 6
{
µµ 	
	CheckArgs
∂∂ 
(
∂∂ 
pos
∂∂ 
,
∂∂ 
numBits
∂∂ "
)
∂∂" #
;
∂∂# $
var
∏∏ 
end
∏∏ 
=
∏∏ 
math
∏∏ 
.
∏∏ 
min
∏∏ 
(
∏∏ 
pos
∏∏ "
+
∏∏# $
numBits
∏∏% ,
,
∏∏, -
Length
∏∏. 4
)
∏∏4 5
;
∏∏5 6
var
ππ 
idxB
ππ 
=
ππ 
pos
ππ 
>>
ππ 
$num
ππ 
;
ππ  
var
∫∫ 
shiftB
∫∫ 
=
∫∫ 
pos
∫∫ 
&
∫∫ 
$num
∫∫ #
;
∫∫# $
var
ªª 
idxE
ªª 
=
ªª 
(
ªª 
end
ªª 
-
ªª 
$num
ªª 
)
ªª  
>>
ªª! #
$num
ªª$ %
;
ªª% &
var
ºº 
shiftE
ºº 
=
ºº 
end
ºº 
&
ºº 
$num
ºº #
;
ºº# $
var
ΩΩ 
maskB
ΩΩ 
=
ΩΩ 
$num
ΩΩ ,
<<
ΩΩ- /
shiftB
ΩΩ0 6
;
ΩΩ6 7
var
ææ 
maskE
ææ 
=
ææ 
$num
ææ ,
>>
ææ- /
(
ææ0 1
$num
ææ1 3
-
ææ4 5
shiftE
ææ6 <
)
ææ< =
;
ææ= >
if
¿¿ 
(
¿¿ 
idxB
¿¿ 
==
¿¿ 
idxE
¿¿ 
)
¿¿ 
{
¡¡ 
var
¬¬ 
mask
¬¬ 
=
¬¬ 
maskB
¬¬  
&
¬¬! "
maskE
¬¬# (
;
¬¬( )
return
√√ 
$num
√√ 
==
√√ 
(
√√ 
Ptr
√√ "
[
√√" #
idxB
√√# '
]
√√' (
&
√√) *
mask
√√+ /
)
√√/ 0
;
√√0 1
}
ƒƒ 
if
∆∆ 
(
∆∆ 
$num
∆∆ 
!=
∆∆ 
(
∆∆ 
Ptr
∆∆ 
[
∆∆ 
idxB
∆∆  
]
∆∆  !
&
∆∆" #
maskB
∆∆$ )
)
∆∆) *
)
∆∆* +
{
«« 
return
»» 
false
»» 
;
»» 
}
…… 
for
ÀÀ 
(
ÀÀ 
var
ÀÀ 
idx
ÀÀ 
=
ÀÀ 
idxB
ÀÀ 
+
ÀÀ  !
$num
ÀÀ" #
;
ÀÀ# $
idx
ÀÀ% (
<
ÀÀ) *
idxE
ÀÀ+ /
;
ÀÀ/ 0
++
ÀÀ1 3
idx
ÀÀ3 6
)
ÀÀ6 7
{
ÃÃ 
if
ÕÕ 
(
ÕÕ 
$num
ÕÕ 
!=
ÕÕ 
Ptr
ÕÕ 
[
ÕÕ 
idx
ÕÕ "
]
ÕÕ" #
)
ÕÕ# $
{
ŒŒ 
return
œœ 
false
œœ  
;
œœ  !
}
–– 
}
—— 
return
”” 
$num
”” 
==
”” 
(
”” 
Ptr
”” 
[
”” 
idxE
”” #
]
””# $
&
””% &
maskE
””' ,
)
””, -
;
””- .
}
‘‘ 	
public
›› 
bool
›› 
TestAny
›› 
(
›› 
int
›› 
pos
››  #
,
››# $
int
››% (
numBits
››) 0
=
››1 2
$num
››3 4
)
››4 5
{
ﬁﬁ 	
	CheckArgs
ﬂﬂ 
(
ﬂﬂ 
pos
ﬂﬂ 
,
ﬂﬂ 
numBits
ﬂﬂ "
)
ﬂﬂ" #
;
ﬂﬂ# $
var
·· 
end
·· 
=
·· 
math
·· 
.
·· 
min
·· 
(
·· 
pos
·· "
+
··# $
numBits
··% ,
,
··, -
Length
··. 4
)
··4 5
;
··5 6
var
‚‚ 
idxB
‚‚ 
=
‚‚ 
pos
‚‚ 
>>
‚‚ 
$num
‚‚ 
;
‚‚  
var
„„ 
shiftB
„„ 
=
„„ 
pos
„„ 
&
„„ 
$num
„„ #
;
„„# $
var
‰‰ 
idxE
‰‰ 
=
‰‰ 
(
‰‰ 
end
‰‰ 
-
‰‰ 
$num
‰‰ 
)
‰‰  
>>
‰‰! #
$num
‰‰$ %
;
‰‰% &
var
ÂÂ 
shiftE
ÂÂ 
=
ÂÂ 
end
ÂÂ 
&
ÂÂ 
$num
ÂÂ #
;
ÂÂ# $
var
ÊÊ 
maskB
ÊÊ 
=
ÊÊ 
$num
ÊÊ ,
<<
ÊÊ- /
shiftB
ÊÊ0 6
;
ÊÊ6 7
var
ÁÁ 
maskE
ÁÁ 
=
ÁÁ 
$num
ÁÁ ,
>>
ÁÁ- /
(
ÁÁ0 1
$num
ÁÁ1 3
-
ÁÁ4 5
shiftE
ÁÁ6 <
)
ÁÁ< =
;
ÁÁ= >
if
ÈÈ 
(
ÈÈ 
idxB
ÈÈ 
==
ÈÈ 
idxE
ÈÈ 
)
ÈÈ 
{
ÍÍ 
var
ÎÎ 
mask
ÎÎ 
=
ÎÎ 
maskB
ÎÎ  
&
ÎÎ! "
maskE
ÎÎ# (
;
ÎÎ( )
return
ÏÏ 
$num
ÏÏ 
!=
ÏÏ 
(
ÏÏ 
Ptr
ÏÏ "
[
ÏÏ" #
idxB
ÏÏ# '
]
ÏÏ' (
&
ÏÏ) *
mask
ÏÏ+ /
)
ÏÏ/ 0
;
ÏÏ0 1
}
ÌÌ 
if
ÔÔ 
(
ÔÔ 
$num
ÔÔ 
!=
ÔÔ 
(
ÔÔ 
Ptr
ÔÔ 
[
ÔÔ 
idxB
ÔÔ  
]
ÔÔ  !
&
ÔÔ" #
maskB
ÔÔ$ )
)
ÔÔ) *
)
ÔÔ* +
{
 
return
ÒÒ 
true
ÒÒ 
;
ÒÒ 
}
ÚÚ 
for
ÙÙ 
(
ÙÙ 
var
ÙÙ 
idx
ÙÙ 
=
ÙÙ 
idxB
ÙÙ 
+
ÙÙ  !
$num
ÙÙ" #
;
ÙÙ# $
idx
ÙÙ% (
<
ÙÙ) *
idxE
ÙÙ+ /
;
ÙÙ/ 0
++
ÙÙ1 3
idx
ÙÙ3 6
)
ÙÙ6 7
{
ıı 
if
ˆˆ 
(
ˆˆ 
$num
ˆˆ 
!=
ˆˆ 
Ptr
ˆˆ 
[
ˆˆ 
idx
ˆˆ "
]
ˆˆ" #
)
ˆˆ# $
{
˜˜ 
return
¯¯ 
true
¯¯ 
;
¯¯  
}
˘˘ 
}
˙˙ 
return
¸¸ 
$num
¸¸ 
!=
¸¸ 
(
¸¸ 
Ptr
¸¸ 
[
¸¸ 
idxE
¸¸ #
]
¸¸# $
&
¸¸% &
maskE
¸¸' ,
)
¸¸, -
;
¸¸- .
}
˝˝ 	
public
ÜÜ 
bool
ÜÜ 
TestAll
ÜÜ 
(
ÜÜ 
int
ÜÜ 
pos
ÜÜ  #
,
ÜÜ# $
int
ÜÜ% (
numBits
ÜÜ) 0
=
ÜÜ1 2
$num
ÜÜ3 4
)
ÜÜ4 5
{
áá 	
	CheckArgs
àà 
(
àà 
pos
àà 
,
àà 
numBits
àà "
)
àà" #
;
àà# $
var
ää 
end
ää 
=
ää 
math
ää 
.
ää 
min
ää 
(
ää 
pos
ää "
+
ää# $
numBits
ää% ,
,
ää, -
Length
ää. 4
)
ää4 5
;
ää5 6
var
ãã 
idxB
ãã 
=
ãã 
pos
ãã 
>>
ãã 
$num
ãã 
;
ãã  
var
åå 
shiftB
åå 
=
åå 
pos
åå 
&
åå 
$num
åå #
;
åå# $
var
çç 
idxE
çç 
=
çç 
(
çç 
end
çç 
-
çç 
$num
çç 
)
çç  
>>
çç! #
$num
çç$ %
;
çç% &
var
éé 
shiftE
éé 
=
éé 
end
éé 
&
éé 
$num
éé #
;
éé# $
var
èè 
maskB
èè 
=
èè 
$num
èè ,
<<
èè- /
shiftB
èè0 6
;
èè6 7
var
êê 
maskE
êê 
=
êê 
$num
êê ,
>>
êê- /
(
êê0 1
$num
êê1 3
-
êê4 5
shiftE
êê6 <
)
êê< =
;
êê= >
if
íí 
(
íí 
idxB
íí 
==
íí 
idxE
íí 
)
íí 
{
ìì 
var
îî 
mask
îî 
=
îî 
maskB
îî  
&
îî! "
maskE
îî# (
;
îî( )
return
ïï 
mask
ïï 
==
ïï 
(
ïï  
Ptr
ïï  #
[
ïï# $
idxB
ïï$ (
]
ïï( )
&
ïï* +
mask
ïï, 0
)
ïï0 1
;
ïï1 2
}
ññ 
if
òò 
(
òò 
maskB
òò 
!=
òò 
(
òò 
Ptr
òò 
[
òò 
idxB
òò "
]
òò" #
&
òò$ %
maskB
òò& +
)
òò+ ,
)
òò, -
{
ôô 
return
öö 
false
öö 
;
öö 
}
õõ 
for
ùù 
(
ùù 
var
ùù 
idx
ùù 
=
ùù 
idxB
ùù 
+
ùù  !
$num
ùù" #
;
ùù# $
idx
ùù% (
<
ùù) *
idxE
ùù+ /
;
ùù/ 0
++
ùù1 3
idx
ùù3 6
)
ùù6 7
{
ûû 
if
üü 
(
üü 
$num
üü (
!=
üü) +
Ptr
üü, /
[
üü/ 0
idx
üü0 3
]
üü3 4
)
üü4 5
{
†† 
return
°° 
false
°°  
;
°°  !
}
¢¢ 
}
££ 
return
•• 
maskE
•• 
==
•• 
(
•• 
Ptr
••  
[
••  !
idxE
••! %
]
••% &
&
••' (
maskE
••) .
)
••. /
;
••/ 0
}
¶¶ 	
public
ØØ 
int
ØØ 
	CountBits
ØØ 
(
ØØ 
int
ØØ  
pos
ØØ! $
,
ØØ$ %
int
ØØ& )
numBits
ØØ* 1
=
ØØ2 3
$num
ØØ4 5
)
ØØ5 6
{
∞∞ 	
	CheckArgs
±± 
(
±± 
pos
±± 
,
±± 
numBits
±± "
)
±±" #
;
±±# $
var
≥≥ 
end
≥≥ 
=
≥≥ 
math
≥≥ 
.
≥≥ 
min
≥≥ 
(
≥≥ 
pos
≥≥ "
+
≥≥# $
numBits
≥≥% ,
,
≥≥, -
Length
≥≥. 4
)
≥≥4 5
;
≥≥5 6
var
¥¥ 
idxB
¥¥ 
=
¥¥ 
pos
¥¥ 
>>
¥¥ 
$num
¥¥ 
;
¥¥  
var
µµ 
shiftB
µµ 
=
µµ 
pos
µµ 
&
µµ 
$num
µµ #
;
µµ# $
var
∂∂ 
idxE
∂∂ 
=
∂∂ 
(
∂∂ 
end
∂∂ 
-
∂∂ 
$num
∂∂ 
)
∂∂  
>>
∂∂! #
$num
∂∂$ %
;
∂∂% &
var
∑∑ 
shiftE
∑∑ 
=
∑∑ 
end
∑∑ 
&
∑∑ 
$num
∑∑ #
;
∑∑# $
var
∏∏ 
maskB
∏∏ 
=
∏∏ 
$num
∏∏ ,
<<
∏∏- /
shiftB
∏∏0 6
;
∏∏6 7
var
ππ 
maskE
ππ 
=
ππ 
$num
ππ ,
>>
ππ- /
(
ππ0 1
$num
ππ1 3
-
ππ4 5
shiftE
ππ6 <
)
ππ< =
;
ππ= >
if
ªª 
(
ªª 
idxB
ªª 
==
ªª 
idxE
ªª 
)
ªª 
{
ºº 
var
ΩΩ 
mask
ΩΩ 
=
ΩΩ 
maskB
ΩΩ  
&
ΩΩ! "
maskE
ΩΩ# (
;
ΩΩ( )
return
ææ 
math
ææ 
.
ææ 
	countbits
ææ %
(
ææ% &
Ptr
ææ& )
[
ææ) *
idxB
ææ* .
]
ææ. /
&
ææ0 1
mask
ææ2 6
)
ææ6 7
;
ææ7 8
}
øø 
var
¡¡ 
count
¡¡ 
=
¡¡ 
math
¡¡ 
.
¡¡ 
	countbits
¡¡ &
(
¡¡& '
Ptr
¡¡' *
[
¡¡* +
idxB
¡¡+ /
]
¡¡/ 0
&
¡¡1 2
maskB
¡¡3 8
)
¡¡8 9
;
¡¡9 :
for
√√ 
(
√√ 
var
√√ 
idx
√√ 
=
√√ 
idxB
√√ 
+
√√  !
$num
√√" #
;
√√# $
idx
√√% (
<
√√) *
idxE
√√+ /
;
√√/ 0
++
√√1 3
idx
√√3 6
)
√√6 7
{
ƒƒ 
count
≈≈ 
+=
≈≈ 
math
≈≈ 
.
≈≈ 
	countbits
≈≈ '
(
≈≈' (
Ptr
≈≈( +
[
≈≈+ ,
idx
≈≈, /
]
≈≈/ 0
)
≈≈0 1
;
≈≈1 2
}
∆∆ 
count
»» 
+=
»» 
math
»» 
.
»» 
	countbits
»» #
(
»»# $
Ptr
»»$ '
[
»»' (
idxE
»»( ,
]
»», -
&
»». /
maskE
»»0 5
)
»»5 6
;
»»6 7
return
   
count
   
;
   
}
ÀÀ 	
[
ÕÕ 	
Conditional
ÕÕ	 
(
ÕÕ 
$str
ÕÕ 6
)
ÕÕ6 7
]
ÕÕ7 8
static
ŒŒ 
void
ŒŒ "
CheckSizeMultipleOf8
ŒŒ (
(
ŒŒ( )
int
ŒŒ) ,
sizeInBytes
ŒŒ- 8
)
ŒŒ8 9
{
œœ 	
if
–– 
(
–– 
(
–– 
sizeInBytes
–– 
&
–– 
$num
––  
)
––  !
!=
––" $
$num
––% &
)
––& '
throw
—— 
new
—— 
ArgumentException
—— +
(
——+ ,
$"
——, .
$str
——. V
{
——V W
sizeInBytes
——W b
}
——b c
$str——c è
{——è ê
sizeInBytes——ê õ
}——õ ú
$str——ú û
"——û ü
)——ü †
;——† °
}
““ 	
[
‘‘ 	
Conditional
‘‘	 
(
‘‘ 
$str
‘‘ 6
)
‘‘6 7
]
‘‘7 8
void
’’ 
	CheckArgs
’’ 
(
’’ 
int
’’ 
pos
’’ 
,
’’ 
int
’’  #
numBits
’’$ +
)
’’+ ,
{
÷÷ 	
if
◊◊ 
(
◊◊ 
pos
◊◊ 
<
◊◊ 
$num
◊◊ 
||
ÿÿ 
pos
ÿÿ 
>=
ÿÿ 
Length
ÿÿ  
||
ŸŸ 
numBits
ŸŸ 
<
ŸŸ 
$num
ŸŸ 
)
ŸŸ 
{
⁄⁄ 
throw
€€ 
new
€€ 
ArgumentException
€€ +
(
€€+ ,
$"
€€, .
$str
€€. N
{
€€N O
pos
€€O R
}
€€R S
$str
€€S _
{
€€_ `
Length
€€` f
-
€€g h
$num
€€i j
}
€€j k
$str
€€k v
{
€€v w
numBits
€€w ~
}
€€~ 
$str€€ ô
"€€ô ö
)€€ö õ
;€€õ ú
}
‹‹ 
}
›› 	
[
ﬂﬂ 	
Conditional
ﬂﬂ	 
(
ﬂﬂ 
$str
ﬂﬂ 6
)
ﬂﬂ6 7
]
ﬂﬂ7 8
void
‡‡ 
CheckArgsPosCount
‡‡ 
(
‡‡ 
int
‡‡ "
begin
‡‡# (
,
‡‡( )
int
‡‡* -
count
‡‡. 3
,
‡‡3 4
int
‡‡5 8
numBits
‡‡9 @
)
‡‡@ A
{
·· 	
if
‚‚ 
(
‚‚ 
begin
‚‚ 
<
‚‚ 
$num
‚‚ 
||
‚‚ 
begin
‚‚ "
>=
‚‚# %
Length
‚‚& ,
)
‚‚, -
{
„„ 
throw
‰‰ 
new
‰‰ 
ArgumentException
‰‰ +
(
‰‰+ ,
$"
‰‰, .
$str
‰‰. O
{
‰‰O P
begin
‰‰P U
}
‰‰U V
$str
‰‰V b
{
‰‰b c
Length
‰‰c i
-
‰‰j k
$num
‰‰l m
}
‰‰m n
$str
‰‰n p
"
‰‰p q
)
‰‰q r
;
‰‰r s
}
ÂÂ 
if
ÁÁ 
(
ÁÁ 
count
ÁÁ 
<
ÁÁ 
$num
ÁÁ 
||
ÁÁ 
count
ÁÁ "
>
ÁÁ# $
Length
ÁÁ% +
)
ÁÁ+ ,
{
ËË 
throw
ÈÈ 
new
ÈÈ 
ArgumentException
ÈÈ +
(
ÈÈ+ ,
$"
ÈÈ, .
$str
ÈÈ. O
{
ÈÈO P
count
ÈÈP U
}
ÈÈU V
$str
ÈÈV b
{
ÈÈb c
Length
ÈÈc i
}
ÈÈi j
$str
ÈÈj l
"
ÈÈl m
)
ÈÈm n
;
ÈÈn o
}
ÍÍ 
if
ÏÏ 
(
ÏÏ 
numBits
ÏÏ 
<
ÏÏ 
$num
ÏÏ 
||
ÏÏ 
count
ÏÏ $
<
ÏÏ% &
numBits
ÏÏ' .
)
ÏÏ. /
{
ÌÌ 
throw
ÓÓ 
new
ÓÓ 
ArgumentException
ÓÓ +
(
ÓÓ+ ,
$"
ÓÓ, .
$str
ÓÓ. Q
{
ÓÓQ R
numBits
ÓÓR Y
}
ÓÓY Z
$str
ÓÓZ t
"
ÓÓt u
)
ÓÓu v
;
ÓÓv w
}
ÔÔ 
}
 	
[
ÚÚ 	
Conditional
ÚÚ	 
(
ÚÚ 
$str
ÚÚ 6
)
ÚÚ6 7
]
ÚÚ7 8
void
ÛÛ 
CheckArgsUlong
ÛÛ 
(
ÛÛ 
int
ÛÛ 
pos
ÛÛ  #
,
ÛÛ# $
int
ÛÛ% (
numBits
ÛÛ) 0
)
ÛÛ0 1
{
ÙÙ 	
	CheckArgs
ıı 
(
ıı 
pos
ıı 
,
ıı 
numBits
ıı "
)
ıı" #
;
ıı# $
if
˜˜ 
(
˜˜ 
numBits
˜˜ 
<
˜˜ 
$num
˜˜ 
||
˜˜ 
numBits
˜˜ &
>
˜˜' (
$num
˜˜) +
)
˜˜+ ,
{
¯¯ 
throw
˘˘ 
new
˘˘ 
ArgumentException
˘˘ +
(
˘˘+ ,
$"
˘˘, .
$str
˘˘. R
{
˘˘R S
numBits
˘˘S Z
}
˘˘Z [
$str
˘˘[ k
"
˘˘k l
)
˘˘l m
;
˘˘m n
}
˙˙ 
if
¸¸ 
(
¸¸ 
pos
¸¸ 
+
¸¸ 
numBits
¸¸ 
>
¸¸ 
Length
¸¸  &
)
¸¸& '
{
˝˝ 
throw
˛˛ 
new
˛˛ 
ArgumentException
˛˛ +
(
˛˛+ ,
$"
˛˛, .
$str
˛˛. \
{
˛˛\ ]
pos
˛˛] `
}
˛˛` a
$str
˛˛a k
{
˛˛k l
numBits
˛˛l s
}
˛˛s t
$str
˛˛t }
{
˛˛} ~
Length˛˛~ Ñ
}˛˛Ñ Ö
$str˛˛Ö Ü
"˛˛Ü á
)˛˛á à
;˛˛à â
}
ˇˇ 
}
ÄÄ 	
[
ÇÇ 	
Conditional
ÇÇ	 
(
ÇÇ 
$str
ÇÇ 6
)
ÇÇ6 7
]
ÇÇ7 8
static
ÉÉ 
void
ÉÉ 
CheckArgsCopy
ÉÉ !
(
ÉÉ! "
ref
ÉÉ" %
UnsafeBitArray
ÉÉ& 4
dstBitArray
ÉÉ5 @
,
ÉÉ@ A
int
ÉÉB E
dstPos
ÉÉF L
,
ÉÉL M
ref
ÉÉN Q
UnsafeBitArray
ÉÉR `
srcBitArray
ÉÉa l
,
ÉÉl m
int
ÉÉn q
srcPos
ÉÉr x
,
ÉÉx y
int
ÉÉz }
numBitsÉÉ~ Ö
)ÉÉÖ Ü
{
ÑÑ 	
if
ÖÖ 
(
ÖÖ 
srcPos
ÖÖ 
+
ÖÖ 
numBits
ÖÖ  
>
ÖÖ! "
srcBitArray
ÖÖ# .
.
ÖÖ. /
Length
ÖÖ/ 5
)
ÖÖ5 6
{
ÜÜ 
throw
áá 
new
áá 
ArgumentException
áá +
(
áá+ ,
$"
áá, .
$str
áá. j
{
ááj k
srcPos
áák q
}
ááq r
$str
áár |
{
áá| }
numBitsáá} Ñ
}ááÑ Ö
$strááÖ ü
{ááü †
srcBitArrayáá† ´
.áá´ ¨
Lengtháá¨ ≤
}áá≤ ≥
$stráá≥ ¥
"áá¥ µ
)ááµ ∂
;áá∂ ∑
}
àà 
if
ää 
(
ää 
dstPos
ää 
+
ää 
numBits
ää  
>
ää! "
dstBitArray
ää# .
.
ää. /
Length
ää/ 5
)
ää5 6
{
ãã 
throw
åå 
new
åå 
ArgumentException
åå +
(
åå+ ,
$"
åå, .
$str
åå. o
{
ååo p
dstPos
ååp v
}
ååv w
$strååw Å
{ååÅ Ç
numBitsååÇ â
}ååâ ä
$strååä ©
{åå© ™
dstBitArrayåå™ µ
.ååµ ∂
Lengthåå∂ º
}ååº Ω
$strååΩ æ
"ååæ ø
)ååø ¿
;åå¿ ¡
}
çç 
}
éé 	
}
èè 
sealed
ëë 

class
ëë %
UnsafeBitArrayDebugView
ëë (
{
íí 
UnsafeBitArray
ìì 
Data
ìì 
;
ìì 
public
ïï %
UnsafeBitArrayDebugView
ïï &
(
ïï& '
UnsafeBitArray
ïï' 5
data
ïï6 :
)
ïï: ;
{
ññ 	
Data
óó 
=
óó 
data
óó 
;
óó 
}
òò 	
public
öö 
bool
öö 
[
öö 
]
öö 
Bits
öö 
{
õõ 	
get
úú 
{
ùù 
var
ûû 
array
ûû 
=
ûû 
new
ûû 
bool
ûû  $
[
ûû$ %
Data
ûû% )
.
ûû) *
Length
ûû* 0
]
ûû0 1
;
ûû1 2
for
üü 
(
üü 
int
üü 
i
üü 
=
üü 
$num
üü 
;
üü 
i
üü  !
<
üü" #
Data
üü$ (
.
üü( )
Length
üü) /
;
üü/ 0
++
üü1 3
i
üü3 4
)
üü4 5
{
†† 
array
°° 
[
°° 
i
°° 
]
°° 
=
°° 
Data
°° #
.
°°# $
IsSet
°°$ )
(
°°) *
i
°°* +
)
°°+ ,
;
°°, -
}
¢¢ 
return
££ 
array
££ 
;
££ 
}
§§ 
}
•• 	
}
¶¶ 
}ßß n
lC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\JetBrains.Annotations.cs∂∂
fC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeReference.cs
	namespace 	
Unity
 
. 
Collections 
{		 
[ 
StructLayout 
( 

LayoutKind 
. 

Sequential '
)' (
]( )
[ 
NativeContainer 
] 
[ 
BurstCompatible 
(  
GenericTypeArguments )
=* +
new, /
[0 1
]1 2
{3 4
typeof5 ;
(; <
int< ?
)? @
}A B
)B C
]C D
public 

unsafe 
struct 
NativeReference (
<( )
T) *
>* +
: 	
INativeDisposable
 
, 	

IEquatable
 
< 
NativeReference $
<$ %
T% &
>& '
>' (
where 
T 
: 
	unmanaged 
{ 
[ 	-
!NativeDisableUnsafePtrRestriction	 *
]* +
internal 
void 
* 
m_Data 
; 
internal 
AtomicSafetyHandle #
m_Safety$ ,
;, -
static 
readonly 
SharedStatic $
<$ %
int% (
>( )

s_SafetyId* 4
=5 6
SharedStatic7 C
<C D
intD G
>G H
.H I
GetOrCreateI T
<T U
NativeReferenceU d
<d e
Te f
>f g
>g h
(h i
)i j
;j k
["" 	.
"NativeSetClassTypeToNullOnSchedule""	 +
]""+ ,
DisposeSentinel## 
m_DisposeSentinel## )
;##) *
internal'' 
AllocatorManager'' !
.''! "
AllocatorHandle''" 1
m_AllocatorLabel''2 B
;''B C
public.. 
NativeReference.. 
(.. 
AllocatorManager.. /
.../ 0
AllocatorHandle..0 ?
	allocator..@ I
,..I J
NativeArrayOptions..K ]
options..^ e
=..f g
NativeArrayOptions..h z
...z {
ClearMemory	..{ Ü
)
..Ü á
{// 	
Allocate00 
(00 
	allocator00 
,00 
out00  #
this00$ (
)00( )
;00) *
if11 
(11 
options11 
==11 
NativeArrayOptions11 -
.11- .
ClearMemory11. 9
)119 :
{22 
UnsafeUtility33 
.33 
MemClear33 &
(33& '
m_Data33' -
,33- .
UnsafeUtility33/ <
.33< =
SizeOf33= C
<33C D
T33D E
>33E F
(33F G
)33G H
)33H I
;33I J
}44 
}55 	
public<< 
NativeReference<< 
(<< 
T<<  
value<<! &
,<<& '
AllocatorManager<<( 8
.<<8 9
AllocatorHandle<<9 H
	allocator<<I R
)<<R S
{== 	
Allocate>> 
(>> 
	allocator>> 
,>> 
out>>  #
this>>$ (
)>>( )
;>>) *
*?? 
(?? 
T?? 
*?? 
)?? 
m_Data?? 
=?? 
value?? 
;??  
}@@ 	
staticBB 
voidBB 
AllocateBB 
(BB 
AllocatorManagerBB -
.BB- .
AllocatorHandleBB. =
	allocatorBB> G
,BBG H
outBBI L
NativeReferenceBBM \
<BB\ ]
TBB] ^
>BB^ _
	referenceBB` i
)BBi j
{CC 	
CollectionHelperDD 
.DD 
CheckAllocatorDD +
(DD+ ,
	allocatorDD, 5
)DD5 6
;DD6 7
	referenceFF 
=FF 
defaultFF 
;FF  
	referenceGG 
.GG 
m_DataGG 
=GG 
MemoryGG %
.GG% &
	UnmanagedGG& /
.GG/ 0
AllocateGG0 8
(GG8 9
UnsafeUtilityGG9 F
.GGF G
SizeOfGGG M
<GGM N
TGGN O
>GGO P
(GGP Q
)GGQ R
,GGR S
UnsafeUtilityGGT a
.GGa b
AlignOfGGb i
<GGi j
TGGj k
>GGk l
(GGl m
)GGm n
,GGn o
	allocatorGGp y
)GGy z
;GGz {
	referenceHH 
.HH 
m_AllocatorLabelHH &
=HH' (
	allocatorHH) 2
;HH2 3
ifNN 
(NN 
	allocatorNN 
.NN 
IsCustomAllocatorNN +
)NN+ ,
{OO 
	referencePP 
.PP 
m_SafetyPP "
=PP# $
AtomicSafetyHandlePP% 7
.PP7 8
CreatePP8 >
(PP> ?
)PP? @
;PP@ A
	referenceQQ 
.QQ 
m_DisposeSentinelQQ +
=QQ, -
nullQQ. 2
;QQ2 3
}RR 
elseSS 
{TT 
DisposeSentinelUU 
.UU  
CreateUU  &
(UU& '
outUU' *
	referenceUU+ 4
.UU4 5
m_SafetyUU5 =
,UU= >
outUU? B
	referenceUUC L
.UUL M
m_DisposeSentinelUUM ^
,UU^ _
$numUU` a
,UUa b
	allocatorUUc l
.UUl m
ToAllocatorUUm x
)UUx y
;UUy z
}VV 
CollectionHelperYY 
.YY 
SetStaticSafetyIdYY .
<YY. /
NativeQueueYY/ :
<YY: ;
TYY; <
>YY< =
>YY= >
(YY> ?
refYY? B
	referenceYYC L
.YYL M
m_SafetyYYM U
,YYU V
refYYW Z

s_SafetyIdYY[ e
.YYe f
DataYYf j
)YYj k
;YYk l
}[[ 	
publicbb 
Tbb 
Valuebb 
{cc 	
getdd 
{ee 
AtomicSafetyHandlegg "
.gg" #
CheckReadAndThrowgg# 4
(gg4 5
m_Safetygg5 =
)gg= >
;gg> ?
returnii 
*ii 
(ii 
Tii 
*ii 
)ii 
m_Dataii "
;ii" #
}jj 
setll 
{mm 
AtomicSafetyHandleoo "
.oo" #
CheckWriteAndThrowoo# 5
(oo5 6
m_Safetyoo6 >
)oo> ?
;oo? @
*qq 
(qq 
Tqq 
*qq 
)qq 
m_Dataqq 
=qq 
valueqq #
;qq# $
}rr 
}ss 	
publicyy 
boolyy 
	IsCreatedyy 
=>yy  
m_Datayy! '
!=yy( *
nullyy+ /
;yy/ 0
public~~ 
void~~ 
Dispose~~ 
(~~ 
)~~ 
{ 	
CheckNotDisposed
ÄÄ 
(
ÄÄ 
)
ÄÄ 
;
ÄÄ 
if
ÇÇ 
(
ÇÇ 
CollectionHelper
ÇÇ  
.
ÇÇ  !
ShouldDeallocate
ÇÇ! 1
(
ÇÇ1 2
m_AllocatorLabel
ÇÇ2 B
)
ÇÇB C
)
ÇÇC D
{
ÉÉ 
DisposeSentinel
ââ 
.
ââ  
Dispose
ââ  '
(
ââ' (
ref
ââ( +
m_Safety
ââ, 4
,
ââ4 5
ref
ââ6 9
m_DisposeSentinel
ââ: K
)
ââK L
;
ââL M
Memory
åå 
.
åå 
	Unmanaged
åå  
.
åå  !
Free
åå! %
(
åå% &
m_Data
åå& ,
,
åå, -
m_AllocatorLabel
åå. >
)
åå> ?
;
åå? @
m_AllocatorLabel
çç  
=
çç! "
	Allocator
çç# ,
.
çç, -
Invalid
çç- 4
;
çç4 5
}
éé 
m_Data
êê 
=
êê 
null
êê 
;
êê 
}
ëë 	
[
òò 	 
NotBurstCompatible
òò	 
]òòú ù
public
ôô 
	JobHandle
ôô 
Dispose
ôô  
(
ôô  !
	JobHandle
ôô! *
	inputDeps
ôô+ 4
)
ôô4 5
{
öö 	
CheckNotDisposed
õõ 
(
õõ 
)
õõ 
;
õõ 
if
ùù 
(
ùù 
CollectionHelper
ùù  
.
ùù  !
ShouldDeallocate
ùù! 1
(
ùù1 2
m_AllocatorLabel
ùù2 B
)
ùùB C
)
ùùC D
{
ûû 
DisposeSentinel
¶¶ 
.
¶¶  
Clear
¶¶  %
(
¶¶% &
ref
¶¶& )
m_DisposeSentinel
¶¶* ;
)
¶¶; <
;
¶¶< =
var
©© 
	jobHandle
©© 
=
©© 
new
©©  #'
NativeReferenceDisposeJob
©©$ =
{
™™ 
Data
´´ 
=
´´ 
new
´´ $
NativeReferenceDispose
´´ 5
{
¨¨ 
m_Data
≠≠ 
=
≠≠  
m_Data
≠≠! '
,
≠≠' (
m_AllocatorLabel
ÆÆ (
=
ÆÆ) *
m_AllocatorLabel
ÆÆ+ ;
,
ÆÆ; <
m_Safety
∞∞  
=
∞∞! "
m_Safety
∞∞# +
}
≤≤ 
}
≥≥ 
.
≥≥ 
Schedule
≥≥ 
(
≥≥ 
	inputDeps
≥≥ $
)
≥≥$ %
;
≥≥% & 
AtomicSafetyHandle
∂∂ "
.
∂∂" #
Release
∂∂# *
(
∂∂* +
m_Safety
∂∂+ 3
)
∂∂3 4
;
∂∂4 5
m_Data
ππ 
=
ππ 
null
ππ 
;
ππ 
m_AllocatorLabel
∫∫  
=
∫∫! "
	Allocator
∫∫# ,
.
∫∫, -
Invalid
∫∫- 4
;
∫∫4 5
return
ºº 
	jobHandle
ºº  
;
ºº  !
}
ΩΩ 
m_Data
øø 
=
øø 
null
øø 
;
øø 
return
¡¡ 
	inputDeps
¡¡ 
;
¡¡ 
}
¬¬ 	
public
»» 
void
»» 
CopyFrom
»» 
(
»» 
NativeReference
»» ,
<
»», -
T
»»- .
>
»». /
	reference
»»0 9
)
»»9 :
{
…… 	
Copy
   
(
   
this
   
,
   
	reference
    
)
    !
;
  ! "
}
ÀÀ 	
public
—— 
void
—— 
CopyTo
—— 
(
—— 
NativeReference
—— *
<
——* +
T
——+ ,
>
——, -
	reference
——. 7
)
——7 8
{
““ 	
Copy
”” 
(
”” 
	reference
”” 
,
”” 
this
””  
)
””  !
;
””! "
}
‘‘ 	
[
€€ 	 
NotBurstCompatible
€€	 
]
€€ 
public
‹‹ 
bool
‹‹ 
Equals
‹‹ 
(
‹‹ 
NativeReference
‹‹ *
<
‹‹* +
T
‹‹+ ,
>
‹‹, -
other
‹‹. 3
)
‹‹3 4
{
›› 	
return
ﬁﬁ 
Value
ﬁﬁ 
.
ﬁﬁ 
Equals
ﬁﬁ 
(
ﬁﬁ  
other
ﬁﬁ  %
.
ﬁﬁ% &
Value
ﬁﬁ& +
)
ﬁﬁ+ ,
;
ﬁﬁ, -
}
ﬂﬂ 	
[
ÁÁ 	 
NotBurstCompatible
ÁÁ	 
]
ÁÁ 
public
ËË 
override
ËË 
bool
ËË 
Equals
ËË #
(
ËË# $
object
ËË$ *
obj
ËË+ .
)
ËË. /
{
ÈÈ 	
if
ÍÍ 
(
ÍÍ 
ReferenceEquals
ÍÍ 
(
ÍÍ  
null
ÍÍ  $
,
ÍÍ$ %
obj
ÍÍ& )
)
ÍÍ) *
)
ÍÍ* +
{
ÎÎ 
return
ÏÏ 
false
ÏÏ 
;
ÏÏ 
}
ÌÌ 
return
ÓÓ 
obj
ÓÓ 
is
ÓÓ 
NativeReference
ÓÓ )
<
ÓÓ) *
T
ÓÓ* +
>
ÓÓ+ ,
&&
ÓÓ- /
Equals
ÓÓ0 6
(
ÓÓ6 7
(
ÓÓ7 8
NativeReference
ÓÓ8 G
<
ÓÓG H
T
ÓÓH I
>
ÓÓI J
)
ÓÓJ K
obj
ÓÓK N
)
ÓÓN O
;
ÓÓO P
}
ÔÔ 	
public
ıı 
override
ıı 
int
ıı 
GetHashCode
ıı '
(
ıı' (
)
ıı( )
{
ˆˆ 	
return
˜˜ 
Value
˜˜ 
.
˜˜ 
GetHashCode
˜˜ $
(
˜˜$ %
)
˜˜% &
;
˜˜& '
}
¯¯ 	
public
ÅÅ 
static
ÅÅ 
bool
ÅÅ 
operator
ÅÅ #
==
ÅÅ$ &
(
ÅÅ& '
NativeReference
ÅÅ' 6
<
ÅÅ6 7
T
ÅÅ7 8
>
ÅÅ8 9
left
ÅÅ: >
,
ÅÅ> ?
NativeReference
ÅÅ@ O
<
ÅÅO P
T
ÅÅP Q
>
ÅÅQ R
right
ÅÅS X
)
ÅÅX Y
{
ÇÇ 	
return
ÉÉ 
left
ÉÉ 
.
ÉÉ 
Equals
ÉÉ 
(
ÉÉ 
right
ÉÉ $
)
ÉÉ$ %
;
ÉÉ% &
}
ÑÑ 	
public
åå 
static
åå 
bool
åå 
operator
åå #
!=
åå$ &
(
åå& '
NativeReference
åå' 6
<
åå6 7
T
åå7 8
>
åå8 9
left
åå: >
,
åå> ?
NativeReference
åå@ O
<
ååO P
T
ååP Q
>
ååQ R
right
ååS X
)
ååX Y
{
çç 	
return
éé 
!
éé 
left
éé 
.
éé 
Equals
éé 
(
éé  
right
éé  %
)
éé% &
;
éé& '
}
èè 	
public
ññ 
static
ññ 
void
ññ 
Copy
ññ 
(
ññ  
NativeReference
ññ  /
<
ññ/ 0
T
ññ0 1
>
ññ1 2
dst
ññ3 6
,
ññ6 7
NativeReference
ññ8 G
<
ññG H
T
ññH I
>
ññI J
src
ññK N
)
ññN O
{
óó 	 
AtomicSafetyHandle
ôô 
.
ôô 
CheckReadAndThrow
ôô 0
(
ôô0 1
src
ôô1 4
.
ôô4 5
m_Safety
ôô5 =
)
ôô= >
;
ôô> ? 
AtomicSafetyHandle
öö 
.
öö  
CheckWriteAndThrow
öö 1
(
öö1 2
dst
öö2 5
.
öö5 6
m_Safety
öö6 >
)
öö> ?
;
öö? @
UnsafeUtility
úú 
.
úú 
MemCpy
úú  
(
úú  !
dst
úú! $
.
úú$ %
m_Data
úú% +
,
úú+ ,
src
úú- 0
.
úú0 1
m_Data
úú1 7
,
úú7 8
UnsafeUtility
úú9 F
.
úúF G
SizeOf
úúG M
<
úúM N
T
úúN O
>
úúO P
(
úúP Q
)
úúQ R
)
úúR S
;
úúS T
}
ùù 	
public
££ 
ReadOnly
££ 

AsReadOnly
££ "
(
££" #
)
££# $
{
§§ 	
return
¶¶ 
new
¶¶ 
ReadOnly
¶¶ 
(
¶¶  
m_Data
¶¶  &
,
¶¶& '
ref
¶¶( +
m_Safety
¶¶, 4
)
¶¶4 5
;
¶¶5 6
}
™™ 	
[
ØØ 	
NativeContainer
ØØ	 
]
ØØ 
[
∞∞ 	'
NativeContainerIsReadOnly
∞∞	 "
]
∞∞" #
[
±± 	
BurstCompatible
±±	 
(
±± "
GenericTypeArguments
±± -
=
±±. /
new
±±0 3
[
±±4 5
]
±±5 6
{
±±7 8
typeof
±±9 ?
(
±±? @
int
±±@ C
)
±±C D
}
±±E F
)
±±F G
]
±±G H
public
≤≤ 
unsafe
≤≤ 
struct
≤≤ 
ReadOnly
≤≤ %
{
≥≥ 	
[
¥¥ /
!NativeDisableUnsafePtrRestriction
¥¥ .
]
¥¥. /
readonly
µµ 
void
µµ 
*
µµ 
m_Data
µµ !
;
µµ! " 
AtomicSafetyHandle
∏∏ 
m_Safety
∏∏ '
;
∏∏' (
internal
ππ 
static
ππ 
readonly
ππ $
SharedStatic
ππ% 1
<
ππ1 2
int
ππ2 5
>
ππ5 6
s_staticSafetyId
ππ7 G
=
ππH I
SharedStatic
ππJ V
<
ππV W
int
ππW Z
>
ππZ [
.
ππ[ \
GetOrCreate
ππ\ g
<
ππg h
ReadOnly
ππh p
>
ππp q
(
ππq r
)
ππr s
;
ππs t
[
ªª 
BurstCompatible
ªª 
(
ªª 
CompileTarget
ªª *
=
ªª+ ,&
BurstCompatibleAttribute
ªª- E
.
ªªE F*
BurstCompatibleCompileTarget
ªªF b
.
ªªb c
Editor
ªªc i
)
ªªi j
]
ªªj k
internal
ºº 
ReadOnly
ºº 
(
ºº 
void
ºº "
*
ºº" #
data
ºº$ (
,
ºº( )
ref
ºº* - 
AtomicSafetyHandle
ºº. @
safety
ººA G
)
ººG H
{
ΩΩ 
m_Data
ææ 
=
ææ 
data
ææ 
;
ææ 
m_Safety
øø 
=
øø 
safety
øø !
;
øø! "
CollectionHelper
¿¿  
.
¿¿  !
SetStaticSafetyId
¿¿! 2
<
¿¿2 3
ReadOnly
¿¿3 ;
>
¿¿; <
(
¿¿< =
ref
¿¿= @
m_Safety
¿¿A I
,
¿¿I J
ref
¿¿K N
s_staticSafetyId
¿¿O _
.
¿¿_ `
Data
¿¿` d
)
¿¿d e
;
¿¿e f
}
¡¡ 
public
ÕÕ 
T
ÕÕ 
Value
ÕÕ 
{
ŒŒ 
get
œœ 
{
––  
AtomicSafetyHandle
““ &
.
““& '
CheckReadAndThrow
““' 8
(
““8 9
m_Safety
““9 A
)
““A B
;
““B C
return
‘‘ 
*
‘‘ 
(
‘‘ 
T
‘‘ 
*
‘‘ 
)
‘‘  
m_Data
‘‘  &
;
‘‘& '
}
’’ 
}
÷÷ 
}
◊◊ 	
[
ŸŸ 	
Conditional
ŸŸ	 
(
ŸŸ 
$str
ŸŸ 6
)
ŸŸ6 7
]
ŸŸ7 8
void
⁄⁄ 
CheckNotDisposed
⁄⁄ 
(
⁄⁄ 
)
⁄⁄ 
{
€€ 	
if
‹‹ 
(
‹‹ 
m_Data
‹‹ 
==
‹‹ 
null
‹‹ 
)
‹‹ 
throw
›› 
new
›› %
ObjectDisposedException
›› 1
(
››1 2
$str
››2 \
)
››\ ]
;
››] ^
}
ﬁﬁ 	
}
ﬂﬂ 
[
·· 
NativeContainer
·· 
]
·· 
unsafe
‚‚ 

struct
‚‚ $
NativeReferenceDispose
‚‚ (
{
„„ 
[
‰‰ 	/
!NativeDisableUnsafePtrRestriction
‰‰	 *
]
‰‰* +
internal
ÂÂ 
void
ÂÂ 
*
ÂÂ 
m_Data
ÂÂ 
;
ÂÂ 
internal
ÁÁ 
AllocatorManager
ÁÁ !
.
ÁÁ! "
AllocatorHandle
ÁÁ" 1
m_AllocatorLabel
ÁÁ2 B
;
ÁÁB C
internal
ÍÍ  
AtomicSafetyHandle
ÍÍ #
m_Safety
ÍÍ$ ,
;
ÍÍ, -
public
ÌÌ 
void
ÌÌ 
Dispose
ÌÌ 
(
ÌÌ 
)
ÌÌ 
{
ÓÓ 	
Memory
ÔÔ 
.
ÔÔ 
	Unmanaged
ÔÔ 
.
ÔÔ 
Free
ÔÔ !
(
ÔÔ! "
m_Data
ÔÔ" (
,
ÔÔ( )
m_AllocatorLabel
ÔÔ* :
)
ÔÔ: ;
;
ÔÔ; <
}
 	
}
ÒÒ 
[
ÛÛ 
BurstCompile
ÛÛ 
]
ÛÛ 
struct
ÙÙ 
'
NativeReferenceDisposeJob
ÙÙ $
:
ÙÙ% &
IJob
ÙÙ' +
{
ıı 
internal
ˆˆ $
NativeReferenceDispose
ˆˆ '
Data
ˆˆ( ,
;
ˆˆ, -
public
¯¯ 
void
¯¯ 
Execute
¯¯ 
(
¯¯ 
)
¯¯ 
{
˘˘ 	
Data
˙˙ 
.
˙˙ 
Dispose
˙˙ 
(
˙˙ 
)
˙˙ 
;
˙˙ 
}
˚˚ 	
}
¸¸ 
}˝˝ 
	namespaceˇˇ 	
Unity
ˇˇ
 
.
ˇˇ 
Collections
ˇˇ 
.
ˇˇ 
LowLevel
ˇˇ $
.
ˇˇ$ %
Unsafe
ˇˇ% +
{ÄÄ 
[
ÑÑ 
BurstCompatible
ÑÑ 
]
ÑÑ 
public
ÖÖ 

static
ÖÖ 
class
ÖÖ *
NativeReferenceUnsafeUtility
ÖÖ 4
{
ÜÜ 
[
éé 	
BurstCompatible
éé	 
(
éé "
GenericTypeArguments
éé -
=
éé. /
new
éé0 3
[
éé4 5
]
éé5 6
{
éé7 8
typeof
éé9 ?
(
éé? @
int
éé@ C
)
ééC D
}
ééE F
)
ééF G
]
ééG H
public
èè 
static
èè 
unsafe
èè 
void
èè !
*
èè! "
GetUnsafePtr
èè# /
<
èè/ 0
T
èè0 1
>
èè1 2
(
èè2 3
this
èè3 7
NativeReference
èè8 G
<
èèG H
T
èèH I
>
èèI J
	reference
èèK T
)
èèT U
where
êê 
T
êê 
:
êê 
	unmanaged
êê 
{
ëë 	 
AtomicSafetyHandle
ìì 
.
ìì  
CheckWriteAndThrow
ìì 1
(
ìì1 2
	reference
ìì2 ;
.
ìì; <
m_Safety
ìì< D
)
ììD E
;
ììE F
return
ïï 
	reference
ïï 
.
ïï 
m_Data
ïï #
;
ïï# $
}
ññ 	
[
üü 	
BurstCompatible
üü	 
(
üü "
GenericTypeArguments
üü -
=
üü. /
new
üü0 3
[
üü4 5
]
üü5 6
{
üü7 8
typeof
üü9 ?
(
üü? @
int
üü@ C
)
üüC D
}
üüE F
)
üüF G
]
üüG H
public
†† 
static
†† 
unsafe
†† 
void
†† !
*
††! ""
GetUnsafeReadOnlyPtr
††# 7
<
††7 8
T
††8 9
>
††9 :
(
††: ;
this
††; ?
NativeReference
††@ O
<
††O P
T
††P Q
>
††Q R
	reference
††S \
)
††\ ]
where
°° 
T
°° 
:
°° 
	unmanaged
°° 
{
¢¢ 	 
AtomicSafetyHandle
§§ 
.
§§ 
CheckReadAndThrow
§§ 0
(
§§0 1
	reference
§§1 :
.
§§: ;
m_Safety
§§; C
)
§§C D
;
§§D E
return
¶¶ 
	reference
¶¶ 
.
¶¶ 
m_Data
¶¶ #
;
¶¶# $
}
ßß 	
[
∞∞ 	
BurstCompatible
∞∞	 
(
∞∞ "
GenericTypeArguments
∞∞ -
=
∞∞. /
new
∞∞0 3
[
∞∞4 5
]
∞∞5 6
{
∞∞7 8
typeof
∞∞9 ?
(
∞∞? @
int
∞∞@ C
)
∞∞C D
}
∞∞E F
)
∞∞F G
]
∞∞G H
public
±± 
static
±± 
unsafe
±± 
void
±± !
*
±±! "'
GetUnsafePtrWithoutChecks
±±# <
<
±±< =
T
±±= >
>
±±> ?
(
±±? @
this
±±@ D
NativeReference
±±E T
<
±±T U
T
±±U V
>
±±V W
	reference
±±X a
)
±±a b
where
≤≤ 
T
≤≤ 
:
≤≤ 
	unmanaged
≤≤ 
{
≥≥ 	
return
¥¥ 
	reference
¥¥ 
.
¥¥ 
m_Data
¥¥ #
;
¥¥# $
}
µµ 	
}
∂∂ 
}∑∑ “”
aC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeSort.cs
	namespace

 	
Unity


 
.

 
Collections

 
{ 
[ 
BurstCompatible 
] 
public 

static 
class 
NativeSortExtension +
{ 
[ 	
BurstCompatible	 
(  
GenericTypeArguments -
=. /
new0 3
[3 4
]4 5
{6 7
typeof8 >
(> ?
int? B
)B C
}D E
)E F
]F G
public 
struct 
DefaultComparer %
<% &
T& '
>' (
:) *
	IComparer+ 4
<4 5
T5 6
>6 7
where8 =
T> ?
:@ A
IComparableB M
<M N
TN O
>O P
{ 	
public   
int   
Compare   
(   
T    
x  ! "
,  " #
T  $ %
y  & '
)  ' (
=>  ) +
x  , -
.  - .
	CompareTo  . 7
(  7 8
y  8 9
)  9 :
;  : ;
}!! 	
[** 	
BurstCompatible**	 
(**  
GenericTypeArguments** -
=**. /
new**0 3
[**3 4
]**4 5
{**6 7
typeof**8 >
(**> ?
int**? B
)**B C
}**D E
)**E F
]**F G
public++ 
unsafe++ 
static++ 
void++ !
Sort++" &
<++& '
T++' (
>++( )
(++) *
T++* +
*+++ ,
array++- 2
,++2 3
int++4 7
length++8 >
)++> ?
where,, 
T,, 
:,, 
	unmanaged,, 
,,,  
IComparable,,! ,
<,,, -
T,,- .
>,,. /
{-- 	
	IntroSort.. 
<.. 
T.. 
,.. 
DefaultComparer.. (
<..( )
T..) *
>..* +
>..+ ,
(.., -
array..- 2
,..2 3
length..4 :
,..: ;
new..< ?
DefaultComparer..@ O
<..O P
T..P Q
>..Q R
(..R S
)..S T
)..T U
;..U V
}// 	
[:: 	
BurstCompatible::	 
(::  
GenericTypeArguments:: -
=::. /
new::0 3
[::3 4
]::4 5
{::6 7
typeof::8 >
(::> ?
int::? B
)::B C
,::C D
typeof::E K
(::K L
DefaultComparer::L [
<::[ \
int::\ _
>::_ `
)::` a
}::b c
)::c d
]::d e
public;; 
unsafe;; 
static;; 
void;; !
Sort;;" &
<;;& '
T;;' (
,;;( )
U;;* +
>;;+ ,
(;;, -
T;;- .
*;;. /
array;;0 5
,;;5 6
int;;7 :
length;;; A
,;;A B
U;;C D
comp;;E I
);;I J
where<< 
T<< 
:<< 
	unmanaged<< 
where== 
U== 
:== 
	IComparer== 
<==  
T==  !
>==! "
{>> 	
	IntroSort?? 
<?? 
T?? 
,?? 
U?? 
>?? 
(?? 
array?? !
,??! "
length??# )
,??) *
comp??+ /
)??/ 0
;??0 1
}@@ 	
[KK 	
NotBurstCompatibleKK	 
]
KKú ù
[LL 	
ObsoleteLL	 
(LL 
$strLL `
,LL` a
falseLLb g
)LLg h
]LLh i
publicMM 
unsafeMM 
staticMM 
	JobHandleMM &
SortMM' +
<MM+ ,
TMM, -
>MM- .
(MM. /
TMM/ 0
*MM0 1
arrayMM2 7
,MM7 8
intMM9 <
lengthMM= C
,MMC D
	JobHandleMME N
	inputDepsMMO X
)MMX Y
whereNN 
TNN 
:NN 
	unmanagedNN 
,NN  
IComparableNN! ,
<NN, -
TNN- .
>NN. /
{OO 	
returnPP 
SortPP 
(PP 
arrayPP 
,PP 
lengthPP %
,PP% &
newPP' *
DefaultComparerPP+ :
<PP: ;
TPP; <
>PP< =
(PP= >
)PP> ?
,PP? @
	inputDepsPPA J
)PPJ K
;PPK L
}QQ 	
[\\ 	
BurstCompatible\\	 
(\\  
GenericTypeArguments\\ -
=\\. /
new\\0 3
[\\3 4
]\\4 5
{\\6 7
typeof\\8 >
(\\> ?
int\\? B
)\\B C
}\\D E
,\\E F
RequiredUnityDefine\\G Z
=\\[ \
$str\\] t
)
\\® ©
]
\\© ™
public]] 
unsafe]] 
static]] 
SortJob]] $
<]]$ %
T]]% &
,]]& '
DefaultComparer]]( 7
<]]7 8
T]]8 9
>]]9 :
>]]: ;
SortJob]]< C
<]]C D
T]]D E
>]]E F
(]]F G
T]]G H
*]]H I
array]]J O
,]]O P
int]]Q T
length]]U [
)]][ \
where^^ 
T^^ 
:^^ 
	unmanaged^^ 
,^^  
IComparable^^! ,
<^^, -
T^^- .
>^^. /
{__ 	
return`` 
new`` 
SortJob`` 
<`` 
T``  
,``  !
DefaultComparer``" 1
<``1 2
T``2 3
>``3 4
>``4 5
{``6 7
Data``7 ;
=``< =
array``> C
,``C D
Length``E K
=``L M
length``N T
,``T U
Comp``V Z
=``[ \
new``] `
DefaultComparer``a p
<``p q
T``q r
>``r s
(``s t
)``t u
}``u v
;``v w
}aa 	
[nn 	
NotBurstCompatiblenn	 
]
nnú ù
[oo 	
Obsoleteoo	 
(oo 
$stroo c
,ooc d
falseooe j
)ooj k
]ook l
publicpp 
unsafepp 
staticpp 
	JobHandlepp &
Sortpp' +
<pp+ ,
Tpp, -
,pp- .
Upp/ 0
>pp0 1
(pp1 2
Tpp2 3
*pp3 4
arraypp5 :
,pp: ;
intpp< ?
lengthpp@ F
,ppF G
UppH I
compppJ N
,ppN O
	JobHandleppP Y
	inputDepsppZ c
)ppc d
whereqq 
Tqq 
:qq 
	unmanagedqq 
whererr 
Urr 
:rr 
	IComparerrr 
<rr  
Trr  !
>rr! "
{ss 	
iftt 
(tt 
lengthtt 
==tt 
$numtt 
)tt 
{uu 
returnvv 
	inputDepsvv  
;vv  !
}ww 
varyy 
segmentCountyy 
=yy 
(yy  
lengthyy  &
+yy' (
$numyy) -
)yy- .
/yy/ 0
$numyy1 5
;yy5 6
var{{ 
workerCount{{ 
={{ 
math{{ "
.{{" #
max{{# &
({{& '
$num{{' (
,{{( )
JobsUtility{{* 5
.{{5 6
MaxJobThreadCount{{6 G
){{G H
;{{H I
var|| 
workerSegmentCount|| "
=||# $
segmentCount||% 1
/||2 3
workerCount||4 ?
;||? @
var}} 
segmentSortJob}} 
=}}  
new}}! $
SegmentSort}}% 0
<}}0 1
T}}1 2
,}}2 3
U}}4 5
>}}5 6
{}}7 8
Data}}9 =
=}}> ?
array}}@ E
,}}E F
Comp}}G K
=}}L M
comp}}N R
,}}R S
Length}}T Z
=}}[ \
length}}] c
,}}c d
SegmentWidth}}e q
=}}r s
$num}}t x
}}}y z
;}}z {
var~~  
segmentSortJobHandle~~ $
=~~% &
segmentSortJob~~' 5
.~~5 6
Schedule~~6 >
(~~> ?
segmentCount~~? K
,~~K L
workerSegmentCount~~M _
,~~_ `
	inputDeps~~a j
)~~j k
;~~k l
var 
segmentSortMergeJob #
=$ %
new& )
SegmentSortMerge* :
<: ;
T; <
,< =
U> ?
>? @
{A B
DataC G
=H I
arrayJ O
,O P
CompQ U
=V W
compX \
,\ ]
Length^ d
=e f
lengthg m
,m n
SegmentWidtho {
=| }
$num	~ Ç
}
É Ñ
;
Ñ Ö
var
ÄÄ '
segmentSortMergeJobHandle
ÄÄ )
=
ÄÄ* +!
segmentSortMergeJob
ÄÄ, ?
.
ÄÄ? @
Schedule
ÄÄ@ H
(
ÄÄH I"
segmentSortJobHandle
ÄÄI ]
)
ÄÄ] ^
;
ÄÄ^ _
return
ÅÅ '
segmentSortMergeJobHandle
ÅÅ ,
;
ÅÅ, -
}
ÇÇ 	
[
èè 	
BurstCompatible
èè	 
(
èè "
GenericTypeArguments
èè -
=
èè. /
new
èè0 3
[
èè3 4
]
èè4 5
{
èè6 7
typeof
èè8 >
(
èè> ?
int
èè? B
)
èèB C
,
èèC D
typeof
èèE K
(
èèK L
DefaultComparer
èèL [
<
èè[ \
int
èè\ _
>
èè_ `
)
èè` a
}
èèb c
,
èèc d!
RequiredUnityDefine
èèe x
=
èèy z
$strèè{ í
)èè∆ «
]èè« »
public
êê 
unsafe
êê 
static
êê 
SortJob
êê $
<
êê$ %
T
êê% &
,
êê& '
U
êê( )
>
êê) *
SortJob
êê+ 2
<
êê2 3
T
êê3 4
,
êê4 5
U
êê6 7
>
êê7 8
(
êê8 9
T
êê9 :
*
êê: ;
array
êê< A
,
êêA B
int
êêC F
length
êêG M
,
êêM N
U
êêO P
comp
êêQ U
)
êêU V
where
ëë 
T
ëë 
:
ëë 
	unmanaged
ëë 
where
íí 
U
íí 
:
íí 
	IComparer
íí 
<
íí  
T
íí  !
>
íí! "
{
ìì 	
return
îî 
new
îî 
SortJob
îî 
<
îî 
T
îî  
,
îî  !
U
îî" #
>
îî# $
(
îî$ %
)
îî% &
{
îî' (
Data
îî( ,
=
îî- .
array
îî/ 4
,
îî4 5
Length
îî6 <
=
îî= >
length
îî? E
,
îîE F
Comp
îîG K
=
îîL M
comp
îîN R
}
îîR S
;
îîS T
}
ïï 	
[
†† 	
BurstCompatible
††	 
(
†† "
GenericTypeArguments
†† -
=
††. /
new
††0 3
[
††3 4
]
††4 5
{
††6 7
typeof
††8 >
(
††> ?
int
††? B
)
††B C
}
††D E
)
††E F
]
††F G
public
°° 
unsafe
°° 
static
°° 
int
°°  
BinarySearch
°°! -
<
°°- .
T
°°. /
>
°°/ 0
(
°°0 1
T
°°1 2
*
°°2 3
ptr
°°4 7
,
°°7 8
int
°°9 <
length
°°= C
,
°°C D
T
°°E F
value
°°G L
)
°°L M
where
¢¢ 
T
¢¢ 
:
¢¢ 
	unmanaged
¢¢ 
,
¢¢  
IComparable
¢¢! ,
<
¢¢, -
T
¢¢- .
>
¢¢. /
{
££ 	
return
§§ 
BinarySearch
§§ 
(
§§  
ptr
§§  #
,
§§# $
length
§§% +
,
§§+ ,
value
§§- 2
,
§§2 3
new
§§4 7
DefaultComparer
§§8 G
<
§§G H
T
§§H I
>
§§I J
(
§§J K
)
§§K L
)
§§L M
;
§§M N
}
•• 	
[
≤≤ 	
BurstCompatible
≤≤	 
(
≤≤ "
GenericTypeArguments
≤≤ -
=
≤≤. /
new
≤≤0 3
[
≤≤3 4
]
≤≤4 5
{
≤≤6 7
typeof
≤≤8 >
(
≤≤> ?
int
≤≤? B
)
≤≤B C
,
≤≤C D
typeof
≤≤E K
(
≤≤K L
DefaultComparer
≤≤L [
<
≤≤[ \
int
≤≤\ _
>
≤≤_ `
)
≤≤` a
}
≤≤b c
)
≤≤c d
]
≤≤d e
public
≥≥ 
unsafe
≥≥ 
static
≥≥ 
int
≥≥  
BinarySearch
≥≥! -
<
≥≥- .
T
≥≥. /
,
≥≥/ 0
U
≥≥1 2
>
≥≥2 3
(
≥≥3 4
T
≥≥4 5
*
≥≥5 6
ptr
≥≥7 :
,
≥≥: ;
int
≥≥< ?
length
≥≥@ F
,
≥≥F G
T
≥≥H I
value
≥≥J O
,
≥≥O P
U
≥≥Q R
comp
≥≥S W
)
≥≥W X
where
¥¥ 
T
¥¥ 
:
¥¥ 
	unmanaged
¥¥ 
where
µµ 
U
µµ 
:
µµ 
	IComparer
µµ 
<
µµ  
T
µµ  !
>
µµ! "
{
∂∂ 	
var
∑∑ 
offset
∑∑ 
=
∑∑ 
$num
∑∑ 
;
∑∑ 
for
ππ 
(
ππ 
var
ππ 
l
ππ 
=
ππ 
length
ππ 
;
ππ  
l
ππ! "
!=
ππ# %
$num
ππ& '
;
ππ' (
l
ππ) *
>>=
ππ+ .
$num
ππ/ 0
)
ππ0 1
{
∫∫ 
var
ªª 
idx
ªª 
=
ªª 
offset
ªª  
+
ªª! "
(
ªª# $
l
ªª$ %
>>
ªª& (
$num
ªª) *
)
ªª* +
;
ªª+ ,
var
ºº 
curr
ºº 
=
ºº 
ptr
ºº 
[
ºº 
idx
ºº "
]
ºº" #
;
ºº# $
var
ΩΩ 
r
ΩΩ 
=
ΩΩ 
comp
ΩΩ 
.
ΩΩ 
Compare
ΩΩ $
(
ΩΩ$ %
value
ΩΩ% *
,
ΩΩ* +
curr
ΩΩ, 0
)
ΩΩ0 1
;
ΩΩ1 2
if
ææ 
(
ææ 
r
ææ 
==
ææ 
$num
ææ 
)
ææ 
{
øø 
return
¿¿ 
idx
¿¿ 
;
¿¿ 
}
¡¡ 
if
√√ 
(
√√ 
r
√√ 
>
√√ 
$num
√√ 
)
√√ 
{
ƒƒ 
offset
≈≈ 
=
≈≈ 
idx
≈≈  
+
≈≈! "
$num
≈≈# $
;
≈≈$ %
--
∆∆ 
l
∆∆ 
;
∆∆ 
}
«« 
}
»» 
return
   
~
   
offset
   
;
   
}
ÀÀ 	
[
““ 	
BurstCompatible
““	 
(
““ "
GenericTypeArguments
““ -
=
““. /
new
““0 3
[
““3 4
]
““4 5
{
““6 7
typeof
““8 >
(
““> ?
int
““? B
)
““B C
}
““D E
)
““E F
]
““F G
public
”” 
unsafe
”” 
static
”” 
void
”” !
Sort
””" &
<
””& '
T
””' (
>
””( )
(
””) *
this
””* .
NativeArray
””/ :
<
””: ;
T
””; <
>
””< =
array
””> C
)
””C D
where
‘‘ 
T
‘‘ 
:
‘‘ 
struct
‘‘ 
,
‘‘ 
IComparable
‘‘ )
<
‘‘) *
T
‘‘* +
>
‘‘+ ,
{
’’ 	
IntroSortStruct
÷÷ 
<
÷÷ 
T
÷÷ 
,
÷÷ 
DefaultComparer
÷÷ .
<
÷÷. /
T
÷÷/ 0
>
÷÷0 1
>
÷÷1 2
(
÷÷2 3
array
÷÷3 8
.
÷÷8 9
GetUnsafePtr
÷÷9 E
(
÷÷E F
)
÷÷F G
,
÷÷G H
array
÷÷I N
.
÷÷N O
Length
÷÷O U
,
÷÷U V
new
÷÷W Z
DefaultComparer
÷÷[ j
<
÷÷j k
T
÷÷k l
>
÷÷l m
(
÷÷m n
)
÷÷n o
)
÷÷o p
;
÷÷p q
}
◊◊ 	
[
‡‡ 	
BurstCompatible
‡‡	 
(
‡‡ "
GenericTypeArguments
‡‡ -
=
‡‡. /
new
‡‡0 3
[
‡‡3 4
]
‡‡4 5
{
‡‡6 7
typeof
‡‡8 >
(
‡‡> ?
int
‡‡? B
)
‡‡B C
,
‡‡C D
typeof
‡‡E K
(
‡‡K L
DefaultComparer
‡‡L [
<
‡‡[ \
int
‡‡\ _
>
‡‡_ `
)
‡‡` a
}
‡‡b c
)
‡‡c d
]
‡‡d e
public
·· 
unsafe
·· 
static
·· 
void
·· !
Sort
··" &
<
··& '
T
··' (
,
··( )
U
··* +
>
··+ ,
(
··, -
this
··- 1
NativeArray
··2 =
<
··= >
T
··> ?
>
··? @
array
··A F
,
··F G
U
··H I
comp
··J N
)
··N O
where
‚‚ 
T
‚‚ 
:
‚‚ 
struct
‚‚ 
where
„„ 
U
„„ 
:
„„ 
	IComparer
„„ 
<
„„  
T
„„  !
>
„„! "
{
‰‰ 	
IntroSortStruct
ÂÂ 
<
ÂÂ 
T
ÂÂ 
,
ÂÂ 
U
ÂÂ  
>
ÂÂ  !
(
ÂÂ! "
array
ÂÂ" '
.
ÂÂ' (
GetUnsafePtr
ÂÂ( 4
(
ÂÂ4 5
)
ÂÂ5 6
,
ÂÂ6 7
array
ÂÂ8 =
.
ÂÂ= >
Length
ÂÂ> D
,
ÂÂD E
comp
ÂÂF J
)
ÂÂJ K
;
ÂÂK L
}
ÊÊ 	
[
 	 
NotBurstCompatible
	 
]ú ù
[
ÒÒ 	
Obsolete
ÒÒ	 
(
ÒÒ 
$str
ÒÒ l
,
ÒÒl m
false
ÒÒn s
)
ÒÒs t
]
ÒÒt u
public
ÚÚ 
unsafe
ÚÚ 
static
ÚÚ 
	JobHandle
ÚÚ &
Sort
ÚÚ' +
<
ÚÚ+ ,
T
ÚÚ, -
>
ÚÚ- .
(
ÚÚ. /
this
ÚÚ/ 3
NativeArray
ÚÚ4 ?
<
ÚÚ? @
T
ÚÚ@ A
>
ÚÚA B
array
ÚÚC H
,
ÚÚH I
	JobHandle
ÚÚJ S
	inputDeps
ÚÚT ]
)
ÚÚ] ^
where
ÛÛ 
T
ÛÛ 
:
ÛÛ 
	unmanaged
ÛÛ 
,
ÛÛ  
IComparable
ÛÛ! ,
<
ÛÛ, -
T
ÛÛ- .
>
ÛÛ. /
{
ÙÙ 	
return
ıı 
Sort
ıı 
(
ıı 
(
ıı 
T
ıı 
*
ıı 
)
ıı &
NativeArrayUnsafeUtility
ıı 4
.
ıı4 51
#GetUnsafeBufferPointerWithoutChecks
ıı5 X
(
ııX Y
array
ııY ^
)
ıı^ _
,
ıı_ `
array
ııa f
.
ııf g
Length
ııg m
,
ıım n
new
ııo r
DefaultComparerııs Ç
<ııÇ É
TııÉ Ñ
>ııÑ Ö
(ııÖ Ü
)ııÜ á
,ııá à
	inputDepsııâ í
)ııí ì
;ııì î
}
ˆˆ 	
[
ˇˇ 	
BurstCompatible
ˇˇ	 
(
ˇˇ "
GenericTypeArguments
ˇˇ -
=
ˇˇ. /
new
ˇˇ0 3
[
ˇˇ3 4
]
ˇˇ4 5
{
ˇˇ6 7
typeof
ˇˇ8 >
(
ˇˇ> ?
int
ˇˇ? B
)
ˇˇB C
}
ˇˇD E
,
ˇˇE F!
RequiredUnityDefine
ˇˇG Z
=
ˇˇ[ \
$str
ˇˇ] t
)ˇˇ® ©
]ˇˇ© ™
public
ÄÄ 
unsafe
ÄÄ 
static
ÄÄ 
SortJob
ÄÄ $
<
ÄÄ$ %
T
ÄÄ% &
,
ÄÄ& '
DefaultComparer
ÄÄ( 7
<
ÄÄ7 8
T
ÄÄ8 9
>
ÄÄ9 :
>
ÄÄ: ;
SortJob
ÄÄ< C
<
ÄÄC D
T
ÄÄD E
>
ÄÄE F
(
ÄÄF G
this
ÄÄG K
NativeArray
ÄÄL W
<
ÄÄW X
T
ÄÄX Y
>
ÄÄY Z
array
ÄÄ[ `
)
ÄÄ` a
where
ÅÅ 
T
ÅÅ 
:
ÅÅ 
	unmanaged
ÅÅ 
,
ÅÅ  
IComparable
ÅÅ! ,
<
ÅÅ, -
T
ÅÅ- .
>
ÅÅ. /
{
ÇÇ 	
return
ÉÉ 
SortJob
ÉÉ 
(
ÉÉ 
(
ÉÉ 
T
ÉÉ 
*
ÉÉ 
)
ÉÉ &
NativeArrayUnsafeUtility
ÉÉ 7
.
ÉÉ7 81
#GetUnsafeBufferPointerWithoutChecks
ÉÉ8 [
(
ÉÉ[ \
array
ÉÉ\ a
)
ÉÉa b
,
ÉÉb c
array
ÉÉd i
.
ÉÉi j
Length
ÉÉj p
,
ÉÉp q
new
ÉÉr u
DefaultComparerÉÉv Ö
<ÉÉÖ Ü
TÉÉÜ á
>ÉÉá à
(ÉÉà â
)ÉÉâ ä
)ÉÉä ã
;ÉÉã å
}
ÑÑ 	
[
êê 	 
NotBurstCompatible
êê	 
]êêú ù
[
ëë 	
Obsolete
ëë	 
(
ëë 
$str
ëë o
,
ëëo p
false
ëëq v
)
ëëv w
]
ëëw x
public
íí 
unsafe
íí 
static
íí 
	JobHandle
íí &
Sort
íí' +
<
íí+ ,
T
íí, -
,
íí- .
U
íí/ 0
>
íí0 1
(
íí1 2
this
íí2 6
NativeArray
íí7 B
<
ííB C
T
ííC D
>
ííD E
array
ííF K
,
ííK L
U
ííM N
comp
ííO S
,
ííS T
	JobHandle
ííU ^
	inputDeps
íí_ h
)
ííh i
where
ìì 
T
ìì 
:
ìì 
	unmanaged
ìì 
where
îî 
U
îî 
:
îî 
	IComparer
îî 
<
îî  
T
îî  !
>
îî! "
{
ïï 	
return
ññ 
Sort
ññ 
(
ññ 
(
ññ 
T
ññ 
*
ññ 
)
ññ &
NativeArrayUnsafeUtility
ññ 4
.
ññ4 51
#GetUnsafeBufferPointerWithoutChecks
ññ5 X
(
ññX Y
array
ññY ^
)
ññ^ _
,
ññ_ `
array
ñña f
.
ññf g
Length
ññg m
,
ññm n
comp
ñño s
,
ññs t
	inputDeps
ññu ~
)
ññ~ 
;ññ Ä
}
óó 	
[
¢¢ 	
BurstCompatible
¢¢	 
(
¢¢ "
GenericTypeArguments
¢¢ -
=
¢¢. /
new
¢¢0 3
[
¢¢3 4
]
¢¢4 5
{
¢¢6 7
typeof
¢¢8 >
(
¢¢> ?
int
¢¢? B
)
¢¢B C
,
¢¢C D
typeof
¢¢E K
(
¢¢K L
DefaultComparer
¢¢L [
<
¢¢[ \
int
¢¢\ _
>
¢¢_ `
)
¢¢` a
}
¢¢b c
,
¢¢c d!
RequiredUnityDefine
¢¢e x
=
¢¢y z
$str¢¢{ í
)¢¢∆ «
]¢¢« »
public
££ 
unsafe
££ 
static
££ 
SortJob
££ $
<
££$ %
T
££% &
,
££& '
U
££( )
>
££) *
SortJob
££+ 2
<
££2 3
T
££3 4
,
££4 5
U
££6 7
>
££7 8
(
££8 9
this
££9 =
NativeArray
££> I
<
££I J
T
££J K
>
££K L
array
££M R
,
££R S
U
££T U
comp
££V Z
)
££Z [
where
§§ 
T
§§ 
:
§§ 
	unmanaged
§§ 
where
•• 
U
•• 
:
•• 
	IComparer
•• 
<
••  
T
••  !
>
••! "
{
¶¶ 	
return
ßß 
new
ßß 
SortJob
ßß 
<
ßß 
T
ßß  
,
ßß  !
U
ßß" #
>
ßß# $
{
®® 
Data
©© 
=
©© 
(
©© 
T
©© 
*
©© 
)
©© &
NativeArrayUnsafeUtility
©© 3
.
©©3 41
#GetUnsafeBufferPointerWithoutChecks
©©4 W
(
©©W X
array
©©X ]
)
©©] ^
,
©©^ _
Length
™™ 
=
™™ 
array
™™ 
.
™™ 
Length
™™ %
,
™™% &
Comp
´´ 
=
´´ 
comp
´´ 
}
¨¨ 
;
¨¨ 
}
≠≠ 	
[
∑∑ 	
BurstCompatible
∑∑	 
(
∑∑ "
GenericTypeArguments
∑∑ -
=
∑∑. /
new
∑∑0 3
[
∑∑3 4
]
∑∑4 5
{
∑∑6 7
typeof
∑∑8 >
(
∑∑> ?
int
∑∑? B
)
∑∑B C
}
∑∑D E
)
∑∑E F
]
∑∑F G
public
∏∏ 
static
∏∏ 
int
∏∏ 
BinarySearch
∏∏ &
<
∏∏& '
T
∏∏' (
>
∏∏( )
(
∏∏) *
this
∏∏* .
NativeArray
∏∏/ :
<
∏∏: ;
T
∏∏; <
>
∏∏< =
array
∏∏> C
,
∏∏C D
T
∏∏E F
value
∏∏G L
)
∏∏L M
where
ππ 
T
ππ 
:
ππ 
	unmanaged
ππ 
,
ππ  
IComparable
ππ! ,
<
ππ, -
T
ππ- .
>
ππ. /
{
∫∫ 	
return
ªª 
array
ªª 
.
ªª 
BinarySearch
ªª %
(
ªª% &
value
ªª& +
,
ªª+ ,
new
ªª- 0
DefaultComparer
ªª1 @
<
ªª@ A
T
ªªA B
>
ªªB C
(
ªªC D
)
ªªD E
)
ªªE F
;
ªªF G
}
ºº 	
[
…… 	
BurstCompatible
……	 
(
…… "
GenericTypeArguments
…… -
=
……. /
new
……0 3
[
……3 4
]
……4 5
{
……6 7
typeof
……8 >
(
……> ?
int
……? B
)
……B C
,
……C D
typeof
……E K
(
……K L
DefaultComparer
……L [
<
……[ \
int
……\ _
>
……_ `
)
……` a
}
……b c
)
……c d
]
……d e
public
   
unsafe
   
static
   
int
    
BinarySearch
  ! -
<
  - .
T
  . /
,
  / 0
U
  1 2
>
  2 3
(
  3 4
this
  4 8
NativeArray
  9 D
<
  D E
T
  E F
>
  F G
array
  H M
,
  M N
T
  O P
value
  Q V
,
  V W
U
  X Y
comp
  Z ^
)
  ^ _
where
ÀÀ 
T
ÀÀ 
:
ÀÀ 
	unmanaged
ÀÀ 
where
ÃÃ 
U
ÃÃ 
:
ÃÃ 
	IComparer
ÃÃ 
<
ÃÃ  
T
ÃÃ  !
>
ÃÃ! "
{
ÕÕ 	
return
ŒŒ 
BinarySearch
ŒŒ 
(
ŒŒ  
(
ŒŒ  !
T
ŒŒ! "
*
ŒŒ" #
)
ŒŒ# $&
NativeArrayUnsafeUtility
ŒŒ$ <
.
ŒŒ< =1
#GetUnsafeBufferPointerWithoutChecks
ŒŒ= `
(
ŒŒ` a
array
ŒŒa f
)
ŒŒf g
,
ŒŒg h
array
ŒŒi n
.
ŒŒn o
Length
ŒŒo u
,
ŒŒu v
value
ŒŒw |
,
ŒŒ| }
compŒŒ~ Ç
)ŒŒÇ É
;ŒŒÉ Ñ
}
œœ 	
[
÷÷ 	
BurstCompatible
÷÷	 
(
÷÷ "
GenericTypeArguments
÷÷ -
=
÷÷. /
new
÷÷0 3
[
÷÷3 4
]
÷÷4 5
{
÷÷6 7
typeof
÷÷8 >
(
÷÷> ?
int
÷÷? B
)
÷÷B C
}
÷÷D E
)
÷÷E F
]
÷÷F G
public
◊◊ 
unsafe
◊◊ 
static
◊◊ 
void
◊◊ !
Sort
◊◊" &
<
◊◊& '
T
◊◊' (
>
◊◊( )
(
◊◊) *
this
◊◊* .

NativeList
◊◊/ 9
<
◊◊9 :
T
◊◊: ;
>
◊◊; <
list
◊◊= A
)
◊◊A B
where
ÿÿ 
T
ÿÿ 
:
ÿÿ 
	unmanaged
ÿÿ 
,
ÿÿ  
IComparable
ÿÿ! ,
<
ÿÿ, -
T
ÿÿ- .
>
ÿÿ. /
{
ŸŸ 	
list
⁄⁄ 
.
⁄⁄ 
Sort
⁄⁄ 
(
⁄⁄ 
new
⁄⁄ 
DefaultComparer
⁄⁄ )
<
⁄⁄) *
T
⁄⁄* +
>
⁄⁄+ ,
(
⁄⁄, -
)
⁄⁄- .
)
⁄⁄. /
;
⁄⁄/ 0
}
€€ 	
[
‰‰ 	
BurstCompatible
‰‰	 
(
‰‰ "
GenericTypeArguments
‰‰ -
=
‰‰. /
new
‰‰0 3
[
‰‰3 4
]
‰‰4 5
{
‰‰6 7
typeof
‰‰8 >
(
‰‰> ?
int
‰‰? B
)
‰‰B C
,
‰‰C D
typeof
‰‰E K
(
‰‰K L
DefaultComparer
‰‰L [
<
‰‰[ \
int
‰‰\ _
>
‰‰_ `
)
‰‰` a
}
‰‰b c
)
‰‰c d
]
‰‰d e
public
ÂÂ 
unsafe
ÂÂ 
static
ÂÂ 
void
ÂÂ !
Sort
ÂÂ" &
<
ÂÂ& '
T
ÂÂ' (
,
ÂÂ( )
U
ÂÂ* +
>
ÂÂ+ ,
(
ÂÂ, -
this
ÂÂ- 1

NativeList
ÂÂ2 <
<
ÂÂ< =
T
ÂÂ= >
>
ÂÂ> ?
list
ÂÂ@ D
,
ÂÂD E
U
ÂÂF G
comp
ÂÂH L
)
ÂÂL M
where
ÊÊ 
T
ÊÊ 
:
ÊÊ 
	unmanaged
ÊÊ 
where
ÁÁ 
U
ÁÁ 
:
ÁÁ 
	IComparer
ÁÁ 
<
ÁÁ  
T
ÁÁ  !
>
ÁÁ! "
{
ËË 	
	IntroSort
ÈÈ 
<
ÈÈ 
T
ÈÈ 
,
ÈÈ 
U
ÈÈ 
>
ÈÈ 
(
ÈÈ 
list
ÈÈ  
.
ÈÈ  !
GetUnsafePtr
ÈÈ! -
(
ÈÈ- .
)
ÈÈ. /
,
ÈÈ/ 0
list
ÈÈ1 5
.
ÈÈ5 6
Length
ÈÈ6 <
,
ÈÈ< =
comp
ÈÈ> B
)
ÈÈB C
;
ÈÈC D
}
ÍÍ 	
[
ÙÙ 	 
NotBurstCompatible
ÙÙ	 
]ÙÙú ù
[
ıı 	
Obsolete
ıı	 
(
ıı 
$str
ıı k
,
ıık l
false
ıım r
)
ıır s
]
ııs t
public
ˆˆ 
unsafe
ˆˆ 
static
ˆˆ 
	JobHandle
ˆˆ &
Sort
ˆˆ' +
<
ˆˆ+ ,
T
ˆˆ, -
>
ˆˆ- .
(
ˆˆ. /
this
ˆˆ/ 3

NativeList
ˆˆ4 >
<
ˆˆ> ?
T
ˆˆ? @
>
ˆˆ@ A
array
ˆˆB G
,
ˆˆG H
	JobHandle
ˆˆI R
	inputDeps
ˆˆS \
)
ˆˆ\ ]
where
˜˜ 
T
˜˜ 
:
˜˜ 
	unmanaged
˜˜ 
,
˜˜  
IComparable
˜˜! ,
<
˜˜, -
T
˜˜- .
>
˜˜. /
{
¯¯ 	
return
˘˘ 
array
˘˘ 
.
˘˘ 
Sort
˘˘ 
(
˘˘ 
new
˘˘ !
DefaultComparer
˘˘" 1
<
˘˘1 2
T
˘˘2 3
>
˘˘3 4
(
˘˘4 5
)
˘˘5 6
,
˘˘6 7
	inputDeps
˘˘8 A
)
˘˘A B
;
˘˘B C
}
˙˙ 	
[
ÉÉ 	
BurstCompatible
ÉÉ	 
(
ÉÉ "
GenericTypeArguments
ÉÉ -
=
ÉÉ. /
new
ÉÉ0 3
[
ÉÉ3 4
]
ÉÉ4 5
{
ÉÉ6 7
typeof
ÉÉ8 >
(
ÉÉ> ?
int
ÉÉ? B
)
ÉÉB C
}
ÉÉD E
,
ÉÉE F!
RequiredUnityDefine
ÉÉG Z
=
ÉÉ[ \
$str
ÉÉ] t
)ÉÉ® ©
]ÉÉ© ™
public
ÑÑ 
unsafe
ÑÑ 
static
ÑÑ 
SortJob
ÑÑ $
<
ÑÑ$ %
T
ÑÑ% &
,
ÑÑ& '
DefaultComparer
ÑÑ( 7
<
ÑÑ7 8
T
ÑÑ8 9
>
ÑÑ9 :
>
ÑÑ: ;
SortJob
ÑÑ< C
<
ÑÑC D
T
ÑÑD E
>
ÑÑE F
(
ÑÑF G
this
ÑÑG K

NativeList
ÑÑL V
<
ÑÑV W
T
ÑÑW X
>
ÑÑX Y
list
ÑÑZ ^
)
ÑÑ^ _
where
ÖÖ 
T
ÖÖ 
:
ÖÖ 
	unmanaged
ÖÖ 
,
ÖÖ  
IComparable
ÖÖ! ,
<
ÖÖ, -
T
ÖÖ- .
>
ÖÖ. /
{
ÜÜ 	
return
áá 
SortJob
áá 
(
áá 
(
áá 
T
áá 
*
áá 
)
áá 
list
áá #
.
áá# $
GetUnsafePtr
áá$ 0
(
áá0 1
)
áá1 2
,
áá2 3
list
áá4 8
.
áá8 9
Length
áá9 ?
,
áá? @
new
áá@ C
DefaultComparer
ááD S
<
ááS T
T
ááT U
>
ááU V
(
ááV W
)
ááW X
)
ááX Y
;
ááY Z
}
àà 	
[
îî 	 
NotBurstCompatible
îî	 
]îîú ù
[
ïï 	
Obsolete
ïï	 
(
ïï 
$str
ïï n
,
ïïn o
false
ïïp u
)
ïïu v
]
ïïv w
public
ññ 
unsafe
ññ 
static
ññ 
	JobHandle
ññ &
Sort
ññ' +
<
ññ+ ,
T
ññ, -
,
ññ- .
U
ññ/ 0
>
ññ0 1
(
ññ1 2
this
ññ2 6

NativeList
ññ7 A
<
ññA B
T
ññB C
>
ññC D
list
ññE I
,
ññI J
U
ññK L
comp
ññM Q
,
ññQ R
	JobHandle
ññS \
	inputDeps
ññ] f
)
ññf g
where
óó 
T
óó 
:
óó 
	unmanaged
óó 
where
òò 
U
òò 
:
òò 
	IComparer
òò 
<
òò  
T
òò  !
>
òò! "
{
ôô 	
return
öö 
Sort
öö 
(
öö 
(
öö 
T
öö 
*
öö 
)
öö 
list
öö  
.
öö  !
GetUnsafePtr
öö! -
(
öö- .
)
öö. /
,
öö/ 0
list
öö1 5
.
öö5 6
Length
öö6 <
,
öö< =
comp
öö> B
,
ööB C
	inputDeps
ööD M
)
ööM N
;
ööN O
}
õõ 	
[
¶¶ 	
BurstCompatible
¶¶	 
(
¶¶ "
GenericTypeArguments
¶¶ -
=
¶¶. /
new
¶¶0 3
[
¶¶3 4
]
¶¶4 5
{
¶¶6 7
typeof
¶¶8 >
(
¶¶> ?
int
¶¶? B
)
¶¶B C
,
¶¶C D
typeof
¶¶E K
(
¶¶K L
DefaultComparer
¶¶L [
<
¶¶[ \
int
¶¶\ _
>
¶¶_ `
)
¶¶` a
}
¶¶b c
,
¶¶c d!
RequiredUnityDefine
¶¶e x
=
¶¶y z
$str¶¶{ í
)¶¶∆ «
]¶¶« »
public
ßß 
unsafe
ßß 
static
ßß 
SortJob
ßß $
<
ßß$ %
T
ßß% &
,
ßß& '
U
ßß( )
>
ßß) *
SortJob
ßß+ 2
<
ßß2 3
T
ßß3 4
,
ßß4 5
U
ßß6 7
>
ßß7 8
(
ßß8 9
this
ßß9 =

NativeList
ßß> H
<
ßßH I
T
ßßI J
>
ßßJ K
list
ßßL P
,
ßßP Q
U
ßßR S
comp
ßßT X
)
ßßX Y
where
®® 
T
®® 
:
®® 
	unmanaged
®® 
where
©© 
U
©© 
:
©© 
	IComparer
©© 
<
©©  
T
©©  !
>
©©! "
{
™™ 	
return
´´ 
SortJob
´´ 
(
´´ 
(
´´ 
T
´´ 
*
´´ 
)
´´ 
list
´´ #
.
´´# $
GetUnsafePtr
´´$ 0
(
´´0 1
)
´´1 2
,
´´2 3
list
´´4 8
.
´´8 9
Length
´´9 ?
,
´´? @
comp
´´A E
)
´´E F
;
´´F G
}
¨¨ 	
[
∂∂ 	
BurstCompatible
∂∂	 
(
∂∂ "
GenericTypeArguments
∂∂ -
=
∂∂. /
new
∂∂0 3
[
∂∂3 4
]
∂∂4 5
{
∂∂6 7
typeof
∂∂8 >
(
∂∂> ?
int
∂∂? B
)
∂∂B C
}
∂∂D E
)
∂∂E F
]
∂∂F G
public
∑∑ 
static
∑∑ 
int
∑∑ 
BinarySearch
∑∑ &
<
∑∑& '
T
∑∑' (
>
∑∑( )
(
∑∑) *
this
∑∑* .

NativeList
∑∑/ 9
<
∑∑9 :
T
∑∑: ;
>
∑∑; <
list
∑∑= A
,
∑∑A B
T
∑∑C D
value
∑∑E J
)
∑∑J K
where
∏∏ 
T
∏∏ 
:
∏∏ 
	unmanaged
∏∏ 
,
∏∏  
IComparable
∏∏! ,
<
∏∏, -
T
∏∏- .
>
∏∏. /
{
ππ 	
return
∫∫ 
list
∫∫ 
.
∫∫ 
BinarySearch
∫∫ $
(
∫∫$ %
value
∫∫% *
,
∫∫* +
new
∫∫, /
DefaultComparer
∫∫0 ?
<
∫∫? @
T
∫∫@ A
>
∫∫A B
(
∫∫B C
)
∫∫C D
)
∫∫D E
;
∫∫E F
}
ªª 	
[
«« 	
BurstCompatible
««	 
(
«« "
GenericTypeArguments
«« -
=
««. /
new
««0 3
[
««3 4
]
««4 5
{
««6 7
typeof
««8 >
(
««> ?
int
««? B
)
««B C
,
««C D
typeof
««E K
(
««K L
DefaultComparer
««L [
<
««[ \
int
««\ _
>
««_ `
)
««` a
}
««b c
)
««c d
]
««d e
public
»» 
unsafe
»» 
static
»» 
int
»»  
BinarySearch
»»! -
<
»»- .
T
»». /
,
»»/ 0
U
»»1 2
>
»»2 3
(
»»3 4
this
»»4 8

NativeList
»»9 C
<
»»C D
T
»»D E
>
»»E F
list
»»G K
,
»»K L
T
»»M N
value
»»O T
,
»»T U
U
»»V W
comp
»»X \
)
»»\ ]
where
…… 
T
…… 
:
…… 
	unmanaged
…… 
where
   
U
   
:
   
	IComparer
   
<
    
T
    !
>
  ! "
{
ÀÀ 	
return
ÃÃ 
BinarySearch
ÃÃ 
(
ÃÃ  
(
ÃÃ  !
T
ÃÃ! "
*
ÃÃ" #
)
ÃÃ# $
list
ÃÃ$ (
.
ÃÃ( )
GetUnsafePtr
ÃÃ) 5
(
ÃÃ5 6
)
ÃÃ6 7
,
ÃÃ7 8
list
ÃÃ9 =
.
ÃÃ= >
Length
ÃÃ> D
,
ÃÃD E
value
ÃÃF K
,
ÃÃK L
comp
ÃÃM Q
)
ÃÃQ R
;
ÃÃR S
}
ÕÕ 	
[
‘‘ 	
BurstCompatible
‘‘	 
(
‘‘ "
GenericTypeArguments
‘‘ -
=
‘‘. /
new
‘‘0 3
[
‘‘3 4
]
‘‘4 5
{
‘‘6 7
typeof
‘‘8 >
(
‘‘> ?
int
‘‘? B
)
‘‘B C
}
‘‘D E
)
‘‘E F
]
‘‘F G
public
’’ 
unsafe
’’ 
static
’’ 
void
’’ !
Sort
’’" &
<
’’& '
T
’’' (
>
’’( )
(
’’) *
this
’’* .

UnsafeList
’’/ 9
<
’’9 :
T
’’: ;
>
’’; <
list
’’= A
)
’’A B
where
’’C H
T
’’I J
:
’’K L
	unmanaged
’’M V
,
’’V W
IComparable
’’X c
<
’’c d
T
’’d e
>
’’e f
{
÷÷ 	
list
◊◊ 
.
◊◊ 
Sort
◊◊ 
(
◊◊ 
new
◊◊ 
DefaultComparer
◊◊ )
<
◊◊) *
T
◊◊* +
>
◊◊+ ,
(
◊◊, -
)
◊◊- .
)
◊◊. /
;
◊◊/ 0
}
ÿÿ 	
[
·· 	
BurstCompatible
··	 
(
·· "
GenericTypeArguments
·· -
=
··. /
new
··0 3
[
··3 4
]
··4 5
{
··6 7
typeof
··8 >
(
··> ?
int
··? B
)
··B C
,
··C D
typeof
··E K
(
··K L
DefaultComparer
··L [
<
··[ \
int
··\ _
>
··_ `
)
··` a
}
··b c
)
··c d
]
··d e
public
‚‚ 
unsafe
‚‚ 
static
‚‚ 
void
‚‚ !
Sort
‚‚" &
<
‚‚& '
T
‚‚' (
,
‚‚( )
U
‚‚* +
>
‚‚+ ,
(
‚‚, -
this
‚‚- 1

UnsafeList
‚‚2 <
<
‚‚< =
T
‚‚= >
>
‚‚> ?
list
‚‚@ D
,
‚‚D E
U
‚‚F G
comp
‚‚H L
)
‚‚L M
where
„„ 
T
„„ 
:
„„ 
	unmanaged
„„ 
where
‰‰ 
U
‰‰ 
:
‰‰ 
	IComparer
‰‰ 
<
‰‰  
T
‰‰  !
>
‰‰! "
{
ÂÂ 	
	IntroSort
ÊÊ 
<
ÊÊ 
T
ÊÊ 
,
ÊÊ 
U
ÊÊ 
>
ÊÊ 
(
ÊÊ 
list
ÊÊ  
.
ÊÊ  !
Ptr
ÊÊ! $
,
ÊÊ$ %
list
ÊÊ& *
.
ÊÊ* +
Length
ÊÊ+ 1
,
ÊÊ1 2
comp
ÊÊ3 7
)
ÊÊ7 8
;
ÊÊ8 9
}
ÁÁ 	
[
ÒÒ 	 
NotBurstCompatible
ÒÒ	 
]ÒÒú ù
[
ÚÚ 	
Obsolete
ÚÚ	 
(
ÚÚ 
$str
ÚÚ k
,
ÚÚk l
false
ÚÚm r
)
ÚÚr s
]
ÚÚs t
public
ÛÛ 
unsafe
ÛÛ 
static
ÛÛ 
	JobHandle
ÛÛ &
Sort
ÛÛ' +
<
ÛÛ+ ,
T
ÛÛ, -
>
ÛÛ- .
(
ÛÛ. /
this
ÛÛ/ 3

UnsafeList
ÛÛ4 >
<
ÛÛ> ?
T
ÛÛ? @
>
ÛÛ@ A
list
ÛÛB F
,
ÛÛF G
	JobHandle
ÛÛH Q
	inputDeps
ÛÛR [
)
ÛÛ[ \
where
ÙÙ 
T
ÙÙ 
:
ÙÙ 
	unmanaged
ÙÙ 
,
ÙÙ  
IComparable
ÙÙ! ,
<
ÙÙ, -
T
ÙÙ- .
>
ÙÙ. /
{
ıı 	
return
ˆˆ 
list
ˆˆ 
.
ˆˆ 
Sort
ˆˆ 
(
ˆˆ 
new
ˆˆ  
DefaultComparer
ˆˆ! 0
<
ˆˆ0 1
T
ˆˆ1 2
>
ˆˆ2 3
(
ˆˆ3 4
)
ˆˆ4 5
,
ˆˆ5 6
	inputDeps
ˆˆ7 @
)
ˆˆ@ A
;
ˆˆA B
}
˜˜ 	
[
ÄÄ 	
BurstCompatible
ÄÄ	 
(
ÄÄ "
GenericTypeArguments
ÄÄ -
=
ÄÄ. /
new
ÄÄ0 3
[
ÄÄ3 4
]
ÄÄ4 5
{
ÄÄ6 7
typeof
ÄÄ8 >
(
ÄÄ> ?
int
ÄÄ? B
)
ÄÄB C
}
ÄÄD E
,
ÄÄE F!
RequiredUnityDefine
ÄÄG Z
=
ÄÄ[ \
$str
ÄÄ] t
)ÄÄ® ©
]ÄÄ© ™
public
ÅÅ 
unsafe
ÅÅ 
static
ÅÅ 
SortJob
ÅÅ $
<
ÅÅ$ %
T
ÅÅ% &
,
ÅÅ& '
DefaultComparer
ÅÅ( 7
<
ÅÅ7 8
T
ÅÅ8 9
>
ÅÅ9 :
>
ÅÅ: ;
SortJob
ÅÅ< C
<
ÅÅC D
T
ÅÅD E
>
ÅÅE F
(
ÅÅF G
this
ÅÅG K

UnsafeList
ÅÅL V
<
ÅÅV W
T
ÅÅW X
>
ÅÅX Y
list
ÅÅZ ^
)
ÅÅ^ _
where
ÇÇ 
T
ÇÇ 
:
ÇÇ 
	unmanaged
ÇÇ 
,
ÇÇ  
IComparable
ÇÇ! ,
<
ÇÇ, -
T
ÇÇ- .
>
ÇÇ. /
{
ÉÉ 	
return
ÑÑ 
SortJob
ÑÑ 
(
ÑÑ 
(
ÑÑ 
T
ÑÑ 
*
ÑÑ 
)
ÑÑ 
list
ÑÑ #
.
ÑÑ# $
Ptr
ÑÑ$ '
,
ÑÑ' (
list
ÑÑ) -
.
ÑÑ- .
Length
ÑÑ. 4
,
ÑÑ4 5
new
ÑÑ6 9
DefaultComparer
ÑÑ: I
<
ÑÑI J
T
ÑÑJ K
>
ÑÑK L
(
ÑÑL M
)
ÑÑM N
)
ÑÑN O
;
ÑÑO P
}
ÖÖ 	
[
ëë 	 
NotBurstCompatible
ëë	 
]ëëú ù
[
íí 	
Obsolete
íí	 
(
íí 
$str
íí n
,
íín o
false
ííp u
)
ííu v
]
íív w
public
ìì 
unsafe
ìì 
static
ìì 
	JobHandle
ìì &
Sort
ìì' +
<
ìì+ ,
T
ìì, -
,
ìì- .
U
ìì/ 0
>
ìì0 1
(
ìì1 2
this
ìì2 6

UnsafeList
ìì7 A
<
ììA B
T
ììB C
>
ììC D
list
ììE I
,
ììI J
U
ììK L
comp
ììM Q
,
ììQ R
	JobHandle
ììS \
	inputDeps
ìì] f
)
ììf g
where
îî 
T
îî 
:
îî 
	unmanaged
îî 
where
ïï 
U
ïï 
:
ïï 
	IComparer
ïï 
<
ïï  
T
ïï  !
>
ïï! "
{
ññ 	
return
óó 
Sort
óó 
(
óó 
list
óó 
.
óó 
Ptr
óó  
,
óó  !
list
óó" &
.
óó& '
Length
óó' -
,
óó- .
comp
óó/ 3
,
óó3 4
	inputDeps
óó5 >
)
óó> ?
;
óó? @
}
òò 	
[
££ 	
BurstCompatible
££	 
(
££ "
GenericTypeArguments
££ -
=
££. /
new
££0 3
[
££3 4
]
££4 5
{
££6 7
typeof
££8 >
(
££> ?
int
££? B
)
££B C
,
££C D
typeof
££E K
(
££K L
DefaultComparer
££L [
<
££[ \
int
££\ _
>
££_ `
)
££` a
}
££b c
,
££c d!
RequiredUnityDefine
££e x
=
££y z
$str££{ í
)££∆ «
]££« »
public
§§ 
unsafe
§§ 
static
§§ 
SortJob
§§ $
<
§§$ %
T
§§% &
,
§§& '
U
§§( )
>
§§) *
SortJob
§§+ 2
<
§§2 3
T
§§3 4
,
§§4 5
U
§§6 7
>
§§7 8
(
§§8 9
this
§§9 =

UnsafeList
§§> H
<
§§H I
T
§§I J
>
§§J K
list
§§L P
,
§§P Q
U
§§R S
comp
§§T X
)
§§X Y
where
•• 
T
•• 
:
•• 
	unmanaged
•• 
where
¶¶ 
U
¶¶ 
:
¶¶ 
	IComparer
¶¶ 
<
¶¶  
T
¶¶  !
>
¶¶! "
{
ßß 	
return
®® 
SortJob
®® 
(
®® 
list
®® 
.
®®  
Ptr
®®  #
,
®®# $
list
®®% )
.
®®) *
Length
®®* 0
,
®®0 1
comp
®®2 6
)
®®6 7
;
®®7 8
}
©© 	
[
≥≥ 	
BurstCompatible
≥≥	 
(
≥≥ "
GenericTypeArguments
≥≥ -
=
≥≥. /
new
≥≥0 3
[
≥≥3 4
]
≥≥4 5
{
≥≥6 7
typeof
≥≥8 >
(
≥≥> ?
int
≥≥? B
)
≥≥B C
}
≥≥D E
)
≥≥E F
]
≥≥F G
public
¥¥ 
static
¥¥ 
int
¥¥ 
BinarySearch
¥¥ &
<
¥¥& '
T
¥¥' (
>
¥¥( )
(
¥¥) *
this
¥¥* .

UnsafeList
¥¥/ 9
<
¥¥9 :
T
¥¥: ;
>
¥¥; <
list
¥¥= A
,
¥¥A B
T
¥¥C D
value
¥¥E J
)
¥¥J K
where
µµ 
T
µµ 
:
µµ 
	unmanaged
µµ 
,
µµ  
IComparable
µµ! ,
<
µµ, -
T
µµ- .
>
µµ. /
{
∂∂ 	
return
∑∑ 
list
∑∑ 
.
∑∑ 
BinarySearch
∑∑ $
(
∑∑$ %
value
∑∑% *
,
∑∑* +
new
∑∑, /
DefaultComparer
∑∑0 ?
<
∑∑? @
T
∑∑@ A
>
∑∑A B
(
∑∑B C
)
∑∑C D
)
∑∑D E
;
∑∑E F
}
∏∏ 	
[
ƒƒ 	
BurstCompatible
ƒƒ	 
(
ƒƒ "
GenericTypeArguments
ƒƒ -
=
ƒƒ. /
new
ƒƒ0 3
[
ƒƒ3 4
]
ƒƒ4 5
{
ƒƒ6 7
typeof
ƒƒ8 >
(
ƒƒ> ?
int
ƒƒ? B
)
ƒƒB C
,
ƒƒC D
typeof
ƒƒE K
(
ƒƒK L
DefaultComparer
ƒƒL [
<
ƒƒ[ \
int
ƒƒ\ _
>
ƒƒ_ `
)
ƒƒ` a
}
ƒƒb c
)
ƒƒc d
]
ƒƒd e
public
≈≈ 
unsafe
≈≈ 
static
≈≈ 
int
≈≈  
BinarySearch
≈≈! -
<
≈≈- .
T
≈≈. /
,
≈≈/ 0
U
≈≈1 2
>
≈≈2 3
(
≈≈3 4
this
≈≈4 8

UnsafeList
≈≈9 C
<
≈≈C D
T
≈≈D E
>
≈≈E F
list
≈≈G K
,
≈≈K L
T
≈≈M N
value
≈≈O T
,
≈≈T U
U
≈≈V W
comp
≈≈X \
)
≈≈\ ]
where
∆∆ 
T
∆∆ 
:
∆∆ 
	unmanaged
∆∆ 
where
«« 
U
«« 
:
«« 
	IComparer
«« 
<
««  
T
««  !
>
««! "
{
»» 	
return
…… 
BinarySearch
…… 
(
……  
list
……  $
.
……$ %
Ptr
……% (
,
……( )
list
……* .
.
……. /
Length
……/ 5
,
……5 6
value
……7 <
,
……< =
comp
……> B
)
……B C
;
……C D
}
   	
[
—— 	
BurstCompatible
——	 
(
—— "
GenericTypeArguments
—— -
=
——. /
new
——0 3
[
——3 4
]
——4 5
{
——6 7
typeof
——8 >
(
——> ?
int
——? B
)
——B C
}
——D E
)
——E F
]
——F G
public
““ 
unsafe
““ 
static
““ 
void
““ !
Sort
““" &
<
““& '
T
““' (
>
““( )
(
““) *
this
““* .
NativeSlice
““/ :
<
““: ;
T
““; <
>
““< =
slice
““> C
)
““C D
where
”” 
T
”” 
:
”” 
struct
”” 
,
”” 
IComparable
”” )
<
””) *
T
””* +
>
””+ ,
{
‘‘ 	
slice
’’ 
.
’’ 
Sort
’’ 
(
’’ 
new
’’ 
DefaultComparer
’’ *
<
’’* +
T
’’+ ,
>
’’, -
(
’’- .
)
’’. /
)
’’/ 0
;
’’0 1
}
÷÷ 	
[
ﬂﬂ 	
BurstCompatible
ﬂﬂ	 
(
ﬂﬂ "
GenericTypeArguments
ﬂﬂ -
=
ﬂﬂ. /
new
ﬂﬂ0 3
[
ﬂﬂ3 4
]
ﬂﬂ4 5
{
ﬂﬂ6 7
typeof
ﬂﬂ8 >
(
ﬂﬂ> ?
int
ﬂﬂ? B
)
ﬂﬂB C
,
ﬂﬂC D
typeof
ﬂﬂE K
(
ﬂﬂK L
DefaultComparer
ﬂﬂL [
<
ﬂﬂ[ \
int
ﬂﬂ\ _
>
ﬂﬂ_ `
)
ﬂﬂ` a
}
ﬂﬂb c
)
ﬂﬂc d
]
ﬂﬂd e
public
‡‡ 
unsafe
‡‡ 
static
‡‡ 
void
‡‡ !
Sort
‡‡" &
<
‡‡& '
T
‡‡' (
,
‡‡( )
U
‡‡* +
>
‡‡+ ,
(
‡‡, -
this
‡‡- 1
NativeSlice
‡‡2 =
<
‡‡= >
T
‡‡> ?
>
‡‡? @
slice
‡‡A F
,
‡‡F G
U
‡‡H I
comp
‡‡J N
)
‡‡N O
where
·· 
T
·· 
:
·· 
struct
·· 
where
‚‚ 
U
‚‚ 
:
‚‚ 
	IComparer
‚‚ 
<
‚‚  
T
‚‚  !
>
‚‚! "
{
„„ 	$
CheckStrideMatchesSize
‰‰ "
<
‰‰" #
T
‰‰# $
>
‰‰$ %
(
‰‰% &
slice
‰‰& +
.
‰‰+ ,
Stride
‰‰, 2
)
‰‰2 3
;
‰‰3 4
IntroSortStruct
ÂÂ 
<
ÂÂ 
T
ÂÂ 
,
ÂÂ 
U
ÂÂ  
>
ÂÂ  !
(
ÂÂ! "
slice
ÂÂ" '
.
ÂÂ' (
GetUnsafePtr
ÂÂ( 4
(
ÂÂ4 5
)
ÂÂ5 6
,
ÂÂ6 7
slice
ÂÂ8 =
.
ÂÂ= >
Length
ÂÂ> D
,
ÂÂD E
comp
ÂÂF J
)
ÂÂJ K
;
ÂÂK L
}
ÊÊ 	
[
 	 
NotBurstCompatible
	 
]ú ù
[
ÒÒ 	
Obsolete
ÒÒ	 
(
ÒÒ 
$str
ÒÒ l
,
ÒÒl m
false
ÒÒn s
)
ÒÒs t
]
ÒÒt u
public
ÚÚ 
unsafe
ÚÚ 
static
ÚÚ 
	JobHandle
ÚÚ &
Sort
ÚÚ' +
<
ÚÚ+ ,
T
ÚÚ, -
>
ÚÚ- .
(
ÚÚ. /
this
ÚÚ/ 3
NativeSlice
ÚÚ4 ?
<
ÚÚ? @
T
ÚÚ@ A
>
ÚÚA B
slice
ÚÚC H
,
ÚÚH I
	JobHandle
ÚÚJ S
	inputDeps
ÚÚT ]
)
ÚÚ] ^
where
ÛÛ 
T
ÛÛ 
:
ÛÛ 
	unmanaged
ÛÛ 
,
ÛÛ  
IComparable
ÛÛ! ,
<
ÛÛ, -
T
ÛÛ- .
>
ÛÛ. /
{
ÙÙ 	
return
ıı 
slice
ıı 
.
ıı 
Sort
ıı 
(
ıı 
new
ıı !
DefaultComparer
ıı" 1
<
ıı1 2
T
ıı2 3
>
ıı3 4
(
ıı4 5
)
ıı5 6
,
ıı6 7
	inputDeps
ıı8 A
)
ııA B
;
ııB C
}
ˆˆ 	
[
ˇˇ 	
BurstCompatible
ˇˇ	 
(
ˇˇ "
GenericTypeArguments
ˇˇ -
=
ˇˇ. /
new
ˇˇ0 3
[
ˇˇ3 4
]
ˇˇ4 5
{
ˇˇ6 7
typeof
ˇˇ8 >
(
ˇˇ> ?
int
ˇˇ? B
)
ˇˇB C
}
ˇˇD E
,
ˇˇE F!
RequiredUnityDefine
ˇˇG Z
=
ˇˇ[ \
$str
ˇˇ] t
)ˇˇ® ©
]ˇˇ© ™
public
ÄÄ 
unsafe
ÄÄ 
static
ÄÄ 
SortJob
ÄÄ $
<
ÄÄ$ %
T
ÄÄ% &
,
ÄÄ& '
DefaultComparer
ÄÄ( 7
<
ÄÄ7 8
T
ÄÄ8 9
>
ÄÄ9 :
>
ÄÄ: ;
SortJob
ÄÄ< C
<
ÄÄC D
T
ÄÄD E
>
ÄÄE F
(
ÄÄF G
this
ÄÄG K
NativeSlice
ÄÄL W
<
ÄÄW X
T
ÄÄX Y
>
ÄÄY Z
slice
ÄÄ[ `
)
ÄÄ` a
where
ÅÅ 
T
ÅÅ 
:
ÅÅ 
	unmanaged
ÅÅ 
,
ÅÅ  
IComparable
ÅÅ! ,
<
ÅÅ, -
T
ÅÅ- .
>
ÅÅ. /
{
ÇÇ 	$
CheckStrideMatchesSize
ÉÉ "
<
ÉÉ" #
T
ÉÉ# $
>
ÉÉ$ %
(
ÉÉ% &
slice
ÉÉ& +
.
ÉÉ+ ,
Stride
ÉÉ, 2
)
ÉÉ2 3
;
ÉÉ3 4
return
ÑÑ 
SortJob
ÑÑ 
(
ÑÑ 
(
ÑÑ 
T
ÑÑ 
*
ÑÑ 
)
ÑÑ 
slice
ÑÑ $
.
ÑÑ$ %
GetUnsafePtr
ÑÑ% 1
(
ÑÑ1 2
)
ÑÑ2 3
,
ÑÑ3 4
slice
ÑÑ5 :
.
ÑÑ: ;
Length
ÑÑ; A
,
ÑÑA B
new
ÑÑC F
DefaultComparer
ÑÑG V
<
ÑÑV W
T
ÑÑW X
>
ÑÑX Y
(
ÑÑY Z
)
ÑÑZ [
)
ÑÑ[ \
;
ÑÑ\ ]
}
ÖÖ 	
[
ëë 	 
NotBurstCompatible
ëë	 
]ëëú ù
[
íí 	
Obsolete
íí	 
(
íí 
$str
íí o
,
íío p
false
ííq v
)
íív w
]
ííw x
public
ìì 
unsafe
ìì 
static
ìì 
	JobHandle
ìì &
Sort
ìì' +
<
ìì+ ,
T
ìì, -
,
ìì- .
U
ìì/ 0
>
ìì0 1
(
ìì1 2
this
ìì2 6
NativeSlice
ìì7 B
<
ììB C
T
ììC D
>
ììD E
slice
ììF K
,
ììK L
U
ììM N
comp
ììO S
,
ììS T
	JobHandle
ììU ^
	inputDeps
ìì_ h
)
ììh i
where
îî 
T
îî 
:
îî 
	unmanaged
îî 
where
ïï 
U
ïï 
:
ïï 
	IComparer
ïï 
<
ïï  
T
ïï  !
>
ïï! "
{
ññ 	
return
óó 
Sort
óó 
(
óó 
(
óó 
T
óó 
*
óó 
)
óó 
slice
óó !
.
óó! "
GetUnsafePtr
óó" .
(
óó. /
)
óó/ 0
,
óó0 1
slice
óó2 7
.
óó7 8
Length
óó8 >
,
óó> ?
comp
óó@ D
,
óóD E
	inputDeps
óóF O
)
óóO P
;
óóP Q
}
òò 	
[
££ 	
BurstCompatible
££	 
(
££ "
GenericTypeArguments
££ -
=
££. /
new
££0 3
[
££3 4
]
££4 5
{
££6 7
typeof
££8 >
(
££> ?
int
££? B
)
££B C
,
££C D
typeof
££E K
(
££K L
DefaultComparer
££L [
<
££[ \
int
££\ _
>
££_ `
)
££` a
}
££b c
,
££c d!
RequiredUnityDefine
££e x
=
££y z
$str££{ í
)££∆ «
]££« »
public
§§ 
unsafe
§§ 
static
§§ 
SortJob
§§ $
<
§§$ %
T
§§% &
,
§§& '
U
§§( )
>
§§) *
SortJob
§§+ 2
<
§§2 3
T
§§3 4
,
§§4 5
U
§§6 7
>
§§7 8
(
§§8 9
this
§§9 =
NativeSlice
§§> I
<
§§I J
T
§§J K
>
§§K L
slice
§§M R
,
§§R S
U
§§T U
comp
§§V Z
)
§§Z [
where
•• 
T
•• 
:
•• 
	unmanaged
•• 
where
¶¶ 
U
¶¶ 
:
¶¶ 
	IComparer
¶¶ 
<
¶¶  
T
¶¶  !
>
¶¶! "
{
ßß 	$
CheckStrideMatchesSize
®® "
<
®®" #
T
®®# $
>
®®$ %
(
®®% &
slice
®®& +
.
®®+ ,
Stride
®®, 2
)
®®2 3
;
®®3 4
return
©© 
SortJob
©© 
(
©© 
(
©© 
T
©© 
*
©© 
)
©© 
slice
©© $
.
©©$ %
GetUnsafePtr
©©% 1
(
©©1 2
)
©©2 3
,
©©3 4
slice
©©5 :
.
©©: ;
Length
©©; A
,
©©A B
comp
©©C G
)
©©G H
;
©©H I
}
™™ 	
[
¥¥ 	
BurstCompatible
¥¥	 
(
¥¥ "
GenericTypeArguments
¥¥ -
=
¥¥. /
new
¥¥0 3
[
¥¥3 4
]
¥¥4 5
{
¥¥6 7
typeof
¥¥8 >
(
¥¥> ?
int
¥¥? B
)
¥¥B C
}
¥¥D E
)
¥¥E F
]
¥¥F G
public
µµ 
static
µµ 
int
µµ 
BinarySearch
µµ &
<
µµ& '
T
µµ' (
>
µµ( )
(
µµ) *
this
µµ* .
NativeSlice
µµ/ :
<
µµ: ;
T
µµ; <
>
µµ< =
slice
µµ> C
,
µµC D
T
µµE F
value
µµG L
)
µµL M
where
∂∂ 
T
∂∂ 
:
∂∂ 
	unmanaged
∂∂ 
,
∂∂  
IComparable
∂∂! ,
<
∂∂, -
T
∂∂- .
>
∂∂. /
{
∑∑ 	
return
∏∏ 
slice
∏∏ 
.
∏∏ 
BinarySearch
∏∏ %
(
∏∏% &
value
∏∏& +
,
∏∏+ ,
new
∏∏- 0
DefaultComparer
∏∏1 @
<
∏∏@ A
T
∏∏A B
>
∏∏B C
(
∏∏C D
)
∏∏D E
)
∏∏E F
;
∏∏F G
}
ππ 	
[
≈≈ 	
BurstCompatible
≈≈	 
(
≈≈ "
GenericTypeArguments
≈≈ -
=
≈≈. /
new
≈≈0 3
[
≈≈3 4
]
≈≈4 5
{
≈≈6 7
typeof
≈≈8 >
(
≈≈> ?
int
≈≈? B
)
≈≈B C
,
≈≈C D
typeof
≈≈E K
(
≈≈K L
DefaultComparer
≈≈L [
<
≈≈[ \
int
≈≈\ _
>
≈≈_ `
)
≈≈` a
}
≈≈b c
)
≈≈c d
]
≈≈d e
public
∆∆ 
unsafe
∆∆ 
static
∆∆ 
int
∆∆  
BinarySearch
∆∆! -
<
∆∆- .
T
∆∆. /
,
∆∆/ 0
U
∆∆1 2
>
∆∆2 3
(
∆∆3 4
this
∆∆4 8
NativeSlice
∆∆9 D
<
∆∆D E
T
∆∆E F
>
∆∆F G
slice
∆∆H M
,
∆∆M N
T
∆∆O P
value
∆∆Q V
,
∆∆V W
U
∆∆X Y
comp
∆∆Z ^
)
∆∆^ _
where
«« 
T
«« 
:
«« 
	unmanaged
«« 
where
»» 
U
»» 
:
»» 
	IComparer
»» 
<
»»  
T
»»  !
>
»»! "
{
…… 	
return
   
BinarySearch
   
(
    
(
    !
T
  ! "
*
  " #
)
  # $
slice
  $ )
.
  ) *
GetUnsafePtr
  * 6
(
  6 7
)
  7 8
,
  8 9
slice
  : ?
.
  ? @
Length
  @ F
,
  F G
value
  H M
,
  M N
comp
  O S
)
  S T
;
  T U
}
ÀÀ 	
[
œœ 	
BurstCompatible
œœ	 
(
œœ "
GenericTypeArguments
œœ -
=
œœ. /
new
œœ0 3
[
œœ3 4
]
œœ4 5
{
œœ6 7
typeof
œœ8 >
(
œœ> ?
int
œœ? B
)
œœB C
,
œœC D
typeof
œœE K
(
œœK L
DefaultComparer
œœL [
<
œœ[ \
int
œœ\ _
>
œœ_ `
)
œœ` a
}
œœb c
)
œœc d
]
œœd e
unsafe
–– 
internal
–– 
static
–– 
void
–– #
	IntroSort
––$ -
<
––- .
T
––. /
,
––/ 0
U
––1 2
>
––2 3
(
––3 4
void
––4 8
*
––8 9
array
––: ?
,
––? @
int
––A D
length
––E K
,
––K L
U
––M N
comp
––O S
)
––S T
where
—— 
T
—— 
:
—— 
	unmanaged
—— 
where
““ 
U
““ 
:
““ 
	IComparer
““ 
<
““  
T
““  !
>
““! "
{
”” 	
	IntroSort
‘‘ 
<
‘‘ 
T
‘‘ 
,
‘‘ 
U
‘‘ 
>
‘‘ 
(
‘‘ 
array
‘‘ !
,
‘‘! "
$num
‘‘# $
,
‘‘$ %
length
‘‘& ,
-
‘‘- .
$num
‘‘/ 0
,
‘‘0 1
$num
‘‘2 3
*
‘‘4 5
CollectionHelper
‘‘6 F
.
‘‘F G
	Log2Floor
‘‘G P
(
‘‘P Q
length
‘‘Q W
)
‘‘W X
,
‘‘X Y
comp
‘‘Z ^
)
‘‘^ _
;
‘‘_ `
}
’’ 	
const
◊◊ 
int
◊◊ &
k_IntrosortSizeThreshold
◊◊ *
=
◊◊+ ,
$num
◊◊- /
;
◊◊/ 0
unsafe
ÿÿ 
static
ÿÿ 
void
ÿÿ 
	IntroSort
ÿÿ $
<
ÿÿ$ %
T
ÿÿ% &
,
ÿÿ& '
U
ÿÿ( )
>
ÿÿ) *
(
ÿÿ* +
void
ÿÿ+ /
*
ÿÿ/ 0
array
ÿÿ1 6
,
ÿÿ6 7
int
ÿÿ8 ;
lo
ÿÿ< >
,
ÿÿ> ?
int
ÿÿ@ C
hi
ÿÿD F
,
ÿÿF G
int
ÿÿH K
depth
ÿÿL Q
,
ÿÿQ R
U
ÿÿS T
comp
ÿÿU Y
)
ÿÿY Z
where
ŸŸ 
T
ŸŸ 
:
ŸŸ 
	unmanaged
ŸŸ 
where
⁄⁄ 
U
⁄⁄ 
:
⁄⁄ 
	IComparer
⁄⁄ 
<
⁄⁄  
T
⁄⁄  !
>
⁄⁄! "
{
€€ 	
while
‹‹ 
(
‹‹ 
hi
‹‹ 
>
‹‹ 
lo
‹‹ 
)
‹‹ 
{
›› 
int
ﬁﬁ 
partitionSize
ﬁﬁ !
=
ﬁﬁ" #
hi
ﬁﬁ$ &
-
ﬁﬁ' (
lo
ﬁﬁ) +
+
ﬁﬁ, -
$num
ﬁﬁ. /
;
ﬁﬁ/ 0
if
ﬂﬂ 
(
ﬂﬂ 
partitionSize
ﬂﬂ !
<=
ﬂﬂ" $&
k_IntrosortSizeThreshold
ﬂﬂ% =
)
ﬂﬂ= >
{
‡‡ 
if
·· 
(
·· 
partitionSize
·· %
==
··& (
$num
··) *
)
··* +
{
‚‚ 
return
„„ 
;
„„ 
}
‰‰ 
if
ÂÂ 
(
ÂÂ 
partitionSize
ÂÂ %
==
ÂÂ& (
$num
ÂÂ) *
)
ÂÂ* +
{
ÊÊ $
SwapIfGreaterWithItems
ÁÁ .
<
ÁÁ. /
T
ÁÁ/ 0
,
ÁÁ0 1
U
ÁÁ2 3
>
ÁÁ3 4
(
ÁÁ4 5
array
ÁÁ5 :
,
ÁÁ: ;
lo
ÁÁ< >
,
ÁÁ> ?
hi
ÁÁ@ B
,
ÁÁB C
comp
ÁÁD H
)
ÁÁH I
;
ÁÁI J
return
ËË 
;
ËË 
}
ÈÈ 
if
ÍÍ 
(
ÍÍ 
partitionSize
ÍÍ %
==
ÍÍ& (
$num
ÍÍ) *
)
ÍÍ* +
{
ÎÎ $
SwapIfGreaterWithItems
ÏÏ .
<
ÏÏ. /
T
ÏÏ/ 0
,
ÏÏ0 1
U
ÏÏ2 3
>
ÏÏ3 4
(
ÏÏ4 5
array
ÏÏ5 :
,
ÏÏ: ;
lo
ÏÏ< >
,
ÏÏ> ?
hi
ÏÏ@ B
-
ÏÏC D
$num
ÏÏE F
,
ÏÏF G
comp
ÏÏH L
)
ÏÏL M
;
ÏÏM N$
SwapIfGreaterWithItems
ÌÌ .
<
ÌÌ. /
T
ÌÌ/ 0
,
ÌÌ0 1
U
ÌÌ2 3
>
ÌÌ3 4
(
ÌÌ4 5
array
ÌÌ5 :
,
ÌÌ: ;
lo
ÌÌ< >
,
ÌÌ> ?
hi
ÌÌ@ B
,
ÌÌB C
comp
ÌÌD H
)
ÌÌH I
;
ÌÌI J$
SwapIfGreaterWithItems
ÓÓ .
<
ÓÓ. /
T
ÓÓ/ 0
,
ÓÓ0 1
U
ÓÓ2 3
>
ÓÓ3 4
(
ÓÓ4 5
array
ÓÓ5 :
,
ÓÓ: ;
hi
ÓÓ< >
-
ÓÓ? @
$num
ÓÓA B
,
ÓÓB C
hi
ÓÓD F
,
ÓÓF G
comp
ÓÓH L
)
ÓÓL M
;
ÓÓM N
return
ÔÔ 
;
ÔÔ 
}
 
InsertionSort
ÚÚ !
<
ÚÚ! "
T
ÚÚ" #
,
ÚÚ# $
U
ÚÚ% &
>
ÚÚ& '
(
ÚÚ' (
array
ÚÚ( -
,
ÚÚ- .
lo
ÚÚ/ 1
,
ÚÚ1 2
hi
ÚÚ3 5
,
ÚÚ5 6
comp
ÚÚ7 ;
)
ÚÚ; <
;
ÚÚ< =
return
ÛÛ 
;
ÛÛ 
}
ÙÙ 
if
ˆˆ 
(
ˆˆ 
depth
ˆˆ 
==
ˆˆ 
$num
ˆˆ 
)
ˆˆ 
{
˜˜ 
HeapSort
¯¯ 
<
¯¯ 
T
¯¯ 
,
¯¯ 
U
¯¯  !
>
¯¯! "
(
¯¯" #
array
¯¯# (
,
¯¯( )
lo
¯¯* ,
,
¯¯, -
hi
¯¯. 0
,
¯¯0 1
comp
¯¯2 6
)
¯¯6 7
;
¯¯7 8
return
˘˘ 
;
˘˘ 
}
˙˙ 
depth
˚˚ 
--
˚˚ 
;
˚˚ 
int
˝˝ 
p
˝˝ 
=
˝˝ 
	Partition
˝˝ !
<
˝˝! "
T
˝˝" #
,
˝˝# $
U
˝˝% &
>
˝˝& '
(
˝˝' (
array
˝˝( -
,
˝˝- .
lo
˝˝/ 1
,
˝˝1 2
hi
˝˝3 5
,
˝˝5 6
comp
˝˝7 ;
)
˝˝; <
;
˝˝< =
	IntroSort
˛˛ 
<
˛˛ 
T
˛˛ 
,
˛˛ 
U
˛˛ 
>
˛˛ 
(
˛˛  
array
˛˛  %
,
˛˛% &
p
˛˛' (
+
˛˛) *
$num
˛˛+ ,
,
˛˛, -
hi
˛˛. 0
,
˛˛0 1
depth
˛˛2 7
,
˛˛7 8
comp
˛˛9 =
)
˛˛= >
;
˛˛> ?
hi
ˇˇ 
=
ˇˇ 
p
ˇˇ 
-
ˇˇ 
$num
ˇˇ 
;
ˇˇ 
}
ÄÄ 
}
ÅÅ 	
unsafe
ÉÉ 
static
ÉÉ 
void
ÉÉ 
InsertionSort
ÉÉ (
<
ÉÉ( )
T
ÉÉ) *
,
ÉÉ* +
U
ÉÉ, -
>
ÉÉ- .
(
ÉÉ. /
void
ÉÉ/ 3
*
ÉÉ3 4
array
ÉÉ5 :
,
ÉÉ: ;
int
ÉÉ< ?
lo
ÉÉ@ B
,
ÉÉB C
int
ÉÉD G
hi
ÉÉH J
,
ÉÉJ K
U
ÉÉL M
comp
ÉÉN R
)
ÉÉR S
where
ÑÑ 
T
ÑÑ 
:
ÑÑ 
	unmanaged
ÑÑ 
where
ÖÖ 
U
ÖÖ 
:
ÖÖ 
	IComparer
ÖÖ 
<
ÖÖ  
T
ÖÖ  !
>
ÖÖ! "
{
ÜÜ 	
int
áá 
i
áá 
,
áá 
j
áá 
;
áá 
T
àà 
t
àà 
;
àà 
for
ââ 
(
ââ 
i
ââ 
=
ââ 
lo
ââ 
;
ââ 
i
ââ 
<
ââ 
hi
ââ 
;
ââ  
i
ââ! "
++
ââ" $
)
ââ$ %
{
ää 
j
ãã 
=
ãã 
i
ãã 
;
ãã 
t
åå 
=
åå 
UnsafeUtility
åå !
.
åå! "
ReadArrayElement
åå" 2
<
åå2 3
T
åå3 4
>
åå4 5
(
åå5 6
array
åå6 ;
,
åå; <
i
åå= >
+
åå? @
$num
ååA B
)
ååB C
;
ååC D
while
çç 
(
çç 
j
çç 
>=
çç 
lo
çç 
&&
çç !
comp
çç" &
.
çç& '
Compare
çç' .
(
çç. /
t
çç/ 0
,
çç0 1
UnsafeUtility
çç2 ?
.
çç? @
ReadArrayElement
çç@ P
<
ççP Q
T
ççQ R
>
ççR S
(
ççS T
array
ççT Y
,
ççY Z
j
çç[ \
)
çç\ ]
)
çç] ^
<
çç_ `
$num
çça b
)
ççb c
{
éé 
UnsafeUtility
èè !
.
èè! "
WriteArrayElement
èè" 3
<
èè3 4
T
èè4 5
>
èè5 6
(
èè6 7
array
èè7 <
,
èè< =
j
èè> ?
+
èè@ A
$num
èèB C
,
èèC D
UnsafeUtility
èèE R
.
èèR S
ReadArrayElement
èèS c
<
èèc d
T
èèd e
>
èèe f
(
èèf g
array
èèg l
,
èèl m
j
èèn o
)
èèo p
)
èèp q
;
èèq r
j
êê 
--
êê 
;
êê 
}
ëë 
UnsafeUtility
íí 
.
íí 
WriteArrayElement
íí /
<
íí/ 0
T
íí0 1
>
íí1 2
(
íí2 3
array
íí3 8
,
íí8 9
j
íí: ;
+
íí< =
$num
íí> ?
,
íí? @
t
ííA B
)
ííB C
;
ííC D
}
ìì 
}
îî 	
unsafe
ññ 
static
ññ 
int
ññ 
	Partition
ññ #
<
ññ# $
T
ññ$ %
,
ññ% &
U
ññ' (
>
ññ( )
(
ññ) *
void
ññ* .
*
ññ. /
array
ññ0 5
,
ññ5 6
int
ññ7 :
lo
ññ; =
,
ññ= >
int
ññ? B
hi
ññC E
,
ññE F
U
ññG H
comp
ññI M
)
ññM N
where
óó 
T
óó 
:
óó 
	unmanaged
óó 
where
òò 
U
òò 
:
òò 
	IComparer
òò 
<
òò  
T
òò  !
>
òò! "
{
ôô 	
int
öö 
mid
öö 
=
öö 
lo
öö 
+
öö 
(
öö 
(
öö 
hi
öö 
-
öö  !
lo
öö" $
)
öö$ %
/
öö& '
$num
öö( )
)
öö) *
;
öö* +$
SwapIfGreaterWithItems
õõ "
<
õõ" #
T
õõ# $
,
õõ$ %
U
õõ& '
>
õõ' (
(
õõ( )
array
õõ) .
,
õõ. /
lo
õõ0 2
,
õõ2 3
mid
õõ4 7
,
õõ7 8
comp
õõ9 =
)
õõ= >
;
õõ> ?$
SwapIfGreaterWithItems
úú "
<
úú" #
T
úú# $
,
úú$ %
U
úú& '
>
úú' (
(
úú( )
array
úú) .
,
úú. /
lo
úú0 2
,
úú2 3
hi
úú4 6
,
úú6 7
comp
úú8 <
)
úú< =
;
úú= >$
SwapIfGreaterWithItems
ùù "
<
ùù" #
T
ùù# $
,
ùù$ %
U
ùù& '
>
ùù' (
(
ùù( )
array
ùù) .
,
ùù. /
mid
ùù0 3
,
ùù3 4
hi
ùù5 7
,
ùù7 8
comp
ùù9 =
)
ùù= >
;
ùù> ?
T
üü 
pivot
üü 
=
üü 
UnsafeUtility
üü #
.
üü# $
ReadArrayElement
üü$ 4
<
üü4 5
T
üü5 6
>
üü6 7
(
üü7 8
array
üü8 =
,
üü= >
mid
üü? B
)
üüB C
;
üüC D
Swap
†† 
<
†† 
T
†† 
>
†† 
(
†† 
array
†† 
,
†† 
mid
†† 
,
†† 
hi
††  "
-
††# $
$num
††% &
)
††& '
;
††' (
int
°° 
left
°° 
=
°° 
lo
°° 
,
°° 
right
°°  
=
°°! "
hi
°°# %
-
°°& '
$num
°°( )
;
°°) *
while
££ 
(
££ 
left
££ 
<
££ 
right
££ 
)
££  
{
§§ 
while
•• 
(
•• 
comp
•• 
.
•• 
Compare
•• #
(
••# $
pivot
••$ )
,
••) *
UnsafeUtility
••+ 8
.
••8 9
ReadArrayElement
••9 I
<
••I J
T
••J K
>
••K L
(
••L M
array
••M R
,
••R S
++
••T V
left
••V Z
)
••Z [
)
••[ \
>
••] ^
$num
••_ `
)
••` a
;
••b c
while
¶¶ 
(
¶¶ 
comp
¶¶ 
.
¶¶ 
Compare
¶¶ #
(
¶¶# $
pivot
¶¶$ )
,
¶¶) *
UnsafeUtility
¶¶+ 8
.
¶¶8 9
ReadArrayElement
¶¶9 I
<
¶¶I J
T
¶¶J K
>
¶¶K L
(
¶¶L M
array
¶¶M R
,
¶¶R S
--
¶¶T V
right
¶¶V [
)
¶¶[ \
)
¶¶\ ]
<
¶¶^ _
$num
¶¶` a
)
¶¶a b
;
¶¶c d
if
®® 
(
®® 
left
®® 
>=
®® 
right
®® !
)
®®! "
break
©© 
;
©© 
Swap
´´ 
<
´´ 
T
´´ 
>
´´ 
(
´´ 
array
´´ 
,
´´ 
left
´´ #
,
´´# $
right
´´% *
)
´´* +
;
´´+ ,
}
¨¨ 
Swap
ÆÆ 
<
ÆÆ 
T
ÆÆ 
>
ÆÆ 
(
ÆÆ 
array
ÆÆ 
,
ÆÆ 
left
ÆÆ 
,
ÆÆ  
(
ÆÆ! "
hi
ÆÆ" $
-
ÆÆ% &
$num
ÆÆ' (
)
ÆÆ( )
)
ÆÆ) *
;
ÆÆ* +
return
ØØ 
left
ØØ 
;
ØØ 
}
∞∞ 	
unsafe
≤≤ 
static
≤≤ 
void
≤≤ 
HeapSort
≤≤ #
<
≤≤# $
T
≤≤$ %
,
≤≤% &
U
≤≤' (
>
≤≤( )
(
≤≤) *
void
≤≤* .
*
≤≤. /
array
≤≤0 5
,
≤≤5 6
int
≤≤7 :
lo
≤≤; =
,
≤≤= >
int
≤≤? B
hi
≤≤C E
,
≤≤E F
U
≤≤G H
comp
≤≤I M
)
≤≤M N
where
≥≥ 
T
≥≥ 
:
≥≥ 
	unmanaged
≥≥ 
where
¥¥ 
U
¥¥ 
:
¥¥ 
	IComparer
¥¥ 
<
¥¥  
T
¥¥  !
>
¥¥! "
{
µµ 	
int
∂∂ 
n
∂∂ 
=
∂∂ 
hi
∂∂ 
-
∂∂ 
lo
∂∂ 
+
∂∂ 
$num
∂∂ 
;
∂∂  
for
∏∏ 
(
∏∏ 
int
∏∏ 
i
∏∏ 
=
∏∏ 
n
∏∏ 
/
∏∏ 
$num
∏∏ 
;
∏∏ 
i
∏∏  !
>=
∏∏" $
$num
∏∏% &
;
∏∏& '
i
∏∏( )
--
∏∏) +
)
∏∏+ ,
{
ππ 
Heapify
∫∫ 
<
∫∫ 
T
∫∫ 
,
∫∫ 
U
∫∫ 
>
∫∫ 
(
∫∫ 
array
∫∫ #
,
∫∫# $
i
∫∫% &
,
∫∫& '
n
∫∫( )
,
∫∫) *
lo
∫∫+ -
,
∫∫- .
comp
∫∫/ 3
)
∫∫3 4
;
∫∫4 5
}
ªª 
for
ΩΩ 
(
ΩΩ 
int
ΩΩ 
i
ΩΩ 
=
ΩΩ 
n
ΩΩ 
;
ΩΩ 
i
ΩΩ 
>
ΩΩ 
$num
ΩΩ  !
;
ΩΩ! "
i
ΩΩ# $
--
ΩΩ$ &
)
ΩΩ& '
{
ææ 
Swap
øø 
<
øø 
T
øø 
>
øø 
(
øø 
array
øø 
,
øø 
lo
øø !
,
øø! "
lo
øø# %
+
øø& '
i
øø( )
-
øø* +
$num
øø, -
)
øø- .
;
øø. /
Heapify
¿¿ 
<
¿¿ 
T
¿¿ 
,
¿¿ 
U
¿¿ 
>
¿¿ 
(
¿¿ 
array
¿¿ #
,
¿¿# $
$num
¿¿% &
,
¿¿& '
i
¿¿( )
-
¿¿* +
$num
¿¿, -
,
¿¿- .
lo
¿¿/ 1
,
¿¿1 2
comp
¿¿3 7
)
¿¿7 8
;
¿¿8 9
}
¡¡ 
}
¬¬ 	
unsafe
ƒƒ 
static
ƒƒ 
void
ƒƒ 
Heapify
ƒƒ "
<
ƒƒ" #
T
ƒƒ# $
,
ƒƒ$ %
U
ƒƒ& '
>
ƒƒ' (
(
ƒƒ( )
void
ƒƒ) -
*
ƒƒ- .
array
ƒƒ/ 4
,
ƒƒ4 5
int
ƒƒ6 9
i
ƒƒ: ;
,
ƒƒ; <
int
ƒƒ= @
n
ƒƒA B
,
ƒƒB C
int
ƒƒD G
lo
ƒƒH J
,
ƒƒJ K
U
ƒƒL M
comp
ƒƒN R
)
ƒƒR S
where
≈≈ 
T
≈≈ 
:
≈≈ 
	unmanaged
≈≈ 
where
∆∆ 
U
∆∆ 
:
∆∆ 
	IComparer
∆∆ 
<
∆∆  
T
∆∆  !
>
∆∆! "
{
«« 	
T
»» 
val
»» 
=
»» 
UnsafeUtility
»» !
.
»»! "
ReadArrayElement
»»" 2
<
»»2 3
T
»»3 4
>
»»4 5
(
»»5 6
array
»»6 ;
,
»»; <
lo
»»= ?
+
»»@ A
i
»»B C
-
»»D E
$num
»»F G
)
»»G H
;
»»H I
int
…… 
child
…… 
;
…… 
while
   
(
   
i
   
<=
   
n
   
/
   
$num
   
)
   
{
ÀÀ 
child
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
*
ÃÃ 
i
ÃÃ 
;
ÃÃ 
if
ÕÕ 
(
ÕÕ 
child
ÕÕ 
<
ÕÕ 
n
ÕÕ 
&&
ÕÕ  
(
ÕÕ! "
comp
ÕÕ" &
.
ÕÕ& '
Compare
ÕÕ' .
(
ÕÕ. /
UnsafeUtility
ÕÕ/ <
.
ÕÕ< =
ReadArrayElement
ÕÕ= M
<
ÕÕM N
T
ÕÕN O
>
ÕÕO P
(
ÕÕP Q
array
ÕÕQ V
,
ÕÕV W
lo
ÕÕX Z
+
ÕÕ[ \
child
ÕÕ] b
-
ÕÕc d
$num
ÕÕe f
)
ÕÕf g
,
ÕÕg h
UnsafeUtility
ÕÕi v
.
ÕÕv w
ReadArrayElementÕÕw á
<ÕÕá à
TÕÕà â
>ÕÕâ ä
(ÕÕä ã
arrayÕÕã ê
,ÕÕê ë
(ÕÕí ì
loÕÕì ï
+ÕÕñ ó
childÕÕò ù
)ÕÕù û
)ÕÕû ü
)ÕÕü †
<ÕÕ° ¢
$numÕÕ£ §
)ÕÕ§ •
)ÕÕ• ¶
{
ŒŒ 
child
œœ 
++
œœ 
;
œœ 
}
–– 
if
—— 
(
—— 
comp
—— 
.
—— 
Compare
——  
(
——  !
UnsafeUtility
——! .
.
——. /
ReadArrayElement
——/ ?
<
——? @
T
——@ A
>
——A B
(
——B C
array
——C H
,
——H I
(
——J K
lo
——K M
+
——N O
child
——P U
-
——V W
$num
——X Y
)
——Y Z
)
——Z [
,
——[ \
val
——] `
)
——` a
<
——b c
$num
——d e
)
——e f
break
““ 
;
““ 
UnsafeUtility
‘‘ 
.
‘‘ 
WriteArrayElement
‘‘ /
(
‘‘/ 0
array
‘‘0 5
,
‘‘5 6
lo
‘‘7 9
+
‘‘: ;
i
‘‘< =
-
‘‘> ?
$num
‘‘@ A
,
‘‘A B
UnsafeUtility
‘‘C P
.
‘‘P Q
ReadArrayElement
‘‘Q a
<
‘‘a b
T
‘‘b c
>
‘‘c d
(
‘‘d e
array
‘‘e j
,
‘‘j k
lo
‘‘l n
+
‘‘o p
child
‘‘q v
-
‘‘w x
$num
‘‘y z
)
‘‘z {
)
‘‘{ |
;
‘‘| }
i
’’ 
=
’’ 
child
’’ 
;
’’ 
}
÷÷ 
UnsafeUtility
◊◊ 
.
◊◊ 
WriteArrayElement
◊◊ +
(
◊◊+ ,
array
◊◊, 1
,
◊◊1 2
lo
◊◊3 5
+
◊◊6 7
i
◊◊8 9
-
◊◊: ;
$num
◊◊< =
,
◊◊= >
val
◊◊? B
)
◊◊B C
;
◊◊C D
}
ÿÿ 	
unsafe
⁄⁄ 
static
⁄⁄ 
void
⁄⁄ 
Swap
⁄⁄ 
<
⁄⁄  
T
⁄⁄  !
>
⁄⁄! "
(
⁄⁄" #
void
⁄⁄# '
*
⁄⁄' (
array
⁄⁄) .
,
⁄⁄. /
int
⁄⁄0 3
lhs
⁄⁄4 7
,
⁄⁄7 8
int
⁄⁄9 <
rhs
⁄⁄= @
)
⁄⁄@ A
where
⁄⁄B G
T
⁄⁄H I
:
⁄⁄J K
	unmanaged
⁄⁄L U
{
€€ 	
T
‹‹ 
val
‹‹ 
=
‹‹ 
UnsafeUtility
‹‹ !
.
‹‹! "
ReadArrayElement
‹‹" 2
<
‹‹2 3
T
‹‹3 4
>
‹‹4 5
(
‹‹5 6
array
‹‹6 ;
,
‹‹; <
lhs
‹‹= @
)
‹‹@ A
;
‹‹A B
UnsafeUtility
›› 
.
›› 
WriteArrayElement
›› +
(
››+ ,
array
››, 1
,
››1 2
lhs
››3 6
,
››6 7
UnsafeUtility
››8 E
.
››E F
ReadArrayElement
››F V
<
››V W
T
››W X
>
››X Y
(
››Y Z
array
››Z _
,
››_ `
rhs
››a d
)
››d e
)
››e f
;
››f g
UnsafeUtility
ﬁﬁ 
.
ﬁﬁ 
WriteArrayElement
ﬁﬁ +
(
ﬁﬁ+ ,
array
ﬁﬁ, 1
,
ﬁﬁ1 2
rhs
ﬁﬁ3 6
,
ﬁﬁ6 7
val
ﬁﬁ8 ;
)
ﬁﬁ; <
;
ﬁﬁ< =
}
ﬂﬂ 	
unsafe
·· 
static
·· 
void
·· $
SwapIfGreaterWithItems
·· 1
<
··1 2
T
··2 3
,
··3 4
U
··5 6
>
··6 7
(
··7 8
void
··8 <
*
··< =
array
··> C
,
··C D
int
··E H
lhs
··I L
,
··L M
int
··N Q
rhs
··R U
,
··U V
U
··W X
comp
··Y ]
)
··] ^
where
‚‚ 
T
‚‚ 
:
‚‚ 
	unmanaged
‚‚ 
where
„„ 
U
„„ 
:
„„ 
	IComparer
„„ 
<
„„  
T
„„  !
>
„„! "
{
‰‰ 	
if
ÂÂ 
(
ÂÂ 
lhs
ÂÂ 
!=
ÂÂ 
rhs
ÂÂ 
)
ÂÂ 
{
ÊÊ 
if
ÁÁ 
(
ÁÁ 
comp
ÁÁ 
.
ÁÁ 
Compare
ÁÁ  
(
ÁÁ  !
UnsafeUtility
ÁÁ! .
.
ÁÁ. /
ReadArrayElement
ÁÁ/ ?
<
ÁÁ? @
T
ÁÁ@ A
>
ÁÁA B
(
ÁÁB C
array
ÁÁC H
,
ÁÁH I
lhs
ÁÁJ M
)
ÁÁM N
,
ÁÁN O
UnsafeUtility
ÁÁP ]
.
ÁÁ] ^
ReadArrayElement
ÁÁ^ n
<
ÁÁn o
T
ÁÁo p
>
ÁÁp q
(
ÁÁq r
array
ÁÁr w
,
ÁÁw x
rhs
ÁÁy |
)
ÁÁ| }
)
ÁÁ} ~
>ÁÁ Ä
$numÁÁÅ Ç
)ÁÁÇ É
{
ËË 
Swap
ÈÈ 
<
ÈÈ 
T
ÈÈ 
>
ÈÈ 
(
ÈÈ 
array
ÈÈ !
,
ÈÈ! "
lhs
ÈÈ# &
,
ÈÈ& '
rhs
ÈÈ( +
)
ÈÈ+ ,
;
ÈÈ, -
}
ÍÍ 
}
ÎÎ 
}
ÏÏ 	
unsafe
ÓÓ 
static
ÓÓ 
void
ÓÓ 
IntroSortStruct
ÓÓ *
<
ÓÓ* +
T
ÓÓ+ ,
,
ÓÓ, -
U
ÓÓ. /
>
ÓÓ/ 0
(
ÓÓ0 1
void
ÓÓ1 5
*
ÓÓ5 6
array
ÓÓ7 <
,
ÓÓ< =
int
ÓÓ> A
length
ÓÓB H
,
ÓÓH I
U
ÓÓJ K
comp
ÓÓL P
)
ÓÓP Q
where
ÔÔ 
T
ÔÔ 
:
ÔÔ 
struct
ÔÔ 
where
 
U
 
:
 
	IComparer
 
<
  
T
  !
>
! "
{
ÒÒ 	
IntroSortStruct
ÚÚ 
<
ÚÚ 
T
ÚÚ 
,
ÚÚ 
U
ÚÚ  
>
ÚÚ  !
(
ÚÚ! "
array
ÚÚ" '
,
ÚÚ' (
$num
ÚÚ) *
,
ÚÚ* +
length
ÚÚ, 2
-
ÚÚ3 4
$num
ÚÚ5 6
,
ÚÚ6 7
$num
ÚÚ8 9
*
ÚÚ: ;
CollectionHelper
ÚÚ< L
.
ÚÚL M
	Log2Floor
ÚÚM V
(
ÚÚV W
length
ÚÚW ]
)
ÚÚ] ^
,
ÚÚ^ _
comp
ÚÚ` d
)
ÚÚd e
;
ÚÚe f
}
ÛÛ 	
unsafe
ıı 
static
ıı 
void
ıı 
IntroSortStruct
ıı *
<
ıı* +
T
ıı+ ,
,
ıı, -
U
ıı. /
>
ıı/ 0
(
ıı0 1
void
ıı1 5
*
ıı5 6
array
ıı7 <
,
ıı< =
int
ıı> A
lo
ııB D
,
ııD E
int
ııF I
hi
ııJ L
,
ııL M
int
ııN Q
depth
ııR W
,
ııW X
U
ııY Z
comp
ıı[ _
)
ıı_ `
where
ˆˆ 
T
ˆˆ 
:
ˆˆ 
struct
ˆˆ 
where
˜˜ 
U
˜˜ 
:
˜˜ 
	IComparer
˜˜ 
<
˜˜  
T
˜˜  !
>
˜˜! "
{
¯¯ 	
while
˘˘ 
(
˘˘ 
hi
˘˘ 
>
˘˘ 
lo
˘˘ 
)
˘˘ 
{
˙˙ 
int
˚˚ 
partitionSize
˚˚ !
=
˚˚" #
hi
˚˚$ &
-
˚˚' (
lo
˚˚) +
+
˚˚, -
$num
˚˚. /
;
˚˚/ 0
if
¸¸ 
(
¸¸ 
partitionSize
¸¸ !
<=
¸¸" $&
k_IntrosortSizeThreshold
¸¸% =
)
¸¸= >
{
˝˝ 
if
˛˛ 
(
˛˛ 
partitionSize
˛˛ %
==
˛˛& (
$num
˛˛) *
)
˛˛* +
{
ˇˇ 
return
ÄÄ 
;
ÄÄ 
}
ÅÅ 
if
ÇÇ 
(
ÇÇ 
partitionSize
ÇÇ %
==
ÇÇ& (
$num
ÇÇ) *
)
ÇÇ* +
{
ÉÉ *
SwapIfGreaterWithItemsStruct
ÑÑ 4
<
ÑÑ4 5
T
ÑÑ5 6
,
ÑÑ6 7
U
ÑÑ8 9
>
ÑÑ9 :
(
ÑÑ: ;
array
ÑÑ; @
,
ÑÑ@ A
lo
ÑÑB D
,
ÑÑD E
hi
ÑÑF H
,
ÑÑH I
comp
ÑÑJ N
)
ÑÑN O
;
ÑÑO P
return
ÖÖ 
;
ÖÖ 
}
ÜÜ 
if
áá 
(
áá 
partitionSize
áá %
==
áá& (
$num
áá) *
)
áá* +
{
àà *
SwapIfGreaterWithItemsStruct
ââ 4
<
ââ4 5
T
ââ5 6
,
ââ6 7
U
ââ8 9
>
ââ9 :
(
ââ: ;
array
ââ; @
,
ââ@ A
lo
ââB D
,
ââD E
hi
ââF H
-
ââI J
$num
ââK L
,
ââL M
comp
ââN R
)
ââR S
;
ââS T*
SwapIfGreaterWithItemsStruct
ää 4
<
ää4 5
T
ää5 6
,
ää6 7
U
ää8 9
>
ää9 :
(
ää: ;
array
ää; @
,
ää@ A
lo
ääB D
,
ääD E
hi
ääF H
,
ääH I
comp
ääJ N
)
ääN O
;
ääO P*
SwapIfGreaterWithItemsStruct
ãã 4
<
ãã4 5
T
ãã5 6
,
ãã6 7
U
ãã8 9
>
ãã9 :
(
ãã: ;
array
ãã; @
,
ãã@ A
hi
ããB D
-
ããE F
$num
ããG H
,
ããH I
hi
ããJ L
,
ããL M
comp
ããN R
)
ããR S
;
ããS T
return
åå 
;
åå 
}
çç !
InsertionSortStruct
èè '
<
èè' (
T
èè( )
,
èè) *
U
èè+ ,
>
èè, -
(
èè- .
array
èè. 3
,
èè3 4
lo
èè5 7
,
èè7 8
hi
èè9 ;
,
èè; <
comp
èè= A
)
èèA B
;
èèB C
return
êê 
;
êê 
}
ëë 
if
ìì 
(
ìì 
depth
ìì 
==
ìì 
$num
ìì 
)
ìì 
{
îî 
HeapSortStruct
ïï "
<
ïï" #
T
ïï# $
,
ïï$ %
U
ïï& '
>
ïï' (
(
ïï( )
array
ïï) .
,
ïï. /
lo
ïï0 2
,
ïï2 3
hi
ïï4 6
,
ïï6 7
comp
ïï8 <
)
ïï< =
;
ïï= >
return
ññ 
;
ññ 
}
óó 
depth
òò 
--
òò 
;
òò 
int
öö 
p
öö 
=
öö 
PartitionStruct
öö '
<
öö' (
T
öö( )
,
öö) *
U
öö+ ,
>
öö, -
(
öö- .
array
öö. 3
,
öö3 4
lo
öö5 7
,
öö7 8
hi
öö9 ;
,
öö; <
comp
öö= A
)
ööA B
;
ööB C
IntroSortStruct
õõ 
<
õõ  
T
õõ  !
,
õõ! "
U
õõ# $
>
õõ$ %
(
õõ% &
array
õõ& +
,
õõ+ ,
p
õõ- .
+
õõ/ 0
$num
õõ1 2
,
õõ2 3
hi
õõ4 6
,
õõ6 7
depth
õõ8 =
,
õõ= >
comp
õõ? C
)
õõC D
;
õõD E
hi
úú 
=
úú 
p
úú 
-
úú 
$num
úú 
;
úú 
}
ùù 
}
ûû 	
unsafe
†† 
static
†† 
void
†† !
InsertionSortStruct
†† .
<
††. /
T
††/ 0
,
††0 1
U
††2 3
>
††3 4
(
††4 5
void
††5 9
*
††9 :
array
††; @
,
††@ A
int
††B E
lo
††F H
,
††H I
int
††J M
hi
††N P
,
††P Q
U
††R S
comp
††T X
)
††X Y
where
°° 
T
°° 
:
°° 
struct
°° 
where
¢¢ 
U
¢¢ 
:
¢¢ 
	IComparer
¢¢ 
<
¢¢  
T
¢¢  !
>
¢¢! "
{
££ 	
int
§§ 
i
§§ 
,
§§ 
j
§§ 
;
§§ 
T
•• 
t
•• 
;
•• 
for
¶¶ 
(
¶¶ 
i
¶¶ 
=
¶¶ 
lo
¶¶ 
;
¶¶ 
i
¶¶ 
<
¶¶ 
hi
¶¶ 
;
¶¶  
i
¶¶! "
++
¶¶" $
)
¶¶$ %
{
ßß 
j
®® 
=
®® 
i
®® 
;
®® 
t
©© 
=
©© 
UnsafeUtility
©© !
.
©©! "
ReadArrayElement
©©" 2
<
©©2 3
T
©©3 4
>
©©4 5
(
©©5 6
array
©©6 ;
,
©©; <
i
©©= >
+
©©? @
$num
©©A B
)
©©B C
;
©©C D
while
™™ 
(
™™ 
j
™™ 
>=
™™ 
lo
™™ 
&&
™™ !
comp
™™" &
.
™™& '
Compare
™™' .
(
™™. /
t
™™/ 0
,
™™0 1
UnsafeUtility
™™2 ?
.
™™? @
ReadArrayElement
™™@ P
<
™™P Q
T
™™Q R
>
™™R S
(
™™S T
array
™™T Y
,
™™Y Z
j
™™[ \
)
™™\ ]
)
™™] ^
<
™™_ `
$num
™™a b
)
™™b c
{
´´ 
UnsafeUtility
¨¨ !
.
¨¨! "
WriteArrayElement
¨¨" 3
<
¨¨3 4
T
¨¨4 5
>
¨¨5 6
(
¨¨6 7
array
¨¨7 <
,
¨¨< =
j
¨¨> ?
+
¨¨@ A
$num
¨¨B C
,
¨¨C D
UnsafeUtility
¨¨E R
.
¨¨R S
ReadArrayElement
¨¨S c
<
¨¨c d
T
¨¨d e
>
¨¨e f
(
¨¨f g
array
¨¨g l
,
¨¨l m
j
¨¨n o
)
¨¨o p
)
¨¨p q
;
¨¨q r
j
≠≠ 
--
≠≠ 
;
≠≠ 
}
ÆÆ 
UnsafeUtility
ØØ 
.
ØØ 
WriteArrayElement
ØØ /
<
ØØ/ 0
T
ØØ0 1
>
ØØ1 2
(
ØØ2 3
array
ØØ3 8
,
ØØ8 9
j
ØØ: ;
+
ØØ< =
$num
ØØ> ?
,
ØØ? @
t
ØØA B
)
ØØB C
;
ØØC D
}
∞∞ 
}
±± 	
unsafe
≥≥ 
static
≥≥ 
int
≥≥ 
PartitionStruct
≥≥ )
<
≥≥) *
T
≥≥* +
,
≥≥+ ,
U
≥≥- .
>
≥≥. /
(
≥≥/ 0
void
≥≥0 4
*
≥≥4 5
array
≥≥6 ;
,
≥≥; <
int
≥≥= @
lo
≥≥A C
,
≥≥C D
int
≥≥E H
hi
≥≥I K
,
≥≥K L
U
≥≥M N
comp
≥≥O S
)
≥≥S T
where
¥¥ 
T
¥¥ 
:
¥¥ 
struct
¥¥ 
where
µµ 
U
µµ 
:
µµ 
	IComparer
µµ 
<
µµ  
T
µµ  !
>
µµ! "
{
∂∂ 	
int
∑∑ 
mid
∑∑ 
=
∑∑ 
lo
∑∑ 
+
∑∑ 
(
∑∑ 
(
∑∑ 
hi
∑∑ 
-
∑∑  !
lo
∑∑" $
)
∑∑$ %
/
∑∑& '
$num
∑∑( )
)
∑∑) *
;
∑∑* +*
SwapIfGreaterWithItemsStruct
∏∏ (
<
∏∏( )
T
∏∏) *
,
∏∏* +
U
∏∏, -
>
∏∏- .
(
∏∏. /
array
∏∏/ 4
,
∏∏4 5
lo
∏∏6 8
,
∏∏8 9
mid
∏∏: =
,
∏∏= >
comp
∏∏? C
)
∏∏C D
;
∏∏D E*
SwapIfGreaterWithItemsStruct
ππ (
<
ππ( )
T
ππ) *
,
ππ* +
U
ππ, -
>
ππ- .
(
ππ. /
array
ππ/ 4
,
ππ4 5
lo
ππ6 8
,
ππ8 9
hi
ππ: <
,
ππ< =
comp
ππ> B
)
ππB C
;
ππC D*
SwapIfGreaterWithItemsStruct
∫∫ (
<
∫∫( )
T
∫∫) *
,
∫∫* +
U
∫∫, -
>
∫∫- .
(
∫∫. /
array
∫∫/ 4
,
∫∫4 5
mid
∫∫6 9
,
∫∫9 :
hi
∫∫; =
,
∫∫= >
comp
∫∫? C
)
∫∫C D
;
∫∫D E
T
ºº 
pivot
ºº 
=
ºº 
UnsafeUtility
ºº #
.
ºº# $
ReadArrayElement
ºº$ 4
<
ºº4 5
T
ºº5 6
>
ºº6 7
(
ºº7 8
array
ºº8 =
,
ºº= >
mid
ºº? B
)
ººB C
;
ººC D

SwapStruct
ΩΩ 
<
ΩΩ 
T
ΩΩ 
>
ΩΩ 
(
ΩΩ 
array
ΩΩ 
,
ΩΩ  
mid
ΩΩ! $
,
ΩΩ$ %
hi
ΩΩ& (
-
ΩΩ) *
$num
ΩΩ+ ,
)
ΩΩ, -
;
ΩΩ- .
int
ææ 
left
ææ 
=
ææ 
lo
ææ 
,
ææ 
right
ææ  
=
ææ! "
hi
ææ# %
-
ææ& '
$num
ææ( )
;
ææ) *
while
¿¿ 
(
¿¿ 
left
¿¿ 
<
¿¿ 
right
¿¿ 
)
¿¿  
{
¡¡ 
while
¬¬ 
(
¬¬ 
comp
¬¬ 
.
¬¬ 
Compare
¬¬ #
(
¬¬# $
pivot
¬¬$ )
,
¬¬) *
UnsafeUtility
¬¬+ 8
.
¬¬8 9
ReadArrayElement
¬¬9 I
<
¬¬I J
T
¬¬J K
>
¬¬K L
(
¬¬L M
array
¬¬M R
,
¬¬R S
++
¬¬T V
left
¬¬V Z
)
¬¬Z [
)
¬¬[ \
>
¬¬] ^
$num
¬¬_ `
)
¬¬` a
;
¬¬b c
while
√√ 
(
√√ 
comp
√√ 
.
√√ 
Compare
√√ #
(
√√# $
pivot
√√$ )
,
√√) *
UnsafeUtility
√√+ 8
.
√√8 9
ReadArrayElement
√√9 I
<
√√I J
T
√√J K
>
√√K L
(
√√L M
array
√√M R
,
√√R S
--
√√T V
right
√√V [
)
√√[ \
)
√√\ ]
<
√√^ _
$num
√√` a
)
√√a b
;
√√c d
if
≈≈ 
(
≈≈ 
left
≈≈ 
>=
≈≈ 
right
≈≈ !
)
≈≈! "
break
∆∆ 
;
∆∆ 

SwapStruct
»» 
<
»» 
T
»» 
>
»» 
(
»» 
array
»» #
,
»»# $
left
»»% )
,
»») *
right
»»+ 0
)
»»0 1
;
»»1 2
}
…… 

SwapStruct
ÀÀ 
<
ÀÀ 
T
ÀÀ 
>
ÀÀ 
(
ÀÀ 
array
ÀÀ 
,
ÀÀ  
left
ÀÀ! %
,
ÀÀ% &
(
ÀÀ' (
hi
ÀÀ( *
-
ÀÀ+ ,
$num
ÀÀ- .
)
ÀÀ. /
)
ÀÀ/ 0
;
ÀÀ0 1
return
ÃÃ 
left
ÃÃ 
;
ÃÃ 
}
ÕÕ 	
unsafe
œœ 
static
œœ 
void
œœ 
HeapSortStruct
œœ )
<
œœ) *
T
œœ* +
,
œœ+ ,
U
œœ- .
>
œœ. /
(
œœ/ 0
void
œœ0 4
*
œœ4 5
array
œœ6 ;
,
œœ; <
int
œœ= @
lo
œœA C
,
œœC D
int
œœE H
hi
œœI K
,
œœK L
U
œœM N
comp
œœO S
)
œœS T
where
–– 
T
–– 
:
–– 
struct
–– 
where
—— 
U
—— 
:
—— 
	IComparer
—— 
<
——  
T
——  !
>
——! "
{
““ 	
int
”” 
n
”” 
=
”” 
hi
”” 
-
”” 
lo
”” 
+
”” 
$num
”” 
;
””  
for
’’ 
(
’’ 
int
’’ 
i
’’ 
=
’’ 
n
’’ 
/
’’ 
$num
’’ 
;
’’ 
i
’’  !
>=
’’" $
$num
’’% &
;
’’& '
i
’’( )
--
’’) +
)
’’+ ,
{
÷÷ 
HeapifyStruct
◊◊ 
<
◊◊ 
T
◊◊ 
,
◊◊  
U
◊◊! "
>
◊◊" #
(
◊◊# $
array
◊◊$ )
,
◊◊) *
i
◊◊+ ,
,
◊◊, -
n
◊◊. /
,
◊◊/ 0
lo
◊◊1 3
,
◊◊3 4
comp
◊◊5 9
)
◊◊9 :
;
◊◊: ;
}
ÿÿ 
for
⁄⁄ 
(
⁄⁄ 
int
⁄⁄ 
i
⁄⁄ 
=
⁄⁄ 
n
⁄⁄ 
;
⁄⁄ 
i
⁄⁄ 
>
⁄⁄ 
$num
⁄⁄  !
;
⁄⁄! "
i
⁄⁄# $
--
⁄⁄$ &
)
⁄⁄& '
{
€€ 

SwapStruct
‹‹ 
<
‹‹ 
T
‹‹ 
>
‹‹ 
(
‹‹ 
array
‹‹ #
,
‹‹# $
lo
‹‹% '
,
‹‹' (
lo
‹‹) +
+
‹‹, -
i
‹‹. /
-
‹‹0 1
$num
‹‹2 3
)
‹‹3 4
;
‹‹4 5
HeapifyStruct
›› 
<
›› 
T
›› 
,
››  
U
››! "
>
››" #
(
››# $
array
››$ )
,
››) *
$num
››+ ,
,
››, -
i
››. /
-
››0 1
$num
››2 3
,
››3 4
lo
››5 7
,
››7 8
comp
››9 =
)
››= >
;
››> ?
}
ﬁﬁ 
}
ﬂﬂ 	
unsafe
·· 
static
·· 
void
·· 
HeapifyStruct
·· (
<
··( )
T
··) *
,
··* +
U
··, -
>
··- .
(
··. /
void
··/ 3
*
··3 4
array
··5 :
,
··: ;
int
··< ?
i
··@ A
,
··A B
int
··C F
n
··G H
,
··H I
int
··J M
lo
··N P
,
··P Q
U
··R S
comp
··T X
)
··X Y
where
‚‚ 
T
‚‚ 
:
‚‚ 
struct
‚‚ 
where
„„ 
U
„„ 
:
„„ 
	IComparer
„„ 
<
„„  
T
„„  !
>
„„! "
{
‰‰ 	
T
ÂÂ 
val
ÂÂ 
=
ÂÂ 
UnsafeUtility
ÂÂ !
.
ÂÂ! "
ReadArrayElement
ÂÂ" 2
<
ÂÂ2 3
T
ÂÂ3 4
>
ÂÂ4 5
(
ÂÂ5 6
array
ÂÂ6 ;
,
ÂÂ; <
lo
ÂÂ= ?
+
ÂÂ@ A
i
ÂÂB C
-
ÂÂD E
$num
ÂÂF G
)
ÂÂG H
;
ÂÂH I
int
ÊÊ 
child
ÊÊ 
;
ÊÊ 
while
ÁÁ 
(
ÁÁ 
i
ÁÁ 
<=
ÁÁ 
n
ÁÁ 
/
ÁÁ 
$num
ÁÁ 
)
ÁÁ 
{
ËË 
child
ÈÈ 
=
ÈÈ 
$num
ÈÈ 
*
ÈÈ 
i
ÈÈ 
;
ÈÈ 
if
ÍÍ 
(
ÍÍ 
child
ÍÍ 
<
ÍÍ 
n
ÍÍ 
&&
ÍÍ  
(
ÍÍ! "
comp
ÍÍ" &
.
ÍÍ& '
Compare
ÍÍ' .
(
ÍÍ. /
UnsafeUtility
ÍÍ/ <
.
ÍÍ< =
ReadArrayElement
ÍÍ= M
<
ÍÍM N
T
ÍÍN O
>
ÍÍO P
(
ÍÍP Q
array
ÍÍQ V
,
ÍÍV W
lo
ÍÍX Z
+
ÍÍ[ \
child
ÍÍ] b
-
ÍÍc d
$num
ÍÍe f
)
ÍÍf g
,
ÍÍg h
UnsafeUtility
ÍÍi v
.
ÍÍv w
ReadArrayElementÍÍw á
<ÍÍá à
TÍÍà â
>ÍÍâ ä
(ÍÍä ã
arrayÍÍã ê
,ÍÍê ë
(ÍÍí ì
loÍÍì ï
+ÍÍñ ó
childÍÍò ù
)ÍÍù û
)ÍÍû ü
)ÍÍü †
<ÍÍ° ¢
$numÍÍ£ §
)ÍÍ§ •
)ÍÍ• ¶
{
ÎÎ 
child
ÏÏ 
++
ÏÏ 
;
ÏÏ 
}
ÌÌ 
if
ÓÓ 
(
ÓÓ 
comp
ÓÓ 
.
ÓÓ 
Compare
ÓÓ  
(
ÓÓ  !
UnsafeUtility
ÓÓ! .
.
ÓÓ. /
ReadArrayElement
ÓÓ/ ?
<
ÓÓ? @
T
ÓÓ@ A
>
ÓÓA B
(
ÓÓB C
array
ÓÓC H
,
ÓÓH I
(
ÓÓJ K
lo
ÓÓK M
+
ÓÓN O
child
ÓÓP U
-
ÓÓV W
$num
ÓÓX Y
)
ÓÓY Z
)
ÓÓZ [
,
ÓÓ[ \
val
ÓÓ] `
)
ÓÓ` a
<
ÓÓb c
$num
ÓÓd e
)
ÓÓe f
break
ÔÔ 
;
ÔÔ 
UnsafeUtility
ÒÒ 
.
ÒÒ 
WriteArrayElement
ÒÒ /
(
ÒÒ/ 0
array
ÒÒ0 5
,
ÒÒ5 6
lo
ÒÒ7 9
+
ÒÒ: ;
i
ÒÒ< =
-
ÒÒ> ?
$num
ÒÒ@ A
,
ÒÒA B
UnsafeUtility
ÒÒC P
.
ÒÒP Q
ReadArrayElement
ÒÒQ a
<
ÒÒa b
T
ÒÒb c
>
ÒÒc d
(
ÒÒd e
array
ÒÒe j
,
ÒÒj k
lo
ÒÒl n
+
ÒÒo p
child
ÒÒq v
-
ÒÒw x
$num
ÒÒy z
)
ÒÒz {
)
ÒÒ{ |
;
ÒÒ| }
i
ÚÚ 
=
ÚÚ 
child
ÚÚ 
;
ÚÚ 
}
ÛÛ 
UnsafeUtility
ÙÙ 
.
ÙÙ 
WriteArrayElement
ÙÙ +
(
ÙÙ+ ,
array
ÙÙ, 1
,
ÙÙ1 2
lo
ÙÙ3 5
+
ÙÙ6 7
i
ÙÙ8 9
-
ÙÙ: ;
$num
ÙÙ< =
,
ÙÙ= >
val
ÙÙ? B
)
ÙÙB C
;
ÙÙC D
}
ıı 	
unsafe
˜˜ 
static
˜˜ 
void
˜˜ 

SwapStruct
˜˜ %
<
˜˜% &
T
˜˜& '
>
˜˜' (
(
˜˜( )
void
˜˜) -
*
˜˜- .
array
˜˜/ 4
,
˜˜4 5
int
˜˜6 9
lhs
˜˜: =
,
˜˜= >
int
˜˜? B
rhs
˜˜C F
)
˜˜F G
where
¯¯ 
T
¯¯ 
:
¯¯ 
struct
¯¯ 
{
˘˘ 	
T
˙˙ 
val
˙˙ 
=
˙˙ 
UnsafeUtility
˙˙ !
.
˙˙! "
ReadArrayElement
˙˙" 2
<
˙˙2 3
T
˙˙3 4
>
˙˙4 5
(
˙˙5 6
array
˙˙6 ;
,
˙˙; <
lhs
˙˙= @
)
˙˙@ A
;
˙˙A B
UnsafeUtility
˚˚ 
.
˚˚ 
WriteArrayElement
˚˚ +
(
˚˚+ ,
array
˚˚, 1
,
˚˚1 2
lhs
˚˚3 6
,
˚˚6 7
UnsafeUtility
˚˚8 E
.
˚˚E F
ReadArrayElement
˚˚F V
<
˚˚V W
T
˚˚W X
>
˚˚X Y
(
˚˚Y Z
array
˚˚Z _
,
˚˚_ `
rhs
˚˚a d
)
˚˚d e
)
˚˚e f
;
˚˚f g
UnsafeUtility
¸¸ 
.
¸¸ 
WriteArrayElement
¸¸ +
(
¸¸+ ,
array
¸¸, 1
,
¸¸1 2
rhs
¸¸3 6
,
¸¸6 7
val
¸¸8 ;
)
¸¸; <
;
¸¸< =
}
˝˝ 	
unsafe
ˇˇ 
static
ˇˇ 
void
ˇˇ *
SwapIfGreaterWithItemsStruct
ˇˇ 7
<
ˇˇ7 8
T
ˇˇ8 9
,
ˇˇ9 :
U
ˇˇ; <
>
ˇˇ< =
(
ˇˇ= >
void
ˇˇ> B
*
ˇˇB C
array
ˇˇD I
,
ˇˇI J
int
ˇˇK N
lhs
ˇˇO R
,
ˇˇR S
int
ˇˇT W
rhs
ˇˇX [
,
ˇˇ[ \
U
ˇˇ] ^
comp
ˇˇ_ c
)
ˇˇc d
where
ÄÄ 
T
ÄÄ 
:
ÄÄ 
struct
ÄÄ 
where
ÅÅ 
U
ÅÅ 
:
ÅÅ 
	IComparer
ÅÅ 
<
ÅÅ  
T
ÅÅ  !
>
ÅÅ! "
{
ÇÇ 	
if
ÉÉ 
(
ÉÉ 
lhs
ÉÉ 
!=
ÉÉ 
rhs
ÉÉ 
)
ÉÉ 
{
ÑÑ 
if
ÖÖ 
(
ÖÖ 
comp
ÖÖ 
.
ÖÖ 
Compare
ÖÖ  
(
ÖÖ  !
UnsafeUtility
ÖÖ! .
.
ÖÖ. /
ReadArrayElement
ÖÖ/ ?
<
ÖÖ? @
T
ÖÖ@ A
>
ÖÖA B
(
ÖÖB C
array
ÖÖC H
,
ÖÖH I
lhs
ÖÖJ M
)
ÖÖM N
,
ÖÖN O
UnsafeUtility
ÖÖP ]
.
ÖÖ] ^
ReadArrayElement
ÖÖ^ n
<
ÖÖn o
T
ÖÖo p
>
ÖÖp q
(
ÖÖq r
array
ÖÖr w
,
ÖÖw x
rhs
ÖÖy |
)
ÖÖ| }
)
ÖÖ} ~
>ÖÖ Ä
$numÖÖÅ Ç
)ÖÖÇ É
{
ÜÜ 

SwapStruct
áá 
<
áá 
T
áá  
>
áá  !
(
áá! "
array
áá" '
,
áá' (
lhs
áá) ,
,
áá, -
rhs
áá. 1
)
áá1 2
;
áá2 3
}
àà 
}
ââ 
}
ää 	
[
åå 	
BurstCompile
åå	 
]
åå 
unsafe
çç 
struct
çç 
SegmentSort
çç !
<
çç! "
T
çç" #
,
çç# $
U
çç% &
>
çç& '
:
çç( )
IJobParallelFor
çç* 9
where
éé 
T
éé 
:
éé 
	unmanaged
éé 
where
èè 
U
èè 
:
èè 
	IComparer
èè 
<
èè  
T
èè  !
>
èè! "
{
êê 	
[
ëë /
!NativeDisableUnsafePtrRestriction
ëë .
]
ëë. /
public
íí 
T
íí 
*
íí 
Data
íí 
;
íí 
public
ìì 
U
ìì 
Comp
ìì 
;
ìì 
public
ïï 
int
ïï 
Length
ïï 
;
ïï 
public
ññ 
int
ññ 
SegmentWidth
ññ #
;
ññ# $
public
òò 
void
òò 
Execute
òò 
(
òò  
int
òò  #
index
òò$ )
)
òò) *
{
ôô 
var
öö 

startIndex
öö 
=
öö  
index
öö! &
*
öö' (
SegmentWidth
öö) 5
;
öö5 6
var
õõ 
segmentLength
õõ !
=
õõ" #
(
õõ$ %
(
õõ% &
Length
õõ& ,
-
õõ- .

startIndex
õõ/ 9
)
õõ9 :
<
õõ; <
SegmentWidth
õõ= I
)
õõI J
?
õõK L
(
õõM N
Length
õõN T
-
õõU V

startIndex
õõW a
)
õõa b
:
õõc d
SegmentWidth
õõe q
;
õõq r
Sort
úú 
(
úú 
Data
úú 
+
úú 

startIndex
úú &
,
úú& '
segmentLength
úú( 5
,
úú5 6
Comp
úú7 ;
)
úú; <
;
úú< =
}
ùù 
}
ûû 	
[
†† 	
BurstCompile
††	 
]
†† 
unsafe
°° 
struct
°° 
SegmentSortMerge
°° &
<
°°& '
T
°°' (
,
°°( )
U
°°* +
>
°°+ ,
:
°°- .
IJob
°°/ 3
where
¢¢ 
T
¢¢ 
:
¢¢ 
	unmanaged
¢¢ 
where
££ 
U
££ 
:
££ 
	IComparer
££ 
<
££  
T
££  !
>
££! "
{
§§ 	
[
•• /
!NativeDisableUnsafePtrRestriction
•• .
]
••. /
public
¶¶ 
T
¶¶ 
*
¶¶ 
Data
¶¶ 
;
¶¶ 
public
ßß 
U
ßß 
Comp
ßß 
;
ßß 
public
©© 
int
©© 
Length
©© 
;
©© 
public
™™ 
int
™™ 
SegmentWidth
™™ #
;
™™# $
public
¨¨ 
void
¨¨ 
Execute
¨¨ 
(
¨¨  
)
¨¨  !
{
≠≠ 
var
ÆÆ 
segmentCount
ÆÆ  
=
ÆÆ! "
(
ÆÆ# $
Length
ÆÆ$ *
+
ÆÆ+ ,
(
ÆÆ- .
SegmentWidth
ÆÆ. :
-
ÆÆ; <
$num
ÆÆ= >
)
ÆÆ> ?
)
ÆÆ? @
/
ÆÆA B
SegmentWidth
ÆÆC O
;
ÆÆO P
var
ØØ 
segmentIndex
ØØ  
=
ØØ! "

stackalloc
ØØ# -
int
ØØ. 1
[
ØØ1 2
segmentCount
ØØ2 >
]
ØØ> ?
;
ØØ? @
var
±± 

resultCopy
±± 
=
±±  
(
±±! "
T
±±" #
*
±±# $
)
±±$ %
Memory
±±% +
.
±±+ ,
	Unmanaged
±±, 5
.
±±5 6
Allocate
±±6 >
(
±±> ?
UnsafeUtility
±±? L
.
±±L M
SizeOf
±±M S
<
±±S T
T
±±T U
>
±±U V
(
±±V W
)
±±W X
*
±±Y Z
Length
±±[ a
,
±±a b
$num
±±c e
,
±±e f
	Allocator
±±g p
.
±±p q
Temp
±±q u
)
±±u v
;
±±v w
for
≥≥ 
(
≥≥ 
int
≥≥ 
	sortIndex
≥≥ "
=
≥≥# $
$num
≥≥% &
;
≥≥& '
	sortIndex
≥≥( 1
<
≥≥2 3
Length
≥≥4 :
;
≥≥: ;
	sortIndex
≥≥< E
++
≥≥E G
)
≥≥G H
{
¥¥ 
int
∂∂ 
bestSegmentIndex
∂∂ (
=
∂∂) *
-
∂∂+ ,
$num
∂∂, -
;
∂∂- .
T
∑∑ 
	bestValue
∑∑ 
=
∑∑  !
default
∑∑" )
(
∑∑) *
T
∑∑* +
)
∑∑+ ,
;
∑∑, -
for
ππ 
(
ππ 
int
ππ 
i
ππ 
=
ππ  
$num
ππ! "
;
ππ" #
i
ππ$ %
<
ππ& '
segmentCount
ππ( 4
;
ππ4 5
i
ππ6 7
++
ππ7 9
)
ππ9 :
{
∫∫ 
var
ªª 

startIndex
ªª &
=
ªª' (
i
ªª) *
*
ªª+ ,
SegmentWidth
ªª- 9
;
ªª9 :
var
ºº 
offset
ºº "
=
ºº# $
segmentIndex
ºº% 1
[
ºº1 2
i
ºº2 3
]
ºº3 4
;
ºº4 5
var
ΩΩ 
segmentLength
ΩΩ )
=
ΩΩ* +
(
ΩΩ, -
(
ΩΩ- .
Length
ΩΩ. 4
-
ΩΩ5 6

startIndex
ΩΩ7 A
)
ΩΩA B
<
ΩΩC D
SegmentWidth
ΩΩE Q
)
ΩΩQ R
?
ΩΩS T
(
ΩΩU V
Length
ΩΩV \
-
ΩΩ] ^

startIndex
ΩΩ_ i
)
ΩΩi j
:
ΩΩk l
SegmentWidth
ΩΩm y
;
ΩΩy z
if
ææ 
(
ææ 
offset
ææ "
==
ææ# %
segmentLength
ææ& 3
)
ææ3 4
continue
øø $
;
øø$ %
var
¡¡ 
	nextValue
¡¡ %
=
¡¡& '
Data
¡¡( ,
[
¡¡, -

startIndex
¡¡- 7
+
¡¡8 9
offset
¡¡: @
]
¡¡@ A
;
¡¡A B
if
¬¬ 
(
¬¬ 
bestSegmentIndex
¬¬ ,
!=
¬¬- /
-
¬¬0 1
$num
¬¬1 2
)
¬¬2 3
{
√√ 
if
ƒƒ 
(
ƒƒ  
Comp
ƒƒ  $
.
ƒƒ$ %
Compare
ƒƒ% ,
(
ƒƒ, -
	nextValue
ƒƒ- 6
,
ƒƒ6 7
	bestValue
ƒƒ8 A
)
ƒƒA B
>
ƒƒC D
$num
ƒƒE F
)
ƒƒF G
continue
≈≈  (
;
≈≈( )
}
∆∆ 
	bestValue
»» !
=
»»" #
	nextValue
»»$ -
;
»»- .
bestSegmentIndex
…… (
=
……) *
i
……+ ,
;
……, -
}
   
segmentIndex
ÃÃ  
[
ÃÃ  !
bestSegmentIndex
ÃÃ! 1
]
ÃÃ1 2
++
ÃÃ2 4
;
ÃÃ4 5

resultCopy
ÕÕ 
[
ÕÕ 
	sortIndex
ÕÕ (
]
ÕÕ( )
=
ÕÕ* +
	bestValue
ÕÕ, 5
;
ÕÕ5 6
}
ŒŒ 
UnsafeUtility
–– 
.
–– 
MemCpy
–– $
(
––$ %
Data
––% )
,
––) *

resultCopy
––+ 5
,
––5 6
UnsafeUtility
––7 D
.
––D E
SizeOf
––E K
<
––K L
T
––L M
>
––M N
(
––N O
)
––O P
*
––Q R
Length
––S Y
)
––Y Z
;
––Z [
}
—— 
}
““ 	
[
‘‘ 	
Conditional
‘‘	 
(
‘‘ 
$str
‘‘ 6
)
‘‘6 7
]
‘‘7 8
static
’’ 
void
’’ $
CheckStrideMatchesSize
’’ *
<
’’* +
T
’’+ ,
>
’’, -
(
’’- .
int
’’. 1
stride
’’2 8
)
’’8 9
where
’’: ?
T
’’@ A
:
’’B C
struct
’’D J
{
÷÷ 	
if
◊◊ 
(
◊◊ 
stride
◊◊ 
!=
◊◊ 
UnsafeUtility
◊◊ '
.
◊◊' (
SizeOf
◊◊( .
<
◊◊. /
T
◊◊/ 0
>
◊◊0 1
(
◊◊1 2
)
◊◊2 3
)
◊◊3 4
{
ÿÿ 
throw
ŸŸ 
new
ŸŸ '
InvalidOperationException
ŸŸ 3
(
ŸŸ3 4
$str
ŸŸ4 s
)
ŸŸs t
;
ŸŸt u
}
⁄⁄ 
}
€€ 	
}
‹‹ 
[
„„ 
BurstCompatible
„„ 
(
„„ "
GenericTypeArguments
„„ )
=
„„* +
new
„„, /
[
„„/ 0
]
„„0 1
{
„„2 3
typeof
„„4 :
(
„„: ;
int
„„; >
)
„„> ?
,
„„? @
typeof
„„A G
(
„„G H!
NativeSortExtension
„„H [
.
„„[ \
DefaultComparer
„„\ k
<
„„k l
int
„„l o
>
„„o p
)
„„p q
}
„„r s
,
„„s t"
RequiredUnityDefine„„u à
=„„â ä
$str„„ã ¢
)„„÷ ◊
]„„◊ ÿ
public
‰‰ 

unsafe
‰‰ 
struct
‰‰ 
SortJob
‰‰  
<
‰‰  !
T
‰‰! "
,
‰‰" #
U
‰‰$ %
>
‰‰% &
where
ÂÂ 
T
ÂÂ 
:
ÂÂ 
	unmanaged
ÂÂ 
where
ÊÊ 
U
ÊÊ 
:
ÊÊ 
	IComparer
ÊÊ 
<
ÊÊ 
T
ÊÊ 
>
ÊÊ 
{
ÁÁ 
public
ÎÎ 
T
ÎÎ 
*
ÎÎ 
Data
ÎÎ 
;
ÎÎ 
public
 
U
 
Comp
 
;
 
public
ıı 
int
ıı 
Length
ıı 
;
ıı 
[
˜˜ 	
BurstCompile
˜˜	 
]
˜˜ 
struct
¯¯ 
SegmentSort
¯¯ 
:
¯¯ 
IJobParallelFor
¯¯ ,
{
˘˘ 	
[
˙˙ /
!NativeDisableUnsafePtrRestriction
˙˙ .
]
˙˙. /
public
˚˚ 
T
˚˚ 
*
˚˚ 
Data
˚˚ 
;
˚˚ 
public
¸¸ 
U
¸¸ 
Comp
¸¸ 
;
¸¸ 
public
˛˛ 
int
˛˛ 
Length
˛˛ 
;
˛˛ 
public
ˇˇ 
int
ˇˇ 
SegmentWidth
ˇˇ #
;
ˇˇ# $
public
Å	Å	 
void
Å	Å	 
Execute
Å	Å	 
(
Å	Å	  
int
Å	Å	  #
index
Å	Å	$ )
)
Å	Å	) *
{
Ç	Ç	 
var
É	É	 

startIndex
É	É	 
=
É	É	  
index
É	É	! &
*
É	É	' (
SegmentWidth
É	É	) 5
;
É	É	5 6
var
Ñ	Ñ	 
segmentLength
Ñ	Ñ	 !
=
Ñ	Ñ	" #
(
Ñ	Ñ	$ %
(
Ñ	Ñ	% &
Length
Ñ	Ñ	& ,
-
Ñ	Ñ	- .

startIndex
Ñ	Ñ	/ 9
)
Ñ	Ñ	9 :
<
Ñ	Ñ	; <
SegmentWidth
Ñ	Ñ	= I
)
Ñ	Ñ	I J
?
Ñ	Ñ	K L
(
Ñ	Ñ	M N
Length
Ñ	Ñ	N T
-
Ñ	Ñ	U V

startIndex
Ñ	Ñ	W a
)
Ñ	Ñ	a b
:
Ñ	Ñ	c d
SegmentWidth
Ñ	Ñ	e q
;
Ñ	Ñ	q r!
NativeSortExtension
Ö	Ö	 #
.
Ö	Ö	# $
Sort
Ö	Ö	$ (
(
Ö	Ö	( )
Data
Ö	Ö	) -
+
Ö	Ö	. /

startIndex
Ö	Ö	0 :
,
Ö	Ö	: ;
segmentLength
Ö	Ö	< I
,
Ö	Ö	I J
Comp
Ö	Ö	K O
)
Ö	Ö	O P
;
Ö	Ö	P Q
}
Ü	Ü	 
}
á	á	 	
[
â	â	 	
BurstCompile
â	â		 
]
â	â	 
struct
ä	ä	 
SegmentSortMerge
ä	ä	 
:
ä	ä	  !
IJob
ä	ä	" &
{
ã	ã	 	
[
å	å	 /
!NativeDisableUnsafePtrRestriction
å	å	 .
]
å	å	. /
public
ç	ç	 
T
ç	ç	 
*
ç	ç	 
Data
ç	ç	 
;
ç	ç	 
public
é	é	 
U
é	é	 
Comp
é	é	 
;
é	é	 
public
ê	ê	 
int
ê	ê	 
Length
ê	ê	 
;
ê	ê	 
public
ë	ë	 
int
ë	ë	 
SegmentWidth
ë	ë	 #
;
ë	ë	# $
public
ì	ì	 
void
ì	ì	 
Execute
ì	ì	 
(
ì	ì	  
)
ì	ì	  !
{
î	î	 
var
ï	ï	 
segmentCount
ï	ï	  
=
ï	ï	! "
(
ï	ï	# $
Length
ï	ï	$ *
+
ï	ï	+ ,
(
ï	ï	- .
SegmentWidth
ï	ï	. :
-
ï	ï	; <
$num
ï	ï	= >
)
ï	ï	> ?
)
ï	ï	? @
/
ï	ï	A B
SegmentWidth
ï	ï	C O
;
ï	ï	O P
var
ñ	ñ	 
segmentIndex
ñ	ñ	  
=
ñ	ñ	! "

stackalloc
ñ	ñ	# -
int
ñ	ñ	. 1
[
ñ	ñ	1 2
segmentCount
ñ	ñ	2 >
]
ñ	ñ	> ?
;
ñ	ñ	? @
var
ò	ò	 

resultCopy
ò	ò	 
=
ò	ò	  
(
ò	ò	! "
T
ò	ò	" #
*
ò	ò	# $
)
ò	ò	$ %
Memory
ò	ò	% +
.
ò	ò	+ ,
	Unmanaged
ò	ò	, 5
.
ò	ò	5 6
Allocate
ò	ò	6 >
(
ò	ò	> ?
UnsafeUtility
ò	ò	? L
.
ò	ò	L M
SizeOf
ò	ò	M S
<
ò	ò	S T
T
ò	ò	T U
>
ò	ò	U V
(
ò	ò	V W
)
ò	ò	W X
*
ò	ò	Y Z
Length
ò	ò	[ a
,
ò	ò	a b
$num
ò	ò	c e
,
ò	ò	e f
	Allocator
ò	ò	g p
.
ò	ò	p q
Temp
ò	ò	q u
)
ò	ò	u v
;
ò	ò	v w
for
ö	ö	 
(
ö	ö	 
int
ö	ö	 
	sortIndex
ö	ö	 "
=
ö	ö	# $
$num
ö	ö	% &
;
ö	ö	& '
	sortIndex
ö	ö	( 1
<
ö	ö	2 3
Length
ö	ö	4 :
;
ö	ö	: ;
	sortIndex
ö	ö	< E
++
ö	ö	E G
)
ö	ö	G H
{
õ	õ	 
int
ù	ù	 
bestSegmentIndex
ù	ù	 (
=
ù	ù	) *
-
ù	ù	+ ,
$num
ù	ù	, -
;
ù	ù	- .
T
û	û	 
	bestValue
û	û	 
=
û	û	  !
default
û	û	" )
(
û	û	) *
T
û	û	* +
)
û	û	+ ,
;
û	û	, -
for
†	†	 
(
†	†	 
int
†	†	 
i
†	†	 
=
†	†	  
$num
†	†	! "
;
†	†	" #
i
†	†	$ %
<
†	†	& '
segmentCount
†	†	( 4
;
†	†	4 5
i
†	†	6 7
++
†	†	7 9
)
†	†	9 :
{
°	°	 
var
¢	¢	 

startIndex
¢	¢	 &
=
¢	¢	' (
i
¢	¢	) *
*
¢	¢	+ ,
SegmentWidth
¢	¢	- 9
;
¢	¢	9 :
var
£	£	 
offset
£	£	 "
=
£	£	# $
segmentIndex
£	£	% 1
[
£	£	1 2
i
£	£	2 3
]
£	£	3 4
;
£	£	4 5
var
§	§	 
segmentLength
§	§	 )
=
§	§	* +
(
§	§	, -
(
§	§	- .
Length
§	§	. 4
-
§	§	5 6

startIndex
§	§	7 A
)
§	§	A B
<
§	§	C D
SegmentWidth
§	§	E Q
)
§	§	Q R
?
§	§	S T
(
§	§	U V
Length
§	§	V \
-
§	§	] ^

startIndex
§	§	_ i
)
§	§	i j
:
§	§	k l
SegmentWidth
§	§	m y
;
§	§	y z
if
•	•	 
(
•	•	 
offset
•	•	 "
==
•	•	# %
segmentLength
•	•	& 3
)
•	•	3 4
continue
¶	¶	 $
;
¶	¶	$ %
var
®	®	 
	nextValue
®	®	 %
=
®	®	& '
Data
®	®	( ,
[
®	®	, -

startIndex
®	®	- 7
+
®	®	8 9
offset
®	®	: @
]
®	®	@ A
;
®	®	A B
if
©	©	 
(
©	©	 
bestSegmentIndex
©	©	 ,
!=
©	©	- /
-
©	©	0 1
$num
©	©	1 2
)
©	©	2 3
{
™	™	 
if
´	´	 
(
´	´	  
Comp
´	´	  $
.
´	´	$ %
Compare
´	´	% ,
(
´	´	, -
	nextValue
´	´	- 6
,
´	´	6 7
	bestValue
´	´	8 A
)
´	´	A B
>
´	´	C D
$num
´	´	E F
)
´	´	F G
continue
¨	¨	  (
;
¨	¨	( )
}
≠	≠	 
	bestValue
Ø	Ø	 !
=
Ø	Ø	" #
	nextValue
Ø	Ø	$ -
;
Ø	Ø	- .
bestSegmentIndex
∞	∞	 (
=
∞	∞	) *
i
∞	∞	+ ,
;
∞	∞	, -
}
±	±	 
segmentIndex
≥	≥	  
[
≥	≥	  !
bestSegmentIndex
≥	≥	! 1
]
≥	≥	1 2
++
≥	≥	2 4
;
≥	≥	4 5

resultCopy
¥	¥	 
[
¥	¥	 
	sortIndex
¥	¥	 (
]
¥	¥	( )
=
¥	¥	* +
	bestValue
¥	¥	, 5
;
¥	¥	5 6
}
µ	µ	 
UnsafeUtility
∑	∑	 
.
∑	∑	 
MemCpy
∑	∑	 $
(
∑	∑	$ %
Data
∑	∑	% )
,
∑	∑	) *

resultCopy
∑	∑	+ 5
,
∑	∑	5 6
UnsafeUtility
∑	∑	7 D
.
∑	∑	D E
SizeOf
∑	∑	E K
<
∑	∑	K L
T
∑	∑	L M
>
∑	∑	M N
(
∑	∑	N O
)
∑	∑	O P
*
∑	∑	Q R
Length
∑	∑	S Y
)
∑	∑	Y Z
;
∑	∑	Z [
}
∏	∏	 
}
π	π	 	
[
¿	¿	 	 
NotBurstCompatible
¿	¿		 
]¿	¿	ú ù
public
¡	¡	 
	JobHandle
¡	¡	 
Schedule
¡	¡	 !
(
¡	¡	! "
	JobHandle
¡	¡	" +
	inputDeps
¡	¡	, 5
=
¡	¡	6 7
default
¡	¡	8 ?
)
¡	¡	? @
{
¬	¬	 	
if
√	√	 
(
√	√	 
Length
√	√	 
==
√	√	 
$num
√	√	 
)
√	√	 
return
ƒ	ƒ	 
	inputDeps
ƒ	ƒ	  
;
ƒ	ƒ	  !
var
≈	≈	 
segmentCount
≈	≈	 
=
≈	≈	 
(
≈	≈	  
Length
≈	≈	  &
+
≈	≈	' (
$num
≈	≈	) -
)
≈	≈	- .
/
≈	≈	/ 0
$num
≈	≈	1 5
;
≈	≈	5 6
var
∆	∆	 
workerCount
∆	∆	 
=
∆	∆	 
math
∆	∆	 "
.
∆	∆	" #
max
∆	∆	# &
(
∆	∆	& '
$num
∆	∆	' (
,
∆	∆	( )
JobsUtility
∆	∆	* 5
.
∆	∆	5 6
MaxJobThreadCount
∆	∆	6 G
)
∆	∆	G H
;
∆	∆	H I
var
«	«	  
workerSegmentCount
«	«	 "
=
«	«	# $
segmentCount
«	«	% 1
/
«	«	2 3
workerCount
«	«	4 ?
;
«	«	? @
var
»	»	 
segmentSortJob
»	»	 
=
»	»	  
new
»	»	! $
SegmentSort
»	»	% 0
{
»	»	1 2
Data
»	»	3 7
=
»	»	8 9
Data
»	»	: >
,
»	»	> ?
Comp
»	»	@ D
=
»	»	E F
Comp
»	»	G K
,
»	»	K L
Length
»	»	M S
=
»	»	T U
Length
»	»	V \
,
»	»	\ ]
SegmentWidth
»	»	^ j
=
»	»	k l
$num
»	»	m q
}
»	»	r s
;
»	»	s t
var
…	…	 "
segmentSortJobHandle
…	…	 $
=
…	…	% &
segmentSortJob
…	…	' 5
.
…	…	5 6
Schedule
…	…	6 >
(
…	…	> ?
segmentCount
…	…	? K
,
…	…	K L 
workerSegmentCount
…	…	M _
,
…	…	_ `
	inputDeps
…	…	a j
)
…	…	j k
;
…	…	k l
var
 	 	 !
segmentSortMergeJob
 	 	 #
=
 	 	$ %
new
 	 	& )
SegmentSortMerge
 	 	* :
{
 	 	; <
Data
 	 	= A
=
 	 	B C
Data
 	 	D H
,
 	 	H I
Comp
 	 	J N
=
 	 	O P
Comp
 	 	Q U
,
 	 	U V
Length
 	 	W ]
=
 	 	^ _
Length
 	 	` f
,
 	 	f g
SegmentWidth
 	 	h t
=
 	 	u v
$num
 	 	w {
}
 	 	| }
;
 	 	} ~
var
À	À	 '
segmentSortMergeJobHandle
À	À	 )
=
À	À	* +!
segmentSortMergeJob
À	À	, ?
.
À	À	? @
Schedule
À	À	@ H
(
À	À	H I"
segmentSortJobHandle
À	À	I ]
)
À	À	] ^
;
À	À	^ _
return
Ã	Ã	 '
segmentSortMergeJobHandle
Ã	Ã	 ,
;
Ã	Ã	, -
}
Õ	Õ	 	
}
Œ	Œ	 
}œ	œ	 ﬁ
`C:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\DebugView.cs
	namespace 	
Unity
 
. 
Collections 
{ 
internal 
struct 
Pair 
< 
Key 
, 
Value #
># $
{ 
public 
Key 
key 
; 
public		 
Value		 
value		 
;		 
public

 
Pair

 
(

 
Key

 
k

 
,

 
Value

  
v

! "
)

" #
{ 	
key 
= 
k 
; 
value 
= 
v 
; 
} 	
public 
override 
string 
ToString '
(' (
)( )
{ 	
return 
$" 
{ 
key 
} 
$str 
{ 
value #
}# $
"$ %
;% &
} 	
} 
internal 
struct 
ListPair 
< 
Key  
,  !
Value" '
>' (
where) .
Value/ 4
:5 6
IList7 <
{ 
public 
Key 
key 
; 
public 
Value 
value 
; 
public   
ListPair   
(   
Key   
k   
,   
Value   $
v  % &
)  & '
{!! 	
key"" 
="" 
k"" 
;"" 
value## 
=## 
v## 
;## 
}$$ 	
public&& 
override&& 
string&& 
ToString&& '
(&&' (
)&&( )
{'' 	
String(( 
result(( 
=(( 
$"(( 
{(( 
key(( "
}((" #
$str((# '
"((' (
;((( )
for)) 
()) 
var)) 
v)) 
=)) 
$num)) 
;)) 
v)) 
<)) 
value))  %
.))% &
Count))& +
;))+ ,
++))- /
v))/ 0
)))0 1
{** 
result++ 
+=++ 
value++ 
[++  
v++  !
]++! "
;++" #
if,, 
(,, 
v,, 
<,, 
value,, 
.,, 
Count,, #
-,,$ %
$num,,& '
),,' (
result-- 
+=-- 
$str-- "
;--" #
}.. 
result00 
+=00 
$str00 
;00 
return11 
result11 
;11 
}22 	
}33 
}55 Øô
gC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\CollectionHelper.cs
	namespace 	
Unity
 
. 
Collections 
{ 
public 

	interface 
INativeDisposable &
:' (
IDisposable) 4
{ 
	JobHandle 
Dispose 
( 
	JobHandle #
	inputDeps$ -
)- .
;. /
} 
[   
BurstCompatible   
]   
public!! 

static!! 
class!! 
CollectionHelper!! (
{"" 
[## 	
Conditional##	 
(## 
$str## 6
)##6 7
]##7 8
internal$$ 
static$$ 
void$$ 
CheckAllocator$$ +
($$+ ,
AllocatorManager$$, <
.$$< =
AllocatorHandle$$= L
	allocator$$M V
)$$V W
{%% 	
if&& 
(&& 
!&& 
ShouldDeallocate&& !
(&&! "
	allocator&&" +
)&&+ ,
)&&, -
throw'' 
new'' 
ArgumentException'' +
(''+ ,
$"'', .
$str''. 8
{''8 9
	allocator''9 B
}''B C
$str''C _
"''_ `
)''` a
;''a b
}(( 	
public.. 
const.. 
int.. 
CacheLineSize.. &
=..' (
JobsUtility..) 4
...4 5
CacheLineSize..5 B
;..B C
[00 	
StructLayout00	 
(00 

LayoutKind00  
.00  !
Explicit00! )
)00) *
]00* +
internal11 
struct11 
LongDoubleUnion11 '
{22 	
[33 
FieldOffset33 
(33 
$num33 
)33 
]33 
internal44 
long44 
	longValue44 #
;44# $
[66 
FieldOffset66 
(66 
$num66 
)66 
]66 
internal77 
double77 
doubleValue77 '
;77' (
}88 	
public?? 
static?? 
int?? 
	Log2Floor?? #
(??# $
int??$ '
value??( -
)??- .
{@@ 	
returnAA 
$numAA 
-AA 
mathAA 
.AA 
lzcntAA "
(AA" #
(AA# $
uintAA$ (
)AA( )
valueAA) .
)AA. /
;AA/ 0
}BB 	
publicII 
staticII 
intII 
Log2CeilII "
(II" #
intII# &
valueII' ,
)II, -
{JJ 	
returnKK 
$numKK 
-KK 
mathKK 
.KK 
lzcntKK "
(KK" #
(KK# $
uintKK$ (
)KK( )
valueKK) .
-KK/ 0
$numKK1 2
)KK2 3
;KK3 4
}LL 	
publicYY 
staticYY 
intYY 
AlignYY 
(YY  
intYY  #
sizeYY$ (
,YY( )
intYY* -
alignmentPowerOfTwoYY. A
)YYA B
{ZZ 	
if[[ 
([[ 
alignmentPowerOfTwo[[ #
==[[$ &
$num[[' (
)[[( )
return\\ 
size\\ 
;\\ &
CheckIntPositivePowerOfTwo^^ &
(^^& '
alignmentPowerOfTwo^^' :
)^^: ;
;^^; <
return`` 
(`` 
size`` 
+`` 
alignmentPowerOfTwo`` .
-``/ 0
$num``1 2
)``2 3
&``4 5
~``6 7
(``7 8
alignmentPowerOfTwo``8 K
-``L M
$num``N O
)``O P
;``P Q
}aa 	
publicnn 
staticnn 
ulongnn 
Alignnn !
(nn! "
ulongnn" '
sizenn( ,
,nn, -
ulongnn. 3
alignmentPowerOfTwonn4 G
)nnG H
{oo 	
ifpp 
(pp 
alignmentPowerOfTwopp #
==pp$ &
$numpp' (
)pp( )
returnqq 
sizeqq 
;qq (
CheckUlongPositivePowerOfTwoss (
(ss( )
alignmentPowerOfTwoss) <
)ss< =
;ss= >
returnuu 
(uu 
sizeuu 
+uu 
alignmentPowerOfTwouu .
-uu/ 0
$numuu1 2
)uu2 3
&uu4 5
~uu6 7
(uu7 8
alignmentPowerOfTwouu8 K
-uuL M
$numuuN O
)uuO P
;uuP Q
}vv 	
public 
static 
unsafe 
bool !
	IsAligned" +
(+ ,
void, 0
*0 1
p2 3
,3 4
int5 8
alignmentPowerOfTwo9 L
)L M
{
ÄÄ 	(
CheckIntPositivePowerOfTwo
ÅÅ &
(
ÅÅ& '!
alignmentPowerOfTwo
ÅÅ' :
)
ÅÅ: ;
;
ÅÅ; <
return
ÇÇ 
(
ÇÇ 
(
ÇÇ 
ulong
ÇÇ 
)
ÇÇ 
p
ÇÇ 
&
ÇÇ 
(
ÇÇ  
(
ÇÇ  !
ulong
ÇÇ! &
)
ÇÇ& '!
alignmentPowerOfTwo
ÇÇ' :
-
ÇÇ; <
$num
ÇÇ= >
)
ÇÇ> ?
)
ÇÇ? @
==
ÇÇA C
$num
ÇÇD E
;
ÇÇE F
}
ÉÉ 	
public
åå 
static
åå 
bool
åå 
	IsAligned
åå $
(
åå$ %
ulong
åå% *
offset
åå+ 1
,
åå1 2
int
åå3 6!
alignmentPowerOfTwo
åå7 J
)
ååJ K
{
çç 	(
CheckIntPositivePowerOfTwo
éé &
(
éé& '!
alignmentPowerOfTwo
éé' :
)
éé: ;
;
éé; <
return
èè 
(
èè 
offset
èè 
&
èè 
(
èè 
(
èè 
ulong
èè $
)
èè$ %!
alignmentPowerOfTwo
èè% 8
-
èè9 :
$num
èè; <
)
èè< =
)
èè= >
==
èè? A
$num
èèB C
;
èèC D
}
êê 	
public
òò 
static
òò 
bool
òò 
IsPowerOfTwo
òò '
(
òò' (
int
òò( +
value
òò, 1
)
òò1 2
{
ôô 	
return
öö 
(
öö 
value
öö 
&
öö 
(
öö 
value
öö "
-
öö# $
$num
öö% &
)
öö& '
)
öö' (
==
öö) +
$num
öö, -
;
öö- .
}
õõ 	
public
§§ 
static
§§ 
unsafe
§§ 
uint
§§ !
Hash
§§" &
(
§§& '
void
§§' +
*
§§+ ,
ptr
§§- 0
,
§§0 1
int
§§2 5
bytes
§§6 ;
)
§§; <
{
•• 	
byte
®® 
*
®® 
str
®® 
=
®® 
(
®® 
byte
®® 
*
®® 
)
®® 
ptr
®® "
;
®®" #
ulong
©© 
hash
©© 
=
©© 
$num
©© 
;
©© 
while
™™ 
(
™™ 
bytes
™™ 
>
™™ 
$num
™™ 
)
™™ 
{
´´ 
ulong
¨¨ 
c
¨¨ 
=
¨¨ 
str
¨¨ 
[
¨¨ 
--
¨¨  
bytes
¨¨  %
]
¨¨% &
;
¨¨& '
hash
≠≠ 
=
≠≠ 
(
≠≠ 
(
≠≠ 
hash
≠≠ 
<<
≠≠  
$num
≠≠! "
)
≠≠" #
+
≠≠$ %
hash
≠≠& *
)
≠≠* +
+
≠≠, -
c
≠≠. /
;
≠≠/ 0
}
ÆÆ 
return
ØØ 
(
ØØ 
uint
ØØ 
)
ØØ 
hash
ØØ 
;
ØØ 
}
∞∞ 	
[
≤≤ 	 
NotBurstCompatible
≤≤	 
]
≤≤: ;
internal
≥≥ 
static
≥≥ 
void
≥≥ 
WriteLayout
≥≥ (
(
≥≥( )
Type
≥≥) -
type
≥≥. 2
)
≥≥2 3
{
¥¥ 	
Console
∂∂ 
.
∂∂ 
	WriteLine
∂∂ 
(
∂∂ 
$"
∂∂  
$str
∂∂  F
{
∂∂F G
$num
∂∂G H
}
∂∂H I
"
∂∂I J
,
∂∂J K
type
∂∂L P
.
∂∂P Q
Name
∂∂Q U
)
∂∂U V
;
∂∂V W
var
∑∑ 
fields
∑∑ 
=
∑∑ 
type
∑∑ 
.
∑∑ 
	GetFields
∑∑ '
(
∑∑' (
BindingFlags
∑∑( 4
.
∑∑4 5
Public
∑∑5 ;
|
∑∑< =
BindingFlags
∑∑> J
.
∑∑J K
	NonPublic
∑∑K T
|
∑∑U V
BindingFlags
∑∑W c
.
∑∑c d
Instance
∑∑d l
)
∑∑l m
;
∑∑m n
foreach
∏∏ 
(
∏∏ 
var
∏∏ 
field
∏∏ 
in
∏∏ !
fields
∏∏" (
)
∏∏( )
{
ππ 
Console
∫∫ 
.
∫∫ 
	WriteLine
∫∫ !
(
∫∫! "
$str
∫∫" <
,
ªª 
Marshal
ªª 
.
ªª 
OffsetOf
ªª &
(
ªª& '
type
ªª' +
,
ªª+ ,
field
ªª- 2
.
ªª2 3
Name
ªª3 7
)
ªª7 8
,
ºº 
Marshal
ºº 
.
ºº 
SizeOf
ºº $
(
ºº$ %
field
ºº% *
.
ºº* +
	FieldType
ºº+ 4
)
ºº4 5
,
ΩΩ 
field
ΩΩ 
.
ΩΩ 
Name
ΩΩ  
)
ææ 
;
ææ 
}
øø 
}
√√ 	
internal
≈≈ 
static
≈≈ 
bool
≈≈ 
ShouldDeallocate
≈≈ -
(
≈≈- .
AllocatorManager
≈≈. >
.
≈≈> ?
AllocatorHandle
≈≈? N
	allocator
≈≈O X
)
≈≈X Y
{
∆∆ 	
return
…… 
	allocator
…… 
.
…… 
ToAllocator
…… (
>
……) *
	Allocator
……+ 4
.
……4 5
None
……5 9
;
……9 :
}
   	
[
—— 	
return
——	 
:
—— 
AssumeRange
—— 
(
—— 
$num
—— 
,
—— 
int
——  #
.
——# $
MaxValue
——$ ,
)
——, -
]
——- .
internal
““ 
static
““ 
int
““ 
AssumePositive
““ *
(
““* +
int
““+ .
value
““/ 4
)
““4 5
{
”” 	
return
‘‘ 
value
‘‘ 
;
‘‘ 
}
’’ 	
[
◊◊ 	
Conditional
◊◊	 
(
◊◊ 
$str
◊◊ 6
)
◊◊6 7
]
◊◊7 8
[
ÿÿ 	
BurstDiscard
ÿÿ	 
]
ÿÿ 
[
ŸŸ 	 
NotBurstCompatible
ŸŸ	 
]
ŸŸ; <
internal
⁄⁄ 
static
⁄⁄ 
void
⁄⁄ 
CheckIsUnmanaged
⁄⁄ -
<
⁄⁄- .
T
⁄⁄. /
>
⁄⁄/ 0
(
⁄⁄0 1
)
⁄⁄1 2
{
€€ 	
if
‹‹ 
(
‹‹ 
!
‹‹ 
UnsafeUtility
‹‹ 
.
‹‹ /
!IsValidNativeContainerElementType
‹‹ @
<
‹‹@ A
T
‹‹A B
>
‹‹B C
(
‹‹C D
)
‹‹D E
)
‹‹E F
{
›› 
throw
ﬁﬁ 
new
ﬁﬁ 
ArgumentException
ﬁﬁ +
(
ﬁﬁ+ ,
$"
ﬁﬁ, .
{
ﬁﬁ. /
typeof
ﬁﬁ/ 5
(
ﬁﬁ5 6
T
ﬁﬁ6 7
)
ﬁﬁ7 8
}
ﬁﬁ8 9
$strﬁﬁ9 °
"ﬁﬁ° ¢
)ﬁﬁ¢ £
;ﬁﬁ£ §
}
ﬂﬂ 
}
‡‡ 	
[
‚‚ 	
Conditional
‚‚	 
(
‚‚ 
$str
‚‚ 6
)
‚‚6 7
]
‚‚7 8
internal
„„ 
static
„„ 
void
„„ (
CheckIntPositivePowerOfTwo
„„ 7
(
„„7 8
int
„„8 ;
value
„„< A
)
„„A B
{
‰‰ 	
var
ÂÂ 
valid
ÂÂ 
=
ÂÂ 
(
ÂÂ 
value
ÂÂ 
>
ÂÂ  
$num
ÂÂ! "
)
ÂÂ" #
&&
ÂÂ$ &
(
ÂÂ' (
(
ÂÂ( )
value
ÂÂ) .
&
ÂÂ/ 0
(
ÂÂ1 2
value
ÂÂ2 7
-
ÂÂ8 9
$num
ÂÂ: ;
)
ÂÂ; <
)
ÂÂ< =
==
ÂÂ> @
$num
ÂÂA B
)
ÂÂB C
;
ÂÂC D
if
ÊÊ 
(
ÊÊ 
!
ÊÊ 
valid
ÊÊ 
)
ÊÊ 
{
ÁÁ 
throw
ËË 
new
ËË 
ArgumentException
ËË +
(
ËË+ ,
$"
ËË, .
$str
ËË. C
{
ËËC D
value
ËËD I
}
ËËI J
$str
ËËJ t
"
ËËt u
)
ËËu v
;
ËËv w
}
ÈÈ 
}
ÍÍ 	
[
ÏÏ 	
Conditional
ÏÏ	 
(
ÏÏ 
$str
ÏÏ 6
)
ÏÏ6 7
]
ÏÏ7 8
internal
ÌÌ 
static
ÌÌ 
void
ÌÌ *
CheckUlongPositivePowerOfTwo
ÌÌ 9
(
ÌÌ9 :
ulong
ÌÌ: ?
value
ÌÌ@ E
)
ÌÌE F
{
ÓÓ 	
var
ÔÔ 
valid
ÔÔ 
=
ÔÔ 
(
ÔÔ 
value
ÔÔ 
>
ÔÔ  
$num
ÔÔ! "
)
ÔÔ" #
&&
ÔÔ$ &
(
ÔÔ' (
(
ÔÔ( )
value
ÔÔ) .
&
ÔÔ/ 0
(
ÔÔ1 2
value
ÔÔ2 7
-
ÔÔ8 9
$num
ÔÔ: ;
)
ÔÔ; <
)
ÔÔ< =
==
ÔÔ> @
$num
ÔÔA B
)
ÔÔB C
;
ÔÔC D
if
 
(
 
!
 
valid
 
)
 
{
ÒÒ 
throw
ÚÚ 
new
ÚÚ 
ArgumentException
ÚÚ +
(
ÚÚ+ ,
$"
ÚÚ, .
$str
ÚÚ. C
{
ÚÚC D
value
ÚÚD I
}
ÚÚI J
$str
ÚÚJ t
"
ÚÚt u
)
ÚÚu v
;
ÚÚv w
}
ÛÛ 
}
ÙÙ 	
[
ˆˆ 	
Conditional
ˆˆ	 
(
ˆˆ 
$str
ˆˆ 6
)
ˆˆ6 7
,
ˆˆ7 8
Conditional
ˆˆ9 D
(
ˆˆD E
$str
ˆˆE W
)
ˆˆW X
]
ˆˆX Y
internal
˜˜ 
static
˜˜ 
void
˜˜ 
CheckIndexInRange
˜˜ .
(
˜˜. /
int
˜˜/ 2
index
˜˜3 8
,
˜˜8 9
int
˜˜: =
length
˜˜> D
)
˜˜D E
{
¯¯ 	
if
˘˘ 
(
˘˘ 
index
˘˘ 
<
˘˘ 
$num
˘˘ 
)
˘˘ 
throw
˙˙ 
new
˙˙ &
IndexOutOfRangeException
˙˙ 2
(
˙˙2 3
$"
˙˙3 5
$str
˙˙5 ;
{
˙˙; <
index
˙˙< A
}
˙˙A B
$str
˙˙B T
"
˙˙T U
)
˙˙U V
;
˙˙V W
if
¸¸ 
(
¸¸ 
index
¸¸ 
>=
¸¸ 
length
¸¸ 
)
¸¸  
throw
˝˝ 
new
˝˝ &
IndexOutOfRangeException
˝˝ 2
(
˝˝2 3
$"
˝˝3 5
$str
˝˝5 ;
{
˝˝; <
index
˝˝< A
}
˝˝A B
$str
˝˝B d
{
˝˝d e
length
˝˝e k
}
˝˝k l
$str
˝˝l u
"
˝˝u v
)
˝˝v w
;
˝˝w x
}
˛˛ 	
[
ÄÄ 	
Conditional
ÄÄ	 
(
ÄÄ 
$str
ÄÄ 6
)
ÄÄ6 7
,
ÄÄ7 8
Conditional
ÄÄ9 D
(
ÄÄD E
$str
ÄÄE W
)
ÄÄW X
]
ÄÄX Y
internal
ÅÅ 
static
ÅÅ 
void
ÅÅ "
CheckCapacityInRange
ÅÅ 1
(
ÅÅ1 2
int
ÅÅ2 5
capacity
ÅÅ6 >
,
ÅÅ> ?
int
ÅÅ@ C
length
ÅÅD J
)
ÅÅJ K
{
ÇÇ 	
if
ÉÉ 
(
ÉÉ 
capacity
ÉÉ 
<
ÉÉ 
$num
ÉÉ 
)
ÉÉ 
throw
ÑÑ 
new
ÑÑ )
ArgumentOutOfRangeException
ÑÑ 5
(
ÑÑ5 6
$"
ÑÑ6 8
$str
ÑÑ8 A
{
ÑÑA B
capacity
ÑÑB J
}
ÑÑJ K
$str
ÑÑK ]
"
ÑÑ] ^
)
ÑÑ^ _
;
ÑÑ_ `
if
ÜÜ 
(
ÜÜ 
capacity
ÜÜ 
<
ÜÜ 
length
ÜÜ !
)
ÜÜ! "
throw
áá 
new
áá )
ArgumentOutOfRangeException
áá 5
(
áá5 6
$"
áá6 8
$str
áá8 A
{
ááA B
capacity
ááB J
}
ááJ K
$str
ááK m
{
áám n
length
áán t
}
áát u
$str
ááu ~
"
áá~ 
)áá Ä
;ááÄ Å
}
àà 	
[
ëë 	
BurstCompatible
ëë	 
(
ëë "
GenericTypeArguments
ëë -
=
ëë. /
new
ëë0 3
[
ëë3 4
]
ëë4 5
{
ëë6 7
typeof
ëë8 >
(
ëë> ?
int
ëë? B
)
ëëB C
,
ëëC D
typeof
ëëE K
(
ëëK L
AllocatorManager
ëëL \
.
ëë\ ]
AllocatorHandle
ëë] l
)
ëël m
}
ëën o
)
ëëo p
]
ëëp q
public
íí 
static
íí 
NativeArray
íí !
<
íí! "
T
íí" #
>
íí# $
CreateNativeArray
íí% 6
<
íí6 7
T
íí7 8
,
íí8 9
U
íí: ;
>
íí; <
(
íí< =
int
íí= @
length
ííA G
,
ííG H
ref
ííI L
U
ííM N
	allocator
ííO X
,
ííX Y 
NativeArrayOptions
ííZ l
options
íím t
=
ííu v!
NativeArrayOptionsííw â
.ííâ ä
ClearMemoryííä ï
)ííï ñ
where
ìì 
T
ìì 
:
ìì 
struct
ìì 
where
îî 
U
îî 
:
îî 
	unmanaged
îî 
,
îî  
AllocatorManager
îî! 1
.
îî1 2

IAllocator
îî2 <
{
ïï 	
NativeArray
ññ 
<
ññ 
T
ññ 
>
ññ 
nativeArray
ññ &
;
ññ& '
if
óó 
(
óó 
!
óó 
	allocator
óó 
.
óó 
IsCustomAllocator
óó ,
)
óó, -
{
òò 
nativeArray
ôô 
=
ôô 
new
ôô !
NativeArray
ôô" -
<
ôô- .
T
ôô. /
>
ôô/ 0
(
ôô0 1
length
ôô1 7
,
ôô7 8
	allocator
ôô9 B
.
ôôB C
ToAllocator
ôôC N
,
ôôN O
options
ôôP W
)
ôôW X
;
ôôX Y
}
öö 
else
õõ 
{
úú 
nativeArray
ùù 
=
ùù 
new
ùù !
NativeArray
ùù" -
<
ùù- .
T
ùù. /
>
ùù/ 0
(
ùù0 1
)
ùù1 2
;
ùù2 3
nativeArray
ûû 
.
ûû 

Initialize
ûû &
(
ûû& '
length
ûû' -
,
ûû- .
ref
ûû/ 2
	allocator
ûû3 <
,
ûû< =
options
ûû> E
)
ûûE F
;
ûûF G
}
üü 
return
†† 
nativeArray
†† 
;
†† 
}
°° 	
[
™™ 	
BurstCompatible
™™	 
(
™™ "
GenericTypeArguments
™™ -
=
™™. /
new
™™0 3
[
™™3 4
]
™™4 5
{
™™6 7
typeof
™™8 >
(
™™> ?
int
™™? B
)
™™B C
}
™™D E
)
™™E F
]
™™F G
public
´´ 
static
´´ 
NativeArray
´´ !
<
´´! "
T
´´" #
>
´´# $
CreateNativeArray
´´% 6
<
´´6 7
T
´´7 8
>
´´8 9
(
´´9 :
int
´´: =
length
´´> D
,
´´D E
AllocatorManager
´´F V
.
´´V W
AllocatorHandle
´´W f
	allocator
´´g p
,
´´p q!
NativeArrayOptions´´r Ñ
options´´Ö å
=´´ç é"
NativeArrayOptions´´è °
.´´° ¢
ClearMemory´´¢ ≠
)´´≠ Æ
where
¨¨ 
T
¨¨ 
:
¨¨ 
struct
¨¨ 
{
≠≠ 	
NativeArray
ÆÆ 
<
ÆÆ 
T
ÆÆ 
>
ÆÆ 
nativeArray
ÆÆ &
;
ÆÆ& '
if
ØØ 
(
ØØ 
!
ØØ 
AllocatorManager
ØØ  
.
ØØ  !
IsCustomAllocator
ØØ! 2
(
ØØ2 3
	allocator
ØØ3 <
)
ØØ< =
)
ØØ= >
{
∞∞ 
nativeArray
±± 
=
±± 
new
±± !
NativeArray
±±" -
<
±±- .
T
±±. /
>
±±/ 0
(
±±0 1
length
±±1 7
,
±±7 8
	allocator
±±9 B
.
±±B C
ToAllocator
±±C N
,
±±N O
options
±±P W
)
±±W X
;
±±X Y
}
≤≤ 
else
≥≥ 
{
¥¥ 
nativeArray
µµ 
=
µµ 
new
µµ !
NativeArray
µµ" -
<
µµ- .
T
µµ. /
>
µµ/ 0
(
µµ0 1
)
µµ1 2
;
µµ2 3
nativeArray
∂∂ 
.
∂∂ 

Initialize
∂∂ &
(
∂∂& '
length
∂∂' -
,
∂∂- .
	allocator
∂∂/ 8
,
∂∂8 9
options
∂∂: A
)
∂∂A B
;
∂∂B C
}
∑∑ 
return
∏∏ 
nativeArray
∏∏ 
;
∏∏ 
}
ππ 	
[
¡¡ 	
BurstCompatible
¡¡	 
(
¡¡ "
GenericTypeArguments
¡¡ -
=
¡¡. /
new
¡¡0 3
[
¡¡3 4
]
¡¡4 5
{
¡¡6 7
typeof
¡¡8 >
(
¡¡> ?
int
¡¡? B
)
¡¡B C
}
¡¡D E
)
¡¡E F
]
¡¡F G
public
¬¬ 
static
¬¬ 
NativeArray
¬¬ !
<
¬¬! "
T
¬¬" #
>
¬¬# $
CreateNativeArray
¬¬% 6
<
¬¬6 7
T
¬¬7 8
>
¬¬8 9
(
¬¬9 :
NativeArray
¬¬: E
<
¬¬E F
T
¬¬F G
>
¬¬G H
array
¬¬I N
,
¬¬N O
AllocatorManager
¬¬P `
.
¬¬` a
AllocatorHandle
¬¬a p
	allocator
¬¬q z
)
¬¬z {
where
√√ 
T
√√ 
:
√√ 
struct
√√ 
{
ƒƒ 	
NativeArray
≈≈ 
<
≈≈ 
T
≈≈ 
>
≈≈ 
nativeArray
≈≈ &
;
≈≈& '
if
∆∆ 
(
∆∆ 
!
∆∆ 
AllocatorManager
∆∆ !
.
∆∆! "
IsCustomAllocator
∆∆" 3
(
∆∆3 4
	allocator
∆∆4 =
)
∆∆= >
)
∆∆> ?
{
«« 
nativeArray
»» 
=
»» 
new
»» !
NativeArray
»»" -
<
»»- .
T
»». /
>
»»/ 0
(
»»0 1
array
»»1 6
,
»»6 7
	allocator
»»8 A
.
»»A B
ToAllocator
»»B M
)
»»M N
;
»»N O
}
…… 
else
   
{
ÀÀ 
nativeArray
ÃÃ 
=
ÃÃ 
new
ÃÃ !
NativeArray
ÃÃ" -
<
ÃÃ- .
T
ÃÃ. /
>
ÃÃ/ 0
(
ÃÃ0 1
)
ÃÃ1 2
;
ÃÃ2 3
nativeArray
ÕÕ 
.
ÕÕ 

Initialize
ÕÕ &
(
ÕÕ& '
array
ÕÕ' ,
.
ÕÕ, -
Length
ÕÕ- 3
,
ÕÕ3 4
	allocator
ÕÕ5 >
)
ÕÕ> ?
;
ÕÕ? @
nativeArray
ŒŒ 
.
ŒŒ 
CopyFrom
ŒŒ $
(
ŒŒ$ %
array
ŒŒ% *
)
ŒŒ* +
;
ŒŒ+ ,
}
œœ 
return
–– 
nativeArray
–– 
;
–– 
}
—— 	
[
ŸŸ 	 
NotBurstCompatible
ŸŸ	 
]
ŸŸ 
public
⁄⁄ 
static
⁄⁄ 
NativeArray
⁄⁄ !
<
⁄⁄! "
T
⁄⁄" #
>
⁄⁄# $
CreateNativeArray
⁄⁄% 6
<
⁄⁄6 7
T
⁄⁄7 8
>
⁄⁄8 9
(
⁄⁄9 :
T
⁄⁄: ;
[
⁄⁄; <
]
⁄⁄< =
array
⁄⁄> C
,
⁄⁄C D
AllocatorManager
⁄⁄E U
.
⁄⁄U V
AllocatorHandle
⁄⁄V e
	allocator
⁄⁄f o
)
⁄⁄o p
where
€€ 
T
€€ 
:
€€ 
struct
€€ 
{
‹‹ 	
NativeArray
›› 
<
›› 
T
›› 
>
›› 
nativeArray
›› &
;
››& '
if
ﬁﬁ 
(
ﬁﬁ 
!
ﬁﬁ 
AllocatorManager
ﬁﬁ !
.
ﬁﬁ! "
IsCustomAllocator
ﬁﬁ" 3
(
ﬁﬁ3 4
	allocator
ﬁﬁ4 =
)
ﬁﬁ= >
)
ﬁﬁ> ?
{
ﬂﬂ 
nativeArray
‡‡ 
=
‡‡ 
new
‡‡ !
NativeArray
‡‡" -
<
‡‡- .
T
‡‡. /
>
‡‡/ 0
(
‡‡0 1
array
‡‡1 6
,
‡‡6 7
	allocator
‡‡8 A
.
‡‡A B
ToAllocator
‡‡B M
)
‡‡M N
;
‡‡N O
}
·· 
else
‚‚ 
{
„„ 
nativeArray
‰‰ 
=
‰‰ 
new
‰‰ !
NativeArray
‰‰" -
<
‰‰- .
T
‰‰. /
>
‰‰/ 0
(
‰‰0 1
)
‰‰1 2
;
‰‰2 3
nativeArray
ÂÂ 
.
ÂÂ 

Initialize
ÂÂ &
(
ÂÂ& '
array
ÂÂ' ,
.
ÂÂ, -
Length
ÂÂ- 3
,
ÂÂ3 4
	allocator
ÂÂ5 >
)
ÂÂ> ?
;
ÂÂ? @
nativeArray
ÊÊ 
.
ÊÊ 
CopyFrom
ÊÊ $
(
ÊÊ$ %
array
ÊÊ% *
)
ÊÊ* +
;
ÊÊ+ ,
}
ÁÁ 
return
ËË 
nativeArray
ËË 
;
ËË 
}
ÈÈ 	
[
ÒÒ 	 
NotBurstCompatible
ÒÒ	 
]
ÒÒ 
public
ÚÚ 
static
ÚÚ 
NativeArray
ÚÚ !
<
ÚÚ! "
T
ÚÚ" #
>
ÚÚ# $
CreateNativeArray
ÚÚ% 6
<
ÚÚ6 7
T
ÚÚ7 8
,
ÚÚ8 9
U
ÚÚ: ;
>
ÚÚ; <
(
ÚÚ< =
T
ÚÚ= >
[
ÚÚ> ?
]
ÚÚ? @
array
ÚÚA F
,
ÚÚF G
ref
ÚÚH K
U
ÚÚL M
	allocator
ÚÚN W
)
ÚÚW X
where
ÛÛ 
T
ÛÛ 
:
ÛÛ 
struct
ÛÛ 
where
ÙÙ 
U
ÙÙ 
:
ÙÙ 
	unmanaged
ÙÙ 
,
ÙÙ  
AllocatorManager
ÙÙ! 1
.
ÙÙ1 2

IAllocator
ÙÙ2 <
{
ıı 	
NativeArray
ˆˆ 
<
ˆˆ 
T
ˆˆ 
>
ˆˆ 
nativeArray
ˆˆ &
;
ˆˆ& '
if
˜˜ 
(
˜˜ 
!
˜˜ 
	allocator
˜˜ 
.
˜˜ 
IsCustomAllocator
˜˜ ,
)
˜˜, -
{
¯¯ 
nativeArray
˘˘ 
=
˘˘ 
new
˘˘ !
NativeArray
˘˘" -
<
˘˘- .
T
˘˘. /
>
˘˘/ 0
(
˘˘0 1
array
˘˘1 6
,
˘˘6 7
	allocator
˘˘8 A
.
˘˘A B
ToAllocator
˘˘B M
)
˘˘M N
;
˘˘N O
}
˙˙ 
else
˚˚ 
{
¸¸ 
nativeArray
˝˝ 
=
˝˝ 
new
˝˝ !
NativeArray
˝˝" -
<
˝˝- .
T
˝˝. /
>
˝˝/ 0
(
˝˝0 1
)
˝˝1 2
;
˝˝2 3
nativeArray
˛˛ 
.
˛˛ 

Initialize
˛˛ &
(
˛˛& '
array
˛˛' ,
.
˛˛, -
Length
˛˛- 3
,
˛˛3 4
ref
˛˛5 8
	allocator
˛˛9 B
)
˛˛B C
;
˛˛C D
nativeArray
ˇˇ 
.
ˇˇ 
CopyFrom
ˇˇ $
(
ˇˇ$ %
array
ˇˇ% *
)
ˇˇ* +
;
ˇˇ+ ,
}
ÄÄ 
return
ÅÅ 
nativeArray
ÅÅ 
;
ÅÅ 
}
ÇÇ 	
[
ää 	
BurstCompatible
ää	 
(
ää "
GenericTypeArguments
ää -
=
ää. /
new
ää0 3
[
ää3 4
]
ää4 5
{
ää6 7
typeof
ää8 >
(
ää> ?
int
ää? B
)
ääB C
,
ääC D
typeof
ääE K
(
ääK L
int
ääL O
)
ääO P
,
ääP Q
typeof
ääR X
(
ääX Y
AllocatorManager
ääY i
.
ääi j
AllocatorHandle
ääj y
)
ääy z
}
ää{ |
)
ää| }
]
ää} ~
public
ãã 
static
ãã  
NativeMultiHashMap
ãã (
<
ãã( )
TKey
ãã) -
,
ãã- .
TValue
ãã/ 5
>
ãã5 6&
CreateNativeMultiHashMap
ãã7 O
<
ããO P
TKey
ããP T
,
ããT U
TValue
ããV \
,
ãã\ ]
U
ãã^ _
>
ãã_ `
(
ãã` a
int
ããa d
length
ããe k
,
ããk l
ref
ããm p
U
ããq r
	allocator
ããs |
)
ãã| }
where
åå 
TKey
åå 
:
åå 
struct
åå 
,
åå  

IEquatable
åå! +
<
åå+ ,
TKey
åå, 0
>
åå0 1
where
çç 
TValue
çç 
:
çç 
struct
çç !
where
éé 
U
éé 
:
éé 
	unmanaged
éé 
,
éé  
AllocatorManager
éé! 1
.
éé1 2

IAllocator
éé2 <
{
èè 	
var
êê  
nativeMultiHashMap
êê "
=
êê# $
new
êê% ( 
NativeMultiHashMap
êê) ;
<
êê; <
TKey
êê< @
,
êê@ A
TValue
êêB H
>
êêH I
(
êêI J
)
êêJ K
;
êêK L 
nativeMultiHashMap
ëë 
.
ëë 

Initialize
ëë )
(
ëë) *
length
ëë* 0
,
ëë0 1
ref
ëë2 5
	allocator
ëë6 ?
)
ëë? @
;
ëë@ A
return
íí  
nativeMultiHashMap
íí %
;
íí% &
}
ìì 	
[
ññ 	
BurstCompatible
ññ	 
(
ññ !
RequiredUnityDefine
ññ ,
=
ññ- .
$str
ññ/ P
)
ññP Q
]
ññQ R
internal
óó 
static
óó  
AtomicSafetyHandle
óó * 
CreateSafetyHandle
óó+ =
(
óó= >
AllocatorManager
óó> N
.
óóN O
AllocatorHandle
óóO ^
	allocator
óó_ h
)
óóh i
{
òò 	
if
ôô 
(
ôô 
	allocator
ôô 
.
ôô 
IsCustomAllocator
ôô +
)
ôô+ ,
{
öö 
return
õõ  
AtomicSafetyHandle
õõ )
.
õõ) *
Create
õõ* 0
(
õõ0 1
)
õõ1 2
;
õõ2 3
}
úú 
return
ûû 
(
ûû 
	allocator
ûû 
.
ûû 
ToAllocator
ûû )
==
ûû* ,
	Allocator
ûû- 6
.
ûû6 7
Temp
ûû7 ;
)
ûû; <
?
ûû= > 
AtomicSafetyHandle
ûû? Q
.
ûûQ R!
GetTempMemoryHandle
ûûR e
(
ûûe f
)
ûûf g
:
ûûh i 
AtomicSafetyHandle
ûûj |
.
ûû| }
Createûû} É
(ûûÉ Ñ
)ûûÑ Ö
;ûûÖ Ü
}
üü 	
[
°° 	
BurstCompatible
°°	 
(
°° !
RequiredUnityDefine
°° ,
=
°°- .
$str
°°/ P
)
°°P Q
]
°°Q R
internal
¢¢ 
static
¢¢ 
void
¢¢ !
DisposeSafetyHandle
¢¢ 0
(
¢¢0 1
ref
¢¢1 4 
AtomicSafetyHandle
¢¢5 G
safety
¢¢H N
)
¢¢N O
{
££ 	 
AtomicSafetyHandle
§§ 
.
§§ %
CheckDeallocateAndThrow
§§ 6
(
§§6 7
safety
§§7 =
)
§§= >
;
§§> ?
if
ßß 
(
ßß  
AtomicSafetyHandle
ßß "
.
ßß" # 
IsTempMemoryHandle
ßß# 5
(
ßß5 6
safety
ßß6 <
)
ßß< =
)
ßß= >
{
®® 
int
©© 
staticSafetyId
©© "
=
©©# $
safety
©©% +
.
©©+ ,
staticSafetyId
©©, :
;
©©: ;
safety
™™ 
=
™™  
AtomicSafetyHandle
™™ +
.
™™+ ,
Create
™™, 2
(
™™2 3
)
™™3 4
;
™™4 5
safety
´´ 
.
´´ 
staticSafetyId
´´ %
=
´´& '
staticSafetyId
´´( 6
;
´´6 7
}
¨¨  
AtomicSafetyHandle
≠≠ 
.
≠≠ 
Release
≠≠ &
(
≠≠& '
safety
≠≠' -
)
≠≠- .
;
≠≠. /
}
ÆÆ 	
static
∞∞ 
unsafe
∞∞ 
void
∞∞ *
CreateStaticSafetyIdInternal
∞∞ 7
(
∞∞7 8
ref
∞∞8 ;
int
∞∞< ?
id
∞∞@ B
,
∞∞B C
in
∞∞D F!
FixedString512Bytes
∞∞G Z
name
∞∞[ _
)
∞∞_ `
{
±± 	
id
≤≤ 
=
≤≤  
AtomicSafetyHandle
≤≤ #
.
≤≤# $
NewStaticSafetyId
≤≤$ 5
(
≤≤5 6
name
≤≤6 :
.
≤≤: ;
GetUnsafePtr
≤≤; G
(
≤≤G H
)
≤≤H I
,
≤≤I J
name
≤≤K O
.
≤≤O P
Length
≤≤P V
)
≤≤V W
;
≤≤W X
}
≥≥ 	
[
µµ 	
BurstDiscard
µµ	 
]
µµ 
static
∂∂ 
void
∂∂ *
CreateStaticSafetyIdInternal
∂∂ 0
<
∂∂0 1
T
∂∂1 2
>
∂∂2 3
(
∂∂3 4
ref
∂∂4 7
int
∂∂8 ;
id
∂∂< >
)
∂∂> ?
{
∑∑ 	*
CreateStaticSafetyIdInternal
∏∏ (
(
∏∏( )
ref
∏∏) ,
id
∏∏- /
,
∏∏/ 0
typeof
∏∏1 7
(
∏∏7 8
T
∏∏8 9
)
∏∏9 :
.
∏∏: ;
ToString
∏∏; C
(
∏∏C D
)
∏∏D E
)
∏∏E F
;
∏∏F G
}
ππ 	
[
¡¡ 	
BurstCompatible
¡¡	 
(
¡¡ !
RequiredUnityDefine
¡¡ ,
=
¡¡- .
$str
¡¡/ P
,
¡¡P Q"
GenericTypeArguments
¡¡R f
=
¡¡g h
new
¡¡i l
[
¡¡l m
]
¡¡m n
{
¡¡o p
typeof
¡¡q w
(
¡¡w x
NativeArray¡¡x É
<¡¡É Ñ
int¡¡Ñ á
>¡¡á à
)¡¡à â
}¡¡ä ã
)¡¡ã å
]¡¡å ç
public
¬¬ 
static
¬¬ 
void
¬¬ 
SetStaticSafetyId
¬¬ ,
<
¬¬, -
T
¬¬- .
>
¬¬. /
(
¬¬/ 0
ref
¬¬0 3 
AtomicSafetyHandle
¬¬4 F
handle
¬¬G M
,
¬¬M N
ref
¬¬O R
int
¬¬S V
sharedStaticId
¬¬W e
)
¬¬e f
{
√√ 	
if
ƒƒ 
(
ƒƒ 
sharedStaticId
ƒƒ 
==
ƒƒ !
$num
ƒƒ" #
)
ƒƒ# $
{
≈≈ *
CreateStaticSafetyIdInternal
   ,
<
  , -
T
  - .
>
  . /
(
  / 0
ref
  0 3
sharedStaticId
  4 B
)
  B C
;
  C D
}
ÀÀ  
AtomicSafetyHandle
ÕÕ 
.
ÕÕ 
SetStaticSafetyId
ÕÕ 0
(
ÕÕ0 1
ref
ÕÕ1 4
handle
ÕÕ5 ;
,
ÕÕ; <
sharedStaticId
ÕÕ= K
)
ÕÕK L
;
ÕÕL M
}
ŒŒ 	
[
÷÷ 	
BurstCompatible
÷÷	 
(
÷÷ !
RequiredUnityDefine
÷÷ ,
=
÷÷- .
$str
÷÷/ P
)
÷÷P Q
]
÷÷Q R
public
◊◊ 
static
◊◊ 
unsafe
◊◊ 
void
◊◊ !
SetStaticSafetyId
◊◊" 3
(
◊◊3 4
ref
◊◊4 7 
AtomicSafetyHandle
◊◊8 J
handle
◊◊K Q
,
◊◊Q R
ref
◊◊S V
int
◊◊W Z
sharedStaticId
◊◊[ i
,
◊◊i j!
FixedString512Bytes
◊◊k ~
name◊◊ É
)◊◊É Ñ
{
ÿÿ 	
if
ŸŸ 
(
ŸŸ 
sharedStaticId
ŸŸ 
==
ŸŸ !
$num
ŸŸ" #
)
ŸŸ# $
{
⁄⁄ *
CreateStaticSafetyIdInternal
€€ ,
(
€€, -
ref
€€- 0
sharedStaticId
€€1 ?
,
€€? @
name
€€A E
)
€€E F
;
€€F G
}
‹‹  
AtomicSafetyHandle
ﬁﬁ 
.
ﬁﬁ 
SetStaticSafetyId
ﬁﬁ 0
(
ﬁﬁ0 1
ref
ﬁﬁ1 4
handle
ﬁﬁ5 ;
,
ﬁﬁ; <
sharedStaticId
ﬁﬁ= K
)
ﬁﬁK L
;
ﬁﬁL M
}
ﬂﬂ 	
}
·· 
}‚‚ ™K
gC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\FixedStringUtils.cs
	namespace 	
Unity
 
. 
Collections 
{ 
public 

	interface 

IUTF8Bytes 
{ 
bool 
IsEmpty 
{ 
get 
; 
} 
unsafe 
byte 
* 
GetUnsafePtr !
(! "
)" #
;# $
bool   
	TryResize   
(   
int   
	newLength   $
,  $ %
NativeArrayOptions  & 8
clearOptions  9 E
=  F G
NativeArrayOptions  H Z
.  Z [
ClearMemory  [ f
)  f g
;  g h
}!! 
[## 
BurstCompatible## 
]## 
internal$$ 
unsafe$$ 
static$$ 
class$$  
FixedStringUtils$$! 1
{%% 
[&& 	
StructLayout&&	 
(&& 

LayoutKind&&  
.&&  !
Explicit&&! )
)&&) *
]&&* +
internal'' 
struct'' 
UintFloatUnion'' &
{(( 	
[)) 
FieldOffset)) 
()) 
$num)) 
))) 
])) 
public** 
uint** 
	uintValue** !
;**! "
[++ 
FieldOffset++ 
(++ 
$num++ 
)++ 
]++ 
public,, 
float,, 

floatValue,, #
;,,# $
}-- 	
internal// 
static// 

ParseError// "
Base10ToBase2//# 0
(//0 1
ref//1 4
float//5 :
output//; A
,//A B
ulong//C H

mantissa10//I S
,//S T
int//U X

exponent10//Y c
)//c d
{00 	
if11 
(11 

mantissa1011 
==11 
$num11 
)11  
{22 
output33 
=33 
$num33 
;33 
return44 

ParseError44 !
.44! "
None44" &
;44& '
}55 
if66 
(66 

exponent1066 
==66 
$num66 
)66  
{77 
output88 
=88 

mantissa1088 #
;88# $
return99 

ParseError99 !
.99! "
None99" &
;99& '
}:: 
var;; 
	exponent2;; 
=;; 

exponent10;; &
;;;& '
var<< 
	mantissa2<< 
=<< 

mantissa10<< &
;<<& '
while== 
(== 

exponent10== 
>== 
$num==  !
)==! "
{>> 
while?? 
(?? 
(?? 
	mantissa2?? !
&??" #
$num??$ 7
)??7 8
!=??9 ;
$num??< =
)??= >
{@@ 
	mantissa2AA 
>>=AA !
$numAA" #
;AA# $
++BB 
	exponent2BB 
;BB  
}CC 
	mantissa2DD 
*=DD 
$numDD 
;DD 
--EE 

exponent10EE 
;EE 
}FF 
whileGG 
(GG 

exponent10GG 
<GG 
$numGG  !
)GG! "
{HH 
whileII 
(II 
(II 
	mantissa2II !
&II" #
$numII$ 7
)II7 8
==II9 ;
$numII< =
)II= >
{JJ 
	mantissa2KK 
<<=KK !
$numKK" #
;KK# $
--LL 
	exponent2LL 
;LL  
}MM 
	mantissa2NN 
/=NN 
$numNN 
;NN 
++OO 

exponent10OO 
;OO 
}PP 
UintFloatUnionRR 
ufuRR 
=RR  
newRR! $
UintFloatUnionRR% 3
(RR3 4
)RR4 5
;RR5 6
ufuSS 
.SS 

floatValueSS 
=SS 
	mantissa2SS &
;SS& '
varTT 
eTT 
=TT 
(TT 
intTT 
)TT 
(TT 
(TT 
ufuTT 
.TT 
	uintValueTT (
>>TT) +
$numTT, .
)TT. /
&TT0 1
$numTT2 7
)TT7 8
-TT9 :
$numTT; >
;TT> ?
eUU 
+=UU 
	exponent2UU 
;UU 
ifVV 
(VV 
eVV 
>VV 
$numVV 
)VV 
returnWW 

ParseErrorWW !
.WW! "
OverflowWW" *
;WW* +
ifXX 
(XX 
eXX 
<XX 
-XX 
$numXX 
)XX 
returnYY 

ParseErrorYY !
.YY! "
	UnderflowYY" +
;YY+ ,
ufuZZ 
.ZZ 
	uintValueZZ 
=ZZ 
(ZZ 
ufuZZ  
.ZZ  !
	uintValueZZ! *
&ZZ+ ,
~ZZ- .
(ZZ. /
$numZZ/ 4
<<ZZ5 7
$numZZ8 :
)ZZ: ;
)ZZ; <
|ZZ= >
(ZZ? @
(ZZ@ A
uintZZA E
)ZZE F
(ZZF G
eZZG H
+ZZI J
$numZZK N
)ZZN O
<<ZZP R
$numZZS U
)ZZU V
;ZZV W
output[[ 
=[[ 
ufu[[ 
.[[ 

floatValue[[ #
;[[# $
return\\ 

ParseError\\ 
.\\ 
None\\ "
;\\" #
}]] 	
internal__ 
static__ 
void__ 
Base2ToBase10__ *
(__* +
ref__+ .
ulong__/ 4

mantissa10__5 ?
,__? @
ref__A D
int__E H

exponent10__I S
,__S T
float__U Z
input__[ `
)__` a
{`` 	
UintFloatUnionaa 
ufuaa 
=aa  
newaa! $
UintFloatUnionaa% 3
(aa3 4
)aa4 5
;aa5 6
ufubb 
.bb 

floatValuebb 
=bb 
inputbb "
;bb" #
ifcc 
(cc 
ufucc 
.cc 
	uintValuecc 
==cc  
$numcc! "
)cc" #
{dd 

mantissa10ee 
=ee 
$numee 
;ee 

exponent10ff 
=ff 
$numff 
;ff 
returngg 
;gg 
}hh 
varii 
	mantissa2ii 
=ii 
(ii 
ufuii  
.ii  !
	uintValueii! *
&ii+ ,
(ii- .
(ii. /
$numii/ 0
<<ii1 3
$numii4 6
)ii6 7
-ii8 9
$numii: ;
)ii; <
)ii< =
|ii> ?
(ii@ A
$numiiA B
<<iiC E
$numiiF H
)iiH I
;iiI J
varjj 
	exponent2jj 
=jj 
(jj 
intjj  
)jj  !
(jj! "
ufujj" %
.jj% &
	uintValuejj& /
>>jj0 2
$numjj3 5
)jj5 6
-jj7 8
$numjj9 <
-jj= >
$numjj? A
;jjA B

mantissa10kk 
=kk 
	mantissa2kk "
;kk" #

exponent10ll 
=ll 
	exponent2ll "
;ll" #
ifmm 
(mm 
	exponent2mm 
>mm 
$nummm 
)mm 
{nn 
whileoo 
(oo 
	exponent2oo  
>oo! "
$numoo# $
)oo$ %
{pp 
whilerr 
(rr 

mantissa10rr %
<=rr& (
UInt64rr) /
.rr/ 0
MaxValuerr0 8
/rr9 :
$numrr; =
)rr= >
{ss 

mantissa10tt "
*=tt# %
$numtt& (
;tt( )
--uu 

exponent10uu $
;uu$ %
}vv 

mantissa10ww 
/=ww !
$numww" #
;ww# $
--xx 
	exponent2xx 
;xx  
}yy 
}zz 
if{{ 
({{ 
	exponent2{{ 
<{{ 
$num{{ 
){{ 
{|| 
while}} 
(}} 
	exponent2}}  
<}}! "
$num}}# $
)}}$ %
{~~ 
while
ÄÄ 
(
ÄÄ 

mantissa10
ÄÄ %
>
ÄÄ& '
UInt64
ÄÄ( .
.
ÄÄ. /
MaxValue
ÄÄ/ 7
/
ÄÄ8 9
$num
ÄÄ: ;
)
ÄÄ; <
{
ÅÅ 

mantissa10
ÇÇ "
/=
ÇÇ# %
$num
ÇÇ& (
;
ÇÇ( )
++
ÉÉ 

exponent10
ÉÉ $
;
ÉÉ$ %
}
ÑÑ 

mantissa10
ÖÖ 
*=
ÖÖ !
$num
ÖÖ" #
;
ÖÖ# $
++
ÜÜ 
	exponent2
ÜÜ 
;
ÜÜ  
}
áá 
}
àà 
while
ää 
(
ää 

mantissa10
ää 
>
ää 
$num
ää  (
||
ää) +

mantissa10
ää, 6
%
ää7 8
$num
ää9 ;
==
ää< >
$num
ää? @
)
ää@ A
{
ãã 

mantissa10
åå 
=
åå 
(
åå 

mantissa10
åå (
+
åå) *
(
åå+ ,

mantissa10
åå, 6
<
åå7 8
$num
åå9 C
?
ååD E
$num
ååF H
:
ååI J
$num
ååK M
)
ååM N
)
ååN O
/
ååP Q
$num
ååR T
;
ååT U
++
çç 

exponent10
çç 
;
çç 
}
éé 
}
èè 	
}
êê 
}ëë öÁ
iC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeMultiHashMap.cs
	namespace		 	
Unity		
 
.		 
Collections		 
.		 
LowLevel		 $
.		$ %
Unsafe		% +
{

 
[ 
StructLayout 
( 

LayoutKind 
. 

Sequential '
)' (
]( )
[ 
DebuggerTypeProxy 
( 
typeof 
( /
#UnsafeMultiHashMapDebuggerTypeProxy A
<A B
,B C
>C D
)D E
)E F
]F G
[ 
BurstCompatible 
(  
GenericTypeArguments )
=* +
new, /
[0 1
]1 2
{3 4
typeof5 ;
(; <
int< ?
)? @
,@ A
typeofB H
(H I
intI L
)L M
}N O
)O P
]P Q
public 

unsafe 
struct 
UnsafeMultiHashMap +
<+ ,
TKey, 0
,0 1
TValue2 8
>8 9
: 	
INativeDisposable
 
, 	
IEnumerable
 
< 
KeyValue 
< 
TKey #
,# $
TValue% +
>+ ,
>, -
where 
TKey 
: 
struct 
, 

IEquatable '
<' (
TKey( ,
>, -
where 
TValue 
: 
struct 
{ 
[ 	-
!NativeDisableUnsafePtrRestriction	 *
]* +
internal 
UnsafeHashMapData "
*" #
m_Buffer$ ,
;, -
internal   
AllocatorManager   !
.  ! "
AllocatorHandle  " 1
m_AllocatorLabel  2 B
;  B C
public'' 
UnsafeMultiHashMap'' !
(''! "
int''" %
capacity''& .
,''. /
AllocatorManager''0 @
.''@ A
AllocatorHandle''A P
	allocator''Q Z
)''Z [
{(( 	
m_AllocatorLabel)) 
=)) 
	allocator)) (
;))( )
UnsafeHashMapData++ 
.++ 
AllocateHashMap++ -
<++- .
TKey++. 2
,++2 3
TValue++4 :
>++: ;
(++; <
capacity++< D
,++D E
capacity++F N
*++O P
$num++Q R
,++R S
	allocator++T ]
,++] ^
out++_ b
m_Buffer++c k
)++k l
;++l m
Clear,, 
(,, 
),, 
;,, 
}-- 	
public33 
bool33 
IsEmpty33 
=>33 
!33  
	IsCreated33  )
||33* ,
UnsafeHashMapData33- >
.33> ?
IsEmpty33? F
(33F G
m_Buffer33G O
)33O P
;33P Q
public:: 
int:: 
Count:: 
(:: 
):: 
{;; 	
if<< 
(<< 
m_Buffer<< 
-><<  
allocatedIndexLength<< .
<=<</ 1
$num<<2 3
)<<3 4
{== 
return>> 
$num>> 
;>> 
}?? 
returnAA 
UnsafeHashMapDataAA $
.AA$ %
GetCountAA% -
(AA- .
m_BufferAA. 6
)AA6 7
;AA7 8
}BB 	
publicJJ 
intJJ 
CapacityJJ 
{KK 	
getLL 
{MM 
UnsafeHashMapDataNN !
*NN! "
dataNN# '
=NN( )
m_BufferNN* 2
;NN2 3
returnOO 
dataOO 
->OO 
keyCapacityOO (
;OO( )
}PP 
setRR 
{SS 
UnsafeHashMapDataTT !
*TT! "
dataTT# '
=TT( )
m_BufferTT* 2
;TT2 3
UnsafeHashMapDataUU !
.UU! "
ReallocateHashMapUU" 3
<UU3 4
TKeyUU4 8
,UU8 9
TValueUU: @
>UU@ A
(UUA B
dataUUB F
,UUF G
valueUUH M
,UUM N
UnsafeHashMapDataUUO `
.UU` a
GetBucketSizeUUa n
(UUn o
valueUUo t
)UUt u
,UUu v
m_AllocatorLabel	UUw á
)
UUá à
;
UUà â
}VV 
}WW 	
public]] 
void]] 
Clear]] 
(]] 
)]] 
{^^ 	
UnsafeHashMapBase__ 
<__ 
TKey__ "
,__" #
TValue__$ *
>__* +
.__+ ,
Clear__, 1
(__1 2
m_Buffer__2 :
)__: ;
;__; <
}`` 	
publicjj 
voidjj 
Addjj 
(jj 
TKeyjj 
keyjj  
,jj  !
TValuejj" (
itemjj) -
)jj- .
{kk 	
UnsafeHashMapBasell 
<ll 
TKeyll "
,ll" #
TValuell$ *
>ll* +
.ll+ ,
TryAddll, 2
(ll2 3
m_Bufferll3 ;
,ll; <
keyll= @
,ll@ A
itemllB F
,llF G
truellH L
,llL M
m_AllocatorLabelllN ^
)ll^ _
;ll_ `
}mm 	
publictt 
inttt 
Removett 
(tt 
TKeytt 
keytt "
)tt" #
{uu 	
returnvv 
UnsafeHashMapBasevv $
<vv$ %
TKeyvv% )
,vv) *
TValuevv+ 1
>vv1 2
.vv2 3
Removevv3 9
(vv9 :
m_Buffervv: B
,vvB C
keyvvD G
,vvG H
truevvI M
)vvM N
;vvN O
}ww 	
[
ÅÅ 	
BurstCompatible
ÅÅ	 
(
ÅÅ "
GenericTypeArguments
ÅÅ -
=
ÅÅ. /
new
ÅÅ0 3
[
ÅÅ4 5
]
ÅÅ5 6
{
ÅÅ7 8
typeof
ÅÅ9 ?
(
ÅÅ? @
int
ÅÅ@ C
)
ÅÅC D
}
ÅÅE F
)
ÅÅF G
]
ÅÅG H
public
ÇÇ 
void
ÇÇ 
Remove
ÇÇ 
<
ÇÇ 
TValueEQ
ÇÇ #
>
ÇÇ# $
(
ÇÇ$ %
TKey
ÇÇ% )
key
ÇÇ* -
,
ÇÇ- .
TValueEQ
ÇÇ/ 7
value
ÇÇ8 =
)
ÇÇ= >
where
ÉÉ 
TValueEQ
ÉÉ 
:
ÉÉ 
struct
ÉÉ #
,
ÉÉ# $

IEquatable
ÉÉ% /
<
ÉÉ/ 0
TValueEQ
ÉÉ0 8
>
ÉÉ8 9
{
ÑÑ 	
UnsafeHashMapBase
ÖÖ 
<
ÖÖ 
TKey
ÖÖ "
,
ÖÖ" #
TValueEQ
ÖÖ$ ,
>
ÖÖ, -
.
ÖÖ- .
RemoveKeyValue
ÖÖ. <
(
ÖÖ< =
m_Buffer
ÖÖ= E
,
ÖÖE F
key
ÖÖG J
,
ÖÖJ K
value
ÖÖL Q
)
ÖÖQ R
;
ÖÖR S
}
ÜÜ 	
public
çç 
void
çç 
Remove
çç 
(
çç (
NativeMultiHashMapIterator
çç 5
<
çç5 6
TKey
çç6 :
>
çç: ;
it
çç< >
)
çç> ?
{
éé 	
UnsafeHashMapBase
èè 
<
èè 
TKey
èè "
,
èè" #
TValue
èè$ *
>
èè* +
.
èè+ ,
Remove
èè, 2
(
èè2 3
m_Buffer
èè3 ;
,
èè; <
it
èè= ?
)
èè? @
;
èè@ A
}
êê 	
public
ôô 
bool
ôô 
TryGetFirstValue
ôô $
(
ôô$ %
TKey
ôô% )
key
ôô* -
,
ôô- .
out
ôô/ 2
TValue
ôô3 9
item
ôô: >
,
ôô> ?
out
ôô@ C(
NativeMultiHashMapIterator
ôôD ^
<
ôô^ _
TKey
ôô_ c
>
ôôc d
it
ôôe g
)
ôôg h
{
öö 	
return
õõ 
UnsafeHashMapBase
õõ $
<
õõ$ %
TKey
õõ% )
,
õõ) *
TValue
õõ+ 1
>
õõ1 2
.
õõ2 3$
TryGetFirstValueAtomic
õõ3 I
(
õõI J
m_Buffer
õõJ R
,
õõR S
key
õõT W
,
õõW X
out
õõY \
item
õõ] a
,
õõa b
out
õõc f
it
õõg i
)
õõi j
;
õõj k
}
úú 	
public
§§ 
bool
§§ 
TryGetNextValue
§§ #
(
§§# $
out
§§$ '
TValue
§§( .
item
§§/ 3
,
§§3 4
ref
§§5 8(
NativeMultiHashMapIterator
§§9 S
<
§§S T
TKey
§§T X
>
§§X Y
it
§§Z \
)
§§\ ]
{
•• 	
return
¶¶ 
UnsafeHashMapBase
¶¶ $
<
¶¶$ %
TKey
¶¶% )
,
¶¶) *
TValue
¶¶+ 1
>
¶¶1 2
.
¶¶2 3#
TryGetNextValueAtomic
¶¶3 H
(
¶¶H I
m_Buffer
¶¶I Q
,
¶¶Q R
out
¶¶S V
item
¶¶W [
,
¶¶[ \
ref
¶¶] `
it
¶¶a c
)
¶¶c d
;
¶¶d e
}
ßß 	
public
ÆÆ 
bool
ÆÆ 
ContainsKey
ÆÆ 
(
ÆÆ  
TKey
ÆÆ  $
key
ÆÆ% (
)
ÆÆ( )
{
ØØ 	
return
∞∞ 
TryGetFirstValue
∞∞ #
(
∞∞# $
key
∞∞$ '
,
∞∞' (
out
∞∞) ,
var
∞∞- 0
temp0
∞∞1 6
,
∞∞6 7
out
∞∞8 ;
var
∞∞< ?
temp1
∞∞@ E
)
∞∞E F
;
∞∞F G
}
±± 	
public
∏∏ 
int
∏∏ 
CountValuesForKey
∏∏ $
(
∏∏$ %
TKey
∏∏% )
key
∏∏* -
)
∏∏- .
{
ππ 	
if
∫∫ 
(
∫∫ 
!
∫∫ 
TryGetFirstValue
∫∫ !
(
∫∫! "
key
∫∫" %
,
∫∫% &
out
∫∫' *
var
∫∫+ .
value
∫∫/ 4
,
∫∫4 5
out
∫∫6 9
var
∫∫: =
iterator
∫∫> F
)
∫∫F G
)
∫∫G H
{
ªª 
return
ºº 
$num
ºº 
;
ºº 
}
ΩΩ 
var
øø 
count
øø 
=
øø 
$num
øø 
;
øø 
while
¿¿ 
(
¿¿ 
TryGetNextValue
¿¿ "
(
¿¿" #
out
¿¿# &
value
¿¿' ,
,
¿¿, -
ref
¿¿. 1
iterator
¿¿2 :
)
¿¿: ;
)
¿¿; <
{
¡¡ 
count
¬¬ 
++
¬¬ 
;
¬¬ 
}
√√ 
return
≈≈ 
count
≈≈ 
;
≈≈ 
}
∆∆ 	
public
ŒŒ 
bool
ŒŒ 
SetValue
ŒŒ 
(
ŒŒ 
TValue
ŒŒ #
item
ŒŒ$ (
,
ŒŒ( )(
NativeMultiHashMapIterator
ŒŒ* D
<
ŒŒD E
TKey
ŒŒE I
>
ŒŒI J
it
ŒŒK M
)
ŒŒM N
{
œœ 	
return
–– 
UnsafeHashMapBase
–– $
<
––$ %
TKey
––% )
,
––) *
TValue
––+ 1
>
––1 2
.
––2 3
SetValue
––3 ;
(
––; <
m_Buffer
––< D
,
––D E
ref
––F I
it
––J L
,
––L M
ref
––N Q
item
––R V
)
––V W
;
––W X
}
—— 	
public
◊◊ 
bool
◊◊ 
	IsCreated
◊◊ 
=>
◊◊  
m_Buffer
◊◊! )
!=
◊◊* ,
null
◊◊- 1
;
◊◊1 2
public
‹‹ 
void
‹‹ 
Dispose
‹‹ 
(
‹‹ 
)
‹‹ 
{
›› 	
UnsafeHashMapData
ﬁﬁ 
.
ﬁﬁ 
DeallocateHashMap
ﬁﬁ /
(
ﬁﬁ/ 0
m_Buffer
ﬁﬁ0 8
,
ﬁﬁ8 9
m_AllocatorLabel
ﬁﬁ: J
)
ﬁﬁJ K
;
ﬁﬁK L
m_Buffer
ﬂﬂ 
=
ﬂﬂ 
null
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 	
[
ÁÁ 	 
NotBurstCompatible
ÁÁ	 
]ÁÁú ù
public
ËË 
	JobHandle
ËË 
Dispose
ËË  
(
ËË  !
	JobHandle
ËË! *
	inputDeps
ËË+ 4
)
ËË4 5
{
ÈÈ 	
var
ÍÍ 
	jobHandle
ÍÍ 
=
ÍÍ 
new
ÍÍ %
UnsafeHashMapDisposeJob
ÍÍ  7
{
ÍÍ8 9
Data
ÍÍ: >
=
ÍÍ? @
m_Buffer
ÍÍA I
,
ÍÍI J
	Allocator
ÍÍK T
=
ÍÍU V
m_AllocatorLabel
ÍÍW g
}
ÍÍh i
.
ÍÍi j
Schedule
ÍÍj r
(
ÍÍr s
	inputDeps
ÍÍs |
)
ÍÍ| }
;
ÍÍ} ~
m_Buffer
ÎÎ 
=
ÎÎ 
null
ÎÎ 
;
ÎÎ 
return
ÏÏ 
	jobHandle
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
public
˜˜ 
NativeArray
˜˜ 
<
˜˜ 
TKey
˜˜ 
>
˜˜  
GetKeyArray
˜˜! ,
(
˜˜, -
AllocatorManager
˜˜- =
.
˜˜= >
AllocatorHandle
˜˜> M
	allocator
˜˜N W
)
˜˜W X
{
¯¯ 	
var
˘˘ 
result
˘˘ 
=
˘˘ 
CollectionHelper
˘˘ )
.
˘˘) *
CreateNativeArray
˘˘* ;
<
˘˘; <
TKey
˘˘< @
>
˘˘@ A
(
˘˘A B
Count
˘˘B G
(
˘˘G H
)
˘˘H I
,
˘˘I J
	allocator
˘˘K T
,
˘˘T U 
NativeArrayOptions
˘˘V h
.
˘˘h i!
UninitializedMemory
˘˘i |
)
˘˘| }
;
˘˘} ~
UnsafeHashMapData
˙˙ 
.
˙˙ 
GetKeyArray
˙˙ )
(
˙˙) *
m_Buffer
˙˙* 2
,
˙˙2 3
result
˙˙4 :
)
˙˙: ;
;
˙˙; <
return
˚˚ 
result
˚˚ 
;
˚˚ 
}
¸¸ 	
public
ÖÖ 
NativeArray
ÖÖ 
<
ÖÖ 
TValue
ÖÖ !
>
ÖÖ! "
GetValueArray
ÖÖ# 0
(
ÖÖ0 1
AllocatorManager
ÖÖ1 A
.
ÖÖA B
AllocatorHandle
ÖÖB Q
	allocator
ÖÖR [
)
ÖÖ[ \
{
ÜÜ 	
var
áá 
result
áá 
=
áá 
CollectionHelper
áá )
.
áá) *
CreateNativeArray
áá* ;
<
áá; <
TValue
áá< B
>
ááB C
(
ááC D
Count
ááD I
(
ááI J
)
ááJ K
,
ááK L
	allocator
ááM V
,
ááV W 
NativeArrayOptions
ááX j
.
ááj k!
UninitializedMemory
áák ~
)
áá~ 
;áá Ä
UnsafeHashMapData
àà 
.
àà 
GetValueArray
àà +
(
àà+ ,
m_Buffer
àà, 4
,
àà4 5
result
àà6 <
)
àà< =
;
àà= >
return
ââ 
result
ââ 
;
ââ 
}
ää 	
public
ìì "
NativeKeyValueArrays
ìì #
<
ìì# $
TKey
ìì$ (
,
ìì( )
TValue
ìì* 0
>
ìì0 1
GetKeyValueArrays
ìì2 C
(
ììC D
AllocatorManager
ììD T
.
ììT U
AllocatorHandle
ììU d
	allocator
ììe n
)
ììn o
{
îî 	
var
ïï 
result
ïï 
=
ïï 
new
ïï "
NativeKeyValueArrays
ïï 1
<
ïï1 2
TKey
ïï2 6
,
ïï6 7
TValue
ïï8 >
>
ïï> ?
(
ïï? @
Count
ïï@ E
(
ïïE F
)
ïïF G
,
ïïG H
	allocator
ïïI R
,
ïïR S 
NativeArrayOptions
ïïT f
.
ïïf g!
UninitializedMemory
ïïg z
)
ïïz {
;
ïï{ |
UnsafeHashMapData
ññ 
.
ññ 
GetKeyValueArrays
ññ /
(
ññ/ 0
m_Buffer
ññ0 8
,
ññ8 9
result
ññ: @
)
ññ@ A
;
ññA B
return
óó 
result
óó 
;
óó 
}
òò 	
public
üü 

Enumerator
üü 
GetValuesForKey
üü )
(
üü) *
TKey
üü* .
key
üü/ 2
)
üü2 3
{
†† 	
return
°° 
new
°° 

Enumerator
°° !
{
°°" #
hashmap
°°$ +
=
°°, -
this
°°. 2
,
°°2 3
key
°°4 7
=
°°8 9
key
°°: =
,
°°= >
isFirst
°°? F
=
°°G H
true
°°I M
}
°°N O
;
°°O P
}
¢¢ 	
public
´´ 
struct
´´ 

Enumerator
´´  
:
´´! "
IEnumerator
´´# .
<
´´. /
TValue
´´/ 5
>
´´5 6
{
¨¨ 	
internal
≠≠  
UnsafeMultiHashMap
≠≠ '
<
≠≠' (
TKey
≠≠( ,
,
≠≠, -
TValue
≠≠. 4
>
≠≠4 5
hashmap
≠≠6 =
;
≠≠= >
internal
ÆÆ 
TKey
ÆÆ 
key
ÆÆ 
;
ÆÆ 
internal
ØØ 
bool
ØØ 
isFirst
ØØ !
;
ØØ! "
TValue
±± 
value
±± 
;
±± (
NativeMultiHashMapIterator
≤≤ &
<
≤≤& '
TKey
≤≤' +
>
≤≤+ ,
iterator
≤≤- 5
;
≤≤5 6
public
∑∑ 
void
∑∑ 
Dispose
∑∑ 
(
∑∑  
)
∑∑  !
{
∑∑" #
}
∑∑$ %
public
ΩΩ 
bool
ΩΩ 
MoveNext
ΩΩ  
(
ΩΩ  !
)
ΩΩ! "
{
ææ 
if
¿¿ 
(
¿¿ 
isFirst
¿¿ 
)
¿¿ 
{
¡¡ 
isFirst
¬¬ 
=
¬¬ 
false
¬¬ #
;
¬¬# $
return
√√ 
hashmap
√√ "
.
√√" #
TryGetFirstValue
√√# 3
(
√√3 4
key
√√4 7
,
√√7 8
out
√√9 <
value
√√= B
,
√√B C
out
√√D G
iterator
√√H P
)
√√P Q
;
√√Q R
}
ƒƒ 
return
∆∆ 
hashmap
∆∆ 
.
∆∆ 
TryGetNextValue
∆∆ .
(
∆∆. /
out
∆∆/ 2
value
∆∆3 8
,
∆∆8 9
ref
∆∆: =
iterator
∆∆> F
)
∆∆F G
;
∆∆G H
}
«« 
public
ÃÃ 
void
ÃÃ 
Reset
ÃÃ 
(
ÃÃ 
)
ÃÃ 
=>
ÃÃ  "
isFirst
ÃÃ# *
=
ÃÃ+ ,
true
ÃÃ- 1
;
ÃÃ1 2
public
““ 
TValue
““ 
Current
““ !
=>
““" $
value
““% *
;
““* +
object
‘‘ 
IEnumerator
‘‘ 
.
‘‘ 
Current
‘‘ &
=>
‘‘' )
Current
‘‘* 1
;
‘‘1 2
public
⁄⁄ 

Enumerator
⁄⁄ 
GetEnumerator
⁄⁄ +
(
⁄⁄+ ,
)
⁄⁄, -
{
⁄⁄. /
return
⁄⁄0 6
this
⁄⁄7 ;
;
⁄⁄; <
}
⁄⁄= >
}
€€ 	
public
·· 
ParallelWriter
·· 
AsParallelWriter
·· .
(
··. /
)
··/ 0
{
‚‚ 	
ParallelWriter
„„ 
writer
„„ !
;
„„! "
writer
ËË 
.
ËË 
m_ThreadIndex
ËË  
=
ËË! "
$num
ËË# $
;
ËË$ %
writer
ÍÍ 
.
ÍÍ 
m_Buffer
ÍÍ 
=
ÍÍ 
m_Buffer
ÍÍ &
;
ÍÍ& '
return
ÏÏ 
writer
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
[
ıı 	.
 NativeContainerIsAtomicWriteOnly
ıı	 )
]
ıı) *
[
ˆˆ 	
BurstCompatible
ˆˆ	 
(
ˆˆ "
GenericTypeArguments
ˆˆ -
=
ˆˆ. /
new
ˆˆ0 3
[
ˆˆ4 5
]
ˆˆ5 6
{
ˆˆ7 8
typeof
ˆˆ9 ?
(
ˆˆ? @
int
ˆˆ@ C
)
ˆˆC D
,
ˆˆD E
typeof
ˆˆF L
(
ˆˆL M
int
ˆˆM P
)
ˆˆP Q
}
ˆˆR S
)
ˆˆS T
]
ˆˆT U
public
˜˜ 
unsafe
˜˜ 
struct
˜˜ 
ParallelWriter
˜˜ +
{
¯¯ 	
[
˘˘ /
!NativeDisableUnsafePtrRestriction
˘˘ .
]
˘˘. /
internal
˙˙ 
UnsafeHashMapData
˙˙ &
*
˙˙& '
m_Buffer
˙˙( 0
;
˙˙0 1
[
¸¸ "
NativeSetThreadIndex
¸¸ !
]
¸¸! "
internal
˝˝ 
int
˝˝ 
m_ThreadIndex
˝˝ &
;
˝˝& '
public
ÉÉ 
int
ÉÉ 
Capacity
ÉÉ 
{
ÑÑ 
get
ÖÖ 
{
ÜÜ 
return
áá 
m_Buffer
áá #
->
áá# %
keyCapacity
áá% 0
;
áá0 1
}
àà 
}
ââ 
public
ìì 
void
ìì 
Add
ìì 
(
ìì 
TKey
ìì  
key
ìì! $
,
ìì$ %
TValue
ìì& ,
item
ìì- 1
)
ìì1 2
{
îî 
Assert
ïï 
.
ïï 
IsTrue
ïï 
(
ïï 
m_ThreadIndex
ïï +
>=
ïï, .
$num
ïï/ 0
)
ïï0 1
;
ïï1 2
UnsafeHashMapBase
ññ !
<
ññ! "
TKey
ññ" &
,
ññ& '
TValue
ññ( .
>
ññ. /
.
ññ/ 0
AddAtomicMulti
ññ0 >
(
ññ> ?
m_Buffer
ññ? G
,
ññG H
key
ññI L
,
ññL M
item
ññN R
,
ññR S
m_ThreadIndex
ññT a
)
ñña b
;
ññb c
}
óó 
}
òò 	
public
üü  
KeyValueEnumerator
üü !
GetEnumerator
üü" /
(
üü/ 0
)
üü0 1
{
†† 	
return
°° 
new
°°  
KeyValueEnumerator
°° )
{
°°* +
m_Enumerator
°°, 8
=
°°9 :
new
°°; >)
UnsafeHashMapDataEnumerator
°°? Z
(
°°Z [
m_Buffer
°°[ c
)
°°c d
}
°°e f
;
°°f g
}
¢¢ 	
IEnumerator
©© 
<
©© 
KeyValue
©© 
<
©© 
TKey
©© !
,
©©! "
TValue
©©# )
>
©©) *
>
©©* +
IEnumerable
©©, 7
<
©©7 8
KeyValue
©©8 @
<
©©@ A
TKey
©©A E
,
©©E F
TValue
©©G M
>
©©M N
>
©©N O
.
©©O P
GetEnumerator
©©P ]
(
©©] ^
)
©©^ _
{
™™ 	
throw
´´ 
new
´´ %
NotImplementedException
´´ -
(
´´- .
)
´´. /
;
´´/ 0
}
¨¨ 	
IEnumerator
≥≥ 
IEnumerable
≥≥ 
.
≥≥  
GetEnumerator
≥≥  -
(
≥≥- .
)
≥≥. /
{
¥¥ 	
throw
µµ 
new
µµ %
NotImplementedException
µµ -
(
µµ- .
)
µµ. /
;
µµ/ 0
}
∂∂ 	
public
¿¿ 
struct
¿¿  
KeyValueEnumerator
¿¿ (
:
¿¿) *
IEnumerator
¿¿+ 6
<
¿¿6 7
KeyValue
¿¿7 ?
<
¿¿? @
TKey
¿¿@ D
,
¿¿D E
TValue
¿¿F L
>
¿¿L M
>
¿¿M N
{
¡¡ 	
internal
¬¬ )
UnsafeHashMapDataEnumerator
¬¬ 0
m_Enumerator
¬¬1 =
;
¬¬= >
public
«« 
void
«« 
Dispose
«« 
(
««  
)
««  !
{
««" #
}
««$ %
public
ÕÕ 
bool
ÕÕ 
MoveNext
ÕÕ  
(
ÕÕ  !
)
ÕÕ! "
=>
ÕÕ# %
m_Enumerator
ÕÕ& 2
.
ÕÕ2 3
MoveNext
ÕÕ3 ;
(
ÕÕ; <
)
ÕÕ< =
;
ÕÕ= >
public
““ 
void
““ 
Reset
““ 
(
““ 
)
““ 
=>
““  "
m_Enumerator
““# /
.
““/ 0
Reset
““0 5
(
““5 6
)
““6 7
;
““7 8
public
ÿÿ 
KeyValue
ÿÿ 
<
ÿÿ 
TKey
ÿÿ  
,
ÿÿ  !
TValue
ÿÿ" (
>
ÿÿ( )
Current
ÿÿ* 1
=>
ÿÿ2 4
m_Enumerator
ÿÿ5 A
.
ÿÿA B

GetCurrent
ÿÿB L
<
ÿÿL M
TKey
ÿÿM Q
,
ÿÿQ R
TValue
ÿÿS Y
>
ÿÿY Z
(
ÿÿZ [
)
ÿÿ[ \
;
ÿÿ\ ]
object
⁄⁄ 
IEnumerator
⁄⁄ 
.
⁄⁄ 
Current
⁄⁄ &
=>
⁄⁄' )
Current
⁄⁄* 1
;
⁄⁄1 2
}
€€ 	
}
‹‹ 
internal
ﬁﬁ 
sealed
ﬁﬁ 
class
ﬁﬁ 1
#UnsafeMultiHashMapDebuggerTypeProxy
ﬁﬁ =
<
ﬁﬁ= >
TKey
ﬁﬁ> B
,
ﬁﬁB C
TValue
ﬁﬁD J
>
ﬁﬁJ K
where
ﬂﬂ 
TKey
ﬂﬂ 
:
ﬂﬂ 
struct
ﬂﬂ 
,
ﬂﬂ 

IEquatable
ﬂﬂ '
<
ﬂﬂ' (
TKey
ﬂﬂ( ,
>
ﬂﬂ, -
,
ﬂﬂ- .
IComparable
ﬂﬂ/ :
<
ﬂﬂ: ;
TKey
ﬂﬂ; ?
>
ﬂﬂ? @
where
‡‡ 
TValue
‡‡ 
:
‡‡ 
struct
‡‡ 
{
··  
UnsafeMultiHashMap
„„ 
<
„„ 
TKey
„„ 
,
„„  
TValue
„„! '
>
„„' (
m_Target
„„) 1
;
„„1 2
public
ÂÂ 1
#UnsafeMultiHashMapDebuggerTypeProxy
ÂÂ 2
(
ÂÂ2 3 
UnsafeMultiHashMap
ÂÂ3 E
<
ÂÂE F
TKey
ÂÂF J
,
ÂÂJ K
TValue
ÂÂL R
>
ÂÂR S
target
ÂÂT Z
)
ÂÂZ [
{
ÊÊ 	
m_Target
ÁÁ 
=
ÁÁ 
target
ÁÁ 
;
ÁÁ 
}
ËË 	
public
ÍÍ 
static
ÍÍ 
(
ÍÍ 
NativeArray
ÍÍ "
<
ÍÍ" #
TKey
ÍÍ# '
>
ÍÍ' (
,
ÍÍ( )
int
ÍÍ* -
)
ÍÍ- .
GetUniqueKeyArray
ÍÍ/ @
(
ÍÍ@ A
ref
ÍÍA D 
UnsafeMultiHashMap
ÍÍE W
<
ÍÍW X
TKey
ÍÍX \
,
ÍÍ\ ]
TValue
ÍÍ^ d
>
ÍÍd e
hashMap
ÍÍf m
,
ÍÍm n
AllocatorManager
ÍÍo 
.ÍÍ Ä
AllocatorHandleÍÍÄ è
	allocatorÍÍê ô
)ÍÍô ö
{
ÎÎ 	
var
ÏÏ 
withDuplicates
ÏÏ 
=
ÏÏ  
hashMap
ÏÏ! (
.
ÏÏ( )
GetKeyArray
ÏÏ) 4
(
ÏÏ4 5
	allocator
ÏÏ5 >
)
ÏÏ> ?
;
ÏÏ? @
withDuplicates
ÌÌ 
.
ÌÌ 
Sort
ÌÌ 
(
ÌÌ  
)
ÌÌ  !
;
ÌÌ! "
int
ÓÓ 
uniques
ÓÓ 
=
ÓÓ 
withDuplicates
ÓÓ (
.
ÓÓ( )
Unique
ÓÓ) /
(
ÓÓ/ 0
)
ÓÓ0 1
;
ÓÓ1 2
return
ÔÔ 
(
ÔÔ 
withDuplicates
ÔÔ "
,
ÔÔ" #
uniques
ÔÔ$ +
)
ÔÔ+ ,
;
ÔÔ, -
}
 	
public
ÚÚ 
List
ÚÚ 
<
ÚÚ 
ListPair
ÚÚ 
<
ÚÚ 
TKey
ÚÚ !
,
ÚÚ! "
List
ÚÚ# '
<
ÚÚ' (
TValue
ÚÚ( .
>
ÚÚ. /
>
ÚÚ/ 0
>
ÚÚ0 1
Items
ÚÚ2 7
{
ÛÛ 	
get
ÙÙ 
{
ıı 
var
ˆˆ 
result
ˆˆ 
=
ˆˆ 
new
ˆˆ  
List
ˆˆ! %
<
ˆˆ% &
ListPair
ˆˆ& .
<
ˆˆ. /
TKey
ˆˆ/ 3
,
ˆˆ3 4
List
ˆˆ5 9
<
ˆˆ9 :
TValue
ˆˆ: @
>
ˆˆ@ A
>
ˆˆA B
>
ˆˆB C
(
ˆˆC D
)
ˆˆD E
;
ˆˆE F
var
˜˜ 
keys
˜˜ 
=
˜˜ 
GetUniqueKeyArray
˜˜ ,
(
˜˜, -
ref
˜˜- 0
m_Target
˜˜1 9
,
˜˜9 :
	Allocator
˜˜; D
.
˜˜D E
Temp
˜˜E I
)
˜˜I J
;
˜˜J K
using
˘˘ 
(
˘˘ 
keys
˘˘ 
.
˘˘ 
Item1
˘˘ !
)
˘˘! "
{
˙˙ 
for
˚˚ 
(
˚˚ 
var
˚˚ 
k
˚˚ 
=
˚˚  
$num
˚˚! "
;
˚˚" #
k
˚˚$ %
<
˚˚& '
keys
˚˚( ,
.
˚˚, -
Item2
˚˚- 2
;
˚˚2 3
++
˚˚4 6
k
˚˚6 7
)
˚˚7 8
{
¸¸ 
var
˝˝ 
values
˝˝ "
=
˝˝# $
new
˝˝% (
List
˝˝) -
<
˝˝- .
TValue
˝˝. 4
>
˝˝4 5
(
˝˝5 6
)
˝˝6 7
;
˝˝7 8
if
˛˛ 
(
˛˛ 
m_Target
˛˛ $
.
˛˛$ %
TryGetFirstValue
˛˛% 5
(
˛˛5 6
keys
˛˛6 :
.
˛˛: ;
Item1
˛˛; @
[
˛˛@ A
k
˛˛A B
]
˛˛B C
,
˛˛C D
out
˛˛E H
var
˛˛I L
value
˛˛M R
,
˛˛R S
out
˛˛T W
var
˛˛X [
iterator
˛˛\ d
)
˛˛d e
)
˛˛e f
{
ˇˇ 
do
ÄÄ 
{
ÅÅ 
values
ÇÇ  &
.
ÇÇ& '
Add
ÇÇ' *
(
ÇÇ* +
value
ÇÇ+ 0
)
ÇÇ0 1
;
ÇÇ1 2
}
ÉÉ 
while
ÑÑ !
(
ÑÑ" #
m_Target
ÑÑ# +
.
ÑÑ+ ,
TryGetNextValue
ÑÑ, ;
(
ÑÑ; <
out
ÑÑ< ?
value
ÑÑ@ E
,
ÑÑE F
ref
ÑÑG J
iterator
ÑÑK S
)
ÑÑS T
)
ÑÑT U
;
ÑÑU V
}
ÖÖ 
result
áá 
.
áá 
Add
áá "
(
áá" #
new
áá# &
ListPair
áá' /
<
áá/ 0
TKey
áá0 4
,
áá4 5
List
áá6 :
<
áá: ;
TValue
áá; A
>
ááA B
>
ááB C
(
ááC D
keys
ááD H
.
ááH I
Item1
ááI N
[
ááN O
k
ááO P
]
ááP Q
,
ááQ R
values
ááS Y
)
ááY Z
)
ááZ [
;
áá[ \
}
àà 
}
ââ 
return
ãã 
result
ãã 
;
ãã 
}
åå 
}
çç 	
}
èè 
}êê Äï
^C:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\Unicode.cs
	namespace 	
Unity
 
. 
Collections 
{ 
public 

enum 
FormatError 
{ 
None 
, 
Overflow 
, 
} 
public 

enum 

ParseError 
{ 
None   
,   
Syntax%% 
,%% 
Overflow** 
,** 
	Underflow// 
,// 
}00 
public55 

enum55 
	CopyError55 
{66 
None:: 
,:: 

Truncation?? 
,?? 
}@@ 
publicEE 

enumEE 
ConversionErrorEE 
{FF 
NoneJJ 
,JJ 
OverflowOO 
,OO 
EncodingTT 
,TT 
	CodePointYY 
,YY 
}ZZ 
[__ 
BurstCompatible__ 
]__ 
public`` 

unsafe`` 
struct`` 
Unicode``  
{aa 
[ee 	
BurstCompatibleee	 
]ee 
publicff 
structff 
Runeff 
{gg 	
publicll 
intll 
valuell 
;ll 
publicss 
Runess 
(ss 
intss 
	codepointss %
)ss% &
{tt 
valueuu 
=uu 
	codepointuu !
;uu! "
}vv 
public~~ 
static~~ 
explicit~~ "
operator~~# +
Rune~~, 0
(~~0 1
char~~1 5
	codepoint~~6 ?
)~~? @
=>~~A C
new~~D G
Rune~~H L
{~~M N
value~~O T
=~~U V
	codepoint~~W `
}~~a b
;~~b c
public
ÖÖ 
static
ÖÖ 
bool
ÖÖ 
IsDigit
ÖÖ &
(
ÖÖ& '
Rune
ÖÖ' +
r
ÖÖ, -
)
ÖÖ- .
{
ÜÜ 
return
áá 
r
áá 
.
áá 
value
áá 
>=
áá !
$char
áá" %
&&
áá& (
r
áá) *
.
áá* +
value
áá+ 0
<=
áá1 3
$char
áá4 7
;
áá7 8
}
àà 
public
èè 
int
èè 
LengthInUtf8Bytes
èè (
(
èè( )
)
èè) *
{
êê 
if
ëë 
(
ëë 
value
ëë 
<
ëë 
$num
ëë 
)
ëë 
return
íí 
$num
íí 
;
íí 
if
ìì 
(
ìì 
value
ìì 
<=
ìì 
$num
ìì !
)
ìì! "
return
îî 
$num
îî 
;
îî 
if
ïï 
(
ïï 
value
ïï 
<=
ïï 
$num
ïï "
)
ïï" #
return
ññ 
$num
ññ 
;
ññ 
if
óó 
(
óó 
value
óó 
<=
óó 
$num
óó #
)
óó# $
return
òò 
$num
òò 
;
òò 
if
ôô 
(
ôô 
value
ôô 
<=
ôô 
$num
ôô %
)
ôô% &
return
öö 
$num
öö 
;
öö 
return
úú 
$num
úú 
;
úú 
}
ùù 
}
ûû 	
public
°° 
const
°° 
int
°° $
kMaximumValidCodePoint
°° /
=
°°0 1
$num
°°2 :
;
°°: ;
public
®® 
static
®® 
bool
®® 
IsValidCodePoint
®® +
(
®®+ ,
int
®®, /
	codepoint
®®0 9
)
®®9 :
{
©© 	
if
™™ 
(
™™ 
	codepoint
™™ 
>
™™ $
kMaximumValidCodePoint
™™ 2
)
™™2 3
return
´´ 
false
´´ 
;
´´ 
if
ÆÆ 
(
ÆÆ 
	codepoint
ÆÆ 
<
ÆÆ 
$num
ÆÆ 
)
ÆÆ 
return
ØØ 
false
ØØ 
;
ØØ 
return
∞∞ 
true
∞∞ 
;
∞∞ 
}
±± 	
public
∏∏ 
static
∏∏ 
bool
∏∏ 

NotTrailer
∏∏ %
(
∏∏% &
byte
∏∏& *
b
∏∏+ ,
)
∏∏, -
{
ππ 	
return
∫∫ 
(
∫∫ 
b
∫∫ 
&
∫∫ 
$num
∫∫ 
)
∫∫ 
!=
∫∫  
$num
∫∫! %
;
∫∫% &
}
ªª 	
public
¬¬ 
static
¬¬ 
Rune
¬¬ "
ReplacementCharacter
¬¬ /
=>
¬¬0 2
new
¬¬3 6
Rune
¬¬7 ;
{
¬¬< =
value
¬¬> C
=
¬¬D E
$num
¬¬F L
}
¬¬M N
;
¬¬N O
public
…… 
static
…… 
Rune
…… 
BadRune
…… "
=>
……# %
new
……& )
Rune
……* .
{
……/ 0
value
……1 6
=
……7 8
$num
……9 :
}
……; <
;
……< =
public
‘‘ 
static
‘‘ 
ConversionError
‘‘ %
	Utf8ToUcs
‘‘& /
(
‘‘/ 0
out
‘‘0 3
Rune
‘‘4 8
rune
‘‘9 =
,
‘‘= >
byte
‘‘? C
*
‘‘C D
buffer
‘‘E K
,
‘‘K L
ref
‘‘M P
int
‘‘Q T
index
‘‘U Z
,
‘‘Z [
int
‘‘\ _
capacity
‘‘` h
)
‘‘h i
{
’’ 	
int
÷÷ 
code
÷÷ 
=
÷÷ 
$num
÷÷ 
;
÷÷ 
rune
◊◊ 
=
◊◊ "
ReplacementCharacter
◊◊ '
;
◊◊' (
if
ÿÿ 
(
ÿÿ 
index
ÿÿ 
+
ÿÿ 
$num
ÿÿ 
>
ÿÿ 
capacity
ÿÿ $
)
ÿÿ$ %
{
ŸŸ 
return
⁄⁄ 
ConversionError
⁄⁄ &
.
⁄⁄& '
Overflow
⁄⁄' /
;
⁄⁄/ 0
}
€€ 
if
›› 
(
›› 
(
›› 
buffer
›› 
[
›› 
index
›› 
]
›› 
&
››  
$num
››! +
)
››+ ,
==
››- /
$num
››0 :
)
››: ;
{
ﬁﬁ 
rune
ﬂﬂ 
.
ﬂﬂ 
value
ﬂﬂ 
=
ﬂﬂ 
buffer
ﬂﬂ #
[
ﬂﬂ# $
index
ﬂﬂ$ )
+
ﬂﬂ* +
$num
ﬂﬂ, -
]
ﬂﬂ- .
;
ﬂﬂ. /
index
‡‡ 
+=
‡‡ 
$num
‡‡ 
;
‡‡ 
return
·· 
ConversionError
·· &
.
··& '
None
··' +
;
··+ ,
}
‚‚ 
if
‰‰ 
(
‰‰ 
(
‰‰ 
buffer
‰‰ 
[
‰‰ 
index
‰‰ 
]
‰‰ 
&
‰‰  
$num
‰‰! +
)
‰‰+ ,
==
‰‰- /
$num
‰‰0 :
)
‰‰: ;
{
ÂÂ 
if
ÊÊ 
(
ÊÊ 
index
ÊÊ 
+
ÊÊ 
$num
ÊÊ 
>
ÊÊ 
capacity
ÊÊ  (
)
ÊÊ( )
{
ÁÁ 
index
ËË 
+=
ËË 
$num
ËË 
;
ËË 
return
ÈÈ 
ConversionError
ÈÈ *
.
ÈÈ* +
Overflow
ÈÈ+ 3
;
ÈÈ3 4
}
ÍÍ 
code
ÎÎ 
=
ÎÎ 
(
ÎÎ 
buffer
ÎÎ 
[
ÎÎ 
index
ÎÎ $
+
ÎÎ% &
$num
ÎÎ' (
]
ÎÎ( )
&
ÎÎ* +
$num
ÎÎ, 6
)
ÎÎ6 7
;
ÎÎ7 8
code
ÏÏ 
=
ÏÏ 
(
ÏÏ 
code
ÏÏ 
<<
ÏÏ 
$num
ÏÏ  !
)
ÏÏ! "
|
ÏÏ# $
(
ÏÏ% &
buffer
ÏÏ& ,
[
ÏÏ, -
index
ÏÏ- 2
+
ÏÏ3 4
$num
ÏÏ5 6
]
ÏÏ6 7
&
ÏÏ8 9
$num
ÏÏ: D
)
ÏÏD E
;
ÏÏE F
if
ÌÌ 
(
ÌÌ 
code
ÌÌ 
<
ÌÌ 
(
ÌÌ 
$num
ÌÌ 
<<
ÌÌ  
$num
ÌÌ! "
)
ÌÌ" #
||
ÌÌ$ &

NotTrailer
ÌÌ' 1
(
ÌÌ1 2
buffer
ÌÌ2 8
[
ÌÌ8 9
index
ÌÌ9 >
+
ÌÌ? @
$num
ÌÌA B
]
ÌÌB C
)
ÌÌC D
)
ÌÌD E
{
ÓÓ 
index
ÔÔ 
+=
ÔÔ 
$num
ÔÔ 
;
ÔÔ 
return
 
ConversionError
 *
.
* +
Encoding
+ 3
;
3 4
}
ÒÒ 
rune
ÚÚ 
.
ÚÚ 
value
ÚÚ 
=
ÚÚ 
code
ÚÚ !
;
ÚÚ! "
index
ÛÛ 
+=
ÛÛ 
$num
ÛÛ 
;
ÛÛ 
return
ÙÙ 
ConversionError
ÙÙ &
.
ÙÙ& '
None
ÙÙ' +
;
ÙÙ+ ,
}
ıı 
if
˜˜ 
(
˜˜ 
(
˜˜ 
buffer
˜˜ 
[
˜˜ 
index
˜˜ 
]
˜˜ 
&
˜˜  
$num
˜˜! +
)
˜˜+ ,
==
˜˜- /
$num
˜˜0 :
)
˜˜: ;
{
¯¯ 
if
˘˘ 
(
˘˘ 
index
˘˘ 
+
˘˘ 
$num
˘˘ 
>
˘˘ 
capacity
˘˘  (
)
˘˘( )
{
˙˙ 
index
˚˚ 
+=
˚˚ 
$num
˚˚ 
;
˚˚ 
return
¸¸ 
ConversionError
¸¸ *
.
¸¸* +
Overflow
¸¸+ 3
;
¸¸3 4
}
˝˝ 
code
˛˛ 
=
˛˛ 
(
˛˛ 
buffer
˛˛ 
[
˛˛ 
index
˛˛ $
+
˛˛% &
$num
˛˛' (
]
˛˛( )
&
˛˛* +
$num
˛˛, 6
)
˛˛6 7
;
˛˛7 8
code
ˇˇ 
=
ˇˇ 
(
ˇˇ 
code
ˇˇ 
<<
ˇˇ 
$num
ˇˇ  !
)
ˇˇ! "
|
ˇˇ# $
(
ˇˇ% &
buffer
ˇˇ& ,
[
ˇˇ, -
index
ˇˇ- 2
+
ˇˇ3 4
$num
ˇˇ5 6
]
ˇˇ6 7
&
ˇˇ8 9
$num
ˇˇ: D
)
ˇˇD E
;
ˇˇE F
code
ÄÄ 
=
ÄÄ 
(
ÄÄ 
code
ÄÄ 
<<
ÄÄ 
$num
ÄÄ  !
)
ÄÄ! "
|
ÄÄ# $
(
ÄÄ% &
buffer
ÄÄ& ,
[
ÄÄ, -
index
ÄÄ- 2
+
ÄÄ3 4
$num
ÄÄ5 6
]
ÄÄ6 7
&
ÄÄ8 9
$num
ÄÄ: D
)
ÄÄD E
;
ÄÄE F
if
ÅÅ 
(
ÅÅ 
code
ÅÅ 
<
ÅÅ 
(
ÅÅ 
$num
ÅÅ 
<<
ÅÅ  
$num
ÅÅ! #
)
ÅÅ# $
||
ÅÅ% '
!
ÅÅ( )
IsValidCodePoint
ÅÅ) 9
(
ÅÅ9 :
code
ÅÅ: >
)
ÅÅ> ?
||
ÅÅ@ B

NotTrailer
ÅÅC M
(
ÅÅM N
buffer
ÅÅN T
[
ÅÅT U
index
ÅÅU Z
+
ÅÅ[ \
$num
ÅÅ] ^
]
ÅÅ^ _
)
ÅÅ_ `
||
ÅÅa c

NotTrailer
ÅÅd n
(
ÅÅn o
buffer
ÅÅo u
[
ÅÅu v
index
ÅÅv {
+
ÅÅ| }
$num
ÅÅ~ 
]ÅÅ Ä
)ÅÅÄ Å
)ÅÅÅ Ç
{
ÇÇ 
index
ÉÉ 
+=
ÉÉ 
$num
ÉÉ 
;
ÉÉ 
return
ÑÑ 
ConversionError
ÑÑ *
.
ÑÑ* +
Encoding
ÑÑ+ 3
;
ÑÑ3 4
}
ÖÖ 
rune
ÜÜ 
.
ÜÜ 
value
ÜÜ 
=
ÜÜ 
code
ÜÜ !
;
ÜÜ! "
index
áá 
+=
áá 
$num
áá 
;
áá 
return
àà 
ConversionError
àà &
.
àà& '
None
àà' +
;
àà+ ,
}
ââ 
if
ãã 
(
ãã 
(
ãã 
buffer
ãã 
[
ãã 
index
ãã 
]
ãã 
&
ãã  
$num
ãã! +
)
ãã+ ,
==
ãã- /
$num
ãã0 :
)
ãã: ;
{
åå 
if
çç 
(
çç 
index
çç 
+
çç 
$num
çç 
>
çç 
capacity
çç  (
)
çç( )
{
éé 
index
èè 
+=
èè 
$num
èè 
;
èè 
return
êê 
ConversionError
êê *
.
êê* +
Overflow
êê+ 3
;
êê3 4
}
ëë 
code
íí 
=
íí 
(
íí 
buffer
íí 
[
íí 
index
íí $
+
íí% &
$num
íí' (
]
íí( )
&
íí* +
$num
íí, 6
)
íí6 7
;
íí7 8
code
ìì 
=
ìì 
(
ìì 
code
ìì 
<<
ìì 
$num
ìì  !
)
ìì! "
|
ìì# $
(
ìì% &
buffer
ìì& ,
[
ìì, -
index
ìì- 2
+
ìì3 4
$num
ìì5 6
]
ìì6 7
&
ìì8 9
$num
ìì: D
)
ììD E
;
ììE F
code
îî 
=
îî 
(
îî 
code
îî 
<<
îî 
$num
îî  !
)
îî! "
|
îî# $
(
îî% &
buffer
îî& ,
[
îî, -
index
îî- 2
+
îî3 4
$num
îî5 6
]
îî6 7
&
îî8 9
$num
îî: D
)
îîD E
;
îîE F
code
ïï 
=
ïï 
(
ïï 
code
ïï 
<<
ïï 
$num
ïï  !
)
ïï! "
|
ïï# $
(
ïï% &
buffer
ïï& ,
[
ïï, -
index
ïï- 2
+
ïï3 4
$num
ïï5 6
]
ïï6 7
&
ïï8 9
$num
ïï: D
)
ïïD E
;
ïïE F
if
ññ 
(
ññ 
code
ññ 
<
ññ 
(
ññ 
$num
ññ 
<<
ññ  
$num
ññ! #
)
ññ# $
||
ññ% '
!
ññ( )
IsValidCodePoint
ññ) 9
(
ññ9 :
code
ññ: >
)
ññ> ?
||
ññ@ B

NotTrailer
ññC M
(
ññM N
buffer
ññN T
[
ññT U
index
ññU Z
+
ññ[ \
$num
ññ] ^
]
ññ^ _
)
ññ_ `
||
ñña c

NotTrailer
ññd n
(
ññn o
buffer
ñño u
[
ññu v
index
ññv {
+
ññ| }
$num
ññ~ 
]ññ Ä
)ññÄ Å
||ññÇ Ñ

NotTrailerññÖ è
(ññè ê
bufferññê ñ
[ñññ ó
indexññó ú
+ññù û
$numññü †
]ññ† °
)ññ° ¢
)ññ¢ £
{
óó 
index
òò 
+=
òò 
$num
òò 
;
òò 
return
ôô 
ConversionError
ôô *
.
ôô* +
Encoding
ôô+ 3
;
ôô3 4
}
öö 
rune
õõ 
.
õõ 
value
õõ 
=
õõ 
code
õõ !
;
õõ! "
index
úú 
+=
úú 
$num
úú 
;
úú 
return
ùù 
ConversionError
ùù &
.
ùù& '
None
ùù' +
;
ùù+ ,
}
ûû 
index
†† 
+=
†† 
$num
†† 
;
†† 
return
°° 
ConversionError
°° "
.
°°" #
Encoding
°°# +
;
°°+ ,
}
¢¢ 	
static
©© 
bool
©©  
IsLeadingSurrogate
©© &
(
©©& '
char
©©' +
c
©©, -
)
©©- .
{
™™ 	
return
´´ 
c
´´ 
>=
´´ 
$num
´´ 
&&
´´ !
c
´´" #
<=
´´$ &
$num
´´' -
;
´´- .
}
¨¨ 	
static
≥≥ 
bool
≥≥ !
IsTrailingSurrogate
≥≥ '
(
≥≥' (
char
≥≥( ,
c
≥≥- .
)
≥≥. /
{
¥¥ 	
return
µµ 
c
µµ 
>=
µµ 
$num
µµ 
&&
µµ !
c
µµ" #
<=
µµ$ &
$num
µµ' -
;
µµ- .
}
∂∂ 	
public
¡¡ 
static
¡¡ 
ConversionError
¡¡ %

Utf16ToUcs
¡¡& 0
(
¡¡0 1
out
¡¡1 4
Rune
¡¡5 9
rune
¡¡: >
,
¡¡> ?
char
¡¡@ D
*
¡¡D E
buffer
¡¡F L
,
¡¡L M
ref
¡¡N Q
int
¡¡R U
index
¡¡V [
,
¡¡[ \
int
¡¡] `
capacity
¡¡a i
)
¡¡i j
{
¬¬ 	
int
√√ 
code
√√ 
=
√√ 
$num
√√ 
;
√√ 
rune
ƒƒ 
=
ƒƒ "
ReplacementCharacter
ƒƒ '
;
ƒƒ' (
if
≈≈ 
(
≈≈ 
index
≈≈ 
+
≈≈ 
$num
≈≈ 
>
≈≈ 
capacity
≈≈ $
)
≈≈$ %
return
∆∆ 
ConversionError
∆∆ &
.
∆∆& '
Overflow
∆∆' /
;
∆∆/ 0
if
«« 
(
«« 
!
««  
IsLeadingSurrogate
«« #
(
««# $
buffer
««$ *
[
««* +
index
««+ 0
]
««0 1
)
««1 2
||
««3 5
(
««6 7
index
««7 <
+
««= >
$num
««? @
>
««A B
capacity
««C K
)
««K L
)
««L M
{
»» 
rune
…… 
.
…… 
value
…… 
=
…… 
buffer
…… #
[
……# $
index
……$ )
]
……) *
;
……* +
index
   
+=
   
$num
   
;
   
return
ÀÀ 
ConversionError
ÀÀ &
.
ÀÀ& '
None
ÀÀ' +
;
ÀÀ+ ,
}
ÃÃ 
code
ÕÕ 
=
ÕÕ 
(
ÕÕ" #
buffer
ÕÕ# )
[
ÕÕ) *
index
ÕÕ* /
+
ÕÕ0 1
$num
ÕÕ2 3
]
ÕÕ3 4
&
ÕÕ5 6
$num
ÕÕ7 =
)
ÕÕ= >
;
ÕÕ> ?
char
ŒŒ 
next
ŒŒ 
=
ŒŒ 
buffer
ŒŒ 
[
ŒŒ 
index
ŒŒ $
+
ŒŒ% &
$num
ŒŒ' (
]
ŒŒ( )
;
ŒŒ) *
if
œœ 
(
œœ 
!
œœ !
IsTrailingSurrogate
œœ $
(
œœ$ %
next
œœ% )
)
œœ) *
)
œœ* +
{
–– 
rune
—— 
.
—— 
value
—— 
=
—— 
buffer
—— #
[
——# $
index
——$ )
]
——) *
;
——* +
index
““ 
+=
““ 
$num
““ 
;
““ 
return
”” 
ConversionError
”” &
.
””& '
None
””' +
;
””+ ,
}
‘‘ 
code
’’ 
=
’’ 
(
’’ 
code
’’ 
<<
’’ 
$num
’’ 
)
’’ 
|
’’  !
(
’’" #
buffer
’’# )
[
’’) *
index
’’* /
+
’’0 1
$num
’’2 3
]
’’3 4
&
’’5 6
$num
’’7 =
)
’’= >
;
’’> ?
code
÷÷ 
+=
÷÷ 
$num
÷÷ 
;
÷÷ 
rune
◊◊ 
.
◊◊ 
value
◊◊ 
=
◊◊ 
code
◊◊ 
;
◊◊ 
index
ÿÿ 
+=
ÿÿ 
$num
ÿÿ 
;
ÿÿ 
return
ŸŸ 
ConversionError
ŸŸ "
.
ŸŸ" #
None
ŸŸ# '
;
ŸŸ' (
}
⁄⁄ 	
public
ÂÂ 
static
ÂÂ 
ConversionError
ÂÂ %
	UcsToUtf8
ÂÂ& /
(
ÂÂ/ 0
byte
ÂÂ0 4
*
ÂÂ4 5
buffer
ÂÂ6 <
,
ÂÂ< =
ref
ÂÂ> A
int
ÂÂB E
index
ÂÂF K
,
ÂÂK L
int
ÂÂM P
capacity
ÂÂQ Y
,
ÂÂY Z
Rune
ÂÂ[ _
rune
ÂÂ` d
)
ÂÂd e
{
ÊÊ 	
if
ÁÁ 
(
ÁÁ 
!
ÁÁ 
IsValidCodePoint
ÁÁ !
(
ÁÁ! "
rune
ÁÁ" &
.
ÁÁ& '
value
ÁÁ' ,
)
ÁÁ, -
)
ÁÁ- .
{
ËË 
return
ÈÈ 
ConversionError
ÈÈ &
.
ÈÈ& '
	CodePoint
ÈÈ' 0
;
ÈÈ0 1
}
ÍÍ 
if
ÏÏ 
(
ÏÏ 
index
ÏÏ 
+
ÏÏ 
$num
ÏÏ 
>
ÏÏ 
capacity
ÏÏ $
)
ÏÏ$ %
{
ÌÌ 
return
ÓÓ 
ConversionError
ÓÓ &
.
ÓÓ& '
Overflow
ÓÓ' /
;
ÓÓ/ 0
}
ÔÔ 
if
ÒÒ 
(
ÒÒ 
rune
ÒÒ 
.
ÒÒ 
value
ÒÒ 
<=
ÒÒ 
$num
ÒÒ "
)
ÒÒ" #
{
ÚÚ 
buffer
ÛÛ 
[
ÛÛ 
index
ÛÛ 
++
ÛÛ 
]
ÛÛ 
=
ÛÛ  !
(
ÛÛ" #
byte
ÛÛ# '
)
ÛÛ' (
rune
ÛÛ( ,
.
ÛÛ, -
value
ÛÛ- 2
;
ÛÛ2 3
return
ÙÙ 
ConversionError
ÙÙ &
.
ÙÙ& '
None
ÙÙ' +
;
ÙÙ+ ,
}
ıı 
if
˜˜ 
(
˜˜ 
rune
˜˜ 
.
˜˜ 
value
˜˜ 
<=
˜˜ 
$num
˜˜ #
)
˜˜# $
{
¯¯ 
if
˘˘ 
(
˘˘ 
index
˘˘ 
+
˘˘ 
$num
˘˘ 
>
˘˘ 
capacity
˘˘  (
)
˘˘( )
{
˙˙ 
return
˚˚ 
ConversionError
˚˚ *
.
˚˚* +
Overflow
˚˚+ 3
;
˚˚3 4
}
¸¸ 
buffer
˛˛ 
[
˛˛ 
index
˛˛ 
++
˛˛ 
]
˛˛ 
=
˛˛  !
(
˛˛" #
byte
˛˛# '
)
˛˛' (
(
˛˛( )
$num
˛˛) -
|
˛˛. /
(
˛˛0 1
rune
˛˛1 5
.
˛˛5 6
value
˛˛6 ;
>>
˛˛< >
$num
˛˛? @
)
˛˛@ A
)
˛˛A B
;
˛˛B C
buffer
ˇˇ 
[
ˇˇ 
index
ˇˇ 
++
ˇˇ 
]
ˇˇ 
=
ˇˇ  !
(
ˇˇ" #
byte
ˇˇ# '
)
ˇˇ' (
(
ˇˇ( )
$num
ˇˇ) -
|
ˇˇ. /
(
ˇˇ0 1
(
ˇˇ1 2
rune
ˇˇ2 6
.
ˇˇ6 7
value
ˇˇ7 <
>>
ˇˇ= ?
$num
ˇˇ@ A
)
ˇˇA B
&
ˇˇC D
$num
ˇˇE I
)
ˇˇI J
)
ˇˇJ K
;
ˇˇK L
return
ÄÄ 
ConversionError
ÄÄ &
.
ÄÄ& '
None
ÄÄ' +
;
ÄÄ+ ,
}
ÅÅ 
if
ÉÉ 
(
ÉÉ 
rune
ÉÉ 
.
ÉÉ 
value
ÉÉ 
<=
ÉÉ 
$num
ÉÉ $
)
ÉÉ$ %
{
ÑÑ 
if
ÖÖ 
(
ÖÖ 
index
ÖÖ 
+
ÖÖ 
$num
ÖÖ 
>
ÖÖ 
capacity
ÖÖ  (
)
ÖÖ( )
{
ÜÜ 
return
áá 
ConversionError
áá *
.
áá* +
Overflow
áá+ 3
;
áá3 4
}
àà 
buffer
ää 
[
ää 
index
ää 
++
ää 
]
ää 
=
ää  !
(
ää" #
byte
ää# '
)
ää' (
(
ää( )
$num
ää) -
|
ää. /
(
ää0 1
rune
ää1 5
.
ää5 6
value
ää6 ;
>>
ää< >
$num
ää? A
)
ääA B
)
ääB C
;
ääC D
buffer
ãã 
[
ãã 
index
ãã 
++
ãã 
]
ãã 
=
ãã  !
(
ãã" #
byte
ãã# '
)
ãã' (
(
ãã( )
$num
ãã) -
|
ãã. /
(
ãã0 1
(
ãã1 2
rune
ãã2 6
.
ãã6 7
value
ãã7 <
>>
ãã= ?
$num
ãã@ A
)
ããA B
&
ããC D
$num
ããE I
)
ããI J
)
ããJ K
;
ããK L
buffer
åå 
[
åå 
index
åå 
++
åå 
]
åå 
=
åå  !
(
åå" #
byte
åå# '
)
åå' (
(
åå( )
$num
åå) -
|
åå. /
(
åå0 1
(
åå1 2
rune
åå2 6
.
åå6 7
value
åå7 <
>>
åå= ?
$num
åå@ A
)
ååA B
&
ååC D
$num
ååE I
)
ååI J
)
ååJ K
;
ååK L
return
çç 
ConversionError
çç &
.
çç& '
None
çç' +
;
çç+ ,
}
éé 
if
êê 
(
êê 
rune
êê 
.
êê 
value
êê 
<=
êê 
$num
êê &
)
êê& '
{
ëë 
if
íí 
(
íí 
index
íí 
+
íí 
$num
íí 
>
íí 
capacity
íí  (
)
íí( )
{
ìì 
return
îî 
ConversionError
îî *
.
îî* +
Overflow
îî+ 3
;
îî3 4
}
ïï 
buffer
óó 
[
óó 
index
óó 
++
óó 
]
óó 
=
óó  !
(
óó" #
byte
óó# '
)
óó' (
(
óó( )
$num
óó) -
|
óó. /
(
óó0 1
rune
óó1 5
.
óó5 6
value
óó6 ;
>>
óó< >
$num
óó? A
)
óóA B
)
óóB C
;
óóC D
buffer
òò 
[
òò 
index
òò 
++
òò 
]
òò 
=
òò  !
(
òò" #
byte
òò# '
)
òò' (
(
òò( )
$num
òò) -
|
òò. /
(
òò0 1
(
òò1 2
rune
òò2 6
.
òò6 7
value
òò7 <
>>
òò= ?
$num
òò@ B
)
òòB C
&
òòD E
$num
òòF J
)
òòJ K
)
òòK L
;
òòL M
buffer
ôô 
[
ôô 
index
ôô 
++
ôô 
]
ôô 
=
ôô  !
(
ôô" #
byte
ôô# '
)
ôô' (
(
ôô( )
$num
ôô) -
|
ôô. /
(
ôô0 1
(
ôô1 2
rune
ôô2 6
.
ôô6 7
value
ôô7 <
>>
ôô= ?
$num
ôô@ A
)
ôôA B
&
ôôC D
$num
ôôE I
)
ôôI J
)
ôôJ K
;
ôôK L
buffer
öö 
[
öö 
index
öö 
++
öö 
]
öö 
=
öö  !
(
öö" #
byte
öö# '
)
öö' (
(
öö( )
$num
öö) -
|
öö. /
(
öö0 1
(
öö1 2
rune
öö2 6
.
öö6 7
value
öö7 <
>>
öö= ?
$num
öö@ A
)
ööA B
&
ööC D
$num
ööE I
)
ööI J
)
ööJ K
;
ööK L
return
õõ 
ConversionError
õõ &
.
õõ& '
None
õõ' +
;
õõ+ ,
}
úú 
return
ûû 
ConversionError
ûû "
.
ûû" #
Encoding
ûû# +
;
ûû+ ,
}
üü 	
public
™™ 
static
™™ 
ConversionError
™™ %

UcsToUtf16
™™& 0
(
™™0 1
char
™™1 5
*
™™5 6
buffer
™™7 =
,
™™= >
ref
™™? B
int
™™C F
index
™™G L
,
™™L M
int
™™N Q
capacity
™™R Z
,
™™Z [
Rune
™™\ `
rune
™™a e
)
™™e f
{
´´ 	
if
¨¨ 
(
¨¨ 
!
¨¨ 
IsValidCodePoint
¨¨ !
(
¨¨! "
rune
¨¨" &
.
¨¨& '
value
¨¨' ,
)
¨¨, -
)
¨¨- .
{
≠≠ 
return
ÆÆ 
ConversionError
ÆÆ &
.
ÆÆ& '
	CodePoint
ÆÆ' 0
;
ÆÆ0 1
}
ØØ 
if
±± 
(
±± 
index
±± 
+
±± 
$num
±± 
>
±± 
capacity
±± $
)
±±$ %
{
≤≤ 
return
≥≥ 
ConversionError
≥≥ &
.
≥≥& '
Overflow
≥≥' /
;
≥≥/ 0
}
¥¥ 
if
∂∂ 
(
∂∂ 
rune
∂∂ 
.
∂∂ 
value
∂∂ 
>=
∂∂ 
$num
∂∂ %
)
∂∂% &
{
∑∑ 
if
∏∏ 
(
∏∏ 
index
∏∏ 
+
∏∏ 
$num
∏∏ 
>
∏∏ 
capacity
∏∏  (
)
∏∏( )
{
ππ 
return
∫∫ 
ConversionError
∫∫ *
.
∫∫* +
Overflow
∫∫+ 3
;
∫∫3 4
}
ªª 
int
ΩΩ 
code
ΩΩ 
=
ΩΩ 
rune
ΩΩ 
.
ΩΩ  
value
ΩΩ  %
-
ΩΩ& '
$num
ΩΩ( /
;
ΩΩ/ 0
if
ææ 
(
ææ 
code
ææ 
>=
ææ 
(
ææ 
$num
ææ 
<<
ææ !
$num
ææ" $
)
ææ$ %
)
ææ% &
{
øø 
return
¿¿ 
ConversionError
¿¿ *
.
¿¿* +
Encoding
¿¿+ 3
;
¿¿3 4
}
¡¡ 
buffer
√√ 
[
√√ 
index
√√ 
++
√√ 
]
√√ 
=
√√  !
(
√√" #
char
√√# '
)
√√' (
(
√√( )
$num
√√) /
|
√√0 1
(
√√2 3
code
√√3 7
>>
√√8 :
$num
√√; =
)
√√= >
)
√√> ?
;
√√? @
buffer
ƒƒ 
[
ƒƒ 
index
ƒƒ 
++
ƒƒ 
]
ƒƒ 
=
ƒƒ  !
(
ƒƒ" #
char
ƒƒ# '
)
ƒƒ' (
(
ƒƒ( )
$num
ƒƒ) /
|
ƒƒ0 1
(
ƒƒ2 3
code
ƒƒ3 7
&
ƒƒ8 9
$num
ƒƒ: ?
)
ƒƒ? @
)
ƒƒ@ A
;
ƒƒA B
return
≈≈ 
ConversionError
≈≈ &
.
≈≈& '
None
≈≈' +
;
≈≈+ ,
}
∆∆ 
buffer
»» 
[
»» 
index
»» 
++
»» 
]
»» 
=
»» 
(
»» 
char
»» #
)
»»# $
rune
»»$ (
.
»»( )
value
»») .
;
»». /
return
…… 
ConversionError
…… "
.
……" #
None
……# '
;
……' (
}
   	
public
÷÷ 
static
÷÷ 
ConversionError
÷÷ %
Utf16ToUtf8
÷÷& 1
(
÷÷1 2
char
÷÷2 6
*
÷÷6 7
utf16Buffer
÷÷8 C
,
÷÷C D
int
÷÷E H
utf16Length
÷÷I T
,
÷÷T U
byte
÷÷V Z
*
÷÷Z [

utf8Buffer
÷÷\ f
,
÷÷f g
out
÷÷h k
int
÷÷l o

utf8Length
÷÷p z
,
÷÷z {
int
÷÷| 
utf8Capacity÷÷Ä å
)÷÷å ç
{
◊◊ 	

utf8Length
ÿÿ 
=
ÿÿ 
$num
ÿÿ 
;
ÿÿ 
for
ŸŸ 
(
ŸŸ 
var
ŸŸ 
utf16Offset
ŸŸ  
=
ŸŸ! "
$num
ŸŸ# $
;
ŸŸ$ %
utf16Offset
ŸŸ& 1
<
ŸŸ2 3
utf16Length
ŸŸ4 ?
;
ŸŸ? @
)
ŸŸ@ A
{
⁄⁄ 

Utf16ToUcs
€€ 
(
€€ 
out
€€ 
var
€€ "
ucs
€€# &
,
€€& '
utf16Buffer
€€( 3
,
€€3 4
ref
€€5 8
utf16Offset
€€9 D
,
€€D E
utf16Length
€€F Q
)
€€Q R
;
€€R S
if
‹‹ 
(
‹‹ 
	UcsToUtf8
‹‹ 
(
‹‹ 

utf8Buffer
‹‹ (
,
‹‹( )
ref
‹‹* -

utf8Length
‹‹. 8
,
‹‹8 9
utf8Capacity
‹‹: F
,
‹‹F G
ucs
‹‹H K
)
‹‹K L
==
‹‹M O
ConversionError
‹‹P _
.
‹‹_ `
Overflow
‹‹` h
)
‹‹h i
return
›› 
ConversionError
›› *
.
››* +
Overflow
››+ 3
;
››3 4
}
ﬁﬁ 
return
ﬂﬂ 
ConversionError
ﬂﬂ "
.
ﬂﬂ" #
None
ﬂﬂ# '
;
ﬂﬂ' (
}
‡‡ 	
public
ÏÏ 
static
ÏÏ 
ConversionError
ÏÏ %

Utf8ToUtf8
ÏÏ& 0
(
ÏÏ0 1
byte
ÏÏ1 5
*
ÏÏ5 6
	srcBuffer
ÏÏ7 @
,
ÏÏ@ A
int
ÏÏB E
	srcLength
ÏÏF O
,
ÏÏO P
byte
ÏÏQ U
*
ÏÏU V

destBuffer
ÏÏW a
,
ÏÏa b
out
ÏÏc f
int
ÏÏg j

destLength
ÏÏk u
,
ÏÏu v
int
ÏÏw z
destCapacityÏÏ{ á
)ÏÏá à
{
ÌÌ 	
if
ÓÓ 
(
ÓÓ 
destCapacity
ÓÓ 
>=
ÓÓ 
	srcLength
ÓÓ  )
)
ÓÓ) *
{
ÔÔ 
UnsafeUtility
 
.
 
MemCpy
 $
(
$ %

destBuffer
% /
,
/ 0
	srcBuffer
1 :
,
: ;
	srcLength
< E
)
E F
;
F G

destLength
ÒÒ 
=
ÒÒ 
	srcLength
ÒÒ &
;
ÒÒ& '
return
ÚÚ 
ConversionError
ÚÚ &
.
ÚÚ& '
None
ÚÚ' +
;
ÚÚ+ ,
}
ÛÛ 

destLength
˜˜ 
=
˜˜ 
$num
˜˜ 
;
˜˜ 
for
¯¯ 
(
¯¯ 
var
¯¯ 
	srcOffset
¯¯ 
=
¯¯  
$num
¯¯! "
;
¯¯" #
	srcOffset
¯¯$ -
<
¯¯. /
	srcLength
¯¯0 9
;
¯¯9 :
)
¯¯: ;
{
˘˘ 
	Utf8ToUcs
˙˙ 
(
˙˙ 
out
˙˙ 
var
˙˙ !
ucs
˙˙" %
,
˙˙% &
	srcBuffer
˙˙' 0
,
˙˙0 1
ref
˙˙2 5
	srcOffset
˙˙6 ?
,
˙˙? @
	srcLength
˙˙A J
)
˙˙J K
;
˙˙K L
if
˚˚ 
(
˚˚ 
	UcsToUtf8
˚˚ 
(
˚˚ 

destBuffer
˚˚ (
,
˚˚( )
ref
˚˚* -

destLength
˚˚. 8
,
˚˚8 9
destCapacity
˚˚: F
,
˚˚F G
ucs
˚˚H K
)
˚˚K L
==
˚˚M O
ConversionError
˚˚P _
.
˚˚_ `
Overflow
˚˚` h
)
˚˚h i
return
¸¸ 
ConversionError
¸¸ *
.
¸¸* +
Overflow
¸¸+ 3
;
¸¸3 4
}
˝˝ 
return
˛˛ 
ConversionError
˛˛ "
.
˛˛" #
None
˛˛# '
;
˛˛' (
}
ˇˇ 	
public
ãã 
static
ãã 
ConversionError
ãã %
Utf8ToUtf16
ãã& 1
(
ãã1 2
byte
ãã2 6
*
ãã6 7

utf8Buffer
ãã8 B
,
ããB C
int
ããD G

utf8Length
ããH R
,
ããR S
char
ããT X
*
ããX Y
utf16Buffer
ããZ e
,
ããe f
out
ããg j
int
ããk n
utf16Length
ãão z
,
ããz {
int
ãã| 
utf16CapacityããÄ ç
)ããç é
{
åå 	
utf16Length
çç 
=
çç 
$num
çç 
;
çç 
for
éé 
(
éé 
var
éé 

utf8Offset
éé 
=
èè 
$num
èè 
;
èè 

utf8Offset
èè 
<
èè  !

utf8Length
èè" ,
;
èè, -
)
èè- .
{
êê 
	Utf8ToUcs
ëë 
(
ëë 
out
ëë 
var
ëë !
ucs
ëë" %
,
ëë% &

utf8Buffer
ëë' 1
,
ëë1 2
ref
ëë3 6

utf8Offset
ëë7 A
,
ëëA B

utf8Length
ëëC M
)
ëëM N
;
ëëN O
if
íí 
(
íí 

UcsToUtf16
íí 
(
íí 
utf16Buffer
íí *
,
íí* +
ref
íí, /
utf16Length
íí0 ;
,
íí; <
utf16Capacity
íí= J
,
ííJ K
ucs
ííL O
)
ííO P
==
ííQ S
ConversionError
ííT c
.
ííc d
Overflow
ííd l
)
ííl m
return
ìì 
ConversionError
ìì *
.
ìì* +
Overflow
ìì+ 3
;
ìì3 4
}
îî 
return
ïï 
ConversionError
ïï "
.
ïï" #
None
ïï# '
;
ïï' (
}
ññ 	
}
óó 
}òò Œ™
oC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\FixedStringAppendMethods.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[ 
BurstCompatible 
] 
public		 

unsafe		 
static		 
partial		  
class		! &
FixedStringMethods		' 9
{

 
[ 	
BurstCompatible	 
(  
GenericTypeArguments -
=. /
new0 3
[3 4
]4 5
{6 7
typeof8 >
(> ?
FixedString128Bytes? R
)R S
}T U
)U V
]V W
public 
static 
FormatError !
Append" (
<( )
T) *
>* +
(+ ,
ref, /
this0 4
T5 6
fs7 9
,9 :
Unicode; B
.B C
RuneC G
runeH L
)L M
where 
T 
: 
struct 
, 
INativeList )
<) *
byte* .
>. /
,/ 0

IUTF8Bytes1 ;
{ 	
var 
len 
= 
fs 
. 
Length 
;  
var 
runeLen 
= 
rune 
. 
LengthInUtf8Bytes 0
(0 1
)1 2
;2 3
if 
( 
! 
fs 
. 
	TryResize 
( 
len !
+" #
runeLen$ +
,+ ,
NativeArrayOptions- ?
.? @
UninitializedMemory@ S
)S T
)T U
return 
FormatError "
." #
Overflow# +
;+ ,
return 
fs 
. 
Write 
( 
ref 
len  #
,# $
rune% )
)) *
;* +
} 	
[$$ 	
BurstCompatible$$	 
($$  
GenericTypeArguments$$ -
=$$. /
new$$0 3
[$$3 4
]$$4 5
{$$6 7
typeof$$8 >
($$> ?
FixedString128Bytes$$? R
)$$R S
}$$T U
)$$U V
]$$V W
public%% 
static%% 
FormatError%% !
Append%%" (
<%%( )
T%%) *
>%%* +
(%%+ ,
ref%%, /
this%%0 4
T%%5 6
fs%%7 9
,%%9 :
char%%; ?
ch%%@ B
)%%B C
where&& 
T&& 
:&& 
struct&& 
,&& 
INativeList&& )
<&&) *
byte&&* .
>&&. /
,&&/ 0

IUTF8Bytes&&1 ;
{'' 	
return(( 
fs(( 
.(( 
Append(( 
((( 
((( 
Unicode(( %
.((% &
Rune((& *
)((* +
ch((, .
)((. /
;((/ 0
})) 	
[55 	
BurstCompatible55	 
(55  
GenericTypeArguments55 -
=55. /
new550 3
[553 4
]554 5
{556 7
typeof558 >
(55> ?
FixedString128Bytes55? R
)55R S
}55T U
)55U V
]55V W
public66 
static66 
FormatError66 !
AppendRawByte66" /
<66/ 0
T660 1
>661 2
(662 3
ref663 6
this667 ;
T66< =
fs66> @
,66@ A
byte66B F
a66G H
)66H I
where77 
T77 
:77 
struct77 
,77 
INativeList77 )
<77) *
byte77* .
>77. /
,77/ 0

IUTF8Bytes771 ;
{88 	
var99 

origLength99 
=99 
fs99 
.99  
Length99  &
;99& '
if:: 
(:: 
!:: 
fs:: 
.:: 
	TryResize:: 
(:: 

origLength:: (
+::) *
$num::+ ,
,::, -
NativeArrayOptions::. @
.::@ A
UninitializedMemory::A T
)::T U
)::U V
return;; 
FormatError;; "
.;;" #
Overflow;;# +
;;;+ ,
fs<< 
.<< 
GetUnsafePtr<< 
(<< 
)<< 
[<< 

origLength<< (
]<<( )
=<<* +
a<<, -
;<<- .
return== 
FormatError== 
.== 
None== #
;==# $
}>> 	
[HH 	
BurstCompatibleHH	 
(HH  
GenericTypeArgumentsHH -
=HH. /
newHH0 3
[HH3 4
]HH4 5
{HH6 7
typeofHH8 >
(HH> ?
FixedString128BytesHH? R
)HHR S
}HHT U
)HHU V
]HHV W
publicII 
staticII 
FormatErrorII !
AppendII" (
<II( )
TII) *
>II* +
(II+ ,
refII, /
thisII0 4
TII5 6
fsII7 9
,II9 :
UnicodeII; B
.IIB C
RuneIIC G
runeIIH L
,IIL M
intIIN Q
countIIR W
)IIW X
whereJJ 
TJJ 
:JJ 
structJJ 
,JJ 
INativeListJJ )
<JJ) *
byteJJ* .
>JJ. /
,JJ/ 0

IUTF8BytesJJ1 ;
{KK 	
varLL 

origLengthLL 
=LL 
fsLL 
.LL  
LengthLL  &
;LL& '
ifNN 
(NN 
!NN 
fsNN 
.NN 
	TryResizeNN 
(NN 

origLengthNN (
+NN) *
runeNN+ /
.NN/ 0
LengthInUtf8BytesNN0 A
(NNA B
)NNB C
*NND E
countNNF K
,NNK L
NativeArrayOptionsNNM _
.NN_ `
UninitializedMemoryNN` s
)NNs t
)NNt u
returnOO 
FormatErrorOO "
.OO" #
OverflowOO# +
;OO+ ,
varQQ 
capQQ 
=QQ 
fsQQ 
.QQ 
CapacityQQ !
;QQ! "
varRR 
bRR 
=RR 
fsRR 
.RR 
GetUnsafePtrRR #
(RR# $
)RR$ %
;RR% &
intSS 
offsetSS 
=SS 

origLengthSS #
;SS# $
forTT 
(TT 
intTT 
iTT 
=TT 
$numTT 
;TT 
iTT 
<TT 
countTT  %
;TT% &
++TT' )
iTT) *
)TT* +
{UU 
varVV 
errorVV 
=VV 
UnicodeVV #
.VV# $
	UcsToUtf8VV$ -
(VV- .
bVV. /
,VV/ 0
refVV1 4
offsetVV5 ;
,VV; <
capVV= @
,VV@ A
runeVVB F
)VVF G
;VVG H
ifWW 
(WW 
errorWW 
!=WW 
ConversionErrorWW ,
.WW, -
NoneWW- 1
)WW1 2
returnXX 
FormatErrorXX &
.XX& '
OverflowXX' /
;XX/ 0
}YY 
return[[ 
FormatError[[ 
.[[ 
None[[ #
;[[# $
}\\ 	
[ee 	
BurstCompatibleee	 
(ee  
GenericTypeArgumentsee -
=ee. /
newee0 3
[ee3 4
]ee4 5
{ee6 7
typeofee8 >
(ee> ?
FixedString128Bytesee? R
)eeR S
}eeT U
)eeU V
]eeV W
publicff 
staticff 
FormatErrorff !
Appendff" (
<ff( )
Tff) *
>ff* +
(ff+ ,
refff, /
thisff0 4
Tff5 6
fsff7 9
,ff9 :
longff; ?
inputff@ E
)ffE F
wheregg 
Tgg 
:gg 
structgg 
,gg 
INativeListgg )
<gg) *
bytegg* .
>gg. /
,gg/ 0

IUTF8Bytesgg1 ;
{hh 	
constii 
intii 
maximumDigitsii #
=ii$ %
$numii& (
;ii( )
varjj 
tempjj 
=jj 

stackallocjj !
bytejj" &
[jj& '
maximumDigitsjj' 4
]jj4 5
;jj5 6
intkk 
offsetkk 
=kk 
maximumDigitskk &
;kk& '
ifll 
(ll 
inputll 
>=ll 
$numll 
)ll 
{mm 
donn 
{oo 
varpp 
digitpp 
=pp 
(pp  !
bytepp! %
)pp% &
(pp& '
inputpp' ,
%pp- .
$numpp/ 1
)pp1 2
;pp2 3
tempqq 
[qq 
--qq 
offsetqq !
]qq! "
=qq# $
(qq% &
byteqq& *
)qq* +
(qq+ ,
$charqq, /
+qq0 1
digitqq2 7
)qq7 8
;qq8 9
inputrr 
/=rr 
$numrr 
;rr  
}ss 
whilett 
(tt 
inputtt 
!=tt 
$numtt  !
)tt! "
;tt" #
}uu 
elsevv 
{ww 
doxx 
{yy 
varzz 
digitzz 
=zz 
(zz  !
bytezz! %
)zz% &
(zz& '
inputzz' ,
%zz- .
$numzz/ 1
)zz1 2
;zz2 3
temp{{ 
[{{ 
--{{ 
offset{{ !
]{{! "
={{# $
({{% &
byte{{& *
){{* +
({{+ ,
$char{{, /
-{{0 1
digit{{2 7
){{7 8
;{{8 9
input|| 
/=|| 
$num|| 
;||  
}}} 
while~~ 
(~~ 
input~~ 
!=~~ 
$num~~  !
)~~! "
;~~" #
temp 
[ 
-- 
offset 
] 
=  
(! "
byte" &
)& '
$char' *
;* +
}
ÄÄ 
return
ÇÇ 
fs
ÇÇ 
.
ÇÇ 
Append
ÇÇ 
(
ÇÇ 
temp
ÇÇ !
+
ÇÇ" #
offset
ÇÇ$ *
,
ÇÇ* +
maximumDigits
ÇÇ, 9
-
ÇÇ: ;
offset
ÇÇ< B
)
ÇÇB C
;
ÇÇC D
}
ÉÉ 	
[
åå 	
BurstCompatible
åå	 
(
åå "
GenericTypeArguments
åå -
=
åå. /
new
åå0 3
[
åå3 4
]
åå4 5
{
åå6 7
typeof
åå8 >
(
åå> ?!
FixedString128Bytes
åå? R
)
ååR S
}
ååT U
)
ååU V
]
ååV W
public
çç 
static
çç 
FormatError
çç !
Append
çç" (
<
çç( )
T
çç) *
>
çç* +
(
çç+ ,
ref
çç, /
this
çç0 4
T
çç5 6
fs
çç7 9
,
çç9 :
int
çç; >
input
çç? D
)
ççD E
where
éé 
T
éé 
:
éé 
struct
éé 
,
éé 
INativeList
éé )
<
éé) *
byte
éé* .
>
éé. /
,
éé/ 0

IUTF8Bytes
éé1 ;
{
èè 	
return
êê 
fs
êê 
.
êê 
Append
êê 
(
êê 
(
êê 
long
êê "
)
êê" #
input
êê# (
)
êê( )
;
êê) *
}
ëë 	
[
öö 	
BurstCompatible
öö	 
(
öö "
GenericTypeArguments
öö -
=
öö. /
new
öö0 3
[
öö3 4
]
öö4 5
{
öö6 7
typeof
öö8 >
(
öö> ?!
FixedString128Bytes
öö? R
)
ööR S
}
ööT U
)
ööU V
]
ööV W
public
õõ 
static
õõ 
FormatError
õõ !
Append
õõ" (
<
õõ( )
T
õõ) *
>
õõ* +
(
õõ+ ,
ref
õõ, /
this
õõ0 4
T
õõ5 6
fs
õõ7 9
,
õõ9 :
ulong
õõ; @
input
õõA F
)
õõF G
where
úú 
T
úú 
:
úú 
struct
úú 
,
úú 
INativeList
úú )
<
úú) *
byte
úú* .
>
úú. /
,
úú/ 0

IUTF8Bytes
úú1 ;
{
ùù 	
const
ûû 
int
ûû 
maximumDigits
ûû #
=
ûû$ %
$num
ûû& (
;
ûû( )
var
üü 
temp
üü 
=
üü 

stackalloc
üü !
byte
üü" &
[
üü& '
maximumDigits
üü' 4
]
üü4 5
;
üü5 6
int
†† 
offset
†† 
=
†† 
maximumDigits
†† &
;
††& '
do
°° 
{
¢¢ 
var
££ 
digit
££ 
=
££ 
(
££ 
byte
££ !
)
££! "
(
££" #
input
££# (
%
££) *
$num
££+ -
)
££- .
;
££. /
temp
§§ 
[
§§ 
--
§§ 
offset
§§ 
]
§§ 
=
§§  
(
§§! "
byte
§§" &
)
§§& '
(
§§' (
$char
§§( +
+
§§, -
digit
§§. 3
)
§§3 4
;
§§4 5
input
•• 
/=
•• 
$num
•• 
;
•• 
}
¶¶ 
while
ßß 
(
ßß 
input
ßß 
!=
ßß 
$num
ßß 
)
ßß 
;
ßß 
return
©© 
fs
©© 
.
©© 
Append
©© 
(
©© 
temp
©© !
+
©©" #
offset
©©$ *
,
©©* +
maximumDigits
©©, 9
-
©©: ;
offset
©©< B
)
©©B C
;
©©C D
}
™™ 	
[
≥≥ 	
BurstCompatible
≥≥	 
(
≥≥ "
GenericTypeArguments
≥≥ -
=
≥≥. /
new
≥≥0 3
[
≥≥3 4
]
≥≥4 5
{
≥≥6 7
typeof
≥≥8 >
(
≥≥> ?!
FixedString128Bytes
≥≥? R
)
≥≥R S
}
≥≥T U
)
≥≥U V
]
≥≥V W
public
¥¥ 
static
¥¥ 
FormatError
¥¥ !
Append
¥¥" (
<
¥¥( )
T
¥¥) *
>
¥¥* +
(
¥¥+ ,
ref
¥¥, /
this
¥¥0 4
T
¥¥5 6
fs
¥¥7 9
,
¥¥9 :
uint
¥¥; ?
input
¥¥@ E
)
¥¥E F
where
µµ 
T
µµ 
:
µµ 
struct
µµ 
,
µµ 
INativeList
µµ )
<
µµ) *
byte
µµ* .
>
µµ. /
,
µµ/ 0

IUTF8Bytes
µµ1 ;
{
∂∂ 	
return
∑∑ 
fs
∑∑ 
.
∑∑ 
Append
∑∑ 
(
∑∑ 
(
∑∑ 
ulong
∑∑ #
)
∑∑# $
input
∑∑$ )
)
∑∑) *
;
∑∑* +
}
∏∏ 	
[
¬¬ 	
BurstCompatible
¬¬	 
(
¬¬ "
GenericTypeArguments
¬¬ -
=
¬¬. /
new
¬¬0 3
[
¬¬3 4
]
¬¬4 5
{
¬¬6 7
typeof
¬¬8 >
(
¬¬> ?!
FixedString128Bytes
¬¬? R
)
¬¬R S
}
¬¬T U
)
¬¬U V
]
¬¬V W
public
√√ 
static
√√ 
FormatError
√√ !
Append
√√" (
<
√√( )
T
√√) *
>
√√* +
(
√√+ ,
ref
√√, /
this
√√0 4
T
√√5 6
fs
√√7 9
,
√√9 :
float
√√; @
input
√√A F
,
√√F G
char
√√H L
decimalSeparator
√√M ]
=
√√^ _
$char
√√` c
)
√√c d
where
ƒƒ 
T
ƒƒ 
:
ƒƒ 
struct
ƒƒ 
,
ƒƒ 
INativeList
ƒƒ )
<
ƒƒ) *
byte
ƒƒ* .
>
ƒƒ. /
,
ƒƒ/ 0

IUTF8Bytes
ƒƒ1 ;
{
≈≈ 	
FixedStringUtils
∆∆ 
.
∆∆ 
UintFloatUnion
∆∆ +
ufu
∆∆, /
=
∆∆0 1
new
∆∆2 5
FixedStringUtils
∆∆6 F
.
∆∆F G
UintFloatUnion
∆∆G U
(
∆∆U V
)
∆∆V W
;
∆∆W X
ufu
«« 
.
«« 

floatValue
«« 
=
«« 
input
«« "
;
««" #
var
»» 
sign
»» 
=
»» 
ufu
»» 
.
»» 
	uintValue
»» $
>>
»»% '
$num
»»( *
;
»»* +
ufu
…… 
.
…… 
	uintValue
…… 
&=
…… 
~
…… 
(
…… 
$num
……  
<<
……! #
$num
……$ &
)
……& '
;
……' (
FormatError
   
error
   
;
   
if
ÀÀ 
(
ÀÀ 
(
ÀÀ 
ufu
ÀÀ 
.
ÀÀ 
	uintValue
ÀÀ 
&
ÀÀ  
$num
ÀÀ! +
)
ÀÀ+ ,
==
ÀÀ- /
$num
ÀÀ0 :
)
ÀÀ: ;
{
ÃÃ 
if
ÕÕ 
(
ÕÕ 
ufu
ÕÕ 
.
ÕÕ 
	uintValue
ÕÕ !
==
ÕÕ" $
$num
ÕÕ% /
)
ÕÕ/ 0
{
ŒŒ 
if
œœ 
(
œœ 
sign
œœ 
!=
œœ 
$num
œœ  !
&&
œœ" $
(
œœ% &
(
œœ& '
error
œœ' ,
=
œœ- .
fs
œœ/ 1
.
œœ1 2
Append
œœ2 8
(
œœ8 9
$char
œœ9 <
)
œœ< =
)
œœ= >
!=
œœ? A
FormatError
œœB M
.
œœM N
None
œœN R
)
œœR S
)
œœS T
return
–– 
error
–– $
;
––$ %
return
—— 
fs
—— 
.
—— 
Append
—— $
(
——$ %
$char
——% (
,
——( )
$char
——* -
,
——- .
$char
——/ 2
,
——2 3
$char
——4 7
,
——7 8
$char
——9 <
,
——< =
$char
——> A
,
——A B
$char
——C F
,
——F G
$char
——H K
)
——K L
;
——L M
}
““ 
return
”” 
fs
”” 
.
”” 
Append
””  
(
””  !
$char
””! $
,
””$ %
$char
””& )
,
””) *
$char
””+ .
)
””. /
;
””/ 0
}
‘‘ 
if
’’ 
(
’’ 
sign
’’ 
!=
’’ 
$num
’’ 
&&
’’ 
ufu
’’  
.
’’  !
	uintValue
’’! *
!=
’’+ -
$num
’’. /
)
’’/ 0
if
÷÷ 
(
÷÷ 
(
÷÷ 
error
÷÷ 
=
÷÷ 
fs
÷÷ 
.
÷÷  
Append
÷÷  &
(
÷÷& '
$char
÷÷' *
)
÷÷* +
)
÷÷+ ,
!=
÷÷- /
FormatError
÷÷0 ;
.
÷÷; <
None
÷÷< @
)
÷÷@ A
return
◊◊ 
error
◊◊  
;
◊◊  !
ulong
ÿÿ 
decimalMantissa
ÿÿ !
=
ÿÿ" #
$num
ÿÿ$ %
;
ÿÿ% &
int
ŸŸ 
decimalExponent
ŸŸ 
=
ŸŸ  !
$num
ŸŸ" #
;
ŸŸ# $
FixedStringUtils
⁄⁄ 
.
⁄⁄ 
Base2ToBase10
⁄⁄ *
(
⁄⁄* +
ref
⁄⁄+ .
decimalMantissa
⁄⁄/ >
,
⁄⁄> ?
ref
⁄⁄@ C
decimalExponent
⁄⁄D S
,
⁄⁄S T
ufu
⁄⁄U X
.
⁄⁄X Y

floatValue
⁄⁄Y c
)
⁄⁄c d
;
⁄⁄d e
var
€€ 
	backwards
€€ 
=
€€ 

stackalloc
€€ &
char
€€' +
[
€€+ ,
$num
€€, -
]
€€- .
;
€€. /
int
‹‹ 
decimalDigits
‹‹ 
=
‹‹ 
$num
‹‹  !
;
‹‹! "
do
›› 
{
ﬁﬁ 
if
ﬂﬂ 
(
ﬂﬂ 
decimalDigits
ﬂﬂ !
>=
ﬂﬂ" $
$num
ﬂﬂ% &
)
ﬂﬂ& '
return
‡‡ 
FormatError
‡‡ &
.
‡‡& '
Overflow
‡‡' /
;
‡‡/ 0
var
·· 
decimalDigit
··  
=
··! "
decimalMantissa
··# 2
%
··3 4
$num
··5 7
;
··7 8
	backwards
‚‚ 
[
‚‚ 
$num
‚‚ 
-
‚‚ 
decimalDigits
‚‚ +
++
‚‚+ -
]
‚‚- .
=
‚‚/ 0
(
‚‚1 2
char
‚‚2 6
)
‚‚6 7
(
‚‚7 8
$char
‚‚8 ;
+
‚‚< =
decimalDigit
‚‚> J
)
‚‚J K
;
‚‚K L
decimalMantissa
„„ 
/=
„„  "
$num
„„# %
;
„„% &
}
‰‰ 
while
ÂÂ 
(
ÂÂ 
decimalMantissa
ÂÂ "
>
ÂÂ# $
$num
ÂÂ% &
)
ÂÂ& '
;
ÂÂ' (
char
ÊÊ 
*
ÊÊ 
ascii
ÊÊ 
=
ÊÊ 
	backwards
ÊÊ #
+
ÊÊ$ %
$num
ÊÊ& '
-
ÊÊ( )
decimalDigits
ÊÊ* 7
;
ÊÊ7 8
var
ÁÁ 
leadingZeroes
ÁÁ 
=
ÁÁ 
-
ÁÁ  !
decimalExponent
ÁÁ! 0
-
ÁÁ1 2
decimalDigits
ÁÁ3 @
+
ÁÁA B
$num
ÁÁC D
;
ÁÁD E
if
ËË 
(
ËË 
leadingZeroes
ËË 
>
ËË 
$num
ËË  !
)
ËË! "
{
ÈÈ 
if
ÍÍ 
(
ÍÍ 
leadingZeroes
ÍÍ !
>
ÍÍ" #
$num
ÍÍ$ %
)
ÍÍ% &
return
ÎÎ 
fs
ÎÎ 
.
ÎÎ 
AppendScientific
ÎÎ .
(
ÎÎ. /
ascii
ÎÎ/ 4
,
ÎÎ4 5
decimalDigits
ÎÎ6 C
,
ÎÎC D
decimalExponent
ÎÎE T
,
ÎÎT U
decimalSeparator
ÎÎV f
)
ÎÎf g
;
ÎÎg h
if
ÏÏ 
(
ÏÏ 
(
ÏÏ 
error
ÏÏ 
=
ÏÏ 
fs
ÏÏ 
.
ÏÏ  
Append
ÏÏ  &
(
ÏÏ& '
$char
ÏÏ' *
,
ÏÏ* +
decimalSeparator
ÏÏ, <
)
ÏÏ< =
)
ÏÏ= >
!=
ÏÏ? A
FormatError
ÏÏB M
.
ÏÏM N
None
ÏÏN R
)
ÏÏR S
return
ÌÌ 
error
ÌÌ  
;
ÌÌ  !
--
ÓÓ 
leadingZeroes
ÓÓ 
;
ÓÓ  
while
ÔÔ 
(
ÔÔ 
leadingZeroes
ÔÔ $
>
ÔÔ% &
$num
ÔÔ' (
)
ÔÔ( )
{
 
if
ÒÒ 
(
ÒÒ 
(
ÒÒ 
error
ÒÒ 
=
ÒÒ  
fs
ÒÒ! #
.
ÒÒ# $
Append
ÒÒ$ *
(
ÒÒ* +
$char
ÒÒ+ .
)
ÒÒ. /
)
ÒÒ/ 0
!=
ÒÒ1 3
FormatError
ÒÒ4 ?
.
ÒÒ? @
None
ÒÒ@ D
)
ÒÒD E
return
ÚÚ 
error
ÚÚ $
;
ÚÚ$ %
--
ÛÛ 
leadingZeroes
ÛÛ #
;
ÛÛ# $
}
ÙÙ 
for
ıı 
(
ıı 
var
ıı 
i
ıı 
=
ıı 
$num
ıı 
;
ıı 
i
ıı  !
<
ıı" #
decimalDigits
ıı$ 1
;
ıı1 2
++
ıı3 5
i
ıı5 6
)
ıı6 7
{
ˆˆ 
if
˜˜ 
(
˜˜ 
(
˜˜ 
error
˜˜ 
=
˜˜  
fs
˜˜! #
.
˜˜# $
Append
˜˜$ *
(
˜˜* +
ascii
˜˜+ 0
[
˜˜0 1
i
˜˜1 2
]
˜˜2 3
)
˜˜3 4
)
˜˜4 5
!=
˜˜6 8
FormatError
˜˜9 D
.
˜˜D E
None
˜˜E I
)
˜˜I J
return
¯¯ 
error
¯¯ $
;
¯¯$ %
}
˘˘ 
return
˙˙ 
FormatError
˙˙ "
.
˙˙" #
None
˙˙# '
;
˙˙' (
}
˚˚ 
var
¸¸ 
trailingZeroes
¸¸ 
=
¸¸  
decimalExponent
¸¸! 0
;
¸¸0 1
if
˝˝ 
(
˝˝ 
trailingZeroes
˝˝ 
>
˝˝  
$num
˝˝! "
)
˝˝" #
{
˛˛ 
if
ˇˇ 
(
ˇˇ 
trailingZeroes
ˇˇ "
>
ˇˇ# $
$num
ˇˇ% &
)
ˇˇ& '
return
ÄÄ 
fs
ÄÄ 
.
ÄÄ 
AppendScientific
ÄÄ .
(
ÄÄ. /
ascii
ÄÄ/ 4
,
ÄÄ4 5
decimalDigits
ÄÄ6 C
,
ÄÄC D
decimalExponent
ÄÄE T
,
ÄÄT U
decimalSeparator
ÄÄV f
)
ÄÄf g
;
ÄÄg h
for
ÅÅ 
(
ÅÅ 
var
ÅÅ 
i
ÅÅ 
=
ÅÅ 
$num
ÅÅ 
;
ÅÅ 
i
ÅÅ  !
<
ÅÅ" #
decimalDigits
ÅÅ$ 1
;
ÅÅ1 2
++
ÅÅ3 5
i
ÅÅ5 6
)
ÅÅ6 7
{
ÇÇ 
if
ÉÉ 
(
ÉÉ 
(
ÉÉ 
error
ÉÉ 
=
ÉÉ  
fs
ÉÉ! #
.
ÉÉ# $
Append
ÉÉ$ *
(
ÉÉ* +
ascii
ÉÉ+ 0
[
ÉÉ0 1
i
ÉÉ1 2
]
ÉÉ2 3
)
ÉÉ3 4
)
ÉÉ4 5
!=
ÉÉ6 8
FormatError
ÉÉ9 D
.
ÉÉD E
None
ÉÉE I
)
ÉÉI J
return
ÑÑ 
error
ÑÑ $
;
ÑÑ$ %
}
ÖÖ 
while
ÜÜ 
(
ÜÜ 
trailingZeroes
ÜÜ %
>
ÜÜ& '
$num
ÜÜ( )
)
ÜÜ) *
{
áá 
if
àà 
(
àà 
(
àà 
error
àà 
=
àà  
fs
àà! #
.
àà# $
Append
àà$ *
(
àà* +
$char
àà+ .
)
àà. /
)
àà/ 0
!=
àà1 3
FormatError
àà4 ?
.
àà? @
None
àà@ D
)
ààD E
return
ââ 
error
ââ $
;
ââ$ %
--
ää 
trailingZeroes
ää $
;
ää$ %
}
ãã 
return
åå 
FormatError
åå "
.
åå" #
None
åå# '
;
åå' (
}
çç 
var
éé 
indexOfSeparator
éé  
=
éé! "
decimalDigits
éé# 0
+
éé1 2
decimalExponent
éé3 B
;
ééB C
for
èè 
(
èè 
var
èè 
i
èè 
=
èè 
$num
èè 
;
èè 
i
èè 
<
èè 
decimalDigits
èè  -
;
èè- .
++
èè/ 1
i
èè1 2
)
èè2 3
{
êê 
if
ëë 
(
ëë 
i
ëë 
==
ëë 
indexOfSeparator
ëë )
)
ëë) *
if
íí 
(
íí 
(
íí 
error
íí 
=
íí  
fs
íí! #
.
íí# $
Append
íí$ *
(
íí* +
decimalSeparator
íí+ ;
)
íí; <
)
íí< =
!=
íí> @
FormatError
ííA L
.
ííL M
None
ííM Q
)
ííQ R
return
ìì 
error
ìì $
;
ìì$ %
if
îî 
(
îî 
(
îî 
error
îî 
=
îî 
fs
îî 
.
îî  
Append
îî  &
(
îî& '
ascii
îî' ,
[
îî, -
i
îî- .
]
îî. /
)
îî/ 0
)
îî0 1
!=
îî2 4
FormatError
îî5 @
.
îî@ A
None
îîA E
)
îîE F
return
ïï 
error
ïï  
;
ïï  !
}
ññ 
return
óó 
FormatError
óó 
.
óó 
None
óó #
;
óó# $
}
òò 	
[
•• 	
BurstCompatible
••	 
(
•• "
GenericTypeArguments
•• -
=
••. /
new
••0 3
[
••3 4
]
••4 5
{
••6 7
typeof
••8 >
(
••> ?!
FixedString128Bytes
••? R
)
••R S
,
••S T
typeof
••U [
(
••[ \!
FixedString128Bytes
••\ o
)
••o p
}
••q r
)
••r s
]
••s t
public
¶¶ 
static
¶¶ 
FormatError
¶¶ !
Append
¶¶" (
<
¶¶( )
T
¶¶) *
,
¶¶* +
T2
¶¶+ -
>
¶¶- .
(
¶¶. /
ref
¶¶/ 2
this
¶¶3 7
T
¶¶8 9
fs
¶¶: <
,
¶¶< =
in
¶¶> @
T2
¶¶A C
input
¶¶D I
)
¶¶I J
where
ßß 
T
ßß 
:
ßß 
struct
ßß 
,
ßß 
INativeList
ßß )
<
ßß) *
byte
ßß* .
>
ßß. /
,
ßß/ 0

IUTF8Bytes
ßß1 ;
where
®® 
T2
®® 
:
®® 
struct
®® 
,
®® 
INativeList
®® *
<
®®* +
byte
®®+ /
>
®®/ 0
,
®®0 1

IUTF8Bytes
®®2 <
{
©© 	
ref
™™ 
var
™™ 
inputRef
™™ 
=
™™ 
ref
™™ "%
UnsafeUtilityExtensions
™™# :
.
™™: ;
AsRef
™™; @
(
™™@ A
input
™™A F
)
™™F G
;
™™G H
return
´´ 
fs
´´ 
.
´´ 
Append
´´ 
(
´´ 
inputRef
´´ %
.
´´% &
GetUnsafePtr
´´& 2
(
´´2 3
)
´´3 4
,
´´4 5
inputRef
´´6 >
.
´´> ?
Length
´´? E
)
´´E F
;
´´F G
}
¨¨ 	
[
ππ 	
BurstCompatible
ππ	 
(
ππ "
GenericTypeArguments
ππ -
=
ππ. /
new
ππ0 3
[
ππ3 4
]
ππ4 5
{
ππ6 7
typeof
ππ8 >
(
ππ> ?!
FixedString128Bytes
ππ? R
)
ππR S
,
ππS T
typeof
ππU [
(
ππ[ \!
FixedString128Bytes
ππ\ o
)
ππo p
}
ππq r
)
ππr s
]
ππs t
public
∫∫ 
static
∫∫ 
	CopyError
∫∫ 
CopyFrom
∫∫  (
<
∫∫( )
T
∫∫) *
,
∫∫* +
T2
∫∫, .
>
∫∫. /
(
∫∫/ 0
ref
∫∫0 3
this
∫∫4 8
T
∫∫9 :
fs
∫∫; =
,
∫∫= >
in
∫∫? A
T2
∫∫B D
input
∫∫E J
)
∫∫J K
where
ªª 
T
ªª 
:
ªª 
struct
ªª 
,
ªª 
INativeList
ªª )
<
ªª) *
byte
ªª* .
>
ªª. /
,
ªª/ 0

IUTF8Bytes
ªª1 ;
where
ºº 
T2
ºº 
:
ºº 
struct
ºº 
,
ºº 
INativeList
ºº *
<
ºº* +
byte
ºº+ /
>
ºº/ 0
,
ºº0 1

IUTF8Bytes
ºº2 <
{
ΩΩ 	
fs
ææ 
.
ææ 
Length
ææ 
=
ææ 
$num
ææ 
;
ææ 
var
øø 
fe
øø 
=
øø 
Append
øø 
(
øø 
ref
øø 
fs
øø  "
,
øø" #
input
øø$ )
)
øø) *
;
øø* +
if
¿¿ 
(
¿¿ 
fe
¿¿ 
!=
¿¿ 
FormatError
¿¿ !
.
¿¿! "
None
¿¿" &
)
¿¿& '
return
¡¡ 
	CopyError
¡¡  
.
¡¡  !

Truncation
¡¡! +
;
¡¡+ ,
return
¬¬ 
	CopyError
¬¬ 
.
¬¬ 
None
¬¬ !
;
¬¬! "
}
√√ 	
[
““ 	
BurstCompatible
““	 
(
““ "
GenericTypeArguments
““ -
=
““. /
new
““0 3
[
““3 4
]
““4 5
{
““6 7
typeof
““8 >
(
““> ?!
FixedString128Bytes
““? R
)
““R S
}
““T U
)
““U V
]
““V W
public
”” 
unsafe
”” 
static
”” 
FormatError
”” (
Append
””) /
<
””/ 0
T
””0 1
>
””1 2
(
””2 3
ref
””3 6
this
””7 ;
T
””< =
fs
””> @
,
””@ A
byte
””B F
*
””F G
	utf8Bytes
””H Q
,
””Q R
int
””S V
utf8BytesLength
””W f
)
””f g
where
‘‘ 
T
‘‘ 
:
‘‘ 
struct
‘‘ 
,
‘‘ 
INativeList
‘‘ )
<
‘‘) *
byte
‘‘* .
>
‘‘. /
,
‘‘/ 0

IUTF8Bytes
‘‘1 ;
{
’’ 	
var
÷÷ 

origLength
÷÷ 
=
÷÷ 
fs
÷÷ 
.
÷÷  
Length
÷÷  &
;
÷÷& '
if
◊◊ 
(
◊◊ 
!
◊◊ 
fs
◊◊ 
.
◊◊ 
	TryResize
◊◊ 
(
◊◊ 

origLength
◊◊ (
+
◊◊) *
utf8BytesLength
◊◊+ :
,
◊◊: ; 
NativeArrayOptions
◊◊< N
.
◊◊N O!
UninitializedMemory
◊◊O b
)
◊◊b c
)
◊◊c d
return
ÿÿ 
FormatError
ÿÿ "
.
ÿÿ" #
Overflow
ÿÿ# +
;
ÿÿ+ ,
UnsafeUtility
ŸŸ 
.
ŸŸ 
MemCpy
ŸŸ  
(
ŸŸ  !
fs
ŸŸ! #
.
ŸŸ# $
GetUnsafePtr
ŸŸ$ 0
(
ŸŸ0 1
)
ŸŸ1 2
+
ŸŸ3 4

origLength
ŸŸ5 ?
,
ŸŸ? @
	utf8Bytes
ŸŸA J
,
ŸŸJ K
utf8BytesLength
ŸŸL [
)
ŸŸ[ \
;
ŸŸ\ ]
return
⁄⁄ 
FormatError
⁄⁄ 
.
⁄⁄ 
None
⁄⁄ #
;
⁄⁄# $
}
€€ 	
[
ÁÁ 	 
NotBurstCompatible
ÁÁ	 
]
ÁÁ 
public
ËË 
unsafe
ËË 
static
ËË 
FormatError
ËË (
Append
ËË) /
<
ËË/ 0
T
ËË0 1
>
ËË1 2
(
ËË2 3
ref
ËË3 6
this
ËË7 ;
T
ËË< =
fs
ËË> @
,
ËË@ A
string
ËËB H
s
ËËI J
)
ËËJ K
where
ÈÈ 
T
ÈÈ 
:
ÈÈ 
struct
ÈÈ 
,
ÈÈ 
INativeList
ÈÈ )
<
ÈÈ) *
byte
ÈÈ* .
>
ÈÈ. /
,
ÈÈ/ 0

IUTF8Bytes
ÈÈ1 ;
{
ÍÍ 	
int
ÏÏ 
worstCaseCapacity
ÏÏ !
=
ÏÏ" #
s
ÏÏ$ %
.
ÏÏ% &
Length
ÏÏ& ,
*
ÏÏ- .
$num
ÏÏ/ 0
;
ÏÏ0 1
byte
ÌÌ 
*
ÌÌ 
	utf8Bytes
ÌÌ 
=
ÌÌ 

stackalloc
ÌÌ (
byte
ÌÌ) -
[
ÌÌ- .
worstCaseCapacity
ÌÌ. ?
]
ÌÌ? @
;
ÌÌ@ A
int
ÓÓ 
utf8Len
ÓÓ 
;
ÓÓ 
fixed
 
(
 
char
 
*
 
chars
 
=
  
s
! "
)
" #
{
ÒÒ 
var
ÚÚ 
err
ÚÚ 
=
ÚÚ $
UTF8ArrayUnsafeUtility
ÚÚ 0
.
ÚÚ0 1
Copy
ÚÚ1 5
(
ÚÚ5 6
	utf8Bytes
ÚÚ6 ?
,
ÚÚ? @
out
ÚÚA D
utf8Len
ÚÚE L
,
ÚÚL M
worstCaseCapacity
ÚÚN _
,
ÚÚ_ `
chars
ÚÚa f
,
ÚÚf g
s
ÚÚh i
.
ÚÚi j
Length
ÚÚj p
)
ÚÚp q
;
ÚÚq r
if
ÛÛ 
(
ÛÛ 
err
ÛÛ 
!=
ÛÛ 
	CopyError
ÛÛ $
.
ÛÛ$ %
None
ÛÛ% )
)
ÛÛ) *
{
ÙÙ 
return
ıı 
FormatError
ıı &
.
ıı& '
Overflow
ıı' /
;
ıı/ 0
}
ˆˆ 
}
˜˜ 
return
˘˘ 
fs
˘˘ 
.
˘˘ 
Append
˘˘ 
(
˘˘ 
	utf8Bytes
˘˘ &
,
˘˘& '
utf8Len
˘˘( /
)
˘˘/ 0
;
˘˘0 1
}
˙˙ 	
[
ÜÜ 	 
NotBurstCompatible
ÜÜ	 
]
ÜÜ 
public
áá 
static
áá 
	CopyError
áá 
CopyFrom
áá  (
<
áá( )
T
áá) *
>
áá* +
(
áá+ ,
ref
áá, /
this
áá0 4
T
áá5 6
fs
áá7 9
,
áá9 :
string
áá; A
s
ááB C
)
ááC D
where
àà 
T
àà 
:
àà 
struct
àà 
,
àà 
INativeList
àà )
<
àà) *
byte
àà* .
>
àà. /
,
àà/ 0

IUTF8Bytes
àà1 ;
{
ââ 	
fs
ää 
.
ää 
Length
ää 
=
ää 
$num
ää 
;
ää 
var
ãã 
fe
ãã 
=
ãã 
Append
ãã 
(
ãã 
ref
ãã 
fs
ãã  "
,
ãã" #
s
ãã$ %
)
ãã% &
;
ãã& '
if
åå 
(
åå 
fe
åå 
!=
åå 
FormatError
åå !
.
åå! "
None
åå" &
)
åå& '
return
çç 
	CopyError
çç  
.
çç  !

Truncation
çç! +
;
çç+ ,
return
éé 
	CopyError
éé 
.
éé 
None
éé !
;
éé! "
}
èè 	
[
óó 	 
NotBurstCompatible
óó	 
]
óó 
public
òò 
static
òò 
void
òò 
CopyFromTruncated
òò ,
<
òò, -
T
òò- .
>
òò. /
(
òò/ 0
ref
òò0 3
this
òò4 8
T
òò9 :
fs
òò; =
,
òò= >
string
òò? E
s
òòF G
)
òòG H
where
ôô 
T
ôô 
:
ôô 
struct
ôô 
,
ôô 
INativeList
ôô )
<
ôô) *
byte
ôô* .
>
ôô. /
,
ôô/ 0

IUTF8Bytes
ôô1 ;
{
öö 	
int
õõ 
utf8Len
õõ 
;
õõ 
fixed
úú 
(
úú 
char
úú 
*
úú 
chars
úú 
=
úú  
s
úú! "
)
úú" #
{
ùù $
UTF8ArrayUnsafeUtility
ûû &
.
ûû& '
Copy
ûû' +
(
ûû+ ,
fs
ûû, .
.
ûû. /
GetUnsafePtr
ûû/ ;
(
ûû; <
)
ûû< =
,
ûû= >
out
ûû? B
utf8Len
ûûC J
,
ûûJ K
fs
ûûL N
.
ûûN O
Capacity
ûûO W
,
ûûW X
chars
ûûY ^
,
ûû^ _
s
ûû` a
.
ûûa b
Length
ûûb h
)
ûûh i
;
ûûi j
fs
üü 
.
üü 
Length
üü 
=
üü 
utf8Len
üü #
;
üü# $
}
†† 
}
°° 	
}
¢¢ 
}££ ≤Í
dC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeHashMap.cs
	namespace

 	
Unity


 
.

 
Collections

 
{ 
[ 
BurstCompatible 
(  
GenericTypeArguments )
=* +
new, /
[0 1
]1 2
{3 4
typeof5 ;
(; <
int< ?
)? @
,@ A
typeofB H
(H I
intI L
)L M
}N O
)O P
]P Q
public 

struct  
NativeKeyValueArrays &
<& '
TKey' +
,+ ,
TValue- 3
>3 4
: 	
INativeDisposable
 
where 
TKey 
: 
struct 
where 
TValue 
: 
struct 
{ 
public 
NativeArray 
< 
TKey 
>  
Keys! %
;% &
public%% 
NativeArray%% 
<%% 
TValue%% !
>%%! "
Values%%# )
;%%) *
public++ 
int++ 
Length++ 
=>++ 
Keys++ !
.++! "
Length++" (
;++( )
public33  
NativeKeyValueArrays33 #
(33# $
int33$ '
length33( .
,33. /
AllocatorManager330 @
.33@ A
AllocatorHandle33A P
	allocator33Q Z
,33Z [
NativeArrayOptions33\ n
options33o v
)33v w
{44 	
Keys55 
=55 
CollectionHelper55 #
.55# $
CreateNativeArray55$ 5
<555 6
TKey556 :
>55: ;
(55; <
length55< B
,55B C
	allocator55D M
,55M N
options55O V
)55V W
;55W X
Values66 
=66 
CollectionHelper66 %
.66% &
CreateNativeArray66& 7
<667 8
TValue668 >
>66> ?
(66? @
length66@ F
,66F G
	allocator66H Q
,66Q R
options66S Z
)66Z [
;66[ \
}77 	
public<< 
void<< 
Dispose<< 
(<< 
)<< 
{== 	
Keys>> 
.>> 
Dispose>> 
(>> 
)>> 
;>> 
Values?? 
.?? 
Dispose?? 
(?? 
)?? 
;?? 
}@@ 	
[GG 	
NotBurstCompatibleGG	 
]
GGú ù
publicHH 
	JobHandleHH 
DisposeHH  
(HH  !
	JobHandleHH! *
	inputDepsHH+ 4
)HH4 5
{II 	
returnJJ 
KeysJJ 
.JJ 
DisposeJJ 
(JJ  
ValuesJJ  &
.JJ& '
DisposeJJ' .
(JJ. /
	inputDepsJJ/ 8
)JJ8 9
)JJ9 :
;JJ: ;
}KK 	
}LL 
[SS 
StructLayoutSS 
(SS 

LayoutKindSS 
.SS 

SequentialSS '
)SS' (
]SS( )
[TT 
NativeContainerTT 
]TT 
[UU 
DebuggerDisplayUU 
(UU 
$str	UU ó
)
UUó ò
]
UUò ô
[VV 
DebuggerTypeProxyVV 
(VV 
typeofVV 
(VV *
NativeHashMapDebuggerTypeProxyVV <
<VV< =
,VV= >
>VV> ?
)VV? @
)VV@ A
]VVA B
[WW 
BurstCompatibleWW 
(WW  
GenericTypeArgumentsWW )
=WW* +
newWW, /
[WW0 1
]WW1 2
{WW3 4
typeofWW5 ;
(WW; <
intWW< ?
)WW? @
,WW@ A
typeofWWB H
(WWH I
intWWI L
)WWL M
}WWN O
)WWO P
]WWP Q
publicXX 

unsafeXX 
structXX 
NativeHashMapXX &
<XX& '
TKeyXX' +
,XX+ ,
TValueXX- 3
>XX3 4
:YY 	
INativeDisposableYY
 
,ZZ 	
IEnumerableZZ
 
<ZZ 
KeyValueZZ 
<ZZ 
TKeyZZ #
,ZZ# $
TValueZZ% +
>ZZ+ ,
>ZZ, -
where[[ 
TKey[[ 
:[[ 
struct[[ 
,[[ 

IEquatable[[ '
<[[' (
TKey[[( ,
>[[, -
where\\ 
TValue\\ 
:\\ 
struct\\ 
{]] 
internal^^ 
UnsafeHashMap^^ 
<^^ 
TKey^^ #
,^^# $
TValue^^% +
>^^+ ,
m_HashMapData^^- :
;^^: ;
internalaa 
AtomicSafetyHandleaa #
m_Safetyaa$ ,
;aa, -
staticbb 
readonlybb 
SharedStaticbb $
<bb$ %
intbb% (
>bb( )
s_staticSafetyIdbb* :
=bb; <
SharedStaticbb= I
<bbI J
intbbJ M
>bbM N
.bbN O
GetOrCreatebbO Z
<bbZ [
NativeHashMapbb[ h
<bbh i
TKeybbi m
,bbm n
TValuebbo u
>bbu v
>bbv w
(bbw x
)bbx y
;bby z
[ff 	.
"NativeSetClassTypeToNullOnScheduleff	 +
]ff+ ,
DisposeSentinelgg 
m_DisposeSentinelgg )
;gg) *
publicpp 
NativeHashMappp 
(pp 
intpp  
capacitypp! )
,pp) *
AllocatorManagerpp+ ;
.pp; <
AllocatorHandlepp< K
	allocatorppL U
)ppU V
:qq 
thisqq 
(qq 
capacityqq 
,qq 
	allocatorqq &
,qq& '
$numqq( )
)qq) *
{rr 	
}ss 	
NativeHashMapuu 
(uu 
intuu 
capacityuu "
,uu" #
AllocatorManageruu$ 4
.uu4 5
AllocatorHandleuu5 D
	allocatoruuE N
,uuN O
intuuP S%
disposeSentinelStackDepthuuT m
)uum n
{vv 	
m_HashMapDataww 
=ww 
newww 
UnsafeHashMapww  -
<ww- .
TKeyww. 2
,ww2 3
TValueww4 :
>ww: ;
(ww; <
capacityww< D
,wwD E
	allocatorwwF O
)wwO P
;wwP Q
if}} 
(}} 
AllocatorManager}}  
.}}  !
IsCustomAllocator}}! 2
(}}2 3
	allocator}}3 <
.}}< =
ToAllocator}}= H
)}}H I
)}}I J
{~~ 
m_Safety 
= 
AtomicSafetyHandle -
.- .
Create. 4
(4 5
)5 6
;6 7
m_DisposeSentinel
ÄÄ !
=
ÄÄ" #
null
ÄÄ$ (
;
ÄÄ( )
}
ÅÅ 
else
ÇÇ 
{
ÉÉ 
DisposeSentinel
ÑÑ 
.
ÑÑ  
Create
ÑÑ  &
(
ÑÑ& '
out
ÑÑ' *
m_Safety
ÑÑ+ 3
,
ÑÑ3 4
out
ÑÑ5 8
m_DisposeSentinel
ÑÑ9 J
,
ÑÑJ K'
disposeSentinelStackDepth
ÑÑL e
,
ÑÑe f
	allocator
ÑÑg p
.
ÑÑp q
ToAllocator
ÑÑq |
)
ÑÑ| }
;
ÑÑ} ~
}
ÖÖ 
CollectionHelper
àà 
.
àà 
SetStaticSafetyId
àà .
<
àà. /
NativeHashMap
àà/ <
<
àà< =
TKey
àà= A
,
ààA B
TValue
ààC I
>
ààI J
>
ààJ K
(
ààK L
ref
ààL O
m_Safety
ààP X
,
ààX Y
ref
ààZ ]
s_staticSafetyId
àà^ n
.
ààn o
Data
àào s
)
ààs t
;
ààt u 
AtomicSafetyHandle
ââ 
.
ââ 4
&SetBumpSecondaryVersionOnScheduleWrite
ââ E
(
ââE F
m_Safety
ââF N
,
ââN O
true
ââP T
)
ââT U
;
ââU V
}
ãã 	
public
ëë 
bool
ëë 
IsEmpty
ëë 
{
íí 	
get
ìì 
{
îî 
if
ïï 
(
ïï 
!
ïï 
	IsCreated
ïï 
)
ïï 
{
ññ 
return
óó 
true
óó 
;
óó  
}
òò 
	CheckRead
öö 
(
öö 
)
öö 
;
öö 
return
õõ 
m_HashMapData
õõ $
.
õõ$ %
IsEmpty
õõ% ,
;
õõ, -
}
úú 
}
ùù 	
public
££ 
int
££ 
Count
££ 
(
££ 
)
££ 
{
§§ 	
	CheckRead
•• 
(
•• 
)
•• 
;
•• 
return
¶¶ 
m_HashMapData
¶¶  
.
¶¶  !
Count
¶¶! &
(
¶¶& '
)
¶¶' (
;
¶¶( )
}
ßß 	
public
ØØ 
int
ØØ 
Capacity
ØØ 
{
∞∞ 	
get
±± 
{
≤≤ 
	CheckRead
≥≥ 
(
≥≥ 
)
≥≥ 
;
≥≥ 
return
¥¥ 
m_HashMapData
¥¥ $
.
¥¥$ %
Capacity
¥¥% -
;
¥¥- .
}
µµ 
set
∑∑ 
{
∏∏ 

CheckWrite
ππ 
(
ππ 
)
ππ 
;
ππ 
m_HashMapData
∫∫ 
.
∫∫ 
Capacity
∫∫ &
=
∫∫' (
value
∫∫) .
;
∫∫. /
}
ªª 
}
ºº 	
public
¬¬ 
void
¬¬ 
Clear
¬¬ 
(
¬¬ 
)
¬¬ 
{
√√ 	

CheckWrite
ƒƒ 
(
ƒƒ 
)
ƒƒ 
;
ƒƒ 
m_HashMapData
≈≈ 
.
≈≈ 
Clear
≈≈ 
(
≈≈  
)
≈≈  !
;
≈≈! "
}
∆∆ 	
public
–– 
bool
–– 
TryAdd
–– 
(
–– 
TKey
–– 
key
––  #
,
––# $
TValue
––% +
item
––, 0
)
––0 1
{
—— 	

CheckWrite
““ 
(
““ 
)
““ 
;
““ 
return
”” 
m_HashMapData
””  
.
””  !
TryAdd
””! '
(
””' (
key
””( +
,
””+ ,
item
””- 1
)
””1 2
;
””2 3
}
‘‘ 	
public
›› 
void
›› 
Add
›› 
(
›› 
TKey
›› 
key
››  
,
››  !
TValue
››" (
item
››) -
)
››- .
{
ﬁﬁ 	
var
ﬂﬂ 
added
ﬂﬂ 
=
ﬂﬂ 
TryAdd
ﬂﬂ 
(
ﬂﬂ 
key
ﬂﬂ "
,
ﬂﬂ" #
item
ﬂﬂ$ (
)
ﬂﬂ( )
;
ﬂﬂ) *
if
·· 
(
·· 
!
·· 
added
·· 
)
·· 
{
‚‚ "
ThrowKeyAlreadyAdded
„„ $
(
„„$ %
key
„„% (
)
„„( )
;
„„) *
}
‰‰ 
}
ÂÂ 	
public
ÏÏ 
bool
ÏÏ 
Remove
ÏÏ 
(
ÏÏ 
TKey
ÏÏ 
key
ÏÏ  #
)
ÏÏ# $
{
ÌÌ 	

CheckWrite
ÓÓ 
(
ÓÓ 
)
ÓÓ 
;
ÓÓ 
return
ÔÔ 
m_HashMapData
ÔÔ  
.
ÔÔ  !
Remove
ÔÔ! '
(
ÔÔ' (
key
ÔÔ( +
)
ÔÔ+ ,
;
ÔÔ, -
}
 	
public
¯¯ 
bool
¯¯ 
TryGetValue
¯¯ 
(
¯¯  
TKey
¯¯  $
key
¯¯% (
,
¯¯( )
out
¯¯* -
TValue
¯¯. 4
item
¯¯5 9
)
¯¯9 :
{
˘˘ 	
	CheckRead
˙˙ 
(
˙˙ 
)
˙˙ 
;
˙˙ 
return
˚˚ 
m_HashMapData
˚˚  
.
˚˚  !
TryGetValue
˚˚! ,
(
˚˚, -
key
˚˚- 0
,
˚˚0 1
out
˚˚2 5
item
˚˚6 :
)
˚˚: ;
;
˚˚; <
}
¸¸ 	
public
ÉÉ 
bool
ÉÉ 
ContainsKey
ÉÉ 
(
ÉÉ  
TKey
ÉÉ  $
key
ÉÉ% (
)
ÉÉ( )
{
ÑÑ 	
	CheckRead
ÖÖ 
(
ÖÖ 
)
ÖÖ 
;
ÖÖ 
return
ÜÜ 
m_HashMapData
ÜÜ  
.
ÜÜ  !
ContainsKey
ÜÜ! ,
(
ÜÜ, -
key
ÜÜ- 0
)
ÜÜ0 1
;
ÜÜ1 2
}
áá 	
public
êê 
TValue
êê 
this
êê 
[
êê 
TKey
êê 
key
êê  #
]
êê# $
{
ëë 	
get
íí 
{
ìì 
	CheckRead
îî 
(
îî 
)
îî 
;
îî 
TValue
ññ 
res
ññ 
;
ññ 
if
òò 
(
òò 
m_HashMapData
òò !
.
òò! "
TryGetValue
òò" -
(
òò- .
key
òò. 1
,
òò1 2
out
òò3 6
res
òò7 :
)
òò: ;
)
òò; <
{
ôô 
return
öö 
res
öö 
;
öö 
}
õõ  
ThrowKeyNotPresent
ùù "
(
ùù" #
key
ùù# &
)
ùù& '
;
ùù' (
return
üü 
default
üü 
;
üü 
}
†† 
set
¢¢ 
{
££ 

CheckWrite
§§ 
(
§§ 
)
§§ 
;
§§ 
m_HashMapData
•• 
[
•• 
key
•• !
]
••! "
=
••# $
value
••% *
;
••* +
}
¶¶ 
}
ßß 	
public
≠≠ 
bool
≠≠ 
	IsCreated
≠≠ 
=>
≠≠  
m_HashMapData
≠≠! .
.
≠≠. /
	IsCreated
≠≠/ 8
;
≠≠8 9
public
≤≤ 
void
≤≤ 
Dispose
≤≤ 
(
≤≤ 
)
≤≤ 
{
≥≥ 	
DisposeSentinel
∏∏ 
.
∏∏ 
Dispose
∏∏ #
(
∏∏# $
ref
∏∏$ '
m_Safety
∏∏( 0
,
∏∏0 1
ref
∏∏2 5
m_DisposeSentinel
∏∏6 G
)
∏∏G H
;
∏∏H I
m_HashMapData
ªª 
.
ªª 
Dispose
ªª !
(
ªª! "
)
ªª" #
;
ªª# $
}
ºº 	
[
√√ 	 
NotBurstCompatible
√√	 
]√√ú ù
public
ƒƒ 
	JobHandle
ƒƒ 
Dispose
ƒƒ  
(
ƒƒ  !
	JobHandle
ƒƒ! *
	inputDeps
ƒƒ+ 4
)
ƒƒ4 5
{
≈≈ 	
DisposeSentinel
ÕÕ 
.
ÕÕ 
Clear
ÕÕ !
(
ÕÕ! "
ref
ÕÕ" %
m_DisposeSentinel
ÕÕ& 7
)
ÕÕ7 8
;
ÕÕ8 9
var
–– 
	jobHandle
–– 
=
–– 
new
–– )
UnsafeHashMapDataDisposeJob
––  ;
{
––< =
Data
––> B
=
––C D
new
––E H&
UnsafeHashMapDataDispose
––I a
{
––b c
m_Buffer
––d l
=
––m n
m_HashMapData
––o |
.
––| }
m_Buffer––} Ö
,––Ö Ü 
m_AllocatorLabel––á ó
=––ò ô
m_HashMapData––ö ß
.––ß ® 
m_AllocatorLabel––® ∏
,––∏ π
m_Safety––∫ ¬
=––√ ƒ
m_Safety––≈ Õ
}––Œ œ
}––– —
.––— “
Schedule––“ ⁄
(––⁄ €
	inputDeps––€ ‰
)––‰ Â
;––Â Ê 
AtomicSafetyHandle
““ 
.
““ 
Release
““ &
(
““& '
m_Safety
““' /
)
““/ 0
;
““0 1
m_HashMapData
÷÷ 
.
÷÷ 
m_Buffer
÷÷ "
=
÷÷# $
null
÷÷% )
;
÷÷) *
return
ÿÿ 
	jobHandle
ÿÿ 
;
ÿÿ 
}
ŸŸ 	
public
‡‡ 
NativeArray
‡‡ 
<
‡‡ 
TKey
‡‡ 
>
‡‡  
GetKeyArray
‡‡! ,
(
‡‡, -
AllocatorManager
‡‡- =
.
‡‡= >
AllocatorHandle
‡‡> M
	allocator
‡‡N W
)
‡‡W X
{
·· 	
	CheckRead
‚‚ 
(
‚‚ 
)
‚‚ 
;
‚‚ 
return
„„ 
m_HashMapData
„„  
.
„„  !
GetKeyArray
„„! ,
(
„„, -
	allocator
„„- 6
)
„„6 7
;
„„7 8
}
‰‰ 	
public
ÎÎ 
NativeArray
ÎÎ 
<
ÎÎ 
TValue
ÎÎ !
>
ÎÎ! "
GetValueArray
ÎÎ# 0
(
ÎÎ0 1
AllocatorManager
ÎÎ1 A
.
ÎÎA B
AllocatorHandle
ÎÎB Q
	allocator
ÎÎR [
)
ÎÎ[ \
{
ÏÏ 	
	CheckRead
ÌÌ 
(
ÌÌ 
)
ÌÌ 
;
ÌÌ 
return
ÓÓ 
m_HashMapData
ÓÓ  
.
ÓÓ  !
GetValueArray
ÓÓ! .
(
ÓÓ. /
	allocator
ÓÓ/ 8
)
ÓÓ8 9
;
ÓÓ9 :
}
ÔÔ 	
public
˜˜ "
NativeKeyValueArrays
˜˜ #
<
˜˜# $
TKey
˜˜$ (
,
˜˜( )
TValue
˜˜* 0
>
˜˜0 1
GetKeyValueArrays
˜˜2 C
(
˜˜C D
AllocatorManager
˜˜D T
.
˜˜T U
AllocatorHandle
˜˜U d
	allocator
˜˜e n
)
˜˜n o
{
¯¯ 	
	CheckRead
˘˘ 
(
˘˘ 
)
˘˘ 
;
˘˘ 
return
˙˙ 
m_HashMapData
˙˙  
.
˙˙  !
GetKeyValueArrays
˙˙! 2
(
˙˙2 3
	allocator
˙˙3 <
)
˙˙< =
;
˙˙= >
}
˚˚ 	
public
ÅÅ 
ParallelWriter
ÅÅ 
AsParallelWriter
ÅÅ .
(
ÅÅ. /
)
ÅÅ/ 0
{
ÇÇ 	
ParallelWriter
ÉÉ 
writer
ÉÉ !
;
ÉÉ! "
writer
ÑÑ 
.
ÑÑ 
m_Writer
ÑÑ 
=
ÑÑ 
m_HashMapData
ÑÑ +
.
ÑÑ+ ,
AsParallelWriter
ÑÑ, <
(
ÑÑ< =
)
ÑÑ= >
;
ÑÑ> ?
writer
ÜÜ 
.
ÜÜ 
m_Safety
ÜÜ 
=
ÜÜ 
m_Safety
ÜÜ &
;
ÜÜ& '
CollectionHelper
áá 
.
áá 
SetStaticSafetyId
áá .
<
áá. /
ParallelWriter
áá/ =
>
áá= >
(
áá> ?
ref
áá? B
writer
ááC I
.
ááI J
m_Safety
ááJ R
,
ááR S
ref
ááT W
ParallelWriter
ááX f
.
ááf g
s_staticSafetyId
áág w
.
ááw x
Data
ááx |
)
áá| }
;
áá} ~
return
ââ 
writer
ââ 
;
ââ 
}
ää 	
[
íí 	
NativeContainer
íí	 
]
íí 
[
ìì 	.
 NativeContainerIsAtomicWriteOnly
ìì	 )
]
ìì) *
[
îî 	
DebuggerDisplay
îî	 
(
îî 
$str
îî 9
)
îî9 :
]
îî: ;
[
ïï 	
BurstCompatible
ïï	 
(
ïï "
GenericTypeArguments
ïï -
=
ïï. /
new
ïï0 3
[
ïï4 5
]
ïï5 6
{
ïï7 8
typeof
ïï9 ?
(
ïï? @
int
ïï@ C
)
ïïC D
,
ïïD E
typeof
ïïF L
(
ïïL M
int
ïïM P
)
ïïP Q
}
ïïR S
)
ïïS T
]
ïïT U
public
ññ 
unsafe
ññ 
struct
ññ 
ParallelWriter
ññ +
{
óó 	
internal
òò 
UnsafeHashMap
òò "
<
òò" #
TKey
òò# '
,
òò' (
TValue
òò) /
>
òò/ 0
.
òò0 1
ParallelWriter
òò1 ?
m_Writer
òò@ H
;
òòH I
internal
õõ  
AtomicSafetyHandle
õõ '
m_Safety
õõ( 0
;
õõ0 1
internal
úú 
static
úú 
readonly
úú $
SharedStatic
úú% 1
<
úú1 2
int
úú2 5
>
úú5 6
s_staticSafetyId
úú7 G
=
úúH I
SharedStatic
úúJ V
<
úúV W
int
úúW Z
>
úúZ [
.
úú[ \
GetOrCreate
úú\ g
<
úúg h
ParallelWriter
úúh v
>
úúv w
(
úúw x
)
úúx y
;
úúy z
public
§§ 
int
§§ 
m_ThreadIndex
§§ $
=>
§§% '
m_Writer
§§( 0
.
§§0 1
m_ThreadIndex
§§1 >
;
§§> ?
public
™™ 
int
™™ 
Capacity
™™ 
{
´´ 
get
¨¨ 
{
≠≠  
AtomicSafetyHandle
ØØ &
.
ØØ& '
CheckReadAndThrow
ØØ' 8
(
ØØ8 9
m_Safety
ØØ9 A
)
ØØA B
;
ØØB C
return
±± 
m_Writer
±± #
.
±±# $
Capacity
±±$ ,
;
±±, -
}
≤≤ 
}
≥≥ 
public
ºº 
bool
ºº 
TryAdd
ºº 
(
ºº 
TKey
ºº #
key
ºº$ '
,
ºº' (
TValue
ºº) /
item
ºº0 4
)
ºº4 5
{
ΩΩ  
AtomicSafetyHandle
øø "
.
øø" #/
!CheckWriteAndBumpSecondaryVersion
øø# D
(
øøD E
m_Safety
øøE M
)
øøM N
;
øøN O
return
¡¡ 
m_Writer
¡¡ 
.
¡¡  
TryAdd
¡¡  &
(
¡¡& '
key
¡¡' *
,
¡¡* +
item
¡¡, 0
)
¡¡0 1
;
¡¡1 2
}
¬¬ 
}
√√ 	
public
…… 

Enumerator
…… 
GetEnumerator
…… '
(
……' (
)
……( )
{
   	 
AtomicSafetyHandle
ÃÃ 
.
ÃÃ 2
$CheckGetSecondaryDataPointerAndThrow
ÃÃ C
(
ÃÃC D
m_Safety
ÃÃD L
)
ÃÃL M
;
ÃÃM N
var
ÕÕ 
ash
ÕÕ 
=
ÕÕ 
m_Safety
ÕÕ 
;
ÕÕ  
AtomicSafetyHandle
ŒŒ 
.
ŒŒ !
UseSecondaryVersion
ŒŒ 2
(
ŒŒ2 3
ref
ŒŒ3 6
ash
ŒŒ7 :
)
ŒŒ: ;
;
ŒŒ; <
return
–– 
new
–– 

Enumerator
–– !
{
—— 
m_Safety
”” 
=
”” 
ash
”” 
,
”” 
m_Enumerator
’’ 
=
’’ 
new
’’ ")
UnsafeHashMapDataEnumerator
’’# >
(
’’> ?
m_HashMapData
’’? L
.
’’L M
m_Buffer
’’M U
)
’’U V
,
’’V W
}
÷÷ 
;
÷÷ 
}
◊◊ 	
IEnumerator
ﬁﬁ 
<
ﬁﬁ 
KeyValue
ﬁﬁ 
<
ﬁﬁ 
TKey
ﬁﬁ !
,
ﬁﬁ! "
TValue
ﬁﬁ# )
>
ﬁﬁ) *
>
ﬁﬁ* +
IEnumerable
ﬁﬁ, 7
<
ﬁﬁ7 8
KeyValue
ﬁﬁ8 @
<
ﬁﬁ@ A
TKey
ﬁﬁA E
,
ﬁﬁE F
TValue
ﬁﬁG M
>
ﬁﬁM N
>
ﬁﬁN O
.
ﬁﬁO P
GetEnumerator
ﬁﬁP ]
(
ﬁﬁ] ^
)
ﬁﬁ^ _
{
ﬂﬂ 	
throw
‡‡ 
new
‡‡ %
NotImplementedException
‡‡ -
(
‡‡- .
)
‡‡. /
;
‡‡/ 0
}
·· 	
IEnumerator
ËË 
IEnumerable
ËË 
.
ËË  
GetEnumerator
ËË  -
(
ËË- .
)
ËË. /
{
ÈÈ 	
throw
ÍÍ 
new
ÍÍ %
NotImplementedException
ÍÍ -
(
ÍÍ- .
)
ÍÍ. /
;
ÍÍ/ 0
}
ÎÎ 	
[
ÙÙ 	
NativeContainer
ÙÙ	 
]
ÙÙ 
[
ıı 	'
NativeContainerIsReadOnly
ıı	 "
]
ıı" #
public
ˆˆ 
struct
ˆˆ 

Enumerator
ˆˆ  
:
ˆˆ! "
IEnumerator
ˆˆ# .
<
ˆˆ. /
KeyValue
ˆˆ/ 7
<
ˆˆ7 8
TKey
ˆˆ8 <
,
ˆˆ< =
TValue
ˆˆ> D
>
ˆˆD E
>
ˆˆE F
{
˜˜ 	
internal
˘˘  
AtomicSafetyHandle
˘˘ '
m_Safety
˘˘( 0
;
˘˘0 1
internal
˚˚ )
UnsafeHashMapDataEnumerator
˚˚ 0
m_Enumerator
˚˚1 =
;
˚˚= >
public
ÄÄ 
void
ÄÄ 
Dispose
ÄÄ 
(
ÄÄ  
)
ÄÄ  !
{
ÄÄ" #
}
ÄÄ$ %
public
ÜÜ 
bool
ÜÜ 
MoveNext
ÜÜ  
(
ÜÜ  !
)
ÜÜ! "
{
áá  
AtomicSafetyHandle
ââ "
.
ââ" #
CheckReadAndThrow
ââ# 4
(
ââ4 5
m_Safety
ââ5 =
)
ââ= >
;
ââ> ?
return
ãã 
m_Enumerator
ãã #
.
ãã# $
MoveNext
ãã$ ,
(
ãã, -
)
ãã- .
;
ãã. /
}
åå 
public
ëë 
void
ëë 
Reset
ëë 
(
ëë 
)
ëë 
{
íí  
AtomicSafetyHandle
îî "
.
îî" #
CheckReadAndThrow
îî# 4
(
îî4 5
m_Safety
îî5 =
)
îî= >
;
îî> ?
m_Enumerator
ññ 
.
ññ 
Reset
ññ "
(
ññ" #
)
ññ# $
;
ññ$ %
}
óó 
public
ùù 
KeyValue
ùù 
<
ùù 
TKey
ùù  
,
ùù  !
TValue
ùù" (
>
ùù( )
Current
ùù* 1
=>
ùù2 4
m_Enumerator
ùù5 A
.
ùùA B

GetCurrent
ùùB L
<
ùùL M
TKey
ùùM Q
,
ùùQ R
TValue
ùùS Y
>
ùùY Z
(
ùùZ [
)
ùù[ \
;
ùù\ ]
object
üü 
IEnumerator
üü 
.
üü 
Current
üü &
=>
üü' )
Current
üü* 1
;
üü1 2
}
†† 	
[
¢¢ 	
Conditional
¢¢	 
(
¢¢ 
$str
¢¢ 6
)
¢¢6 7
]
¢¢7 8
void
££ 
	CheckRead
££ 
(
££ 
)
££ 
{
§§ 	 
AtomicSafetyHandle
¶¶ 
.
¶¶ 
CheckReadAndThrow
¶¶ 0
(
¶¶0 1
m_Safety
¶¶1 9
)
¶¶9 :
;
¶¶: ;
}
®® 	
[
™™ 	
Conditional
™™	 
(
™™ 
$str
™™ 6
)
™™6 7
]
™™7 8
void
´´ 

CheckWrite
´´ 
(
´´ 
)
´´ 
{
¨¨ 	 
AtomicSafetyHandle
ÆÆ 
.
ÆÆ /
!CheckWriteAndBumpSecondaryVersion
ÆÆ @
(
ÆÆ@ A
m_Safety
ÆÆA I
)
ÆÆI J
;
ÆÆJ K
}
∞∞ 	
[
≤≤ 	
Conditional
≤≤	 
(
≤≤ 
$str
≤≤ 6
)
≤≤6 7
]
≤≤7 8
void
≥≥  
ThrowKeyNotPresent
≥≥ 
(
≥≥  
TKey
≥≥  $
key
≥≥% (
)
≥≥( )
{
¥¥ 	
throw
µµ 
new
µµ 
ArgumentException
µµ '
(
µµ' (
$"
µµ( *
$str
µµ* /
{
µµ/ 0
key
µµ0 3
}
µµ3 4
$str
µµ4 Y
"
µµY Z
)
µµZ [
;
µµ[ \
}
∂∂ 	
[
∏∏ 	
Conditional
∏∏	 
(
∏∏ 
$str
∏∏ 6
)
∏∏6 7
]
∏∏7 8
void
ππ "
ThrowKeyAlreadyAdded
ππ !
(
ππ! "
TKey
ππ" &
key
ππ' *
)
ππ* +
{
∫∫ 	
throw
ªª 
new
ªª 
ArgumentException
ªª '
(
ªª' (
$str
ªª( Z
,
ªªZ [
nameof
ªª\ b
(
ªªb c
key
ªªc f
)
ªªf g
)
ªªg h
;
ªªh i
}
ºº 	
}
ΩΩ 
internal
øø 
sealed
øø 
class
øø ,
NativeHashMapDebuggerTypeProxy
øø 8
<
øø8 9
TKey
øø9 =
,
øø= >
TValue
øø? E
>
øøE F
where
¿¿ 
TKey
¿¿ 
:
¿¿ 
struct
¿¿ 
,
¿¿ 

IEquatable
¿¿ '
<
¿¿' (
TKey
¿¿( ,
>
¿¿, -
where
¡¡ 
TValue
¡¡ 
:
¡¡ 
struct
¡¡ 
{
¬¬ 
UnsafeHashMap
ƒƒ 
<
ƒƒ 
TKey
ƒƒ 
,
ƒƒ 
TValue
ƒƒ "
>
ƒƒ" #
m_Target
ƒƒ$ ,
;
ƒƒ, -
public
∆∆ ,
NativeHashMapDebuggerTypeProxy
∆∆ -
(
∆∆- .
NativeHashMap
∆∆. ;
<
∆∆; <
TKey
∆∆< @
,
∆∆@ A
TValue
∆∆B H
>
∆∆H I
target
∆∆J P
)
∆∆P Q
{
«« 	
m_Target
»» 
=
»» 
target
»» 
.
»» 
m_HashMapData
»» +
;
»»+ ,
}
…… 	
public
ÀÀ 
List
ÀÀ 
<
ÀÀ 
Pair
ÀÀ 
<
ÀÀ 
TKey
ÀÀ 
,
ÀÀ 
TValue
ÀÀ %
>
ÀÀ% &
>
ÀÀ& '
Items
ÀÀ( -
{
ÃÃ 	
get
ÕÕ 
{
ŒŒ 
var
œœ 
result
œœ 
=
œœ 
new
œœ  
List
œœ! %
<
œœ% &
Pair
œœ& *
<
œœ* +
TKey
œœ+ /
,
œœ/ 0
TValue
œœ1 7
>
œœ7 8
>
œœ8 9
(
œœ9 :
)
œœ: ;
;
œœ; <
using
–– 
(
–– 
var
–– 
kva
–– 
=
––  
m_Target
––! )
.
––) *
GetKeyValueArrays
––* ;
(
––; <
	Allocator
––< E
.
––E F
Temp
––F J
)
––J K
)
––K L
{
—— 
for
““ 
(
““ 
var
““ 
i
““ 
=
““  
$num
““! "
;
““" #
i
““$ %
<
““& '
kva
““( +
.
““+ ,
Length
““, 2
;
““2 3
++
““4 6
i
““6 7
)
““7 8
{
”” 
result
‘‘ 
.
‘‘ 
Add
‘‘ "
(
‘‘" #
new
‘‘# &
Pair
‘‘' +
<
‘‘+ ,
TKey
‘‘, 0
,
‘‘0 1
TValue
‘‘2 8
>
‘‘8 9
(
‘‘9 :
kva
‘‘: =
.
‘‘= >
Keys
‘‘> B
[
‘‘B C
i
‘‘C D
]
‘‘D E
,
‘‘E F
kva
‘‘G J
.
‘‘J K
Values
‘‘K Q
[
‘‘Q R
i
‘‘R S
]
‘‘S T
)
‘‘T U
)
‘‘U V
;
‘‘V W
}
’’ 
}
÷÷ 
return
◊◊ 
result
◊◊ 
;
◊◊ 
}
ÿÿ 
}
ŸŸ 	
}
€€ 
}‹‹ Ô∂
_C:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\BitField.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[ 
BurstCompatible 
] 
internal 
unsafe 
struct 
Bitwise "
{		 
internal

 
static

 
int

 
	AlignDown

 %
(

% &
int

& )
value

* /
,

/ 0
int

1 4
	alignPow2

5 >
)

> ?
{ 	
return 
value 
& 
~ 
( 
	alignPow2 &
-' (
$num) *
)* +
;+ ,
} 	
internal 
static 
int 
AlignUp #
(# $
int$ '
value( -
,- .
int/ 2
	alignPow23 <
)< =
{ 	
return 
	AlignDown 
( 
value "
+# $
	alignPow2% .
-/ 0
$num1 2
,2 3
	alignPow24 =
)= >
;> ?
} 	
internal 
static 
int 
FromBool $
($ %
bool% )
value* /
)/ 0
{ 	
return 
value 
? 
$num 
: 
$num  
;  !
} 	
internal 
static 
uint 
ExtractBits (
(( )
uint) -
input. 3
,3 4
int5 8
pos9 <
,< =
uint> B
maskC G
)G H
{ 	
var 
tmp0 
= 
input 
>> 
pos  #
;# $
return 
tmp0 
& 
mask 
; 
} 	
internal!! 
static!! 
uint!! 
ReplaceBits!! (
(!!( )
uint!!) -
input!!. 3
,!!3 4
int!!5 8
pos!!9 <
,!!< =
uint!!> B
mask!!C G
,!!G H
uint!!I M
value!!N S
)!!S T
{"" 	
var## 
tmp0## 
=## 
(## 
value## 
&## 
mask##  $
)##$ %
<<##& (
pos##) ,
;##, -
var$$ 
tmp1$$ 
=$$ 
input$$ 
&$$ 
~$$  
($$  !
mask$$! %
<<$$& (
pos$$) ,
)$$, -
;$$- .
return%% 
tmp0%% 
|%% 
tmp1%% 
;%% 
}&& 	
internal(( 
static(( 
uint(( 
SetBits(( $
((($ %
uint((% )
input((* /
,((/ 0
int((1 4
pos((5 8
,((8 9
uint((: >
mask((? C
,((C D
bool((E I
value((J O
)((O P
{)) 	
return** 
ReplaceBits** 
(** 
input** $
,**$ %
pos**& )
,**) *
mask**+ /
,**/ 0
(**1 2
uint**2 6
)**6 7
-**7 8
FromBool**8 @
(**@ A
value**A F
)**F G
)**G H
;**H I
}++ 	
internal// 
static// 
ulong// 
ExtractBits// )
(//) *
ulong//* /
input//0 5
,//5 6
int//7 :
pos//; >
,//> ?
ulong//@ E
mask//F J
)//J K
{00 	
var11 
tmp011 
=11 
input11 
>>11 
pos11  #
;11# $
return22 
tmp022 
&22 
mask22 
;22 
}33 	
internal55 
static55 
ulong55 
ReplaceBits55 )
(55) *
ulong55* /
input550 5
,555 6
int557 :
pos55; >
,55> ?
ulong55@ E
mask55F J
,55J K
ulong55L Q
value55R W
)55W X
{66 	
var77 
tmp077 
=77 
(77 
value77 
&77 
mask77  $
)77$ %
<<77& (
pos77) ,
;77, -
var88 
tmp188 
=88 
input88 
&88 
~88  
(88  !
mask88! %
<<88& (
pos88) ,
)88, -
;88- .
return99 
tmp099 
|99 
tmp199 
;99 
}:: 	
internal<< 
static<< 
ulong<< 
SetBits<< %
(<<% &
ulong<<& +
input<<, 1
,<<1 2
int<<3 6
pos<<7 :
,<<: ;
ulong<<< A
mask<<B F
,<<F G
bool<<H L
value<<M R
)<<R S
{== 	
return>> 
ReplaceBits>> 
(>> 
input>> $
,>>$ %
pos>>& )
,>>) *
mask>>+ /
,>>/ 0
(>>1 2
ulong>>2 7
)>>7 8
->>8 9
(>>9 :
long>>: >
)>>> ?
FromBool>>? G
(>>G H
value>>H M
)>>M N
)>>N O
;>>O P
}?? 	
internalAA 
staticAA 
intAA 
lzcntAA !
(AA! "
byteAA" &
valueAA' ,
)AA, -
{BB 	
returnCC 
mathCC 
.CC 
lzcntCC 
(CC 
(CC 
uintCC #
)CC# $
valueCC$ )
)CC) *
-CC+ ,
$numCC- /
;CC/ 0
}DD 	
internalFF 
staticFF 
intFF 
tzcntFF !
(FF! "
byteFF" &
valueFF' ,
)FF, -
{GG 	
returnHH 
mathHH 
.HH 
minHH 
(HH 
$numHH 
,HH 
mathHH #
.HH# $
tzcntHH$ )
(HH) *
(HH* +
uintHH+ /
)HH/ 0
valueHH0 5
)HH5 6
)HH6 7
;HH7 8
}II 	
internalKK 
staticKK 
intKK 
lzcntKK !
(KK! "
ushortKK" (
valueKK) .
)KK. /
{LL 	
returnMM 
mathMM 
.MM 
lzcntMM 
(MM 
(MM 
uintMM #
)MM# $
valueMM$ )
)MM) *
-MM+ ,
$numMM- /
;MM/ 0
}NN 	
internalPP 
staticPP 
intPP 
tzcntPP !
(PP! "
ushortPP" (
valuePP) .
)PP. /
{QQ 	
returnRR 
mathRR 
.RR 
minRR 
(RR 
$numRR 
,RR 
mathRR  $
.RR$ %
tzcntRR% *
(RR* +
(RR+ ,
uintRR, 0
)RR0 1
valueRR1 6
)RR6 7
)RR7 8
;RR8 9
}SS 	
staticUU 
intUU 
	FindUlongUU 
(UU 
ulongUU "
*UU" #
ptrUU$ '
,UU' (
intUU) ,
beginBitUU- 5
,UU5 6
intUU7 :
endBitUU; A
,UUA B
intUUC F
numBitsUUG N
)UUN O
{VV 	
varWW 
bitsWW 
=WW 
ptrWW 
;WW 
varXX 
numStepsXX 
=XX 
(XX 
numBitsXX #
+XX$ %
$numXX& (
)XX( )
>>XX* ,
$numXX- .
;XX. /
varYY 
numBitsPerStepYY 
=YY  
$numYY! #
;YY# $
varZZ 
maxBitsZZ 
=ZZ 
numStepsZZ "
*ZZ# $
numBitsPerStepZZ% 3
;ZZ3 4
for\\ 
(\\ 
int\\ 
i\\ 
=\\ 
beginBit\\ !
/\\" #
numBitsPerStep\\$ 2
,\\2 3
end\\4 7
=\\8 9
AlignUp\\: A
(\\A B
endBit\\B H
,\\H I
numBitsPerStep\\J X
)\\X Y
/\\Z [
numBitsPerStep\\\ j
;\\j k
i\\l m
<\\n o
end\\p s
;\\s t
++\\u w
i\\w x
)\\x y
{]] 
if^^ 
(^^ 
bits^^ 
[^^ 
i^^ 
]^^ 
!=^^ 
$num^^  
)^^  !
{__ 
continue`` 
;`` 
}aa 
varcc 
idxcc 
=cc 
icc 
*cc 
numBitsPerStepcc ,
;cc, -
vardd 
numdd 
=dd 
mathdd 
.dd 
mindd "
(dd" #
idxdd# &
+dd' (
numBitsPerStepdd) 7
,dd7 8
endBitdd9 ?
)dd? @
-ddA B
idxddC F
;ddF G
ifff 
(ff 
idxff 
!=ff 
beginBitff #
)ff# $
{gg 
varhh 
testhh 
=hh 
bitshh #
[hh# $
idxhh$ '
/hh( )
numBitsPerStephh* 8
-hh9 :
$numhh; <
]hh< =
;hh= >
varii 
newIdxii 
=ii  
mathii! %
.ii% &
maxii& )
(ii) *
idxii* -
-ii. /
mathii0 4
.ii4 5
lzcntii5 :
(ii: ;
testii; ?
)ii? @
,ii@ A
beginBitiiB J
)iiJ K
;iiK L
numkk 
+=kk 
idxkk 
-kk  
newIdxkk! '
;kk' (
idxll 
=ll 
newIdxll  
;ll  !
}mm 
foroo 
(oo 
++oo 
ioo 
;oo 
ioo 
<oo 
endoo !
;oo! "
++oo# %
ioo% &
)oo& '
{pp 
ifqq 
(qq 
numqq 
>=qq 
numBitsqq &
)qq& '
{rr 
returnss 
idxss "
;ss" #
}tt 
varvv 
testvv 
=vv 
bitsvv #
[vv# $
ivv$ %
]vv% &
;vv& '
varww 
posww 
=ww 
iww 
*ww  !
numBitsPerStepww" 0
;ww0 1
numxx 
+=xx 
mathxx 
.xx  
minxx  #
(xx# $
posxx$ '
+xx( )
mathxx* .
.xx. /
tzcntxx/ 4
(xx4 5
testxx5 9
)xx9 :
,xx: ;
endBitxx< B
)xxB C
-xxD E
posxxF I
;xxI J
ifzz 
(zz 
testzz 
!=zz 
$numzz  !
)zz! "
{{{ 
break|| 
;|| 
}}} 
}~~ 
if
ÄÄ 
(
ÄÄ 
num
ÄÄ 
>=
ÄÄ 
numBits
ÄÄ "
)
ÄÄ" #
{
ÅÅ 
return
ÇÇ 
idx
ÇÇ 
;
ÇÇ 
}
ÉÉ 
}
ÑÑ 
return
ÜÜ 
endBit
ÜÜ 
;
ÜÜ 
}
áá 	
static
ââ 
int
ââ 
FindUint
ââ 
(
ââ 
ulong
ââ !
*
ââ! "
ptr
ââ# &
,
ââ& '
int
ââ( +
beginBit
ââ, 4
,
ââ4 5
int
ââ6 9
endBit
ââ: @
,
ââ@ A
int
ââB E
numBits
ââF M
)
ââM N
{
ää 	
var
ãã 
bits
ãã 
=
ãã 
(
ãã 
uint
ãã 
*
ãã 
)
ãã 
ptr
ãã !
;
ãã! "
var
åå 
numSteps
åå 
=
åå 
(
åå 
numBits
åå #
+
åå$ %
$num
åå& (
)
åå( )
>>
åå* ,
$num
åå- .
;
åå. /
var
çç 
numBitsPerStep
çç 
=
çç  
$num
çç! #
;
çç# $
var
éé 
maxBits
éé 
=
éé 
numSteps
éé "
*
éé# $
numBitsPerStep
éé% 3
;
éé3 4
for
êê 
(
êê 
int
êê 
i
êê 
=
êê 
beginBit
êê !
/
êê" #
numBitsPerStep
êê$ 2
,
êê2 3
end
êê4 7
=
êê8 9
AlignUp
êê: A
(
êêA B
endBit
êêB H
,
êêH I
numBitsPerStep
êêJ X
)
êêX Y
/
êêZ [
numBitsPerStep
êê\ j
;
êêj k
i
êêl m
<
êên o
end
êêp s
;
êês t
++
êêu w
i
êêw x
)
êêx y
{
ëë 
if
íí 
(
íí 
bits
íí 
[
íí 
i
íí 
]
íí 
!=
íí 
$num
íí  
)
íí  !
{
ìì 
continue
îî 
;
îî 
}
ïï 
var
óó 
idx
óó 
=
óó 
i
óó 
*
óó 
numBitsPerStep
óó ,
;
óó, -
var
òò 
num
òò 
=
òò 
math
òò 
.
òò 
min
òò "
(
òò" #
idx
òò# &
+
òò' (
numBitsPerStep
òò) 7
,
òò7 8
endBit
òò9 ?
)
òò? @
-
òòA B
idx
òòC F
;
òòF G
if
öö 
(
öö 
idx
öö 
!=
öö 
beginBit
öö #
)
öö# $
{
õõ 
var
úú 
test
úú 
=
úú 
bits
úú #
[
úú# $
idx
úú$ '
/
úú( )
numBitsPerStep
úú* 8
-
úú9 :
$num
úú; <
]
úú< =
;
úú= >
var
ùù 
newIdx
ùù 
=
ùù  
math
ùù! %
.
ùù% &
max
ùù& )
(
ùù) *
idx
ùù* -
-
ùù. /
math
ùù0 4
.
ùù4 5
lzcnt
ùù5 :
(
ùù: ;
test
ùù; ?
)
ùù? @
,
ùù@ A
beginBit
ùùB J
)
ùùJ K
;
ùùK L
num
üü 
+=
üü 
idx
üü 
-
üü  
newIdx
üü! '
;
üü' (
idx
†† 
=
†† 
newIdx
††  
;
††  !
}
°° 
for
££ 
(
££ 
++
££ 
i
££ 
;
££ 
i
££ 
<
££ 
end
££ !
;
££! "
++
££# %
i
££% &
)
££& '
{
§§ 
if
•• 
(
•• 
num
•• 
>=
•• 
numBits
•• &
)
••& '
{
¶¶ 
return
ßß 
idx
ßß "
;
ßß" #
}
®® 
var
™™ 
test
™™ 
=
™™ 
bits
™™ #
[
™™# $
i
™™$ %
]
™™% &
;
™™& '
var
´´ 
pos
´´ 
=
´´ 
i
´´ 
*
´´  !
numBitsPerStep
´´" 0
;
´´0 1
num
¨¨ 
+=
¨¨ 
math
¨¨ 
.
¨¨  
min
¨¨  #
(
¨¨# $
pos
¨¨$ '
+
¨¨( )
math
¨¨* .
.
¨¨. /
tzcnt
¨¨/ 4
(
¨¨4 5
test
¨¨5 9
)
¨¨9 :
,
¨¨: ;
endBit
¨¨< B
)
¨¨B C
-
¨¨D E
pos
¨¨F I
;
¨¨I J
if
ÆÆ 
(
ÆÆ 
test
ÆÆ 
!=
ÆÆ 
$num
ÆÆ  !
)
ÆÆ! "
{
ØØ 
break
∞∞ 
;
∞∞ 
}
±± 
}
≤≤ 
if
¥¥ 
(
¥¥ 
num
¥¥ 
>=
¥¥ 
numBits
¥¥ "
)
¥¥" #
{
µµ 
return
∂∂ 
idx
∂∂ 
;
∂∂ 
}
∑∑ 
}
∏∏ 
return
∫∫ 
endBit
∫∫ 
;
∫∫ 
}
ªª 	
static
ΩΩ 
int
ΩΩ 

FindUshort
ΩΩ 
(
ΩΩ 
ulong
ΩΩ #
*
ΩΩ# $
ptr
ΩΩ% (
,
ΩΩ( )
int
ΩΩ* -
beginBit
ΩΩ. 6
,
ΩΩ6 7
int
ΩΩ8 ;
endBit
ΩΩ< B
,
ΩΩB C
int
ΩΩD G
numBits
ΩΩH O
)
ΩΩO P
{
ææ 	
var
øø 
bits
øø 
=
øø 
(
øø 
ushort
øø 
*
øø 
)
øø  
ptr
øø  #
;
øø# $
var
¿¿ 
numSteps
¿¿ 
=
¿¿ 
(
¿¿ 
numBits
¿¿ #
+
¿¿$ %
$num
¿¿& (
)
¿¿( )
>>
¿¿* ,
$num
¿¿- .
;
¿¿. /
var
¡¡ 
numBitsPerStep
¡¡ 
=
¡¡  
$num
¡¡! #
;
¡¡# $
var
¬¬ 
maxBits
¬¬ 
=
¬¬ 
numSteps
¬¬ "
*
¬¬# $
numBitsPerStep
¬¬% 3
;
¬¬3 4
for
ƒƒ 
(
ƒƒ 
int
ƒƒ 
i
ƒƒ 
=
ƒƒ 
beginBit
ƒƒ !
/
ƒƒ" #
numBitsPerStep
ƒƒ$ 2
,
ƒƒ2 3
end
ƒƒ4 7
=
ƒƒ8 9
AlignUp
ƒƒ: A
(
ƒƒA B
endBit
ƒƒB H
,
ƒƒH I
numBitsPerStep
ƒƒJ X
)
ƒƒX Y
/
ƒƒZ [
numBitsPerStep
ƒƒ\ j
;
ƒƒj k
i
ƒƒl m
<
ƒƒn o
end
ƒƒp s
;
ƒƒs t
++
ƒƒu w
i
ƒƒw x
)
ƒƒx y
{
≈≈ 
if
∆∆ 
(
∆∆ 
bits
∆∆ 
[
∆∆ 
i
∆∆ 
]
∆∆ 
!=
∆∆ 
$num
∆∆  
)
∆∆  !
{
«« 
continue
»» 
;
»» 
}
…… 
var
ÀÀ 
idx
ÀÀ 
=
ÀÀ 
i
ÀÀ 
*
ÀÀ 
numBitsPerStep
ÀÀ ,
;
ÀÀ, -
var
ÃÃ 
num
ÃÃ 
=
ÃÃ 
math
ÃÃ 
.
ÃÃ 
min
ÃÃ "
(
ÃÃ" #
idx
ÃÃ# &
+
ÃÃ' (
numBitsPerStep
ÃÃ) 7
,
ÃÃ7 8
endBit
ÃÃ9 ?
)
ÃÃ? @
-
ÃÃA B
idx
ÃÃC F
;
ÃÃF G
if
ŒŒ 
(
ŒŒ 
idx
ŒŒ 
!=
ŒŒ 
beginBit
ŒŒ #
)
ŒŒ# $
{
œœ 
var
–– 
test
–– 
=
–– 
bits
–– #
[
––# $
idx
––$ '
/
––( )
numBitsPerStep
––* 8
-
––9 :
$num
––; <
]
––< =
;
––= >
var
—— 
newIdx
—— 
=
——  
math
——! %
.
——% &
max
——& )
(
——) *
idx
——* -
-
——. /
lzcnt
——0 5
(
——5 6
test
——6 :
)
——: ;
,
——; <
beginBit
——= E
)
——E F
;
——F G
num
”” 
+=
”” 
idx
”” 
-
””  
newIdx
””! '
;
””' (
idx
‘‘ 
=
‘‘ 
newIdx
‘‘  
;
‘‘  !
}
’’ 
for
◊◊ 
(
◊◊ 
++
◊◊ 
i
◊◊ 
;
◊◊ 
i
◊◊ 
<
◊◊ 
end
◊◊ !
;
◊◊! "
++
◊◊# %
i
◊◊% &
)
◊◊& '
{
ÿÿ 
if
ŸŸ 
(
ŸŸ 
num
ŸŸ 
>=
ŸŸ 
numBits
ŸŸ &
)
ŸŸ& '
{
⁄⁄ 
return
€€ 
idx
€€ "
;
€€" #
}
‹‹ 
var
ﬁﬁ 
test
ﬁﬁ 
=
ﬁﬁ 
bits
ﬁﬁ #
[
ﬁﬁ# $
i
ﬁﬁ$ %
]
ﬁﬁ% &
;
ﬁﬁ& '
var
ﬂﬂ 
pos
ﬂﬂ 
=
ﬂﬂ 
i
ﬂﬂ 
*
ﬂﬂ  !
numBitsPerStep
ﬂﬂ" 0
;
ﬂﬂ0 1
num
‡‡ 
+=
‡‡ 
math
‡‡ 
.
‡‡  
min
‡‡  #
(
‡‡# $
pos
‡‡$ '
+
‡‡( )
tzcnt
‡‡* /
(
‡‡/ 0
test
‡‡0 4
)
‡‡4 5
,
‡‡5 6
endBit
‡‡7 =
)
‡‡= >
-
‡‡? @
pos
‡‡A D
;
‡‡D E
if
‚‚ 
(
‚‚ 
test
‚‚ 
!=
‚‚ 
$num
‚‚  !
)
‚‚! "
{
„„ 
break
‰‰ 
;
‰‰ 
}
ÂÂ 
}
ÊÊ 
if
ËË 
(
ËË 
num
ËË 
>=
ËË 
numBits
ËË "
)
ËË" #
{
ÈÈ 
return
ÍÍ 
idx
ÍÍ 
;
ÍÍ 
}
ÎÎ 
}
ÏÏ 
return
ÓÓ 
endBit
ÓÓ 
;
ÓÓ 
}
ÔÔ 	
static
ÒÒ 
int
ÒÒ 
FindByte
ÒÒ 
(
ÒÒ 
ulong
ÒÒ !
*
ÒÒ! "
ptr
ÒÒ# &
,
ÒÒ& '
int
ÒÒ( +
beginBit
ÒÒ, 4
,
ÒÒ4 5
int
ÒÒ6 9
endBit
ÒÒ: @
,
ÒÒ@ A
int
ÒÒB E
numBits
ÒÒF M
)
ÒÒM N
{
ÚÚ 	
var
ÛÛ 
bits
ÛÛ 
=
ÛÛ 
(
ÛÛ 
byte
ÛÛ 
*
ÛÛ 
)
ÛÛ 
ptr
ÛÛ !
;
ÛÛ! "
var
ÙÙ 
numSteps
ÙÙ 
=
ÙÙ 
(
ÙÙ 
numBits
ÙÙ #
+
ÙÙ$ %
$num
ÙÙ& '
)
ÙÙ' (
>>
ÙÙ) +
$num
ÙÙ, -
;
ÙÙ- .
var
ıı 
numBitsPerStep
ıı 
=
ıı  
$num
ıı! "
;
ıı" #
var
ˆˆ 
maxBits
ˆˆ 
=
ˆˆ 
numSteps
ˆˆ "
*
ˆˆ# $
numBitsPerStep
ˆˆ% 3
;
ˆˆ3 4
for
¯¯ 
(
¯¯ 
int
¯¯ 
i
¯¯ 
=
¯¯ 
beginBit
¯¯ !
/
¯¯" #
numBitsPerStep
¯¯$ 2
,
¯¯2 3
end
¯¯4 7
=
¯¯8 9
AlignUp
¯¯: A
(
¯¯A B
endBit
¯¯B H
,
¯¯H I
numBitsPerStep
¯¯J X
)
¯¯X Y
/
¯¯Z [
numBitsPerStep
¯¯\ j
;
¯¯j k
i
¯¯l m
<
¯¯n o
end
¯¯p s
;
¯¯s t
++
¯¯u w
i
¯¯w x
)
¯¯x y
{
˘˘ 
if
˙˙ 
(
˙˙ 
bits
˙˙ 
[
˙˙ 
i
˙˙ 
]
˙˙ 
!=
˙˙ 
$num
˙˙  
)
˙˙  !
{
˚˚ 
continue
¸¸ 
;
¸¸ 
}
˝˝ 
var
ˇˇ 
idx
ˇˇ 
=
ˇˇ 
i
ˇˇ 
*
ˇˇ 
numBitsPerStep
ˇˇ ,
;
ˇˇ, -
var
ÄÄ 
num
ÄÄ 
=
ÄÄ 
math
ÄÄ 
.
ÄÄ 
min
ÄÄ "
(
ÄÄ" #
idx
ÄÄ# &
+
ÄÄ' (
numBitsPerStep
ÄÄ) 7
,
ÄÄ7 8
endBit
ÄÄ9 ?
)
ÄÄ? @
-
ÄÄA B
idx
ÄÄC F
;
ÄÄF G
if
ÇÇ 
(
ÇÇ 
idx
ÇÇ 
!=
ÇÇ 
beginBit
ÇÇ #
)
ÇÇ# $
{
ÉÉ 
var
ÑÑ 
test
ÑÑ 
=
ÑÑ 
bits
ÑÑ #
[
ÑÑ# $
idx
ÑÑ$ '
/
ÑÑ( )
numBitsPerStep
ÑÑ* 8
-
ÑÑ9 :
$num
ÑÑ; <
]
ÑÑ< =
;
ÑÑ= >
var
ÖÖ 
newIdx
ÖÖ 
=
ÖÖ  
math
ÖÖ! %
.
ÖÖ% &
max
ÖÖ& )
(
ÖÖ) *
idx
ÖÖ* -
-
ÖÖ. /
lzcnt
ÖÖ0 5
(
ÖÖ5 6
test
ÖÖ6 :
)
ÖÖ: ;
,
ÖÖ; <
beginBit
ÖÖ= E
)
ÖÖE F
;
ÖÖF G
num
áá 
+=
áá 
idx
áá 
-
áá  
newIdx
áá! '
;
áá' (
idx
àà 
=
àà 
newIdx
àà  
;
àà  !
}
ââ 
for
ãã 
(
ãã 
++
ãã 
i
ãã 
;
ãã 
i
ãã 
<
ãã 
end
ãã !
;
ãã! "
++
ãã# %
i
ãã% &
)
ãã& '
{
åå 
if
çç 
(
çç 
num
çç 
>=
çç 
numBits
çç &
)
çç& '
{
éé 
return
èè 
idx
èè "
;
èè" #
}
êê 
var
íí 
test
íí 
=
íí 
bits
íí #
[
íí# $
i
íí$ %
]
íí% &
;
íí& '
var
ìì 
pos
ìì 
=
ìì 
i
ìì 
*
ìì  !
numBitsPerStep
ìì" 0
;
ìì0 1
num
îî 
+=
îî 
math
îî 
.
îî  
min
îî  #
(
îî# $
pos
îî$ '
+
îî( )
tzcnt
îî* /
(
îî/ 0
test
îî0 4
)
îî4 5
,
îî5 6
endBit
îî7 =
)
îî= >
-
îî? @
pos
îîA D
;
îîD E
if
ññ 
(
ññ 
test
ññ 
!=
ññ 
$num
ññ  !
)
ññ! "
{
óó 
break
òò 
;
òò 
}
ôô 
}
öö 
if
úú 
(
úú 
num
úú 
>=
úú 
numBits
úú "
)
úú" #
{
ùù 
return
ûû 
idx
ûû 
;
ûû 
}
üü 
}
†† 
return
¢¢ 
endBit
¢¢ 
;
¢¢ 
}
££ 	
static
•• 
int
•• 
FindUpto14bits
•• !
(
••! "
ulong
••" '
*
••' (
ptr
••) ,
,
••, -
int
••. 1
beginBit
••2 :
,
••: ;
int
••< ?
endBit
••@ F
,
••F G
int
••H K
numBits
••L S
)
••S T
{
¶¶ 	
var
ßß 
bits
ßß 
=
ßß 
(
ßß 
byte
ßß 
*
ßß 
)
ßß 
ptr
ßß !
;
ßß! "
var
©© 
bit
©© 
=
©© 
(
©© 
byte
©© 
)
©© 
(
©© 
beginBit
©© %
&
©©& '
$num
©©( )
)
©©) *
;
©©* +
byte
™™ 
	beginMask
™™ 
=
™™ 
(
™™ 
byte
™™ "
)
™™" #
~
™™# $
(
™™$ %
$num
™™% )
<<
™™* ,
bit
™™- 0
)
™™0 1
;
™™1 2
var
¨¨ 
lz
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨ 
for
≠≠ 
(
≠≠ 
int
≠≠ 
begin
≠≠ 
=
≠≠ 
beginBit
≠≠ %
/
≠≠& '
$num
≠≠( )
,
≠≠) *
end
≠≠+ .
=
≠≠/ 0
AlignUp
≠≠1 8
(
≠≠8 9
endBit
≠≠9 ?
,
≠≠? @
$num
≠≠A B
)
≠≠B C
/
≠≠D E
$num
≠≠F G
,
≠≠G H
i
≠≠I J
=
≠≠K L
begin
≠≠M R
;
≠≠R S
i
≠≠T U
<
≠≠V W
end
≠≠X [
;
≠≠[ \
++
≠≠] _
i
≠≠_ `
)
≠≠` a
{
ÆÆ 
var
ØØ 
test
ØØ 
=
ØØ 
bits
ØØ 
[
ØØ  
i
ØØ  !
]
ØØ! "
;
ØØ" #
test
∞∞ 
|=
∞∞ 
i
∞∞ 
==
∞∞ 
begin
∞∞ "
?
∞∞# $
	beginMask
∞∞% .
:
∞∞/ 0
(
∞∞1 2
byte
∞∞2 6
)
∞∞6 7
$num
∞∞7 8
;
∞∞8 9
if
≤≤ 
(
≤≤ 
test
≤≤ 
==
≤≤ 
$num
≤≤  
)
≤≤  !
{
≥≥ 
continue
¥¥ 
;
¥¥ 
}
µµ 
var
∑∑ 
pos
∑∑ 
=
∑∑ 
i
∑∑ 
*
∑∑ 
$num
∑∑ 
;
∑∑  
var
∏∏ 
tz
∏∏ 
=
∏∏ 
math
∏∏ 
.
∏∏ 
min
∏∏ !
(
∏∏! "
pos
∏∏" %
+
∏∏& '
tzcnt
∏∏( -
(
∏∏- .
test
∏∏. 2
)
∏∏2 3
,
∏∏3 4
endBit
∏∏5 ;
)
∏∏; <
-
∏∏= >
pos
∏∏? B
;
∏∏B C
if
∫∫ 
(
∫∫ 
lz
∫∫ 
+
∫∫ 
tz
∫∫ 
>=
∫∫ 
numBits
∫∫ &
)
∫∫& '
{
ªª 
return
ºº 
pos
ºº 
-
ºº  
lz
ºº! #
;
ºº# $
}
ΩΩ 
lz
øø 
=
øø 
lzcnt
øø 
(
øø 
test
øø 
)
øø  
;
øø  !
var
¡¡ 
idx
¡¡ 
=
¡¡ 
pos
¡¡ 
+
¡¡ 
$num
¡¡  !
;
¡¡! "
var
¬¬ 
newIdx
¬¬ 
=
¬¬ 
math
¬¬ !
.
¬¬! "
max
¬¬" %
(
¬¬% &
idx
¬¬& )
-
¬¬* +
lz
¬¬, .
,
¬¬. /
beginBit
¬¬0 8
)
¬¬8 9
;
¬¬9 :
lz
√√ 
=
√√ 
math
√√ 
.
√√ 
min
√√ 
(
√√ 
idx
√√ !
,
√√! "
endBit
√√# )
)
√√) *
-
√√+ ,
newIdx
√√- 3
;
√√3 4
if
≈≈ 
(
≈≈ 
lz
≈≈ 
>=
≈≈ 
numBits
≈≈ !
)
≈≈! "
{
∆∆ 
return
«« 
newIdx
«« !
;
««! "
}
»» 
}
…… 
return
ÀÀ 
endBit
ÀÀ 
;
ÀÀ 
}
ÃÃ 	
static
ŒŒ 
int
ŒŒ 
FindUpto6bits
ŒŒ  
(
ŒŒ  !
ulong
ŒŒ! &
*
ŒŒ& '
ptr
ŒŒ( +
,
ŒŒ+ ,
int
ŒŒ- 0
beginBit
ŒŒ1 9
,
ŒŒ9 :
int
ŒŒ; >
endBit
ŒŒ? E
,
ŒŒE F
int
ŒŒG J
numBits
ŒŒK R
)
ŒŒR S
{
œœ 	
var
–– 
bits
–– 
=
–– 
(
–– 
byte
–– 
*
–– 
)
–– 
ptr
–– !
;
––! "
byte
““ 
	beginMask
““ 
=
““ 
(
““ 
byte
““ "
)
““" #
~
““# $
(
““$ %
$num
““% )
<<
““* ,
(
““- .
beginBit
““. 6
&
““7 8
$num
““9 :
)
““: ;
)
““; <
;
““< =
byte
”” 
endMask
”” 
=
”” 
(
”” 
byte
””  
)
””  !
~
””! "
(
””" #
$num
””# '
>>
””( *
(
””+ ,
(
””, -
$num
””- .
-
””. /
(
””/ 0
endBit
””0 6
&
””7 8
$num
””9 :
)
””: ;
&
””< =
$num
””> ?
)
””? @
)
””@ A
)
””A B
;
””B C
var
’’ 
mask
’’ 
=
’’ 
$num
’’ 
<<
’’ 
numBits
’’ #
-
’’$ %
$num
’’& '
;
’’' (
for
◊◊ 
(
◊◊ 
int
◊◊ 
begin
◊◊ 
=
◊◊ 
beginBit
◊◊ %
/
◊◊& '
$num
◊◊( )
,
◊◊) *
end
◊◊+ .
=
◊◊/ 0
AlignUp
◊◊1 8
(
◊◊8 9
endBit
◊◊9 ?
,
◊◊? @
$num
◊◊A B
)
◊◊B C
/
◊◊D E
$num
◊◊F G
,
◊◊G H
i
◊◊I J
=
◊◊K L
begin
◊◊M R
;
◊◊R S
i
◊◊T U
<
◊◊V W
end
◊◊X [
;
◊◊[ \
++
◊◊] _
i
◊◊_ `
)
◊◊` a
{
ÿÿ 
var
ŸŸ 
test
ŸŸ 
=
ŸŸ 
bits
ŸŸ 
[
ŸŸ  
i
ŸŸ  !
]
ŸŸ! "
;
ŸŸ" #
test
⁄⁄ 
|=
⁄⁄ 
i
⁄⁄ 
==
⁄⁄ 
begin
⁄⁄ "
?
⁄⁄# $
	beginMask
⁄⁄% .
:
⁄⁄/ 0
(
⁄⁄1 2
byte
⁄⁄2 6
)
⁄⁄6 7
$num
⁄⁄7 8
;
⁄⁄8 9
test
€€ 
|=
€€ 
i
€€ 
==
€€ 
end
€€  
-
€€! "
$num
€€# $
?
€€% &
endMask
€€' .
:
€€/ 0
(
€€1 2
byte
€€2 6
)
€€6 7
$num
€€7 8
;
€€8 9
if
›› 
(
›› 
test
›› 
==
›› 
$num
››  
)
››  !
{
ﬁﬁ 
continue
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 
for
‚‚ 
(
‚‚ 
int
‚‚ 
pos
‚‚ 
=
‚‚ 
i
‚‚  
*
‚‚! "
$num
‚‚# $
,
‚‚$ %
posEnd
‚‚& ,
=
‚‚- .
pos
‚‚/ 2
+
‚‚3 4
$num
‚‚5 6
;
‚‚6 7
pos
‚‚8 ;
<
‚‚< =
posEnd
‚‚> D
;
‚‚D E
++
‚‚F H
pos
‚‚H K
)
‚‚K L
{
„„ 
var
‰‰ 
tz
‰‰ 
=
‰‰ 
tzcnt
‰‰ "
(
‰‰" #
(
‰‰# $
byte
‰‰$ (
)
‰‰( )
(
‰‰) *
test
‰‰* .
^
‰‰. /
$num
‰‰/ 3
)
‰‰3 4
)
‰‰4 5
;
‰‰5 6
test
ÂÂ 
>>=
ÂÂ 
tz
ÂÂ 
;
ÂÂ  
pos
ÁÁ 
+=
ÁÁ 
tz
ÁÁ 
;
ÁÁ 
if
ÈÈ 
(
ÈÈ 
(
ÈÈ 
test
ÈÈ 
&
ÈÈ 
mask
ÈÈ  $
)
ÈÈ$ %
==
ÈÈ& (
$num
ÈÈ) *
)
ÈÈ* +
{
ÍÍ 
return
ÎÎ 
pos
ÎÎ "
;
ÎÎ" #
}
ÏÏ 
test
ÓÓ 
>>=
ÓÓ 
$num
ÓÓ 
;
ÓÓ 
}
ÔÔ 
}
 
return
ÚÚ 
endBit
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
internal
ıı 
static
ıı 
int
ıı 
FindWithBeginEnd
ıı ,
(
ıı, -
ulong
ıı- 2
*
ıı2 3
ptr
ıı4 7
,
ıı7 8
int
ıı9 <
beginBit
ıı= E
,
ııE F
int
ııG J
endBit
ııK Q
,
ııQ R
int
ııS V
numBits
ııW ^
)
ıı^ _
{
ˆˆ 	
int
˜˜ 
idx
˜˜ 
;
˜˜ 
if
˘˘ 
(
˘˘ 
numBits
˘˘ 
>=
˘˘ 
$num
˘˘ 
)
˘˘ 
{
˙˙ 
idx
˚˚ 
=
˚˚ 
	FindUlong
˚˚ 
(
˚˚  
ptr
˚˚  #
,
˚˚# $
beginBit
˚˚% -
,
˚˚- .
endBit
˚˚/ 5
,
˚˚5 6
numBits
˚˚7 >
)
˚˚> ?
;
˚˚? @
if
¸¸ 
(
¸¸ 
idx
¸¸ 
!=
¸¸ 
endBit
¸¸ !
)
¸¸! "
{
˝˝ 
return
˛˛ 
idx
˛˛ 
;
˛˛ 
}
ˇˇ 
}
ÄÄ 
if
ÇÇ 
(
ÇÇ 
numBits
ÇÇ 
>=
ÇÇ 
$num
ÇÇ 
)
ÇÇ 
{
ÉÉ 
idx
ÑÑ 
=
ÑÑ 
FindUint
ÑÑ 
(
ÑÑ 
ptr
ÑÑ "
,
ÑÑ" #
beginBit
ÑÑ$ ,
,
ÑÑ, -
endBit
ÑÑ. 4
,
ÑÑ4 5
numBits
ÑÑ6 =
)
ÑÑ= >
;
ÑÑ> ?
if
ÖÖ 
(
ÖÖ 
idx
ÖÖ 
!=
ÖÖ 
endBit
ÖÖ !
)
ÖÖ! "
{
ÜÜ 
return
áá 
idx
áá 
;
áá 
}
àà 
}
ââ 
if
ãã 
(
ãã 
numBits
ãã 
>=
ãã 
$num
ãã 
)
ãã 
{
åå 
return
éé 
int
éé 
.
éé 
MaxValue
éé #
;
éé# $
}
èè 
if
ëë 
(
ëë 
numBits
ëë 
>=
ëë 
$num
ëë 
)
ëë 
{
íí 
idx
ìì 
=
ìì 

FindUshort
ìì  
(
ìì  !
ptr
ìì! $
,
ìì$ %
beginBit
ìì& .
,
ìì. /
endBit
ìì0 6
,
ìì6 7
numBits
ìì8 ?
)
ìì? @
;
ìì@ A
if
îî 
(
îî 
idx
îî 
!=
îî 
endBit
îî !
)
îî! "
{
ïï 
return
ññ 
idx
ññ 
;
ññ 
}
óó 
}
òò 
if
öö 
(
öö 
numBits
öö 
>=
öö 
$num
öö 
)
öö 
{
õõ 
return
ùù 
int
ùù 
.
ùù 
MaxValue
ùù #
;
ùù# $
}
ûû 
idx
†† 
=
†† 
FindByte
†† 
(
†† 
ptr
†† 
,
†† 
beginBit
††  (
,
††( )
endBit
††* 0
,
††0 1
numBits
††2 9
)
††9 :
;
††: ;
if
°° 
(
°° 
idx
°° 
!=
°° 
endBit
°° 
)
°° 
{
¢¢ 
return
££ 
idx
££ 
;
££ 
}
§§ 
if
¶¶ 
(
¶¶ 
numBits
¶¶ 
<
¶¶ 
$num
¶¶ 
)
¶¶ 
{
ßß 
idx
®® 
=
®® 
FindUpto14bits
®® $
(
®®$ %
ptr
®®% (
,
®®( )
beginBit
®®* 2
,
®®2 3
endBit
®®4 :
,
®®: ;
numBits
®®< C
)
®®C D
;
®®D E
if
™™ 
(
™™ 
idx
™™ 
!=
™™ 
endBit
™™ !
)
™™! "
{
´´ 
return
¨¨ 
idx
¨¨ 
;
¨¨ 
}
≠≠ 
if
ØØ 
(
ØØ 
numBits
ØØ 
<
ØØ 
$num
ØØ 
)
ØØ  
{
∞∞ 
idx
¥¥ 
=
¥¥ 
FindUpto6bits
¥¥ '
(
¥¥' (
ptr
¥¥( +
,
¥¥+ ,
beginBit
¥¥- 5
,
¥¥5 6
endBit
¥¥7 =
,
¥¥= >
numBits
¥¥? F
)
¥¥F G
;
¥¥G H
if
∂∂ 
(
∂∂ 
idx
∂∂ 
!=
∂∂ 
endBit
∂∂ %
)
∂∂% &
{
∑∑ 
return
∏∏ 
idx
∏∏ "
;
∏∏" #
}
ππ 
}
∫∫ 
}
ªª 
return
ΩΩ 
int
ΩΩ 
.
ΩΩ 
MaxValue
ΩΩ 
;
ΩΩ  
}
ææ 	
internal
¿¿ 
static
¿¿ 
int
¿¿ 
Find
¿¿  
(
¿¿  !
ulong
¿¿! &
*
¿¿& '
ptr
¿¿( +
,
¿¿+ ,
int
¿¿- 0
pos
¿¿1 4
,
¿¿4 5
int
¿¿6 9
count
¿¿: ?
,
¿¿? @
int
¿¿A D
numBits
¿¿E L
)
¿¿L M
=>
¿¿N P
FindWithBeginEnd
¿¿Q a
(
¿¿a b
ptr
¿¿b e
,
¿¿e f
pos
¿¿g j
,
¿¿j k
pos
¿¿l o
+
¿¿p q
count
¿¿r w
,
¿¿w x
numBits¿¿y Ä
)¿¿Ä Å
;¿¿Å Ç
}
¡¡ 
[
…… 
DebuggerTypeProxy
…… 
(
…… 
typeof
…… 
(
…… !
BitField32DebugView
…… 1
)
……1 2
)
……2 3
]
……3 4
[
   
BurstCompatible
   
]
   
public
ÀÀ 

struct
ÀÀ 

BitField32
ÀÀ 
{
ÃÃ 
public
—— 
uint
—— 
Value
—— 
;
—— 
public
◊◊ 

BitField32
◊◊ 
(
◊◊ 
uint
◊◊ 
initialValue
◊◊ +
=
◊◊, -
$num
◊◊. 0
)
◊◊0 1
{
ÿÿ 	
Value
ŸŸ 
=
ŸŸ 
initialValue
ŸŸ  
;
ŸŸ  !
}
⁄⁄ 	
public
ﬂﬂ 
void
ﬂﬂ 
Clear
ﬂﬂ 
(
ﬂﬂ 
)
ﬂﬂ 
{
‡‡ 	
Value
·· 
=
·· 
$num
·· 
;
·· 
}
‚‚ 	
public
ÍÍ 
void
ÍÍ 
SetBits
ÍÍ 
(
ÍÍ 
int
ÍÍ 
pos
ÍÍ  #
,
ÍÍ# $
bool
ÍÍ% )
value
ÍÍ* /
)
ÍÍ/ 0
{
ÎÎ 	
	CheckArgs
ÏÏ 
(
ÏÏ 
pos
ÏÏ 
,
ÏÏ 
$num
ÏÏ 
)
ÏÏ 
;
ÏÏ 
Value
ÌÌ 
=
ÌÌ 
Bitwise
ÌÌ 
.
ÌÌ 
SetBits
ÌÌ #
(
ÌÌ# $
Value
ÌÌ$ )
,
ÌÌ) *
pos
ÌÌ+ .
,
ÌÌ. /
$num
ÌÌ0 1
,
ÌÌ1 2
value
ÌÌ3 8
)
ÌÌ8 9
;
ÌÌ9 :
}
ÓÓ 	
public
˜˜ 
void
˜˜ 
SetBits
˜˜ 
(
˜˜ 
int
˜˜ 
pos
˜˜  #
,
˜˜# $
bool
˜˜% )
value
˜˜* /
,
˜˜/ 0
int
˜˜1 4
numBits
˜˜5 <
)
˜˜< =
{
¯¯ 	
	CheckArgs
˘˘ 
(
˘˘ 
pos
˘˘ 
,
˘˘ 
numBits
˘˘ "
)
˘˘" #
;
˘˘# $
var
˙˙ 
mask
˙˙ 
=
˙˙ 
$num
˙˙ "
>>
˙˙# %
(
˙˙& '
$num
˙˙' )
-
˙˙* +
numBits
˙˙, 3
)
˙˙3 4
;
˙˙4 5
Value
˚˚ 
=
˚˚ 
Bitwise
˚˚ 
.
˚˚ 
SetBits
˚˚ #
(
˚˚# $
Value
˚˚$ )
,
˚˚) *
pos
˚˚+ .
,
˚˚. /
mask
˚˚0 4
,
˚˚4 5
value
˚˚6 ;
)
˚˚; <
;
˚˚< =
}
¸¸ 	
public
ÖÖ 
uint
ÖÖ 
GetBits
ÖÖ 
(
ÖÖ 
int
ÖÖ 
pos
ÖÖ  #
,
ÖÖ# $
int
ÖÖ% (
numBits
ÖÖ) 0
=
ÖÖ1 2
$num
ÖÖ3 4
)
ÖÖ4 5
{
ÜÜ 	
	CheckArgs
áá 
(
áá 
pos
áá 
,
áá 
numBits
áá "
)
áá" #
;
áá# $
var
àà 
mask
àà 
=
àà 
$num
àà "
>>
àà# %
(
àà& '
$num
àà' )
-
àà* +
numBits
àà, 3
)
àà3 4
;
àà4 5
return
ââ 
Bitwise
ââ 
.
ââ 
ExtractBits
ââ &
(
ââ& '
Value
ââ' ,
,
ââ, -
pos
ââ. 1
,
ââ1 2
mask
ââ3 7
)
ââ7 8
;
ââ8 9
}
ää 	
public
ëë 
bool
ëë 
IsSet
ëë 
(
ëë 
int
ëë 
pos
ëë !
)
ëë! "
{
íí 	
return
ìì 
$num
ìì 
!=
ìì 
GetBits
ìì 
(
ìì  
pos
ìì  #
)
ìì# $
;
ìì$ %
}
îî 	
public
ùù 
bool
ùù 
TestNone
ùù 
(
ùù 
int
ùù  
pos
ùù! $
,
ùù$ %
int
ùù& )
numBits
ùù* 1
=
ùù2 3
$num
ùù4 5
)
ùù5 6
{
ûû 	
return
üü 
$num
üü 
==
üü 
GetBits
üü  
(
üü  !
pos
üü! $
,
üü$ %
numBits
üü& -
)
üü- .
;
üü. /
}
†† 	
public
©© 
bool
©© 
TestAny
©© 
(
©© 
int
©© 
pos
©©  #
,
©©# $
int
©©% (
numBits
©©) 0
=
©©1 2
$num
©©3 4
)
©©4 5
{
™™ 	
return
´´ 
$num
´´ 
!=
´´ 
GetBits
´´  
(
´´  !
pos
´´! $
,
´´$ %
numBits
´´& -
)
´´- .
;
´´. /
}
¨¨ 	
public
µµ 
bool
µµ 
TestAll
µµ 
(
µµ 
int
µµ 
pos
µµ  #
,
µµ# $
int
µµ% (
numBits
µµ) 0
=
µµ1 2
$num
µµ3 4
)
µµ4 5
{
∂∂ 	
	CheckArgs
∑∑ 
(
∑∑ 
pos
∑∑ 
,
∑∑ 
numBits
∑∑ "
)
∑∑" #
;
∑∑# $
var
∏∏ 
mask
∏∏ 
=
∏∏ 
$num
∏∏ "
>>
∏∏# %
(
∏∏& '
$num
∏∏' )
-
∏∏* +
numBits
∏∏, 3
)
∏∏3 4
;
∏∏4 5
return
ππ 
mask
ππ 
==
ππ 
Bitwise
ππ "
.
ππ" #
ExtractBits
ππ# .
(
ππ. /
Value
ππ/ 4
,
ππ4 5
pos
ππ6 9
,
ππ9 :
mask
ππ; ?
)
ππ? @
;
ππ@ A
}
∫∫ 	
public
¿¿ 
int
¿¿ 
	CountBits
¿¿ 
(
¿¿ 
)
¿¿ 
{
¡¡ 	
return
¬¬ 
math
¬¬ 
.
¬¬ 
	countbits
¬¬ !
(
¬¬! "
Value
¬¬" '
)
¬¬' (
;
¬¬( )
}
√√ 	
public
…… 
int
…… 
CountLeadingZeros
…… $
(
……$ %
)
……% &
{
   	
return
ÀÀ 
math
ÀÀ 
.
ÀÀ 
lzcnt
ÀÀ 
(
ÀÀ 
Value
ÀÀ #
)
ÀÀ# $
;
ÀÀ$ %
}
ÃÃ 	
public
““ 
int
““  
CountTrailingZeros
““ %
(
““% &
)
““& '
{
”” 	
return
‘‘ 
math
‘‘ 
.
‘‘ 
tzcnt
‘‘ 
(
‘‘ 
Value
‘‘ #
)
‘‘# $
;
‘‘$ %
}
’’ 	
[
◊◊ 	
Conditional
◊◊	 
(
◊◊ 
$str
◊◊ 6
)
◊◊6 7
]
◊◊7 8
static
ÿÿ 
void
ÿÿ 
	CheckArgs
ÿÿ 
(
ÿÿ 
int
ÿÿ !
pos
ÿÿ" %
,
ÿÿ% &
int
ÿÿ' *
numBits
ÿÿ+ 2
)
ÿÿ2 3
{
ŸŸ 	
if
⁄⁄ 
(
⁄⁄ 
pos
⁄⁄ 
>
⁄⁄ 
$num
⁄⁄ 
||
€€ 
numBits
€€ 
==
€€ 
$num
€€ 
||
‹‹ 
numBits
‹‹ 
>
‹‹ 
$num
‹‹ 
||
›› 
pos
›› 
+
›› 
numBits
››  
>
››! "
$num
››# %
)
››% &
{
ﬁﬁ 
throw
ﬂﬂ 
new
ﬂﬂ 
ArgumentException
ﬂﬂ +
(
ﬂﬂ+ ,
$"
ﬂﬂ, .
$str
ﬂﬂ. P
{
ﬂﬂP Q
pos
ﬂﬂQ T
}
ﬂﬂT U
$str
ﬂﬂU n
{
ﬂﬂn o
numBits
ﬂﬂo v
}
ﬂﬂv w
$strﬂﬂw á
"ﬂﬂá à
)ﬂﬂà â
;ﬂﬂâ ä
}
‡‡ 
}
·· 	
}
‚‚ 
sealed
‰‰ 

class
‰‰ !
BitField32DebugView
‰‰ $
{
ÂÂ 

BitField32
ÊÊ 
BitField
ÊÊ 
;
ÊÊ 
public
ËË !
BitField32DebugView
ËË "
(
ËË" #

BitField32
ËË# -
bitfield
ËË. 6
)
ËË6 7
{
ÈÈ 	
BitField
ÍÍ 
=
ÍÍ 
bitfield
ÍÍ 
;
ÍÍ  
}
ÎÎ 	
public
ÌÌ 
bool
ÌÌ 
[
ÌÌ 
]
ÌÌ 
Bits
ÌÌ 
{
ÓÓ 	
get
ÔÔ 
{
 
var
ÒÒ 
array
ÒÒ 
=
ÒÒ 
new
ÒÒ 
bool
ÒÒ  $
[
ÒÒ$ %
$num
ÒÒ% '
]
ÒÒ' (
;
ÒÒ( )
for
ÚÚ 
(
ÚÚ 
int
ÚÚ 
i
ÚÚ 
=
ÚÚ 
$num
ÚÚ 
;
ÚÚ 
i
ÚÚ  !
<
ÚÚ" #
$num
ÚÚ$ &
;
ÚÚ& '
++
ÚÚ( *
i
ÚÚ* +
)
ÚÚ+ ,
{
ÛÛ 
array
ÙÙ 
[
ÙÙ 
i
ÙÙ 
]
ÙÙ 
=
ÙÙ 
BitField
ÙÙ '
.
ÙÙ' (
IsSet
ÙÙ( -
(
ÙÙ- .
i
ÙÙ. /
)
ÙÙ/ 0
;
ÙÙ0 1
}
ıı 
return
ˆˆ 
array
ˆˆ 
;
ˆˆ 
}
˜˜ 
}
¯¯ 	
}
˘˘ 
[
ÅÅ 
DebuggerTypeProxy
ÅÅ 
(
ÅÅ 
typeof
ÅÅ 
(
ÅÅ !
BitField64DebugView
ÅÅ 1
)
ÅÅ1 2
)
ÅÅ2 3
]
ÅÅ3 4
[
ÇÇ 
BurstCompatible
ÇÇ 
]
ÇÇ 
public
ÉÉ 

struct
ÉÉ 

BitField64
ÉÉ 
{
ÑÑ 
public
ââ 
ulong
ââ 
Value
ââ 
;
ââ 
public
èè 

BitField64
èè 
(
èè 
ulong
èè 
initialValue
èè  ,
=
èè- .
$num
èè/ 2
)
èè2 3
{
êê 	
Value
ëë 
=
ëë 
initialValue
ëë  
;
ëë  !
}
íí 	
public
óó 
void
óó 
Clear
óó 
(
óó 
)
óó 
{
òò 	
Value
ôô 
=
ôô 
$num
ôô 
;
ôô 
}
öö 	
public
°° 
void
°° 
SetBits
°° 
(
°° 
int
°° 
pos
°°  #
,
°°# $
bool
°°% )
value
°°* /
)
°°/ 0
{
¢¢ 	
	CheckArgs
££ 
(
££ 
pos
££ 
,
££ 
$num
££ 
)
££ 
;
££ 
Value
§§ 
=
§§ 
Bitwise
§§ 
.
§§ 
SetBits
§§ #
(
§§# $
Value
§§$ )
,
§§) *
pos
§§+ .
,
§§. /
$num
§§0 1
,
§§1 2
value
§§3 8
)
§§8 9
;
§§9 :
}
•• 	
public
ØØ 
void
ØØ 
SetBits
ØØ 
(
ØØ 
int
ØØ 
pos
ØØ  #
,
ØØ# $
bool
ØØ% )
value
ØØ* /
,
ØØ/ 0
int
ØØ1 4
numBits
ØØ5 <
=
ØØ= >
$num
ØØ? @
)
ØØ@ A
{
∞∞ 	
	CheckArgs
±± 
(
±± 
pos
±± 
,
±± 
numBits
±± "
)
±±" #
;
±±# $
var
≤≤ 
mask
≤≤ 
=
≤≤ 
$num
≤≤ +
>>
≤≤, .
(
≤≤/ 0
$num
≤≤0 2
-
≤≤3 4
numBits
≤≤5 <
)
≤≤< =
;
≤≤= >
Value
≥≥ 
=
≥≥ 
Bitwise
≥≥ 
.
≥≥ 
SetBits
≥≥ #
(
≥≥# $
Value
≥≥$ )
,
≥≥) *
pos
≥≥+ .
,
≥≥. /
mask
≥≥0 4
,
≥≥4 5
value
≥≥6 ;
)
≥≥; <
;
≥≥< =
}
¥¥ 	
public
ΩΩ 
ulong
ΩΩ 
GetBits
ΩΩ 
(
ΩΩ 
int
ΩΩ  
pos
ΩΩ! $
,
ΩΩ$ %
int
ΩΩ& )
numBits
ΩΩ* 1
=
ΩΩ2 3
$num
ΩΩ4 5
)
ΩΩ5 6
{
ææ 	
	CheckArgs
øø 
(
øø 
pos
øø 
,
øø 
numBits
øø "
)
øø" #
;
øø# $
var
¿¿ 
mask
¿¿ 
=
¿¿ 
$num
¿¿ +
>>
¿¿, .
(
¿¿/ 0
$num
¿¿0 2
-
¿¿3 4
numBits
¿¿5 <
)
¿¿< =
;
¿¿= >
return
¡¡ 
Bitwise
¡¡ 
.
¡¡ 
ExtractBits
¡¡ &
(
¡¡& '
Value
¡¡' ,
,
¡¡, -
pos
¡¡. 1
,
¡¡1 2
mask
¡¡3 7
)
¡¡7 8
;
¡¡8 9
}
¬¬ 	
public
…… 
bool
…… 
IsSet
…… 
(
…… 
int
…… 
pos
…… !
)
……! "
{
   	
return
ÀÀ 
$num
ÀÀ 
!=
ÀÀ 
GetBits
ÀÀ !
(
ÀÀ! "
pos
ÀÀ" %
)
ÀÀ% &
;
ÀÀ& '
}
ÃÃ 	
public
’’ 
bool
’’ 
TestNone
’’ 
(
’’ 
int
’’  
pos
’’! $
,
’’$ %
int
’’& )
numBits
’’* 1
=
’’2 3
$num
’’4 5
)
’’5 6
{
÷÷ 	
return
◊◊ 
$num
◊◊ 
==
◊◊ 
GetBits
◊◊ !
(
◊◊! "
pos
◊◊" %
,
◊◊% &
numBits
◊◊' .
)
◊◊. /
;
◊◊/ 0
}
ÿÿ 	
public
·· 
bool
·· 
TestAny
·· 
(
·· 
int
·· 
pos
··  #
,
··# $
int
··% (
numBits
··) 0
=
··1 2
$num
··3 4
)
··4 5
{
‚‚ 	
return
„„ 
$num
„„ 
!=
„„ 
GetBits
„„ !
(
„„! "
pos
„„" %
,
„„% &
numBits
„„' .
)
„„. /
;
„„/ 0
}
‰‰ 	
public
ÌÌ 
bool
ÌÌ 
TestAll
ÌÌ 
(
ÌÌ 
int
ÌÌ 
pos
ÌÌ  #
,
ÌÌ# $
int
ÌÌ% (
numBits
ÌÌ) 0
=
ÌÌ1 2
$num
ÌÌ3 4
)
ÌÌ4 5
{
ÓÓ 	
	CheckArgs
ÔÔ 
(
ÔÔ 
pos
ÔÔ 
,
ÔÔ 
numBits
ÔÔ "
)
ÔÔ" #
;
ÔÔ# $
var
 
mask
 
=
 
$num
 +
>>
, .
(
/ 0
$num
0 2
-
3 4
numBits
5 <
)
< =
;
= >
return
ÒÒ 
mask
ÒÒ 
==
ÒÒ 
Bitwise
ÒÒ "
.
ÒÒ" #
ExtractBits
ÒÒ# .
(
ÒÒ. /
Value
ÒÒ/ 4
,
ÒÒ4 5
pos
ÒÒ6 9
,
ÒÒ9 :
mask
ÒÒ; ?
)
ÒÒ? @
;
ÒÒ@ A
}
ÚÚ 	
public
¯¯ 
int
¯¯ 
	CountBits
¯¯ 
(
¯¯ 
)
¯¯ 
{
˘˘ 	
return
˙˙ 
math
˙˙ 
.
˙˙ 
	countbits
˙˙ !
(
˙˙! "
Value
˙˙" '
)
˙˙' (
;
˙˙( )
}
˚˚ 	
public
ÅÅ 
int
ÅÅ 
CountLeadingZeros
ÅÅ $
(
ÅÅ$ %
)
ÅÅ% &
{
ÇÇ 	
return
ÉÉ 
math
ÉÉ 
.
ÉÉ 
lzcnt
ÉÉ 
(
ÉÉ 
Value
ÉÉ #
)
ÉÉ# $
;
ÉÉ$ %
}
ÑÑ 	
public
ää 
int
ää  
CountTrailingZeros
ää %
(
ää% &
)
ää& '
{
ãã 	
return
åå 
math
åå 
.
åå 
tzcnt
åå 
(
åå 
Value
åå #
)
åå# $
;
åå$ %
}
çç 	
[
èè 	
Conditional
èè	 
(
èè 
$str
èè 6
)
èè6 7
]
èè7 8
static
êê 
void
êê 
	CheckArgs
êê 
(
êê 
int
êê !
pos
êê" %
,
êê% &
int
êê' *
numBits
êê+ 2
)
êê2 3
{
ëë 	
if
íí 
(
íí 
pos
íí 
>
íí 
$num
íí 
||
ìì 
numBits
ìì 
==
ìì 
$num
ìì 
||
îî 
numBits
îî 
>
îî 
$num
îî 
||
ïï 
pos
ïï 
+
ïï 
numBits
ïï  
>
ïï! "
$num
ïï# %
)
ïï% &
{
ññ 
throw
óó 
new
óó 
ArgumentException
óó +
(
óó+ ,
$"
óó, .
$str
óó. P
{
óóP Q
pos
óóQ T
}
óóT U
$str
óóU n
{
óón o
numBits
óóo v
}
óóv w
$stróów á
"óóá à
)óóà â
;óóâ ä
}
òò 
}
ôô 	
}
öö 
sealed
úú 

class
úú !
BitField64DebugView
úú $
{
ùù 

BitField64
ûû 
Data
ûû 
;
ûû 
public
†† !
BitField64DebugView
†† "
(
††" #

BitField64
††# -
data
††. 2
)
††2 3
{
°° 	
Data
¢¢ 
=
¢¢ 
data
¢¢ 
;
¢¢ 
}
££ 	
public
•• 
bool
•• 
[
•• 
]
•• 
Bits
•• 
{
¶¶ 	
get
ßß 
{
®® 
var
©© 
array
©© 
=
©© 
new
©© 
bool
©©  $
[
©©$ %
$num
©©% '
]
©©' (
;
©©( )
for
™™ 
(
™™ 
int
™™ 
i
™™ 
=
™™ 
$num
™™ 
;
™™ 
i
™™  !
<
™™" #
$num
™™$ &
;
™™& '
++
™™( *
i
™™* +
)
™™+ ,
{
´´ 
array
¨¨ 
[
¨¨ 
i
¨¨ 
]
¨¨ 
=
¨¨ 
Data
¨¨ #
.
¨¨# $
IsSet
¨¨$ )
(
¨¨) *
i
¨¨* +
)
¨¨+ ,
;
¨¨, -
}
≠≠ 
return
ÆÆ 
array
ÆÆ 
;
ÆÆ 
}
ØØ 
}
∞∞ 	
}
±± 
}≤≤ √À
dC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UnsafeHashMap.cs
	namespace 	
Unity
 
. 
Collections 
. 
LowLevel $
.$ %
Unsafe% +
{ 
[ 
BurstCompatible 
] 
public 

unsafe 
struct #
UnsafeHashMapBucketData 0
{ 
internal #
UnsafeHashMapBucketData (
(( )
byte) -
*- .
v/ 0
,0 1
byte2 6
*6 7
k8 9
,9 :
byte; ?
*? @
nA B
,B C
byteD H
*H I
bJ K
,K L
intM P
bcmQ T
)T U
{ 	
values 
= 
v 
; 
keys 
= 
k 
; 
next 
= 
n 
; 
buckets 
= 
b 
; 
bucketCapacityMask 
=  
bcm! $
;$ %
} 	
public## 
readonly## 
byte## 
*## 
values## $
;##$ %
public)) 
readonly)) 
byte)) 
*)) 
keys)) "
;))" #
public// 
readonly// 
byte// 
*// 
next// "
;//" #
public55 
readonly55 
byte55 
*55 
buckets55 %
;55% &
public;; 
readonly;; 
int;; 
bucketCapacityMask;; .
;;;. /
}<< 
[>> 
StructLayout>> 
(>> 

LayoutKind>> 
.>> 
Explicit>> %
)>>% &
]>>& '
[?? 
BurstCompatible?? 
]?? 
internal@@ 
unsafe@@ 
struct@@ 
UnsafeHashMapData@@ ,
{AA 
[BB 	
FieldOffsetBB	 
(BB 
$numBB 
)BB 
]BB 
internalCC 
byteCC 
*CC 
valuesCC 
;CC 
[FF 	
FieldOffsetFF	 
(FF 
$numFF 
)FF 
]FF 
internalGG 
byteGG 
*GG 
keysGG 
;GG 
[JJ 	
FieldOffsetJJ	 
(JJ 
$numJJ 
)JJ 
]JJ 
internalKK 
byteKK 
*KK 
nextKK 
;KK 
[NN 	
FieldOffsetNN	 
(NN 
$numNN 
)NN 
]NN 
internalOO 
byteOO 
*OO 
bucketsOO 
;OO 
[RR 	
FieldOffsetRR	 
(RR 
$numRR 
)RR 
]RR 
internalSS 
intSS 
keyCapacitySS  
;SS  !
[UU 	
FieldOffsetUU	 
(UU 
$numUU 
)UU 
]UU 
internalVV 
intVV 
bucketCapacityMaskVV '
;VV' (
[XX 	
FieldOffsetXX	 
(XX 
$numXX 
)XX 
]XX 
internalYY 
intYY  
allocatedIndexLengthYY )
;YY) *
[[[ 	
FieldOffset[[	 
([[ 
JobsUtility[[  
.[[  !
CacheLineSize[[! .
<[[/ 0
$num[[1 3
?[[4 5
$num[[6 8
:[[9 :
JobsUtility[[; F
.[[F G
CacheLineSize[[G T
)[[T U
][[U V
internal\\ 
fixed\\ 
int\\ 
firstFreeTLS\\ '
[\\' (
JobsUtility\\( 3
.\\3 4
MaxJobThreadCount\\4 E
*\\F G
IntsPerCacheLine\\H X
]\\X Y
;\\Y Z
internal__ 
const__ 
int__ 
IntsPerCacheLine__ +
=__, -
JobsUtility__. 9
.__9 :
CacheLineSize__: G
/__H I
sizeof__J P
(__P Q
int__Q T
)__T U
;__U V
internalaa 
staticaa 
intaa 
GetBucketSizeaa )
(aa) *
intaa* -
capacityaa. 6
)aa6 7
{bb 	
returncc 
capacitycc 
*cc 
$numcc 
;cc  
}dd 	
internalff 
staticff 
intff 
GrowCapacityff (
(ff( )
intff) ,
capacityff- 5
)ff5 6
{gg 	
ifhh 
(hh 
capacityhh 
==hh 
$numhh 
)hh 
{ii 
returnjj 
$numjj 
;jj 
}kk 
returnmm 
capacitymm 
*mm 
$nummm 
;mm  
}nn 	
[pp 	
BurstCompatiblepp	 
(pp  
GenericTypeArgumentspp -
=pp. /
newpp0 3
[pp4 5
]pp5 6
{pp7 8
typeofpp9 ?
(pp? @
intpp@ C
)ppC D
,ppD E
typeofppF L
(ppL M
intppM P
)ppP Q
}ppR S
)ppS T
]ppT U
internalqq 
staticqq 
voidqq 
AllocateHashMapqq ,
<qq, -
TKeyqq- 1
,qq1 2
TValueqq3 9
>qq9 :
(qq: ;
intqq; >
lengthqq? E
,qqE F
intqqG J
bucketLengthqqK W
,qqW X
AllocatorManagerqqY i
.qqi j
AllocatorHandleqqj y
labelqqz 
,	qq Ä
outrr 
UnsafeHashMapDatarr !
*rr! "
outBufrr# )
)rr) *
wheress 
TKeyss 
:ss 
structss 
wherett 
TValuett 
:tt 
structtt !
{uu 	
CollectionHelpervv 
.vv 
CheckIsUnmanagedvv -
<vv- .
TKeyvv. 2
>vv2 3
(vv3 4
)vv4 5
;vv5 6
CollectionHelperww 
.ww 
CheckIsUnmanagedww -
<ww- .
TValueww. 4
>ww4 5
(ww5 6
)ww6 7
;ww7 8
UnsafeHashMapDatayy 
*yy 
datayy #
=yy$ %
(yy& '
UnsafeHashMapDatayy' 8
*yy8 9
)yy9 :
Memoryyy: @
.yy@ A
	UnmanagedyyA J
.yyJ K
AllocateyyK S
(yyS T
sizeofyyT Z
(yyZ [
UnsafeHashMapDatayy[ l
)yyl m
,yym n
UnsafeUtilityyyo |
.yy| }
AlignOf	yy} Ñ
<
yyÑ Ö
UnsafeHashMapData
yyÖ ñ
>
yyñ ó
(
yyó ò
)
yyò ô
,
yyô ö
label
yyõ †
)
yy† °
;
yy° ¢
bucketLength{{ 
={{ 
math{{ 
.{{  
ceilpow2{{  (
({{( )
bucketLength{{) 5
){{5 6
;{{6 7
data}} 
->}} 
keyCapacity}} 
=}} 
length}}  &
;}}& '
data~~ 
->~~ 
bucketCapacityMask~~ $
=~~% &
bucketLength~~' 3
-~~4 5
$num~~6 7
;~~7 8
int
ÄÄ 
	keyOffset
ÄÄ 
,
ÄÄ 

nextOffset
ÄÄ %
,
ÄÄ% &
bucketOffset
ÄÄ' 3
;
ÄÄ3 4
int
ÅÅ 
	totalSize
ÅÅ 
=
ÅÅ 
CalculateDataSize
ÅÅ -
<
ÅÅ- .
TKey
ÅÅ. 2
,
ÅÅ2 3
TValue
ÅÅ4 :
>
ÅÅ: ;
(
ÅÅ; <
length
ÅÅ< B
,
ÅÅB C
bucketLength
ÅÅD P
,
ÅÅP Q
out
ÅÅR U
	keyOffset
ÅÅV _
,
ÅÅ_ `
out
ÅÅa d

nextOffset
ÅÅe o
,
ÅÅo p
out
ÅÅq t
bucketOffsetÅÅu Å
)ÅÅÅ Ç
;ÅÅÇ É
data
ÉÉ 
->
ÉÉ 
values
ÉÉ 
=
ÉÉ 
(
ÉÉ 
byte
ÉÉ  
*
ÉÉ  !
)
ÉÉ! "
Memory
ÉÉ" (
.
ÉÉ( )
	Unmanaged
ÉÉ) 2
.
ÉÉ2 3
Allocate
ÉÉ3 ;
(
ÉÉ; <
	totalSize
ÉÉ< E
,
ÉÉE F
JobsUtility
ÉÉG R
.
ÉÉR S
CacheLineSize
ÉÉS `
,
ÉÉ` a
label
ÉÉb g
)
ÉÉg h
;
ÉÉh i
data
ÑÑ 
->
ÑÑ 
keys
ÑÑ 
=
ÑÑ 
data
ÑÑ 
->
ÑÑ 
values
ÑÑ %
+
ÑÑ& '
	keyOffset
ÑÑ( 1
;
ÑÑ1 2
data
ÖÖ 
->
ÖÖ 
next
ÖÖ 
=
ÖÖ 
data
ÖÖ 
->
ÖÖ 
values
ÖÖ %
+
ÖÖ& '

nextOffset
ÖÖ( 2
;
ÖÖ2 3
data
ÜÜ 
->
ÜÜ 
buckets
ÜÜ 
=
ÜÜ 
data
ÜÜ  
->
ÜÜ  "
values
ÜÜ" (
+
ÜÜ) *
bucketOffset
ÜÜ+ 7
;
ÜÜ7 8
outBuf
àà 
=
àà 
data
àà 
;
àà 
}
ââ 	
[
ãã 	
BurstCompatible
ãã	 
(
ãã "
GenericTypeArguments
ãã -
=
ãã. /
new
ãã0 3
[
ãã4 5
]
ãã5 6
{
ãã7 8
typeof
ãã9 ?
(
ãã? @
int
ãã@ C
)
ããC D
,
ããD E
typeof
ããF L
(
ããL M
int
ããM P
)
ããP Q
}
ããR S
)
ããS T
]
ããT U
internal
åå 
static
åå 
void
åå 
ReallocateHashMap
åå .
<
åå. /
TKey
åå/ 3
,
åå3 4
TValue
åå5 ;
>
åå; <
(
åå< =
UnsafeHashMapData
åå= N
*
ååN O
data
ååP T
,
ååT U
int
ååV Y
newCapacity
ååZ e
,
ååe f
int
ååg j
newBucketCapacity
ååk |
,
åå| }
AllocatorManageråå~ é
.ååé è
AllocatorHandleååè û
labelååü §
)åå§ •
where
çç 
TKey
çç 
:
çç 
struct
çç 
where
éé 
TValue
éé 
:
éé 
struct
éé !
{
èè 	
newBucketCapacity
êê 
=
êê 
math
êê  $
.
êê$ %
ceilpow2
êê% -
(
êê- .
newBucketCapacity
êê. ?
)
êê? @
;
êê@ A
if
íí 
(
íí 
data
íí 
->
íí 
keyCapacity
íí !
==
íí" $
newCapacity
íí% 0
&&
íí1 3
(
íí4 5
data
íí5 9
->
íí9 ; 
bucketCapacityMask
íí; M
+
ííN O
$num
ííP Q
)
ííQ R
==
ííS U
newBucketCapacity
ííV g
)
ííg h
{
ìì 
return
îî 
;
îî 
}
ïï 1
#CheckHashMapReallocateDoesNotShrink
óó /
(
óó/ 0
data
óó0 4
,
óó4 5
newCapacity
óó6 A
)
óóA B
;
óóB C
int
ôô 
	keyOffset
ôô 
,
ôô 

nextOffset
ôô %
,
ôô% &
bucketOffset
ôô' 3
;
ôô3 4
int
öö 
	totalSize
öö 
=
öö 
CalculateDataSize
öö -
<
öö- .
TKey
öö. 2
,
öö2 3
TValue
öö4 :
>
öö: ;
(
öö; <
newCapacity
öö< G
,
ööG H
newBucketCapacity
ööI Z
,
ööZ [
out
öö\ _
	keyOffset
öö` i
,
ööi j
out
öök n

nextOffset
ööo y
,
ööy z
out
öö{ ~
bucketOffsetöö ã
)ööã å
;ööå ç
byte
úú 
*
úú 
newData
úú 
=
úú 
(
úú 
byte
úú !
*
úú! "
)
úú" #
Memory
úú# )
.
úú) *
	Unmanaged
úú* 3
.
úú3 4
Allocate
úú4 <
(
úú< =
	totalSize
úú= F
,
úúF G
JobsUtility
úúH S
.
úúS T
CacheLineSize
úúT a
,
úúa b
label
úúc h
)
úúh i
;
úúi j
byte
ùù 
*
ùù 
newKeys
ùù 
=
ùù 
newData
ùù #
+
ùù$ %
	keyOffset
ùù& /
;
ùù/ 0
byte
ûû 
*
ûû 
newNext
ûû 
=
ûû 
newData
ûû #
+
ûû$ %

nextOffset
ûû& 0
;
ûû0 1
byte
üü 
*
üü 

newBuckets
üü 
=
üü 
newData
üü &
+
üü' (
bucketOffset
üü) 5
;
üü5 6
UnsafeUtility
¢¢ 
.
¢¢ 
MemCpy
¢¢  
(
¢¢  !
newData
¢¢! (
,
¢¢( )
data
¢¢* .
->
¢¢. 0
values
¢¢0 6
,
¢¢6 7
data
¢¢8 <
->
¢¢< >
keyCapacity
¢¢> I
*
¢¢J K
UnsafeUtility
¢¢L Y
.
¢¢Y Z
SizeOf
¢¢Z `
<
¢¢` a
TValue
¢¢a g
>
¢¢g h
(
¢¢h i
)
¢¢i j
)
¢¢j k
;
¢¢k l
UnsafeUtility
££ 
.
££ 
MemCpy
££  
(
££  !
newKeys
££! (
,
££( )
data
££* .
->
££. 0
keys
££0 4
,
££4 5
data
££6 :
->
££: <
keyCapacity
££< G
*
££H I
UnsafeUtility
££J W
.
££W X
SizeOf
££X ^
<
££^ _
TKey
££_ c
>
££c d
(
££d e
)
££e f
)
££f g
;
££g h
UnsafeUtility
§§ 
.
§§ 
MemCpy
§§  
(
§§  !
newNext
§§! (
,
§§( )
data
§§* .
->
§§. 0
next
§§0 4
,
§§4 5
data
§§6 :
->
§§: <
keyCapacity
§§< G
*
§§H I
UnsafeUtility
§§J W
.
§§W X
SizeOf
§§X ^
<
§§^ _
int
§§_ b
>
§§b c
(
§§c d
)
§§d e
)
§§e f
;
§§f g
for
¶¶ 
(
¶¶ 
int
¶¶ 
	emptyNext
¶¶ 
=
¶¶  
data
¶¶! %
->
¶¶% '
keyCapacity
¶¶' 2
;
¶¶2 3
	emptyNext
¶¶4 =
<
¶¶> ?
newCapacity
¶¶@ K
;
¶¶K L
++
¶¶M O
	emptyNext
¶¶O X
)
¶¶X Y
{
ßß 
(
®® 
(
®® 
int
®® 
*
®® 
)
®® 
newNext
®® 
)
®® 
[
®®  
	emptyNext
®®  )
]
®®) *
=
®®+ ,
-
®®- .
$num
®®. /
;
®®/ 0
}
©© 
for
¨¨ 
(
¨¨ 
int
¨¨ 
bucket
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨  
bucket
¨¨! '
<
¨¨( )
newBucketCapacity
¨¨* ;
;
¨¨; <
++
¨¨= ?
bucket
¨¨? E
)
¨¨E F
{
≠≠ 
(
ÆÆ 
(
ÆÆ 
int
ÆÆ 
*
ÆÆ 
)
ÆÆ 

newBuckets
ÆÆ !
)
ÆÆ! "
[
ÆÆ" #
bucket
ÆÆ# )
]
ÆÆ) *
=
ÆÆ+ ,
-
ÆÆ- .
$num
ÆÆ. /
;
ÆÆ/ 0
}
ØØ 
for
±± 
(
±± 
int
±± 
bucket
±± 
=
±± 
$num
±± 
;
±±  
bucket
±±! '
<=
±±( *
data
±±+ /
->
±±/ 1 
bucketCapacityMask
±±1 C
;
±±C D
++
±±E G
bucket
±±G M
)
±±M N
{
≤≤ 
int
≥≥ 
*
≥≥ 
buckets
≥≥ 
=
≥≥ 
(
≥≥  
int
≥≥  #
*
≥≥# $
)
≥≥$ %
data
≥≥% )
->
≥≥) +
buckets
≥≥+ 2
;
≥≥2 3
int
¥¥ 
*
¥¥ 
nextPtrs
¥¥ 
=
¥¥ 
(
¥¥  !
int
¥¥! $
*
¥¥$ %
)
¥¥% &
newNext
¥¥& -
;
¥¥- .
while
µµ 
(
µµ 
buckets
µµ 
[
µµ 
bucket
µµ %
]
µµ% &
>=
µµ' )
$num
µµ* +
)
µµ+ ,
{
∂∂ 
int
∑∑ 
curEntry
∑∑  
=
∑∑! "
buckets
∑∑# *
[
∑∑* +
bucket
∑∑+ 1
]
∑∑1 2
;
∑∑2 3
buckets
∏∏ 
[
∏∏ 
bucket
∏∏ "
]
∏∏" #
=
∏∏$ %
nextPtrs
∏∏& .
[
∏∏. /
curEntry
∏∏/ 7
]
∏∏7 8
;
∏∏8 9
int
ππ 
	newBucket
ππ !
=
ππ" #
UnsafeUtility
ππ$ 1
.
ππ1 2
ReadArrayElement
ππ2 B
<
ππB C
TKey
ππC G
>
ππG H
(
ππH I
data
ππI M
->
ππM O
keys
ππO S
,
ππS T
curEntry
ππU ]
)
ππ] ^
.
ππ^ _
GetHashCode
ππ_ j
(
ππj k
)
ππk l
&
ππm n
(
ππo p 
newBucketCapacityππp Å
-ππÇ É
$numππÑ Ö
)ππÖ Ü
;ππÜ á
nextPtrs
∫∫ 
[
∫∫ 
curEntry
∫∫ %
]
∫∫% &
=
∫∫' (
(
∫∫) *
(
∫∫* +
int
∫∫+ .
*
∫∫. /
)
∫∫/ 0

newBuckets
∫∫0 :
)
∫∫: ;
[
∫∫; <
	newBucket
∫∫< E
]
∫∫E F
;
∫∫F G
(
ªª 
(
ªª 
int
ªª 
*
ªª 
)
ªª 

newBuckets
ªª %
)
ªª% &
[
ªª& '
	newBucket
ªª' 0
]
ªª0 1
=
ªª2 3
curEntry
ªª4 <
;
ªª< =
}
ºº 
}
ΩΩ 
Memory
øø 
.
øø 
	Unmanaged
øø 
.
øø 
Free
øø !
(
øø! "
data
øø" &
->
øø& (
values
øø( .
,
øø. /
label
øø0 5
)
øø5 6
;
øø6 7
if
¿¿ 
(
¿¿ 
data
¿¿ 
->
¿¿ "
allocatedIndexLength
¿¿ *
>
¿¿+ ,
data
¿¿- 1
->
¿¿1 3
keyCapacity
¿¿3 >
)
¿¿> ?
{
¡¡ 
data
¬¬ 
->
¬¬ "
allocatedIndexLength
¬¬ *
=
¬¬+ ,
data
¬¬- 1
->
¬¬1 3
keyCapacity
¬¬3 >
;
¬¬> ?
}
√√ 
data
≈≈ 
->
≈≈ 
values
≈≈ 
=
≈≈ 
newData
≈≈ "
;
≈≈" #
data
∆∆ 
->
∆∆ 
keys
∆∆ 
=
∆∆ 
newKeys
∆∆  
;
∆∆  !
data
«« 
->
«« 
next
«« 
=
«« 
newNext
««  
;
««  !
data
»» 
->
»» 
buckets
»» 
=
»» 

newBuckets
»» &
;
»»& '
data
…… 
->
…… 
keyCapacity
…… 
=
…… 
newCapacity
……  +
;
……+ ,
data
   
->
    
bucketCapacityMask
   $
=
  % &
newBucketCapacity
  ' 8
-
  9 :
$num
  ; <
;
  < =
}
ÀÀ 	
internal
ÕÕ 
static
ÕÕ 
void
ÕÕ 
DeallocateHashMap
ÕÕ .
(
ÕÕ. /
UnsafeHashMapData
ÕÕ/ @
*
ÕÕ@ A
data
ÕÕB F
,
ÕÕF G
AllocatorManager
ÕÕH X
.
ÕÕX Y
AllocatorHandle
ÕÕY h
	allocator
ÕÕi r
)
ÕÕr s
{
ŒŒ 	
Memory
œœ 
.
œœ 
	Unmanaged
œœ 
.
œœ 
Free
œœ !
(
œœ! "
data
œœ" &
->
œœ& (
values
œœ( .
,
œœ. /
	allocator
œœ0 9
)
œœ9 :
;
œœ: ;
Memory
–– 
.
–– 
	Unmanaged
–– 
.
–– 
Free
–– !
(
––! "
data
––" &
,
––& '
	allocator
––( 1
)
––1 2
;
––2 3
}
—— 	
[
”” 	
BurstCompatible
””	 
(
”” "
GenericTypeArguments
”” -
=
””. /
new
””0 3
[
””4 5
]
””5 6
{
””7 8
typeof
””9 ?
(
””? @
int
””@ C
)
””C D
,
””D E
typeof
””F L
(
””L M
int
””M P
)
””P Q
}
””R S
)
””S T
]
””T U
internal
‘‘ 
static
‘‘ 
int
‘‘ 
CalculateDataSize
‘‘ -
<
‘‘- .
TKey
‘‘. 2
,
‘‘2 3
TValue
‘‘4 :
>
‘‘: ;
(
‘‘; <
int
‘‘< ?
length
‘‘@ F
,
‘‘F G
int
‘‘H K
bucketLength
‘‘L X
,
‘‘X Y
out
‘‘Z ]
int
‘‘^ a
	keyOffset
‘‘b k
,
‘‘k l
out
‘‘m p
int
‘‘q t

nextOffset
‘‘u 
,‘‘ Ä
out‘‘Å Ñ
int‘‘Ö à
bucketOffset‘‘â ï
)‘‘ï ñ
where
’’ 
TKey
’’ 
:
’’ 
struct
’’ 
where
÷÷ 
TValue
÷÷ 
:
÷÷ 
struct
÷÷ !
{
◊◊ 	
var
ÿÿ 
sizeOfTValue
ÿÿ 
=
ÿÿ 
UnsafeUtility
ÿÿ ,
.
ÿÿ, -
SizeOf
ÿÿ- 3
<
ÿÿ3 4
TValue
ÿÿ4 :
>
ÿÿ: ;
(
ÿÿ; <
)
ÿÿ< =
;
ÿÿ= >
var
ŸŸ 

sizeOfTKey
ŸŸ 
=
ŸŸ 
UnsafeUtility
ŸŸ *
.
ŸŸ* +
SizeOf
ŸŸ+ 1
<
ŸŸ1 2
TKey
ŸŸ2 6
>
ŸŸ6 7
(
ŸŸ7 8
)
ŸŸ8 9
;
ŸŸ9 :
var
⁄⁄ 
	sizeOfInt
⁄⁄ 
=
⁄⁄ 
UnsafeUtility
⁄⁄ )
.
⁄⁄) *
SizeOf
⁄⁄* 0
<
⁄⁄0 1
int
⁄⁄1 4
>
⁄⁄4 5
(
⁄⁄5 6
)
⁄⁄6 7
;
⁄⁄7 8
var
‹‹ 

valuesSize
‹‹ 
=
‹‹ 
CollectionHelper
‹‹ -
.
‹‹- .
Align
‹‹. 3
(
‹‹3 4
sizeOfTValue
‹‹4 @
*
‹‹A B
length
‹‹C I
,
‹‹I J
JobsUtility
‹‹K V
.
‹‹V W
CacheLineSize
‹‹W d
)
‹‹d e
;
‹‹e f
var
›› 
keysSize
›› 
=
›› 
CollectionHelper
›› +
.
››+ ,
Align
››, 1
(
››1 2

sizeOfTKey
››2 <
*
››= >
length
››? E
,
››E F
JobsUtility
››G R
.
››R S
CacheLineSize
››S `
)
››` a
;
››a b
var
ﬁﬁ 
nextSize
ﬁﬁ 
=
ﬁﬁ 
CollectionHelper
ﬁﬁ +
.
ﬁﬁ+ ,
Align
ﬁﬁ, 1
(
ﬁﬁ1 2
	sizeOfInt
ﬁﬁ2 ;
*
ﬁﬁ< =
length
ﬁﬁ> D
,
ﬁﬁD E
JobsUtility
ﬁﬁF Q
.
ﬁﬁQ R
CacheLineSize
ﬁﬁR _
)
ﬁﬁ_ `
;
ﬁﬁ` a
var
ﬂﬂ 

bucketSize
ﬂﬂ 
=
ﬂﬂ 
CollectionHelper
ﬂﬂ -
.
ﬂﬂ- .
Align
ﬂﬂ. 3
(
ﬂﬂ3 4
	sizeOfInt
ﬂﬂ4 =
*
ﬂﬂ> ?
bucketLength
ﬂﬂ@ L
,
ﬂﬂL M
JobsUtility
ﬂﬂN Y
.
ﬂﬂY Z
CacheLineSize
ﬂﬂZ g
)
ﬂﬂg h
;
ﬂﬂh i
var
‡‡ 
	totalSize
‡‡ 
=
‡‡ 

valuesSize
‡‡ &
+
‡‡' (
keysSize
‡‡) 1
+
‡‡2 3
nextSize
‡‡4 <
+
‡‡= >

bucketSize
‡‡? I
;
‡‡I J
	keyOffset
‚‚ 
=
‚‚ 
$num
‚‚ 
+
‚‚ 

valuesSize
‚‚ &
;
‚‚& '

nextOffset
„„ 
=
„„ 
	keyOffset
„„ "
+
„„# $
keysSize
„„% -
;
„„- .
bucketOffset
‰‰ 
=
‰‰ 

nextOffset
‰‰ %
+
‰‰& '
nextSize
‰‰( 0
;
‰‰0 1
return
ÊÊ 
	totalSize
ÊÊ 
;
ÊÊ 
}
ÁÁ 	
internal
ÈÈ 
static
ÈÈ 
bool
ÈÈ 
IsEmpty
ÈÈ $
(
ÈÈ$ %
UnsafeHashMapData
ÈÈ% 6
*
ÈÈ6 7
data
ÈÈ8 <
)
ÈÈ< =
{
ÍÍ 	
if
ÎÎ 
(
ÎÎ 
data
ÎÎ 
->
ÎÎ "
allocatedIndexLength
ÎÎ *
<=
ÎÎ+ -
$num
ÎÎ. /
)
ÎÎ/ 0
{
ÏÏ 
return
ÌÌ 
true
ÌÌ 
;
ÌÌ 
}
ÓÓ 
var
 
bucketArray
 
=
 
(
 
int
 "
*
" #
)
# $
data
$ (
->
( *
buckets
* 1
;
1 2
var
ÒÒ 

bucketNext
ÒÒ 
=
ÒÒ 
(
ÒÒ 
int
ÒÒ !
*
ÒÒ! "
)
ÒÒ" #
data
ÒÒ# '
->
ÒÒ' )
next
ÒÒ) -
;
ÒÒ- .
var
ÚÚ 
capacityMask
ÚÚ 
=
ÚÚ 
data
ÚÚ #
->
ÚÚ# % 
bucketCapacityMask
ÚÚ% 7
;
ÚÚ7 8
for
ÙÙ 
(
ÙÙ 
int
ÙÙ 
i
ÙÙ 
=
ÙÙ 
$num
ÙÙ 
;
ÙÙ 
i
ÙÙ 
<=
ÙÙ  
capacityMask
ÙÙ! -
;
ÙÙ- .
++
ÙÙ/ 1
i
ÙÙ1 2
)
ÙÙ2 3
{
ıı 
int
ˆˆ 
bucket
ˆˆ 
=
ˆˆ 
bucketArray
ˆˆ (
[
ˆˆ( )
i
ˆˆ) *
]
ˆˆ* +
;
ˆˆ+ ,
if
¯¯ 
(
¯¯ 
bucket
¯¯ 
!=
¯¯ 
-
¯¯ 
$num
¯¯  
)
¯¯  !
{
˘˘ 
return
˙˙ 
false
˙˙  
;
˙˙  !
}
˚˚ 
}
¸¸ 
return
˛˛ 
true
˛˛ 
;
˛˛ 
}
ˇˇ 	
internal
ÅÅ 
static
ÅÅ 
int
ÅÅ 
GetCount
ÅÅ $
(
ÅÅ$ %
UnsafeHashMapData
ÅÅ% 6
*
ÅÅ6 7
data
ÅÅ8 <
)
ÅÅ< =
{
ÇÇ 	
if
ÉÉ 
(
ÉÉ 
data
ÉÉ 
->
ÉÉ "
allocatedIndexLength
ÉÉ *
<=
ÉÉ+ -
$num
ÉÉ. /
)
ÉÉ/ 0
{
ÑÑ 
return
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
}
ÜÜ 
var
àà 

bucketNext
àà 
=
àà 
(
àà 
int
àà !
*
àà! "
)
àà" #
data
àà# '
->
àà' )
next
àà) -
;
àà- .
var
ââ 
freeListSize
ââ 
=
ââ 
$num
ââ  
;
ââ  !
for
ãã 
(
ãã 
int
ãã 
tls
ãã 
=
ãã 
$num
ãã 
;
ãã 
tls
ãã !
<
ãã" #
JobsUtility
ãã$ /
.
ãã/ 0
MaxJobThreadCount
ãã0 A
;
ããA B
++
ããC E
tls
ããE H
)
ããH I
{
åå 
for
çç 
(
çç 
var
çç 
freeIdx
çç  
=
çç! "
data
çç# '
->
çç' )
firstFreeTLS
çç) 5
[
çç5 6
tls
çç6 9
*
çç: ;
IntsPerCacheLine
çç< L
]
ççL M
;
éé 
freeIdx
éé 
>=
éé  
$num
éé! "
;
èè 
freeIdx
èè 
=
èè 

bucketNext
èè  *
[
èè* +
freeIdx
èè+ 2
]
èè2 3
)
êê 
{
ëë 
++
íí 
freeListSize
íí "
;
íí" #
}
ìì 
}
îî 
return
ññ 
math
ññ 
.
ññ 
min
ññ 
(
ññ 
data
ññ  
->
ññ  "
keyCapacity
ññ" -
,
ññ- .
data
ññ/ 3
->
ññ3 5"
allocatedIndexLength
ññ5 I
)
ññI J
-
ññK L
freeListSize
ññM Y
;
ññY Z
}
óó 	
internal
ôô 
static
ôô 
bool
ôô 
MoveNext
ôô %
(
ôô% &
UnsafeHashMapData
ôô& 7
*
ôô7 8
data
ôô9 =
,
ôô= >
ref
ôô? B
int
ôôC F
bucketIndex
ôôG R
,
ôôR S
ref
ôôT W
int
ôôX [
	nextIndex
ôô\ e
,
ôôe f
out
ôôg j
int
ôôk n
index
ôôo t
)
ôôt u
{
öö 	
var
õõ 
bucketArray
õõ 
=
õõ 
(
õõ 
int
õõ "
*
õõ" #
)
õõ# $
data
õõ$ (
->
õõ( *
buckets
õõ* 1
;
õõ1 2
var
úú 

bucketNext
úú 
=
úú 
(
úú 
int
úú !
*
úú! "
)
úú" #
data
úú# '
->
úú' )
next
úú) -
;
úú- .
var
ùù 
capacityMask
ùù 
=
ùù 
data
ùù #
->
ùù# % 
bucketCapacityMask
ùù% 7
;
ùù7 8
if
üü 
(
üü 
	nextIndex
üü 
!=
üü 
-
üü 
$num
üü 
)
üü  
{
†† 
index
°° 
=
°° 
	nextIndex
°° !
;
°°! "
	nextIndex
¢¢ 
=
¢¢ 

bucketNext
¢¢ &
[
¢¢& '
	nextIndex
¢¢' 0
]
¢¢0 1
;
¢¢1 2
return
££ 
true
££ 
;
££ 
}
§§ 
for
¶¶ 
(
¶¶ 
int
¶¶ 
i
¶¶ 
=
¶¶ 
bucketIndex
¶¶ $
;
¶¶$ %
i
¶¶& '
<=
¶¶( *
capacityMask
¶¶+ 7
;
¶¶7 8
++
¶¶9 ;
i
¶¶; <
)
¶¶< =
{
ßß 
var
®® 
idx
®® 
=
®® 
bucketArray
®® %
[
®®% &
i
®®& '
]
®®' (
;
®®( )
if
™™ 
(
™™ 
idx
™™ 
!=
™™ 
-
™™ 
$num
™™ 
)
™™ 
{
´´ 
index
¨¨ 
=
¨¨ 
idx
¨¨ 
;
¨¨  
bucketIndex
≠≠ 
=
≠≠  !
i
≠≠" #
+
≠≠$ %
$num
≠≠& '
;
≠≠' (
	nextIndex
ÆÆ 
=
ÆÆ 

bucketNext
ÆÆ  *
[
ÆÆ* +
idx
ÆÆ+ .
]
ÆÆ. /
;
ÆÆ/ 0
return
∞∞ 
true
∞∞ 
;
∞∞  
}
±± 
}
≤≤ 
index
¥¥ 
=
¥¥ 
-
¥¥ 
$num
¥¥ 
;
¥¥ 
bucketIndex
µµ 
=
µµ 
capacityMask
µµ &
+
µµ' (
$num
µµ) *
;
µµ* +
	nextIndex
∂∂ 
=
∂∂ 
-
∂∂ 
$num
∂∂ 
;
∂∂ 
return
∑∑ 
false
∑∑ 
;
∑∑ 
}
∏∏ 	
[
∫∫ 	
BurstCompatible
∫∫	 
(
∫∫ "
GenericTypeArguments
∫∫ -
=
∫∫. /
new
∫∫0 3
[
∫∫4 5
]
∫∫5 6
{
∫∫7 8
typeof
∫∫9 ?
(
∫∫? @
int
∫∫@ C
)
∫∫C D
}
∫∫E F
)
∫∫F G
]
∫∫G H
internal
ªª 
static
ªª 
void
ªª 
GetKeyArray
ªª (
<
ªª( )
TKey
ªª) -
>
ªª- .
(
ªª. /
UnsafeHashMapData
ªª/ @
*
ªª@ A
data
ªªB F
,
ªªF G
NativeArray
ªªH S
<
ªªS T
TKey
ªªT X
>
ªªX Y
result
ªªZ `
)
ªª` a
where
ºº 
TKey
ºº 
:
ºº 
struct
ºº 
{
ΩΩ 	
var
ææ 
bucketArray
ææ 
=
ææ 
(
ææ 
int
ææ "
*
ææ" #
)
ææ# $
data
ææ$ (
->
ææ( *
buckets
ææ* 1
;
ææ1 2
var
øø 

bucketNext
øø 
=
øø 
(
øø 
int
øø !
*
øø! "
)
øø" #
data
øø# '
->
øø' )
next
øø) -
;
øø- .
for
¡¡ 
(
¡¡ 
int
¡¡ 
i
¡¡ 
=
¡¡ 
$num
¡¡ 
,
¡¡ 
count
¡¡ !
=
¡¡" #
$num
¡¡$ %
,
¡¡% &
max
¡¡' *
=
¡¡+ ,
result
¡¡- 3
.
¡¡3 4
Length
¡¡4 :
;
¡¡: ;
i
¡¡< =
<=
¡¡> @
data
¡¡A E
->
¡¡E G 
bucketCapacityMask
¡¡G Y
&&
¡¡Z \
count
¡¡] b
<
¡¡c d
max
¡¡e h
;
¡¡h i
++
¡¡j l
i
¡¡l m
)
¡¡m n
{
¬¬ 
int
√√ 
bucket
√√ 
=
√√ 
bucketArray
√√ (
[
√√( )
i
√√) *
]
√√* +
;
√√+ ,
while
≈≈ 
(
≈≈ 
bucket
≈≈ 
!=
≈≈  
-
≈≈! "
$num
≈≈" #
)
≈≈# $
{
∆∆ 
result
«« 
[
«« 
count
««  
++
««  "
]
««" #
=
««$ %
UnsafeUtility
««& 3
.
««3 4
ReadArrayElement
««4 D
<
««D E
TKey
««E I
>
««I J
(
««J K
data
««K O
->
««O Q
keys
««Q U
,
««U V
bucket
««W ]
)
««] ^
;
««^ _
bucket
»» 
=
»» 

bucketNext
»» '
[
»»' (
bucket
»»( .
]
»». /
;
»»/ 0
}
…… 
}
   
}
ÀÀ 	
[
ÕÕ 	
BurstCompatible
ÕÕ	 
(
ÕÕ "
GenericTypeArguments
ÕÕ -
=
ÕÕ. /
new
ÕÕ0 3
[
ÕÕ4 5
]
ÕÕ5 6
{
ÕÕ7 8
typeof
ÕÕ9 ?
(
ÕÕ? @
int
ÕÕ@ C
)
ÕÕC D
}
ÕÕE F
)
ÕÕF G
]
ÕÕG H
internal
ŒŒ 
static
ŒŒ 
void
ŒŒ 
GetValueArray
ŒŒ *
<
ŒŒ* +
TValue
ŒŒ+ 1
>
ŒŒ1 2
(
ŒŒ2 3
UnsafeHashMapData
ŒŒ3 D
*
ŒŒD E
data
ŒŒF J
,
ŒŒJ K
NativeArray
ŒŒL W
<
ŒŒW X
TValue
ŒŒX ^
>
ŒŒ^ _
result
ŒŒ` f
)
ŒŒf g
where
œœ 
TValue
œœ 
:
œœ 
struct
œœ !
{
–– 	
var
—— 
bucketArray
—— 
=
—— 
(
—— 
int
—— "
*
——" #
)
——# $
data
——$ (
->
——( *
buckets
——* 1
;
——1 2
var
““ 

bucketNext
““ 
=
““ 
(
““ 
int
““ !
*
““! "
)
““" #
data
““# '
->
““' )
next
““) -
;
““- .
for
‘‘ 
(
‘‘ 
int
‘‘ 
i
‘‘ 
=
‘‘ 
$num
‘‘ 
,
‘‘ 
count
‘‘ !
=
‘‘" #
$num
‘‘$ %
,
‘‘% &
max
‘‘' *
=
‘‘+ ,
result
‘‘- 3
.
‘‘3 4
Length
‘‘4 :
,
‘‘: ;
capacityMask
‘‘< H
=
‘‘I J
data
‘‘K O
->
‘‘O Q 
bucketCapacityMask
‘‘Q c
;
’’ 
i
’’ 
<=
’’ 
capacityMask
’’ #
&&
’’$ &
count
’’' ,
<
’’- .
max
’’/ 2
;
÷÷ 
++
÷÷ 
i
÷÷ 
)
◊◊ 
{
ÿÿ 
int
ŸŸ 
bucket
ŸŸ 
=
ŸŸ 
bucketArray
ŸŸ (
[
ŸŸ( )
i
ŸŸ) *
]
ŸŸ* +
;
ŸŸ+ ,
while
€€ 
(
€€ 
bucket
€€ 
!=
€€  
-
€€! "
$num
€€" #
)
€€# $
{
‹‹ 
result
›› 
[
›› 
count
››  
++
››  "
]
››" #
=
››$ %
UnsafeUtility
››& 3
.
››3 4
ReadArrayElement
››4 D
<
››D E
TValue
››E K
>
››K L
(
››L M
data
››M Q
->
››Q S
values
››S Y
,
››Y Z
bucket
››[ a
)
››a b
;
››b c
bucket
ﬁﬁ 
=
ﬁﬁ 

bucketNext
ﬁﬁ '
[
ﬁﬁ' (
bucket
ﬁﬁ( .
]
ﬁﬁ. /
;
ﬁﬁ/ 0
}
ﬂﬂ 
}
‡‡ 
}
·· 	
[
„„ 	
BurstCompatible
„„	 
(
„„ "
GenericTypeArguments
„„ -
=
„„. /
new
„„0 3
[
„„4 5
]
„„5 6
{
„„7 8
typeof
„„9 ?
(
„„? @
int
„„@ C
)
„„C D
,
„„D E
typeof
„„F L
(
„„L M
int
„„M P
)
„„P Q
}
„„R S
)
„„S T
]
„„T U
internal
‰‰ 
static
‰‰ 
void
‰‰ 
GetKeyValueArrays
‰‰ .
<
‰‰. /
TKey
‰‰/ 3
,
‰‰3 4
TValue
‰‰5 ;
>
‰‰; <
(
‰‰< =
UnsafeHashMapData
‰‰= N
*
‰‰N O
data
‰‰P T
,
‰‰T U"
NativeKeyValueArrays
‰‰V j
<
‰‰j k
TKey
‰‰k o
,
‰‰o p
TValue
‰‰q w
>
‰‰w x
result
‰‰y 
)‰‰ Ä
where
ÂÂ 
TKey
ÂÂ 
:
ÂÂ 
struct
ÂÂ 
where
ÊÊ 
TValue
ÊÊ 
:
ÊÊ 
struct
ÊÊ !
{
ÁÁ 	
var
ËË 
bucketArray
ËË 
=
ËË 
(
ËË 
int
ËË "
*
ËË" #
)
ËË# $
data
ËË$ (
->
ËË( *
buckets
ËË* 1
;
ËË1 2
var
ÈÈ 

bucketNext
ÈÈ 
=
ÈÈ 
(
ÈÈ 
int
ÈÈ !
*
ÈÈ! "
)
ÈÈ" #
data
ÈÈ# '
->
ÈÈ' )
next
ÈÈ) -
;
ÈÈ- .
for
ÎÎ 
(
ÎÎ 
int
ÎÎ 
i
ÎÎ 
=
ÎÎ 
$num
ÎÎ 
,
ÎÎ 
count
ÎÎ !
=
ÎÎ" #
$num
ÎÎ$ %
,
ÎÎ% &
max
ÎÎ' *
=
ÎÎ+ ,
result
ÎÎ- 3
.
ÎÎ3 4
Length
ÎÎ4 :
,
ÎÎ: ;
capacityMask
ÎÎ< H
=
ÎÎI J
data
ÎÎK O
->
ÎÎO Q 
bucketCapacityMask
ÎÎQ c
;
ÏÏ 
i
ÏÏ 
<=
ÏÏ 
capacityMask
ÏÏ #
&&
ÏÏ$ &
count
ÏÏ' ,
<
ÏÏ- .
max
ÏÏ/ 2
;
ÌÌ 
++
ÌÌ 
i
ÌÌ 
)
ÓÓ 
{
ÔÔ 
int
 
bucket
 
=
 
bucketArray
 (
[
( )
i
) *
]
* +
;
+ ,
while
ÚÚ 
(
ÚÚ 
bucket
ÚÚ 
!=
ÚÚ  
-
ÚÚ! "
$num
ÚÚ" #
)
ÚÚ# $
{
ÛÛ 
result
ÙÙ 
.
ÙÙ 
Keys
ÙÙ 
[
ÙÙ  
count
ÙÙ  %
]
ÙÙ% &
=
ÙÙ' (
UnsafeUtility
ÙÙ) 6
.
ÙÙ6 7
ReadArrayElement
ÙÙ7 G
<
ÙÙG H
TKey
ÙÙH L
>
ÙÙL M
(
ÙÙM N
data
ÙÙN R
->
ÙÙR T
keys
ÙÙT X
,
ÙÙX Y
bucket
ÙÙZ `
)
ÙÙ` a
;
ÙÙa b
result
ıı 
.
ıı 
Values
ıı !
[
ıı! "
count
ıı" '
]
ıı' (
=
ıı) *
UnsafeUtility
ıı+ 8
.
ıı8 9
ReadArrayElement
ıı9 I
<
ııI J
TValue
ııJ P
>
ııP Q
(
ııQ R
data
ııR V
->
ııV X
values
ııX ^
,
ıı^ _
bucket
ıı` f
)
ııf g
;
ııg h
count
ˆˆ 
++
ˆˆ 
;
ˆˆ 
bucket
˜˜ 
=
˜˜ 

bucketNext
˜˜ '
[
˜˜' (
bucket
˜˜( .
]
˜˜. /
;
˜˜/ 0
}
¯¯ 
}
˘˘ 
}
˙˙ 	
internal
¸¸ %
UnsafeHashMapBucketData
¸¸ (
GetBucketData
¸¸) 6
(
¸¸6 7
)
¸¸7 8
{
˝˝ 	
return
˛˛ 
new
˛˛ %
UnsafeHashMapBucketData
˛˛ .
(
˛˛. /
values
˛˛/ 5
,
˛˛5 6
keys
˛˛7 ;
,
˛˛; <
next
˛˛= A
,
˛˛A B
buckets
˛˛C J
,
˛˛J K 
bucketCapacityMask
˛˛L ^
)
˛˛^ _
;
˛˛_ `
}
ˇˇ 	
[
ÅÅ 	
Conditional
ÅÅ	 
(
ÅÅ 
$str
ÅÅ 6
)
ÅÅ6 7
]
ÅÅ7 8
static
ÇÇ 
void
ÇÇ 1
#CheckHashMapReallocateDoesNotShrink
ÇÇ 7
(
ÇÇ7 8
UnsafeHashMapData
ÇÇ8 I
*
ÇÇI J
data
ÇÇK O
,
ÇÇO P
int
ÇÇQ T
newCapacity
ÇÇU `
)
ÇÇ` a
{
ÉÉ 	
if
ÑÑ 
(
ÑÑ 
data
ÑÑ 
->
ÑÑ 
keyCapacity
ÑÑ !
>
ÑÑ" #
newCapacity
ÑÑ$ /
)
ÑÑ/ 0
throw
ÖÖ 
new
ÖÖ 
	Exception
ÖÖ #
(
ÖÖ# $
$str
ÖÖ$ K
)
ÖÖK L
;
ÖÖL M
}
ÜÜ 	
}
áá 
[
ââ 
NativeContainer
ââ 
]
ââ 
[
ää 
BurstCompatible
ää 
]
ää 
internal
ãã 
unsafe
ãã 
struct
ãã &
UnsafeHashMapDataDispose
ãã 3
{
åå 
[
çç 	/
!NativeDisableUnsafePtrRestriction
çç	 *
]
çç* +
internal
éé 
UnsafeHashMapData
éé "
*
éé" #
m_Buffer
éé$ ,
;
éé, -
internal
èè 
AllocatorManager
èè !
.
èè! "
AllocatorHandle
èè" 1
m_AllocatorLabel
èè2 B
;
èèB C
internal
íí  
AtomicSafetyHandle
íí #
m_Safety
íí$ ,
;
íí, -
public
ïï 
void
ïï 
Dispose
ïï 
(
ïï 
)
ïï 
{
ññ 	
UnsafeHashMapData
óó 
.
óó 
DeallocateHashMap
óó /
(
óó/ 0
m_Buffer
óó0 8
,
óó8 9
m_AllocatorLabel
óó: J
)
óóJ K
;
óóK L
}
òò 	
}
ôô 
[
õõ 
BurstCompile
õõ 
]
õõ 
internal
úú 
unsafe
úú 
struct
úú )
UnsafeHashMapDataDisposeJob
úú 6
:
úú7 8
IJob
úú9 =
{
ùù 
internal
ûû &
UnsafeHashMapDataDispose
ûû )
Data
ûû* .
;
ûû. /
public
†† 
void
†† 
Execute
†† 
(
†† 
)
†† 
{
°° 	
Data
¢¢ 
.
¢¢ 
Dispose
¢¢ 
(
¢¢ 
)
¢¢ 
;
¢¢ 
}
££ 	
}
§§ 
[
¶¶ 
StructLayout
¶¶ 
(
¶¶ 

LayoutKind
¶¶ 
.
¶¶ 

Sequential
¶¶ '
)
¶¶' (
]
¶¶( )
[
ßß 
BurstCompatible
ßß 
(
ßß "
GenericTypeArguments
ßß )
=
ßß* +
new
ßß, /
[
ßß0 1
]
ßß1 2
{
ßß3 4
typeof
ßß5 ;
(
ßß; <
int
ßß< ?
)
ßß? @
,
ßß@ A
typeof
ßßB H
(
ßßH I
int
ßßI L
)
ßßL M
}
ßßN O
)
ßßO P
]
ßßP Q
internal
®® 
struct
®® 
UnsafeHashMapBase
®® %
<
®®% &
TKey
®®& *
,
®®* +
TValue
®®, 2
>
®®2 3
where
©© 
TKey
©© 
:
©© 
struct
©© 
,
©© 

IEquatable
©© '
<
©©' (
TKey
©©( ,
>
©©, -
where
™™ 
TValue
™™ 
:
™™ 
struct
™™ 
{
´´ 
internal
¨¨ 
static
¨¨ 
unsafe
¨¨ 
void
¨¨ #
Clear
¨¨$ )
(
¨¨) *
UnsafeHashMapData
¨¨* ;
*
¨¨; <
data
¨¨= A
)
¨¨A B
{
≠≠ 	
UnsafeUtility
ÆÆ 
.
ÆÆ 
MemSet
ÆÆ  
(
ÆÆ  !
data
ÆÆ! %
->
ÆÆ% '
buckets
ÆÆ' .
,
ÆÆ. /
$num
ÆÆ0 4
,
ÆÆ4 5
(
ÆÆ6 7
data
ÆÆ7 ;
->
ÆÆ; = 
bucketCapacityMask
ÆÆ= O
+
ÆÆP Q
$num
ÆÆR S
)
ÆÆS T
*
ÆÆU V
$num
ÆÆW X
)
ÆÆX Y
;
ÆÆY Z
UnsafeUtility
ØØ 
.
ØØ 
MemSet
ØØ  
(
ØØ  !
data
ØØ! %
->
ØØ% '
next
ØØ' +
,
ØØ+ ,
$num
ØØ- 1
,
ØØ1 2
(
ØØ3 4
data
ØØ4 8
->
ØØ8 :
keyCapacity
ØØ: E
)
ØØE F
*
ØØG H
$num
ØØI J
)
ØØJ K
;
ØØK L
for
±± 
(
±± 
int
±± 
tls
±± 
=
±± 
$num
±± 
;
±± 
tls
±± !
<
±±" #
JobsUtility
±±$ /
.
±±/ 0
MaxJobThreadCount
±±0 A
;
±±A B
++
±±C E
tls
±±E H
)
±±H I
{
≤≤ 
data
≥≥ 
->
≥≥ 
firstFreeTLS
≥≥ "
[
≥≥" #
tls
≥≥# &
*
≥≥' (
UnsafeHashMapData
≥≥) :
.
≥≥: ;
IntsPerCacheLine
≥≥; K
]
≥≥K L
=
≥≥M N
-
≥≥O P
$num
≥≥P Q
;
≥≥Q R
}
¥¥ 
data
∂∂ 
->
∂∂ "
allocatedIndexLength
∂∂ &
=
∂∂' (
$num
∂∂) *
;
∂∂* +
}
∑∑ 	
internal
ππ 
static
ππ 
unsafe
ππ 
int
ππ "

AllocEntry
ππ# -
(
ππ- .
UnsafeHashMapData
ππ. ?
*
ππ? @
data
ππA E
,
ππE F
int
ππG J
threadIndex
ππK V
)
ππV W
{
∫∫ 	
int
ªª 
idx
ªª 
;
ªª 
int
ºº 
*
ºº 
nextPtrs
ºº 
=
ºº 
(
ºº 
int
ºº  
*
ºº  !
)
ºº! "
data
ºº" &
->
ºº& (
next
ºº( ,
;
ºº, -
do
ææ 
{
øø 
idx
¿¿ 
=
¿¿ 
data
¿¿ 
->
¿¿ 
firstFreeTLS
¿¿ (
[
¿¿( )
threadIndex
¿¿) 4
*
¿¿5 6
UnsafeHashMapData
¿¿7 H
.
¿¿H I
IntsPerCacheLine
¿¿I Y
]
¿¿Y Z
;
¿¿Z [
if
√√ 
(
√√ 
idx
√√ 
<
√√ 
$num
√√ 
)
√√ 
{
ƒƒ 
Interlocked
   
.
    
Exchange
    (
(
  ( )
ref
  ) ,
data
  - 1
->
  1 3
firstFreeTLS
  3 ?
[
  ? @
threadIndex
  @ K
*
  L M
UnsafeHashMapData
  N _
.
  _ `
IntsPerCacheLine
  ` p
]
  p q
,
  q r
-
  s t
$num
  t u
)
  u v
;
  v w
if
ÕÕ 
(
ÕÕ 
data
ÕÕ 
->
ÕÕ "
allocatedIndexLength
ÕÕ 2
<
ÕÕ3 4
data
ÕÕ5 9
->
ÕÕ9 ;
keyCapacity
ÕÕ; F
)
ÕÕF G
{
ŒŒ 
idx
œœ 
=
œœ 
Interlocked
œœ )
.
œœ) *
Add
œœ* -
(
œœ- .
ref
œœ. 1
data
œœ2 6
->
œœ6 8"
allocatedIndexLength
œœ8 L
,
œœL M
$num
œœN P
)
œœP Q
-
œœR S
$num
œœT V
;
œœV W
if
—— 
(
—— 
idx
—— 
<
——  !
data
——" &
->
——& (
keyCapacity
——( 3
-
——4 5
$num
——6 7
)
——7 8
{
““ 
int
”” 
count
””  %
=
””& '
math
””( ,
.
””, -
min
””- 0
(
””0 1
$num
””1 3
,
””3 4
data
””5 9
->
””9 ;
keyCapacity
””; F
-
””G H
idx
””I L
)
””L M
;
””M N
for
÷÷ 
(
÷÷  !
int
÷÷! $
i
÷÷% &
=
÷÷' (
$num
÷÷) *
;
÷÷* +
i
÷÷, -
<
÷÷. /
count
÷÷0 5
;
÷÷5 6
++
÷÷7 9
i
÷÷9 :
)
÷÷: ;
{
◊◊ 
nextPtrs
ÿÿ  (
[
ÿÿ( )
idx
ÿÿ) ,
+
ÿÿ- .
i
ÿÿ/ 0
]
ÿÿ0 1
=
ÿÿ2 3
idx
ÿÿ4 7
+
ÿÿ8 9
i
ÿÿ: ;
+
ÿÿ< =
$num
ÿÿ> ?
;
ÿÿ? @
}
ŸŸ 
nextPtrs
‹‹ $
[
‹‹$ %
idx
‹‹% (
+
‹‹) *
count
‹‹+ 0
-
‹‹1 2
$num
‹‹3 4
]
‹‹4 5
=
‹‹6 7
-
‹‹8 9
$num
‹‹9 :
;
‹‹: ;
nextPtrs
ﬂﬂ $
[
ﬂﬂ$ %
idx
ﬂﬂ% (
]
ﬂﬂ( )
=
ﬂﬂ* +
-
ﬂﬂ, -
$num
ﬂﬂ- .
;
ﬂﬂ. /
Interlocked
‚‚ '
.
‚‚' (
Exchange
‚‚( 0
(
‚‚0 1
ref
‚‚1 4
data
‚‚5 9
->
‚‚9 ;
firstFreeTLS
‚‚; G
[
‚‚G H
threadIndex
‚‚H S
*
‚‚T U
UnsafeHashMapData
‚‚V g
.
‚‚g h
IntsPerCacheLine
‚‚h x
]
‚‚x y
,
‚‚y z
idx
‚‚{ ~
+‚‚ Ä
$num‚‚Å Ç
)‚‚Ç É
;‚‚É Ñ
return
‰‰ "
idx
‰‰# &
;
‰‰& '
}
ÂÂ 
if
ÁÁ 
(
ÁÁ 
idx
ÁÁ 
==
ÁÁ  "
data
ÁÁ# '
->
ÁÁ' )
keyCapacity
ÁÁ) 4
-
ÁÁ5 6
$num
ÁÁ7 8
)
ÁÁ8 9
{
ËË 
Interlocked
ÎÎ '
.
ÎÎ' (
Exchange
ÎÎ( 0
(
ÎÎ0 1
ref
ÎÎ1 4
data
ÎÎ5 9
->
ÎÎ9 ;
firstFreeTLS
ÎÎ; G
[
ÎÎG H
threadIndex
ÎÎH S
*
ÎÎT U
UnsafeHashMapData
ÎÎV g
.
ÎÎg h
IntsPerCacheLine
ÎÎh x
]
ÎÎx y
,
ÎÎy z
-
ÎÎ{ |
$num
ÎÎ| }
)
ÎÎ} ~
;
ÎÎ~ 
return
ÌÌ "
idx
ÌÌ# &
;
ÌÌ& '
}
ÓÓ 
}
ÔÔ 
Interlocked
ÚÚ 
.
ÚÚ  
Exchange
ÚÚ  (
(
ÚÚ( )
ref
ÚÚ) ,
data
ÚÚ- 1
->
ÚÚ1 3
firstFreeTLS
ÚÚ3 ?
[
ÚÚ? @
threadIndex
ÚÚ@ K
*
ÚÚL M
UnsafeHashMapData
ÚÚN _
.
ÚÚ_ `
IntsPerCacheLine
ÚÚ` p
]
ÚÚp q
,
ÚÚq r
-
ÚÚs t
$num
ÚÚt u
)
ÚÚu v
;
ÚÚv w
bool
ıı 
again
ıı 
=
ıı  
true
ıı! %
;
ıı% &
while
ˆˆ 
(
ˆˆ 
again
ˆˆ  
)
ˆˆ  !
{
˜˜ 
again
¯¯ 
=
¯¯ 
false
¯¯  %
;
¯¯% &
for
˘˘ 
(
˘˘ 
int
˘˘  
other
˘˘! &
=
˘˘' (
(
˘˘) *
threadIndex
˘˘* 5
+
˘˘6 7
$num
˘˘8 9
)
˘˘9 :
%
˘˘; <
JobsUtility
˘˘= H
.
˘˘H I
MaxJobThreadCount
˘˘I Z
;
˙˙ 
other
˙˙ $
!=
˙˙% '
threadIndex
˙˙( 3
;
˚˚ 
other
˚˚ $
=
˚˚% &
(
˚˚' (
other
˚˚( -
+
˚˚. /
$num
˚˚0 1
)
˚˚1 2
%
˚˚3 4
JobsUtility
˚˚5 @
.
˚˚@ A
MaxJobThreadCount
˚˚A R
)
¸¸ 
{
˝˝ 
do
ÄÄ 
{
ÅÅ 
idx
ÇÇ  #
=
ÇÇ$ %
data
ÇÇ& *
->
ÇÇ* ,
firstFreeTLS
ÇÇ, 8
[
ÇÇ8 9
other
ÇÇ9 >
*
ÇÇ? @
UnsafeHashMapData
ÇÇA R
.
ÇÇR S
IntsPerCacheLine
ÇÇS c
]
ÇÇc d
;
ÇÇd e
if
ÑÑ  "
(
ÑÑ# $
idx
ÑÑ$ '
<
ÑÑ( )
$num
ÑÑ* +
)
ÑÑ+ ,
{
ÖÖ  !
break
ÜÜ$ )
;
ÜÜ) *
}
áá  !
}
àà 
while
ââ !
(
ââ" #
Interlocked
ââ# .
.
ââ. /
CompareExchange
ââ/ >
(
ââ> ?
ref
ää  #
data
ää$ (
->
ää( *
firstFreeTLS
ää* 6
[
ää6 7
other
ää7 <
*
ää= >
UnsafeHashMapData
ää? P
.
ääP Q
IntsPerCacheLine
ääQ a
]
ääa b
,
ãã  !
nextPtrs
ãã" *
[
ãã* +
idx
ãã+ .
]
ãã. /
,
åå  !
idx
åå" %
)
çç# $
!=
çç% '
idx
çç( +
)
éé 
;
éé 
if
êê 
(
êê  
idx
êê  #
==
êê$ &
-
êê' (
$num
êê( )
)
êê) *
{
ëë 
again
ìì  %
=
ìì& '
true
ìì( ,
;
ìì, -
}
îî 
else
ïï  
if
ïï! #
(
ïï$ %
idx
ïï% (
>=
ïï) +
$num
ïï, -
)
ïï- .
{
ññ 
nextPtrs
ôô  (
[
ôô( )
idx
ôô) ,
]
ôô, -
=
ôô. /
-
ôô0 1
$num
ôô1 2
;
ôô2 3
return
öö  &
idx
öö' *
;
öö* +
}
õõ 
}
úú 
}
ùù 
	ThrowFull
ûû 
(
ûû 
)
ûû 
;
ûû  
}
üü  
CheckOutOfCapacity
°° "
(
°°" #
idx
°°# &
,
°°& '
data
°°( ,
->
°°, .
keyCapacity
°°. 9
)
°°9 :
;
°°: ;
}
¢¢ 
while
££ 
(
££ 
Interlocked
££ 
.
££ 
CompareExchange
££ .
(
££. /
ref
§§ 
data
§§ 
->
§§ 
firstFreeTLS
§§ &
[
§§& '
threadIndex
§§' 2
*
§§3 4
UnsafeHashMapData
§§5 F
.
§§F G
IntsPerCacheLine
§§G W
]
§§W X
,
•• 
nextPtrs
•• 
[
•• 
idx
•• 
]
•• 
,
¶¶ 
idx
¶¶ 
)
ßß 
!=
ßß 
idx
ßß 
)
®® 
;
®® 
nextPtrs
™™ 
[
™™ 
idx
™™ 
]
™™ 
=
™™ 
-
™™ 
$num
™™ 
;
™™ 
return
´´ 
idx
´´ 
;
´´ 
}
¨¨ 	
internal
ÆÆ 
static
ÆÆ 
unsafe
ÆÆ 
void
ÆÆ #
	FreeEntry
ÆÆ$ -
(
ÆÆ- .
UnsafeHashMapData
ÆÆ. ?
*
ÆÆ? @
data
ÆÆA E
,
ÆÆE F
int
ÆÆG J
idx
ÆÆK N
,
ÆÆN O
int
ÆÆP S
threadIndex
ÆÆT _
)
ÆÆ_ `
{
ØØ 	
int
∞∞ 
*
∞∞ 
nextPtrs
∞∞ 
=
∞∞ 
(
∞∞ 
int
∞∞  
*
∞∞  !
)
∞∞! "
data
∞∞" &
->
∞∞& (
next
∞∞( ,
;
∞∞, -
int
±± 
next
±± 
=
±± 
-
±± 
$num
±± 
;
±± 
do
≥≥ 
{
¥¥ 
next
µµ 
=
µµ 
data
µµ 
->
µµ 
firstFreeTLS
µµ )
[
µµ) *
threadIndex
µµ* 5
*
µµ6 7
UnsafeHashMapData
µµ8 I
.
µµI J
IntsPerCacheLine
µµJ Z
]
µµZ [
;
µµ[ \
nextPtrs
∂∂ 
[
∂∂ 
idx
∂∂ 
]
∂∂ 
=
∂∂ 
next
∂∂  $
;
∂∂$ %
}
∑∑ 
while
∏∏ 
(
∏∏ 
Interlocked
∏∏ 
.
∏∏ 
CompareExchange
∏∏ .
(
∏∏. /
ref
ππ 
data
ππ 
->
ππ 
firstFreeTLS
ππ &
[
ππ& '
threadIndex
ππ' 2
*
ππ3 4
UnsafeHashMapData
ππ5 F
.
ππF G
IntsPerCacheLine
ππG W
]
ππW X
,
∫∫ 
idx
∫∫ 
,
ªª 
next
ªª 
)
ºº 
!=
ºº 
next
ºº 
)
ΩΩ 
;
ΩΩ 
}
ææ 	
internal
¿¿ 
static
¿¿ 
unsafe
¿¿ 
bool
¿¿ #
TryAddAtomic
¿¿$ 0
(
¿¿0 1
UnsafeHashMapData
¿¿1 B
*
¿¿B C
data
¿¿D H
,
¿¿H I
TKey
¿¿J N
key
¿¿O R
,
¿¿R S
TValue
¿¿T Z
item
¿¿[ _
,
¿¿_ `
int
¿¿a d
threadIndex
¿¿e p
)
¿¿p q
{
¡¡ 	
TValue
¬¬ 
tempItem
¬¬ 
;
¬¬ (
NativeMultiHashMapIterator
√√ &
<
√√& '
TKey
√√' +
>
√√+ ,
tempIt
√√- 3
;
√√3 4
if
ƒƒ 
(
ƒƒ $
TryGetFirstValueAtomic
ƒƒ &
(
ƒƒ& '
data
ƒƒ' +
,
ƒƒ+ ,
key
ƒƒ- 0
,
ƒƒ0 1
out
ƒƒ2 5
tempItem
ƒƒ6 >
,
ƒƒ> ?
out
ƒƒ@ C
tempIt
ƒƒD J
)
ƒƒJ K
)
ƒƒK L
{
≈≈ 
return
∆∆ 
false
∆∆ 
;
∆∆ 
}
«« 
int
   
idx
   
=
   

AllocEntry
    
(
    !
data
  ! %
,
  % &
threadIndex
  ' 2
)
  2 3
;
  3 4
UnsafeUtility
ÕÕ 
.
ÕÕ 
WriteArrayElement
ÕÕ +
(
ÕÕ+ ,
data
ÕÕ, 0
->
ÕÕ0 2
keys
ÕÕ2 6
,
ÕÕ6 7
idx
ÕÕ8 ;
,
ÕÕ; <
key
ÕÕ= @
)
ÕÕ@ A
;
ÕÕA B
UnsafeUtility
ŒŒ 
.
ŒŒ 
WriteArrayElement
ŒŒ +
(
ŒŒ+ ,
data
ŒŒ, 0
->
ŒŒ0 2
values
ŒŒ2 8
,
ŒŒ8 9
idx
ŒŒ: =
,
ŒŒ= >
item
ŒŒ? C
)
ŒŒC D
;
ŒŒD E
int
–– 
bucket
–– 
=
–– 
key
–– 
.
–– 
GetHashCode
–– (
(
––( )
)
––) *
&
––+ ,
data
––- 1
->
––1 3 
bucketCapacityMask
––3 E
;
––E F
int
““ 
*
““ 
buckets
““ 
=
““ 
(
““ 
int
““ 
*
““  
)
““  !
data
““! %
->
““% '
buckets
““' .
;
““. /
if
÷÷ 
(
÷÷ 
Interlocked
÷÷ 
.
÷÷ 
CompareExchange
÷÷ +
(
÷÷+ ,
ref
÷÷, /
buckets
÷÷0 7
[
÷÷7 8
bucket
÷÷8 >
]
÷÷> ?
,
÷÷? @
idx
÷÷A D
,
÷÷D E
-
÷÷F G
$num
÷÷G H
)
÷÷H I
!=
÷÷J L
-
÷÷M N
$num
÷÷N O
)
÷÷O P
{
◊◊ 
int
ÿÿ 
*
ÿÿ 
nextPtrs
ÿÿ 
=
ÿÿ 
(
ÿÿ  !
int
ÿÿ! $
*
ÿÿ$ %
)
ÿÿ% &
data
ÿÿ& *
->
ÿÿ* ,
next
ÿÿ, 0
;
ÿÿ0 1
int
ŸŸ 
next
ŸŸ 
=
ŸŸ 
-
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
do
€€ 
{
‹‹ 
next
‡‡ 
=
‡‡ 
buckets
‡‡ "
[
‡‡" #
bucket
‡‡# )
]
‡‡) *
;
‡‡* +
nextPtrs
·· 
[
·· 
idx
··  
]
··  !
=
··" #
next
··$ (
;
··( )
if
‰‰ 
(
‰‰ $
TryGetFirstValueAtomic
‰‰ .
(
‰‰. /
data
‰‰/ 3
,
‰‰3 4
key
‰‰5 8
,
‰‰8 9
out
‰‰: =
tempItem
‰‰> F
,
‰‰F G
out
‰‰H K
tempIt
‰‰L R
)
‰‰R S
)
‰‰S T
{
ÂÂ 
	FreeEntry
ÁÁ !
(
ÁÁ! "
data
ÁÁ" &
,
ÁÁ& '
idx
ÁÁ( +
,
ÁÁ+ ,
threadIndex
ÁÁ- 8
)
ÁÁ8 9
;
ÁÁ9 :
return
ÈÈ 
false
ÈÈ $
;
ÈÈ$ %
}
ÍÍ 
}
ÎÎ 
while
ÏÏ 
(
ÏÏ 
Interlocked
ÏÏ "
.
ÏÏ" #
CompareExchange
ÏÏ# 2
(
ÏÏ2 3
ref
ÏÏ3 6
buckets
ÏÏ7 >
[
ÏÏ> ?
bucket
ÏÏ? E
]
ÏÏE F
,
ÏÏF G
idx
ÏÏH K
,
ÏÏK L
next
ÏÏM Q
)
ÏÏQ R
!=
ÏÏS U
next
ÏÏV Z
)
ÏÏZ [
;
ÏÏ[ \
}
ÌÌ 
return
ÔÔ 
true
ÔÔ 
;
ÔÔ 
}
 	
internal
ÚÚ 
static
ÚÚ 
unsafe
ÚÚ 
void
ÚÚ #
AddAtomicMulti
ÚÚ$ 2
(
ÚÚ2 3
UnsafeHashMapData
ÚÚ3 D
*
ÚÚD E
data
ÚÚF J
,
ÚÚJ K
TKey
ÚÚL P
key
ÚÚQ T
,
ÚÚT U
TValue
ÚÚV \
item
ÚÚ] a
,
ÚÚa b
int
ÚÚc f
threadIndex
ÚÚg r
)
ÚÚr s
{
ÛÛ 	
int
ıı 
idx
ıı 
=
ıı 

AllocEntry
ıı  
(
ıı  !
data
ıı! %
,
ıı% &
threadIndex
ıı' 2
)
ıı2 3
;
ıı3 4
UnsafeUtility
¯¯ 
.
¯¯ 
WriteArrayElement
¯¯ +
(
¯¯+ ,
data
¯¯, 0
->
¯¯0 2
keys
¯¯2 6
,
¯¯6 7
idx
¯¯8 ;
,
¯¯; <
key
¯¯= @
)
¯¯@ A
;
¯¯A B
UnsafeUtility
˘˘ 
.
˘˘ 
WriteArrayElement
˘˘ +
(
˘˘+ ,
data
˘˘, 0
->
˘˘0 2
values
˘˘2 8
,
˘˘8 9
idx
˘˘: =
,
˘˘= >
item
˘˘? C
)
˘˘C D
;
˘˘D E
int
˚˚ 
bucket
˚˚ 
=
˚˚ 
key
˚˚ 
.
˚˚ 
GetHashCode
˚˚ (
(
˚˚( )
)
˚˚) *
&
˚˚+ ,
data
˚˚- 1
->
˚˚1 3 
bucketCapacityMask
˚˚3 E
;
˚˚E F
int
˝˝ 
*
˝˝ 
buckets
˝˝ 
=
˝˝ 
(
˝˝ 
int
˝˝ 
*
˝˝  
)
˝˝  !
data
˝˝! %
->
˝˝% '
buckets
˝˝' .
;
˝˝. /
int
ˇˇ 
nextPtr
ˇˇ 
;
ˇˇ 
int
ÄÄ 
*
ÄÄ 
nextPtrs
ÄÄ 
=
ÄÄ 
(
ÄÄ 
int
ÄÄ  
*
ÄÄ  !
)
ÄÄ! "
data
ÄÄ" &
->
ÄÄ& (
next
ÄÄ( ,
;
ÄÄ, -
do
ÅÅ 
{
ÇÇ 
nextPtr
ÉÉ 
=
ÉÉ 
buckets
ÉÉ !
[
ÉÉ! "
bucket
ÉÉ" (
]
ÉÉ( )
;
ÉÉ) *
nextPtrs
ÑÑ 
[
ÑÑ 
idx
ÑÑ 
]
ÑÑ 
=
ÑÑ 
nextPtr
ÑÑ  '
;
ÑÑ' (
}
ÖÖ 
while
ÜÜ 
(
ÜÜ 
Interlocked
ÜÜ 
.
ÜÜ 
CompareExchange
ÜÜ .
(
ÜÜ. /
ref
ÜÜ/ 2
buckets
ÜÜ3 :
[
ÜÜ: ;
bucket
ÜÜ; A
]
ÜÜA B
,
ÜÜB C
idx
ÜÜD G
,
ÜÜG H
nextPtr
ÜÜI P
)
ÜÜP Q
!=
ÜÜR T
nextPtr
ÜÜU \
)
ÜÜ\ ]
;
ÜÜ] ^
}
áá 	
internal
ââ 
static
ââ 
unsafe
ââ 
bool
ââ #
TryAdd
ââ$ *
(
ââ* +
UnsafeHashMapData
ââ+ <
*
ââ< =
data
ââ> B
,
ââB C
TKey
ââD H
key
ââI L
,
ââL M
TValue
ââN T
item
ââU Y
,
ââY Z
bool
ââ[ _
isMultiHashMap
ââ` n
,
âân o
AllocatorManagerââp Ä
.ââÄ Å
AllocatorHandleââÅ ê

allocationââë õ
)ââõ ú
{
ää 	
TValue
ãã 
tempItem
ãã 
;
ãã (
NativeMultiHashMapIterator
åå &
<
åå& '
TKey
åå' +
>
åå+ ,
tempIt
åå- 3
;
åå3 4
if
çç 
(
çç 
!
çç 
isMultiHashMap
çç 
&&
çç  "$
TryGetFirstValueAtomic
çç# 9
(
çç9 :
data
çç: >
,
çç> ?
key
çç@ C
,
ççC D
out
ççE H
tempItem
ççI Q
,
ççQ R
out
ççS V
tempIt
ççW ]
)
çç] ^
)
çç^ _
{
éé 
return
èè 
false
èè 
;
èè 
}
êê 
int
ìì 
idx
ìì 
;
ìì 
int
îî 
*
îî 
nextPtrs
îî 
;
îî 
if
ññ 
(
ññ 
data
ññ 
->
ññ "
allocatedIndexLength
ññ *
>=
ññ+ -
data
ññ. 2
->
ññ2 4
keyCapacity
ññ4 ?
&&
ññ@ B
data
ññC G
->
ññG I
firstFreeTLS
ññI U
[
ññU V
$num
ññV W
]
ññW X
<
ññY Z
$num
ññ[ \
)
ññ\ ]
{
óó 
for
òò 
(
òò 
int
òò 
tls
òò 
=
òò 
$num
òò  
;
òò  !
tls
òò" %
<
òò& '
JobsUtility
òò( 3
.
òò3 4
MaxJobThreadCount
òò4 E
;
òòE F
++
òòG I
tls
òòI L
)
òòL M
{
ôô 
if
öö 
(
öö 
data
öö 
->
öö 
firstFreeTLS
öö *
[
öö* +
tls
öö+ .
*
öö/ 0
UnsafeHashMapData
öö1 B
.
ööB C
IntsPerCacheLine
ööC S
]
ööS T
>=
ööU W
$num
ööX Y
)
ööY Z
{
õõ 
idx
úú 
=
úú 
data
úú "
->
úú" $
firstFreeTLS
úú$ 0
[
úú0 1
tls
úú1 4
*
úú5 6
UnsafeHashMapData
úú7 H
.
úúH I
IntsPerCacheLine
úúI Y
]
úúY Z
;
úúZ [
nextPtrs
ùù  
=
ùù! "
(
ùù# $
int
ùù$ '
*
ùù' (
)
ùù( )
data
ùù) -
->
ùù- /
next
ùù/ 3
;
ùù3 4
data
ûû 
->
ûû 
firstFreeTLS
ûû *
[
ûû* +
tls
ûû+ .
*
ûû/ 0
UnsafeHashMapData
ûû1 B
.
ûûB C
IntsPerCacheLine
ûûC S
]
ûûS T
=
ûûU V
nextPtrs
ûûW _
[
ûû_ `
idx
ûû` c
]
ûûc d
;
ûûd e
nextPtrs
üü  
[
üü  !
idx
üü! $
]
üü$ %
=
üü& '
-
üü( )
$num
üü) *
;
üü* +
data
†† 
->
†† 
firstFreeTLS
†† *
[
††* +
$num
††+ ,
]
††, -
=
††. /
idx
††0 3
;
††3 4
break
°° 
;
°° 
}
¢¢ 
}
££ 
if
•• 
(
•• 
data
•• 
->
•• 
firstFreeTLS
•• &
[
••& '
$num
••' (
]
••( )
<
••* +
$num
••, -
)
••- .
{
¶¶ 
int
ßß 
newCap
ßß 
=
ßß  
UnsafeHashMapData
ßß! 2
.
ßß2 3
GrowCapacity
ßß3 ?
(
ßß? @
data
ßß@ D
->
ßßD F
keyCapacity
ßßF Q
)
ßßQ R
;
ßßR S
UnsafeHashMapData
®® %
.
®®% &
ReallocateHashMap
®®& 7
<
®®7 8
TKey
®®8 <
,
®®< =
TValue
®®> D
>
®®D E
(
®®E F
data
®®F J
,
®®J K
newCap
®®L R
,
®®R S
UnsafeHashMapData
®®T e
.
®®e f
GetBucketSize
®®f s
(
®®s t
newCap
®®t z
)
®®z {
,
®®{ |

allocation®®} á
)®®á à
;®®à â
}
©© 
}
™™ 
idx
¨¨ 
=
¨¨ 
data
¨¨ 
->
¨¨ 
firstFreeTLS
¨¨ $
[
¨¨$ %
$num
¨¨% &
]
¨¨& '
;
¨¨' (
if
ÆÆ 
(
ÆÆ 
idx
ÆÆ 
>=
ÆÆ 
$num
ÆÆ 
)
ÆÆ 
{
ØØ 
data
∞∞ 
->
∞∞ 
firstFreeTLS
∞∞ "
[
∞∞" #
$num
∞∞# $
]
∞∞$ %
=
∞∞& '
(
∞∞( )
(
∞∞) *
int
∞∞* -
*
∞∞- .
)
∞∞. /
data
∞∞/ 3
->
∞∞3 5
next
∞∞5 9
)
∞∞9 :
[
∞∞: ;
idx
∞∞; >
]
∞∞> ?
;
∞∞? @
}
±± 
else
≤≤ 
{
≥≥ 
idx
¥¥ 
=
¥¥ 
data
¥¥ 
->
¥¥ "
allocatedIndexLength
¥¥ 0
++
¥¥0 2
;
¥¥2 3
}
µµ #
CheckIndexOutOfBounds
∑∑ !
(
∑∑! "
data
∑∑" &
,
∑∑& '
idx
∑∑( +
)
∑∑+ ,
;
∑∑, -
UnsafeUtility
∫∫ 
.
∫∫ 
WriteArrayElement
∫∫ +
(
∫∫+ ,
data
∫∫, 0
->
∫∫0 2
keys
∫∫2 6
,
∫∫6 7
idx
∫∫8 ;
,
∫∫; <
key
∫∫= @
)
∫∫@ A
;
∫∫A B
UnsafeUtility
ªª 
.
ªª 
WriteArrayElement
ªª +
(
ªª+ ,
data
ªª, 0
->
ªª0 2
values
ªª2 8
,
ªª8 9
idx
ªª: =
,
ªª= >
item
ªª? C
)
ªªC D
;
ªªD E
int
ΩΩ 
bucket
ΩΩ 
=
ΩΩ 
key
ΩΩ 
.
ΩΩ 
GetHashCode
ΩΩ (
(
ΩΩ( )
)
ΩΩ) *
&
ΩΩ+ ,
data
ΩΩ- 1
->
ΩΩ1 3 
bucketCapacityMask
ΩΩ3 E
;
ΩΩE F
int
øø 
*
øø 
buckets
øø 
=
øø 
(
øø 
int
øø 
*
øø  
)
øø  !
data
øø! %
->
øø% '
buckets
øø' .
;
øø. /
nextPtrs
¿¿ 
=
¿¿ 
(
¿¿ 
int
¿¿ 
*
¿¿ 
)
¿¿ 
data
¿¿ !
->
¿¿! #
next
¿¿# '
;
¿¿' (
nextPtrs
¡¡ 
[
¡¡ 
idx
¡¡ 
]
¡¡ 
=
¡¡ 
buckets
¡¡ #
[
¡¡# $
bucket
¡¡$ *
]
¡¡* +
;
¡¡+ ,
buckets
¬¬ 
[
¬¬ 
bucket
¬¬ 
]
¬¬ 
=
¬¬ 
idx
¬¬ !
;
¬¬! "
return
ƒƒ 
true
ƒƒ 
;
ƒƒ 
}
≈≈ 	
internal
«« 
static
«« 
unsafe
«« 
int
«« "
Remove
««# )
(
««) *
UnsafeHashMapData
««* ;
*
««; <
data
««= A
,
««A B
TKey
««C G
key
««H K
,
««K L
bool
««M Q
isMultiHashMap
««R `
)
««` a
{
»» 	
if
…… 
(
…… 
data
…… 
->
…… 
keyCapacity
…… !
==
……" $
$num
……% &
)
……& '
{
   
return
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
}
ÃÃ 
var
ŒŒ 
removed
ŒŒ 
=
ŒŒ 
$num
ŒŒ 
;
ŒŒ 
var
—— 
buckets
—— 
=
—— 
(
—— 
int
—— 
*
—— 
)
——  
data
——  $
->
——$ &
buckets
——& -
;
——- .
var
““ 
nextPtrs
““ 
=
““ 
(
““ 
int
““ 
*
““  
)
““  !
data
““! %
->
““% '
next
““' +
;
““+ ,
var
”” 
bucket
”” 
=
”” 
key
”” 
.
”” 
GetHashCode
”” (
(
””( )
)
””) *
&
””+ ,
data
””- 1
->
””1 3 
bucketCapacityMask
””3 E
;
””E F
var
‘‘ 
	prevEntry
‘‘ 
=
‘‘ 
-
‘‘ 
$num
‘‘ 
;
‘‘ 
var
’’ 
entryIdx
’’ 
=
’’ 
buckets
’’ "
[
’’" #
bucket
’’# )
]
’’) *
;
’’* +
while
◊◊ 
(
◊◊ 
entryIdx
◊◊ 
>=
◊◊ 
$num
◊◊  
&&
◊◊! #
entryIdx
◊◊$ ,
<
◊◊- .
data
◊◊/ 3
->
◊◊3 5
keyCapacity
◊◊5 @
)
◊◊@ A
{
ÿÿ 
if
ŸŸ 
(
ŸŸ 
UnsafeUtility
ŸŸ !
.
ŸŸ! "
ReadArrayElement
ŸŸ" 2
<
ŸŸ2 3
TKey
ŸŸ3 7
>
ŸŸ7 8
(
ŸŸ8 9
data
ŸŸ9 =
->
ŸŸ= ?
keys
ŸŸ? C
,
ŸŸC D
entryIdx
ŸŸE M
)
ŸŸM N
.
ŸŸN O
Equals
ŸŸO U
(
ŸŸU V
key
ŸŸV Y
)
ŸŸY Z
)
ŸŸZ [
{
⁄⁄ 
++
€€ 
removed
€€ 
;
€€ 
if
ﬁﬁ 
(
ﬁﬁ 
	prevEntry
ﬁﬁ !
<
ﬁﬁ" #
$num
ﬁﬁ$ %
)
ﬁﬁ% &
{
ﬂﬂ 
buckets
‡‡ 
[
‡‡  
bucket
‡‡  &
]
‡‡& '
=
‡‡( )
nextPtrs
‡‡* 2
[
‡‡2 3
entryIdx
‡‡3 ;
]
‡‡; <
;
‡‡< =
}
·· 
else
‚‚ 
{
„„ 
nextPtrs
‰‰  
[
‰‰  !
	prevEntry
‰‰! *
]
‰‰* +
=
‰‰, -
nextPtrs
‰‰. 6
[
‰‰6 7
entryIdx
‰‰7 ?
]
‰‰? @
;
‰‰@ A
}
ÂÂ 
int
ËË 
nextIdx
ËË 
=
ËË  !
nextPtrs
ËË" *
[
ËË* +
entryIdx
ËË+ 3
]
ËË3 4
;
ËË4 5
nextPtrs
ÈÈ 
[
ÈÈ 
entryIdx
ÈÈ %
]
ÈÈ% &
=
ÈÈ' (
data
ÈÈ) -
->
ÈÈ- /
firstFreeTLS
ÈÈ/ ;
[
ÈÈ; <
$num
ÈÈ< =
]
ÈÈ= >
;
ÈÈ> ?
data
ÍÍ 
->
ÍÍ 
firstFreeTLS
ÍÍ &
[
ÍÍ& '
$num
ÍÍ' (
]
ÍÍ( )
=
ÍÍ* +
entryIdx
ÍÍ, 4
;
ÍÍ4 5
entryIdx
ÎÎ 
=
ÎÎ 
nextIdx
ÎÎ &
;
ÎÎ& '
if
ÓÓ 
(
ÓÓ 
!
ÓÓ 
isMultiHashMap
ÓÓ '
)
ÓÓ' (
{
ÔÔ 
break
 
;
 
}
ÒÒ 
}
ÚÚ 
else
ÛÛ 
{
ÙÙ 
	prevEntry
ıı 
=
ıı 
entryIdx
ıı  (
;
ıı( )
entryIdx
ˆˆ 
=
ˆˆ 
nextPtrs
ˆˆ '
[
ˆˆ' (
entryIdx
ˆˆ( 0
]
ˆˆ0 1
;
ˆˆ1 2
}
˜˜ 
}
¯¯ 
return
˙˙ 
removed
˙˙ 
;
˙˙ 
}
˚˚ 	
internal
˝˝ 
static
˝˝ 
unsafe
˝˝ 
void
˝˝ #
Remove
˝˝$ *
(
˝˝* +
UnsafeHashMapData
˝˝+ <
*
˝˝< =
data
˝˝> B
,
˝˝B C(
NativeMultiHashMapIterator
˝˝D ^
<
˝˝^ _
TKey
˝˝_ c
>
˝˝c d
it
˝˝e g
)
˝˝g h
{
˛˛ 	
int
ÄÄ 
*
ÄÄ 
buckets
ÄÄ 
=
ÄÄ 
(
ÄÄ 
int
ÄÄ 
*
ÄÄ  
)
ÄÄ  !
data
ÄÄ! %
->
ÄÄ% '
buckets
ÄÄ' .
;
ÄÄ. /
int
ÅÅ 
*
ÅÅ 
nextPtrs
ÅÅ 
=
ÅÅ 
(
ÅÅ 
int
ÅÅ  
*
ÅÅ  !
)
ÅÅ! "
data
ÅÅ" &
->
ÅÅ& (
next
ÅÅ( ,
;
ÅÅ, -
int
ÇÇ 
bucket
ÇÇ 
=
ÇÇ 
it
ÇÇ 
.
ÇÇ 
key
ÇÇ 
.
ÇÇ  
GetHashCode
ÇÇ  +
(
ÇÇ+ ,
)
ÇÇ, -
&
ÇÇ. /
data
ÇÇ0 4
->
ÇÇ4 6 
bucketCapacityMask
ÇÇ6 H
;
ÇÇH I
int
ÑÑ 
entryIdx
ÑÑ 
=
ÑÑ 
buckets
ÑÑ "
[
ÑÑ" #
bucket
ÑÑ# )
]
ÑÑ) *
;
ÑÑ* +
if
ÜÜ 
(
ÜÜ 
entryIdx
ÜÜ 
==
ÜÜ 
it
ÜÜ 
.
ÜÜ 

EntryIndex
ÜÜ )
)
ÜÜ) *
{
áá 
buckets
àà 
[
àà 
bucket
àà 
]
àà 
=
àà  !
nextPtrs
àà" *
[
àà* +
entryIdx
àà+ 3
]
àà3 4
;
àà4 5
}
ââ 
else
ää 
{
ãã 
while
åå 
(
åå 
entryIdx
åå 
>=
åå  "
$num
åå# $
&&
åå% '
nextPtrs
åå( 0
[
åå0 1
entryIdx
åå1 9
]
åå9 :
!=
åå; =
it
åå> @
.
åå@ A

EntryIndex
ååA K
)
ååK L
{
çç 
entryIdx
éé 
=
éé 
nextPtrs
éé '
[
éé' (
entryIdx
éé( 0
]
éé0 1
;
éé1 2
}
èè 
if
ëë 
(
ëë 
entryIdx
ëë 
<
ëë 
$num
ëë  
)
ëë  !
{
íí "
ThrowInvalidIterator
ìì (
(
ìì( )
)
ìì) *
;
ìì* +
}
îî 
nextPtrs
ññ 
[
ññ 
entryIdx
ññ !
]
ññ! "
=
ññ# $
nextPtrs
ññ% -
[
ññ- .
it
ññ. 0
.
ññ0 1

EntryIndex
ññ1 ;
]
ññ; <
;
ññ< =
}
óó 
nextPtrs
öö 
[
öö 
it
öö 
.
öö 

EntryIndex
öö "
]
öö" #
=
öö$ %
data
öö& *
->
öö* ,
firstFreeTLS
öö, 8
[
öö8 9
$num
öö9 :
]
öö: ;
;
öö; <
data
õõ 
->
õõ 
firstFreeTLS
õõ 
[
õõ 
$num
õõ  
]
õõ  !
=
õõ" #
it
õõ$ &
.
õõ& '

EntryIndex
õõ' 1
;
õõ1 2
}
úú 	
[
ûû 	
BurstCompatible
ûû	 
(
ûû "
GenericTypeArguments
ûû -
=
ûû. /
new
ûû0 3
[
ûû4 5
]
ûû5 6
{
ûû7 8
typeof
ûû9 ?
(
ûû? @
int
ûû@ C
)
ûûC D
}
ûûE F
)
ûûF G
]
ûûG H
internal
üü 
static
üü 
unsafe
üü 
void
üü #
RemoveKeyValue
üü$ 2
<
üü2 3
TValueEQ
üü3 ;
>
üü; <
(
üü< =
UnsafeHashMapData
üü= N
*
üüN O
data
üüP T
,
üüT U
TKey
üüV Z
key
üü[ ^
,
üü^ _
TValueEQ
üü` h
value
üüi n
)
üün o
where
†† 
TValueEQ
†† 
:
†† 
struct
†† #
,
††# $

IEquatable
††% /
<
††/ 0
TValueEQ
††0 8
>
††8 9
{
°° 	
if
¢¢ 
(
¢¢ 
data
¢¢ 
->
¢¢ 
keyCapacity
¢¢ !
==
¢¢" $
$num
¢¢% &
)
¢¢& '
{
££ 
return
§§ 
;
§§ 
}
•• 
var
ßß 
buckets
ßß 
=
ßß 
(
ßß 
int
ßß 
*
ßß 
)
ßß  
data
ßß  $
->
ßß$ &
buckets
ßß& -
;
ßß- .
var
®® 
keyCapacity
®® 
=
®® 
(
®® 
uint
®® #
)
®®# $
data
®®$ (
->
®®( *
keyCapacity
®®* 5
;
®®5 6
var
©© 
prevNextPtr
©© 
=
©© 
buckets
©© %
+
©©& '
(
©©( )
key
©©) ,
.
©©, -
GetHashCode
©©- 8
(
©©8 9
)
©©9 :
&
©©; <
data
©©= A
->
©©A C 
bucketCapacityMask
©©C U
)
©©U V
;
©©V W
var
™™ 
entryIdx
™™ 
=
™™ 
*
™™ 
prevNextPtr
™™ '
;
™™' (
if
¨¨ 
(
¨¨ 
(
¨¨ 
uint
¨¨ 
)
¨¨ 
entryIdx
¨¨ 
>=
¨¨ !
keyCapacity
¨¨" -
)
¨¨- .
{
≠≠ 
return
ÆÆ 
;
ÆÆ 
}
ØØ 
var
±± 
nextPtrs
±± 
=
±± 
(
±± 
int
±± 
*
±±  
)
±±  !
data
±±! %
->
±±% '
next
±±' +
;
±±+ ,
var
≤≤ 
keys
≤≤ 
=
≤≤ 
data
≤≤ 
->
≤≤ 
keys
≤≤ !
;
≤≤! "
var
≥≥ 
values
≥≥ 
=
≥≥ 
data
≥≥ 
->
≥≥ 
values
≥≥ %
;
≥≥% &
var
¥¥ 
firstFreeTLS
¥¥ 
=
¥¥ 
data
¥¥ #
->
¥¥# %
firstFreeTLS
¥¥% 1
;
¥¥1 2
do
∂∂ 
{
∑∑ 
if
∏∏ 
(
∏∏ 
UnsafeUtility
∏∏ !
.
∏∏! "
ReadArrayElement
∏∏" 2
<
∏∏2 3
TKey
∏∏3 7
>
∏∏7 8
(
∏∏8 9
keys
∏∏9 =
,
∏∏= >
entryIdx
∏∏? G
)
∏∏G H
.
∏∏H I
Equals
∏∏I O
(
∏∏O P
key
∏∏P S
)
∏∏S T
&&
ππ 
UnsafeUtility
ππ $
.
ππ$ %
ReadArrayElement
ππ% 5
<
ππ5 6
TValueEQ
ππ6 >
>
ππ> ?
(
ππ? @
values
ππ@ F
,
ππF G
entryIdx
ππH P
)
ππP Q
.
ππQ R
Equals
ππR X
(
ππX Y
value
ππY ^
)
ππ^ _
)
ππ_ `
{
∫∫ 
int
ªª 
nextIdx
ªª 
=
ªª  !
nextPtrs
ªª" *
[
ªª* +
entryIdx
ªª+ 3
]
ªª3 4
;
ªª4 5
nextPtrs
ºº 
[
ºº 
entryIdx
ºº %
]
ºº% &
=
ºº' (
firstFreeTLS
ºº) 5
[
ºº5 6
$num
ºº6 7
]
ºº7 8
;
ºº8 9
firstFreeTLS
ΩΩ  
[
ΩΩ  !
$num
ΩΩ! "
]
ΩΩ" #
=
ΩΩ$ %
entryIdx
ΩΩ& .
;
ΩΩ. /
*
ææ 
prevNextPtr
ææ  
=
ææ! "
entryIdx
ææ# +
=
ææ, -
nextIdx
ææ. 5
;
ææ5 6
}
øø 
else
¿¿ 
{
¡¡ 
prevNextPtr
¬¬ 
=
¬¬  !
nextPtrs
¬¬" *
+
¬¬+ ,
entryIdx
¬¬- 5
;
¬¬5 6
entryIdx
√√ 
=
√√ 
*
√√  
prevNextPtr
√√  +
;
√√+ ,
}
ƒƒ 
}
≈≈ 
while
∆∆ 
(
∆∆ 
(
∆∆ 
uint
∆∆ 
)
∆∆ 
entryIdx
∆∆ !
<
∆∆" #
keyCapacity
∆∆$ /
)
∆∆/ 0
;
∆∆0 1
}
«« 	
internal
…… 
static
…… 
unsafe
…… 
bool
…… #$
TryGetFirstValueAtomic
……$ :
(
……: ;
UnsafeHashMapData
……; L
*
……L M
data
……N R
,
……R S
TKey
……T X
key
……Y \
,
……\ ]
out
……^ a
TValue
……b h
item
……i m
,
……m n
out
……o r)
NativeMultiHashMapIterator……s ç
<……ç é
TKey……é í
>……í ì
it……î ñ
)……ñ ó
{
   	
it
ÀÀ 
.
ÀÀ 
key
ÀÀ 
=
ÀÀ 
key
ÀÀ 
;
ÀÀ 
if
ÕÕ 
(
ÕÕ 
data
ÕÕ 
->
ÕÕ "
allocatedIndexLength
ÕÕ *
<=
ÕÕ+ -
$num
ÕÕ. /
)
ÕÕ/ 0
{
ŒŒ 
it
œœ 
.
œœ 

EntryIndex
œœ 
=
œœ 
it
œœ  "
.
œœ" #
NextEntryIndex
œœ# 1
=
œœ2 3
-
œœ4 5
$num
œœ5 6
;
œœ6 7
item
–– 
=
–– 
default
–– 
;
–– 
return
—— 
false
—— 
;
—— 
}
““ 
int
’’ 
*
’’ 
buckets
’’ 
=
’’ 
(
’’ 
int
’’ 
*
’’  
)
’’  !
data
’’! %
->
’’% '
buckets
’’' .
;
’’. /
int
÷÷ 
bucket
÷÷ 
=
÷÷ 
key
÷÷ 
.
÷÷ 
GetHashCode
÷÷ (
(
÷÷( )
)
÷÷) *
&
÷÷+ ,
data
÷÷- 1
->
÷÷1 3 
bucketCapacityMask
÷÷3 E
;
÷÷E F
it
◊◊ 
.
◊◊ 

EntryIndex
◊◊ 
=
◊◊ 
it
◊◊ 
.
◊◊ 
NextEntryIndex
◊◊ -
=
◊◊. /
buckets
◊◊0 7
[
◊◊7 8
bucket
◊◊8 >
]
◊◊> ?
;
◊◊? @
return
ÿÿ #
TryGetNextValueAtomic
ÿÿ (
(
ÿÿ( )
data
ÿÿ) -
,
ÿÿ- .
out
ÿÿ/ 2
item
ÿÿ3 7
,
ÿÿ7 8
ref
ÿÿ9 <
it
ÿÿ= ?
)
ÿÿ? @
;
ÿÿ@ A
}
ŸŸ 	
internal
€€ 
static
€€ 
unsafe
€€ 
bool
€€ ##
TryGetNextValueAtomic
€€$ 9
(
€€9 :
UnsafeHashMapData
€€: K
*
€€K L
data
€€M Q
,
€€Q R
out
€€S V
TValue
€€W ]
item
€€^ b
,
€€b c
ref
€€d g)
NativeMultiHashMapIterator€€h Ç
<€€Ç É
TKey€€É á
>€€á à
it€€â ã
)€€ã å
{
‹‹ 	
int
›› 
entryIdx
›› 
=
›› 
it
›› 
.
›› 
NextEntryIndex
›› ,
;
››, -
it
ﬁﬁ 
.
ﬁﬁ 
NextEntryIndex
ﬁﬁ 
=
ﬁﬁ 
-
ﬁﬁ  !
$num
ﬁﬁ! "
;
ﬁﬁ" #
it
ﬂﬂ 
.
ﬂﬂ 

EntryIndex
ﬂﬂ 
=
ﬂﬂ 
-
ﬂﬂ 
$num
ﬂﬂ 
;
ﬂﬂ 
item
‡‡ 
=
‡‡ 
default
‡‡ 
;
‡‡ 
if
·· 
(
·· 
entryIdx
·· 
<
·· 
$num
·· 
||
·· 
entryIdx
··  (
>=
··) +
data
··, 0
->
··0 2
keyCapacity
··2 =
)
··= >
{
‚‚ 
return
„„ 
false
„„ 
;
„„ 
}
‰‰ 
int
ÊÊ 
*
ÊÊ 
nextPtrs
ÊÊ 
=
ÊÊ 
(
ÊÊ 
int
ÊÊ  
*
ÊÊ  !
)
ÊÊ! "
data
ÊÊ" &
->
ÊÊ& (
next
ÊÊ( ,
;
ÊÊ, -
while
ÁÁ 
(
ÁÁ 
!
ÁÁ 
UnsafeUtility
ÁÁ !
.
ÁÁ! "
ReadArrayElement
ÁÁ" 2
<
ÁÁ2 3
TKey
ÁÁ3 7
>
ÁÁ7 8
(
ÁÁ8 9
data
ÁÁ9 =
->
ÁÁ= ?
keys
ÁÁ? C
,
ÁÁC D
entryIdx
ÁÁE M
)
ÁÁM N
.
ÁÁN O
Equals
ÁÁO U
(
ÁÁU V
it
ÁÁV X
.
ÁÁX Y
key
ÁÁY \
)
ÁÁ\ ]
)
ÁÁ] ^
{
ËË 
entryIdx
ÈÈ 
=
ÈÈ 
nextPtrs
ÈÈ #
[
ÈÈ# $
entryIdx
ÈÈ$ ,
]
ÈÈ, -
;
ÈÈ- .
if
ÍÍ 
(
ÍÍ 
entryIdx
ÍÍ 
<
ÍÍ 
$num
ÍÍ  
||
ÍÍ! #
entryIdx
ÍÍ$ ,
>=
ÍÍ- /
data
ÍÍ0 4
->
ÍÍ4 6
keyCapacity
ÍÍ6 A
)
ÍÍA B
{
ÎÎ 
return
ÏÏ 
false
ÏÏ  
;
ÏÏ  !
}
ÌÌ 
}
ÓÓ 
it
 
.
 
NextEntryIndex
 
=
 
nextPtrs
  (
[
( )
entryIdx
) 1
]
1 2
;
2 3
it
ÒÒ 
.
ÒÒ 

EntryIndex
ÒÒ 
=
ÒÒ 
entryIdx
ÒÒ $
;
ÒÒ$ %
item
ÙÙ 
=
ÙÙ 
UnsafeUtility
ÙÙ  
.
ÙÙ  !
ReadArrayElement
ÙÙ! 1
<
ÙÙ1 2
TValue
ÙÙ2 8
>
ÙÙ8 9
(
ÙÙ9 :
data
ÙÙ: >
->
ÙÙ> @
values
ÙÙ@ F
,
ÙÙF G
entryIdx
ÙÙH P
)
ÙÙP Q
;
ÙÙQ R
return
ˆˆ 
true
ˆˆ 
;
ˆˆ 
}
˜˜ 	
internal
˘˘ 
static
˘˘ 
unsafe
˘˘ 
bool
˘˘ #
SetValue
˘˘$ ,
(
˘˘, -
UnsafeHashMapData
˘˘- >
*
˘˘> ?
data
˘˘@ D
,
˘˘D E
ref
˘˘F I(
NativeMultiHashMapIterator
˘˘J d
<
˘˘d e
TKey
˘˘e i
>
˘˘i j
it
˘˘k m
,
˘˘m n
ref
˘˘o r
TValue
˘˘s y
item
˘˘z ~
)
˘˘~ 
{
˙˙ 	
int
˚˚ 
entryIdx
˚˚ 
=
˚˚ 
it
˚˚ 
.
˚˚ 

EntryIndex
˚˚ (
;
˚˚( )
if
¸¸ 
(
¸¸ 
entryIdx
¸¸ 
<
¸¸ 
$num
¸¸ 
||
¸¸ 
entryIdx
¸¸  (
>=
¸¸) +
data
¸¸, 0
->
¸¸0 2
keyCapacity
¸¸2 =
)
¸¸= >
{
˝˝ 
return
˛˛ 
false
˛˛ 
;
˛˛ 
}
ˇˇ 
UnsafeUtility
ÅÅ 
.
ÅÅ 
WriteArrayElement
ÅÅ +
(
ÅÅ+ ,
data
ÅÅ, 0
->
ÅÅ0 2
values
ÅÅ2 8
,
ÅÅ8 9
entryIdx
ÅÅ: B
,
ÅÅB C
item
ÅÅD H
)
ÅÅH I
;
ÅÅI J
return
ÇÇ 
true
ÇÇ 
;
ÇÇ 
}
ÉÉ 	
[
ÖÖ 	
Conditional
ÖÖ	 
(
ÖÖ 
$str
ÖÖ 6
)
ÖÖ6 7
]
ÖÖ7 8
static
ÜÜ 
void
ÜÜ  
CheckOutOfCapacity
ÜÜ &
(
ÜÜ& '
int
ÜÜ' *
idx
ÜÜ+ .
,
ÜÜ. /
int
ÜÜ0 3
keyCapacity
ÜÜ4 ?
)
ÜÜ? @
{
áá 	
if
àà 
(
àà 
idx
àà 
>=
àà 
keyCapacity
àà "
)
àà" #
{
ââ 
throw
ää 
new
ää '
InvalidOperationException
ää 3
(
ää3 4
string
ää4 :
.
ää: ;
Format
ää; A
(
ääA B
$str
ääB g
,
ääg h
idx
ääi l
,
ääl m
keyCapacity
ään y
)
ääy z
)
ääz {
;
ää{ |
}
ãã 
}
åå 	
[
éé 	
Conditional
éé	 
(
éé 
$str
éé 6
)
éé6 7
]
éé7 8
static
èè 
unsafe
èè 
void
èè #
CheckIndexOutOfBounds
èè 0
(
èè0 1
UnsafeHashMapData
èè1 B
*
èèB C
data
èèD H
,
èèH I
int
èèJ M
idx
èèN Q
)
èèQ R
{
êê 	
if
ëë 
(
ëë 
idx
ëë 
<
ëë 
$num
ëë 
||
ëë 
idx
ëë 
>=
ëë !
data
ëë" &
->
ëë& (
keyCapacity
ëë( 3
)
ëë3 4
throw
íí 
new
íí '
InvalidOperationException
íí 3
(
íí3 4
$str
íí4 L
)
ííL M
;
ííM N
}
ìì 	
[
ïï 	
Conditional
ïï	 
(
ïï 
$str
ïï 6
)
ïï6 7
]
ïï7 8
static
ññ 
void
ññ 
	ThrowFull
ññ 
(
ññ 
)
ññ 
{
óó 	
throw
òò 
new
òò '
InvalidOperationException
òò /
(
òò/ 0
$str
òò0 A
)
òòA B
;
òòB C
}
ôô 	
[
õõ 	
Conditional
õõ	 
(
õõ 
$str
õõ 6
)
õõ6 7
]
õõ7 8
static
úú 
void
úú "
ThrowInvalidIterator
úú (
(
úú( )
)
úú) *
{
ùù 	
throw
ûû 
new
ûû '
InvalidOperationException
ûû /
(
ûû/ 0
$str
ûû0 [
)
ûû[ \
;
ûû\ ]
}
üü 	
}
†† 
[
®® 
DebuggerDisplay
®® 
(
®® 
$str
®® 3
)
®®3 4
]
®®4 5
[
©© 
BurstCompatible
©© 
(
©© "
GenericTypeArguments
©© )
=
©©* +
new
©©, /
[
©©/ 0
]
©©0 1
{
©©2 3
typeof
©©3 9
(
©©9 :
int
©©: =
)
©©= >
,
©©> ?
typeof
©©@ F
(
©©F G
int
©©G J
)
©©J K
}
©©K L
)
©©L M
]
©©M N
public
™™ 

unsafe
™™ 
struct
™™ 
KeyValue
™™ !
<
™™! "
TKey
™™" &
,
™™& '
TValue
™™( .
>
™™. /
where
´´ 
TKey
´´ 
:
´´ 
struct
´´ 
,
´´ 

IEquatable
´´ '
<
´´' (
TKey
´´( ,
>
´´, -
where
¨¨ 
TValue
¨¨ 
:
¨¨ 
struct
¨¨ 
{
≠≠ 
internal
ÆÆ 
UnsafeHashMapData
ÆÆ "
*
ÆÆ" #
m_Buffer
ÆÆ$ ,
;
ÆÆ, -
internal
ØØ 
int
ØØ 
m_Index
ØØ 
;
ØØ 
internal
∞∞ 
int
∞∞ 
m_Next
∞∞ 
;
∞∞ 
public
∂∂ 
static
∂∂ 
KeyValue
∂∂ 
<
∂∂ 
TKey
∂∂ #
,
∂∂# $
TValue
∂∂% +
>
∂∂+ ,
Null
∂∂- 1
=>
∂∂2 4
new
∂∂5 8
KeyValue
∂∂9 A
<
∂∂A B
TKey
∂∂B F
,
∂∂F G
TValue
∂∂H N
>
∂∂N O
{
∂∂O P
m_Index
∂∂P W
=
∂∂X Y
-
∂∂Z [
$num
∂∂[ \
}
∂∂\ ]
;
∂∂] ^
public
ºº 
TKey
ºº 
Key
ºº 
{
ΩΩ 	
get
ææ 
{
øø 
if
¿¿ 
(
¿¿ 
m_Index
¿¿ 
!=
¿¿ 
-
¿¿  
$num
¿¿  !
)
¿¿! "
{
¡¡ 
return
¬¬ 
UnsafeUtility
¬¬ (
.
¬¬( )
ReadArrayElement
¬¬) 9
<
¬¬9 :
TKey
¬¬: >
>
¬¬> ?
(
¬¬? @
m_Buffer
¬¬@ H
->
¬¬H J
keys
¬¬J N
,
¬¬N O
m_Index
¬¬P W
)
¬¬W X
;
¬¬X Y
}
√√ 
return
≈≈ 
default
≈≈ 
;
≈≈ 
}
∆∆ 
}
«« 	
public
ÃÃ 
ref
ÃÃ 
TValue
ÃÃ 
Value
ÃÃ 
{
ÕÕ 	
get
ŒŒ 
{
œœ 
if
—— 
(
—— 
m_Index
—— 
==
—— 
-
——  
$num
——  !
)
——! "
throw
““ 
new
““ 
ArgumentException
““ /
(
““/ 0
$str
““0 ?
)
““? @
;
““@ A
return
’’ 
ref
’’ 
UnsafeUtility
’’ (
.
’’( )
AsRef
’’) .
<
’’. /
TValue
’’/ 5
>
’’5 6
(
’’6 7
m_Buffer
’’7 ?
->
’’? A
values
’’A G
+
’’H I
UnsafeUtility
’’J W
.
’’W X
SizeOf
’’X ^
<
’’^ _
TValue
’’_ e
>
’’e f
(
’’f g
)
’’g h
*
’’i j
m_Index
’’k r
)
’’r s
;
’’s t
}
÷÷ 
}
◊◊ 	
public
ﬂﬂ 
bool
ﬂﬂ 
GetKeyValue
ﬂﬂ 
(
ﬂﬂ  
out
ﬂﬂ  #
TKey
ﬂﬂ$ (
key
ﬂﬂ) ,
,
ﬂﬂ, -
out
ﬂﬂ. 1
TValue
ﬂﬂ2 8
value
ﬂﬂ9 >
)
ﬂﬂ> ?
{
‡‡ 	
if
·· 
(
·· 
m_Index
·· 
!=
·· 
-
·· 
$num
·· 
)
·· 
{
‚‚ 
key
„„ 
=
„„ 
UnsafeUtility
„„ #
.
„„# $
ReadArrayElement
„„$ 4
<
„„4 5
TKey
„„5 9
>
„„9 :
(
„„: ;
m_Buffer
„„; C
->
„„C E
keys
„„E I
,
„„I J
m_Index
„„K R
)
„„R S
;
„„S T
value
‰‰ 
=
‰‰ 
UnsafeUtility
‰‰ %
.
‰‰% &
ReadArrayElement
‰‰& 6
<
‰‰6 7
TValue
‰‰7 =
>
‰‰= >
(
‰‰> ?
m_Buffer
‰‰? G
->
‰‰G I
values
‰‰I O
,
‰‰O P
m_Index
‰‰Q X
)
‰‰X Y
;
‰‰Y Z
return
ÂÂ 
true
ÂÂ 
;
ÂÂ 
}
ÊÊ 
key
ËË 
=
ËË 
default
ËË 
;
ËË 
value
ÈÈ 
=
ÈÈ 
default
ÈÈ 
;
ÈÈ 
return
ÍÍ 
false
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
}
ÏÏ 
internal
ÓÓ 
unsafe
ÓÓ 
struct
ÓÓ )
UnsafeHashMapDataEnumerator
ÓÓ 6
{
ÔÔ 
[
 	/
!NativeDisableUnsafePtrRestriction
	 *
]
* +
internal
ÒÒ 
UnsafeHashMapData
ÒÒ "
*
ÒÒ" #
m_Buffer
ÒÒ$ ,
;
ÒÒ, -
internal
ÚÚ 
int
ÚÚ 
m_Index
ÚÚ 
;
ÚÚ 
internal
ÛÛ 
int
ÛÛ 
m_BucketIndex
ÛÛ "
;
ÛÛ" #
internal
ÙÙ 
int
ÙÙ 
m_NextIndex
ÙÙ  
;
ÙÙ  !
internal
ˆˆ 
unsafe
ˆˆ )
UnsafeHashMapDataEnumerator
ˆˆ 3
(
ˆˆ3 4
UnsafeHashMapData
ˆˆ4 E
*
ˆˆE F
data
ˆˆG K
)
ˆˆK L
{
˜˜ 	
m_Buffer
¯¯ 
=
¯¯ 
data
¯¯ 
;
¯¯ 
m_Index
˘˘ 
=
˘˘ 
-
˘˘ 
$num
˘˘ 
;
˘˘ 
m_BucketIndex
˙˙ 
=
˙˙ 
$num
˙˙ 
;
˙˙ 
m_NextIndex
˚˚ 
=
˚˚ 
-
˚˚ 
$num
˚˚ 
;
˚˚ 
}
¸¸ 	
internal
˛˛ 
bool
˛˛ 
MoveNext
˛˛ 
(
˛˛ 
)
˛˛  
{
ˇˇ 	
return
ÄÄ 
UnsafeHashMapData
ÄÄ $
.
ÄÄ$ %
MoveNext
ÄÄ% -
(
ÄÄ- .
m_Buffer
ÄÄ. 6
,
ÄÄ6 7
ref
ÄÄ8 ;
m_BucketIndex
ÄÄ< I
,
ÄÄI J
ref
ÄÄK N
m_NextIndex
ÄÄO Z
,
ÄÄZ [
out
ÄÄ\ _
m_Index
ÄÄ` g
)
ÄÄg h
;
ÄÄh i
}
ÅÅ 	
internal
ÉÉ 
void
ÉÉ 
Reset
ÉÉ 
(
ÉÉ 
)
ÉÉ 
{
ÑÑ 	
m_Index
ÖÖ 
=
ÖÖ 
-
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
m_BucketIndex
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
;
ÜÜ 
m_NextIndex
áá 
=
áá 
-
áá 
$num
áá 
;
áá 
}
àà 	
internal
ää 
KeyValue
ää 
<
ää 
TKey
ää 
,
ää 
TValue
ää  &
>
ää& '

GetCurrent
ää( 2
<
ää2 3
TKey
ää3 7
,
ää7 8
TValue
ää9 ?
>
ää? @
(
ää@ A
)
ääA B
where
ãã 
TKey
ãã 
:
ãã 
struct
ãã 
,
ãã  

IEquatable
ãã! +
<
ãã+ ,
TKey
ãã, 0
>
ãã0 1
where
åå 
TValue
åå 
:
åå 
struct
åå !
{
çç 	
return
éé 
new
éé 
KeyValue
éé 
<
éé  
TKey
éé  $
,
éé$ %
TValue
éé& ,
>
éé, -
{
éé. /
m_Buffer
éé0 8
=
éé9 :
m_Buffer
éé; C
,
ééC D
m_Index
ééE L
=
ééM N
m_Index
ééO V
}
ééW X
;
ééX Y
}
èè 	
internal
ëë 
TKey
ëë 
GetCurrentKey
ëë #
<
ëë# $
TKey
ëë$ (
>
ëë( )
(
ëë) *
)
ëë* +
where
íí 
TKey
íí 
:
íí 
struct
íí 
,
íí  

IEquatable
íí! +
<
íí+ ,
TKey
íí, 0
>
íí0 1
{
ìì 	
if
îî 
(
îî 
m_Index
îî 
!=
îî 
-
îî 
$num
îî 
)
îî 
{
ïï 
return
ññ 
UnsafeUtility
ññ $
.
ññ$ %
ReadArrayElement
ññ% 5
<
ññ5 6
TKey
ññ6 :
>
ññ: ;
(
ññ; <
m_Buffer
ññ< D
->
ññD F
keys
ññF J
,
ññJ K
m_Index
ññL S
)
ññS T
;
ññT U
}
óó 
return
ôô 
default
ôô 
;
ôô 
}
öö 	
}
õõ 
[
¢¢ 
StructLayout
¢¢ 
(
¢¢ 

LayoutKind
¢¢ 
.
¢¢ 

Sequential
¢¢ '
)
¢¢' (
]
¢¢( )
[
££ 
DebuggerDisplay
££ 
(
££ 
$str
££ m
)
££m n
]
££n o
[
§§ 
DebuggerTypeProxy
§§ 
(
§§ 
typeof
§§ 
(
§§ ,
UnsafeHashMapDebuggerTypeProxy
§§ <
<
§§< =
,
§§= >
>
§§> ?
)
§§? @
)
§§@ A
]
§§A B
[
•• 
BurstCompatible
•• 
(
•• "
GenericTypeArguments
•• )
=
••* +
new
••, /
[
••0 1
]
••1 2
{
••3 4
typeof
••5 ;
(
••; <
int
••< ?
)
••? @
,
••@ A
typeof
••B H
(
••H I
int
••I L
)
••L M
}
••N O
)
••O P
]
••P Q
public
¶¶ 

unsafe
¶¶ 
struct
¶¶ 
UnsafeHashMap
¶¶ &
<
¶¶& '
TKey
¶¶' +
,
¶¶+ ,
TValue
¶¶- 3
>
¶¶3 4
:
ßß 	
INativeDisposable
ßß
 
,
®® 	
IEnumerable
®®
 
<
®® 
KeyValue
®® 
<
®® 
TKey
®® #
,
®®# $
TValue
®®% +
>
®®+ ,
>
®®, -
where
©© 
TKey
©© 
:
©© 
struct
©© 
,
©© 

IEquatable
©© '
<
©©' (
TKey
©©( ,
>
©©, -
where
™™ 
TValue
™™ 
:
™™ 
struct
™™ 
{
´´ 
[
¨¨ 	/
!NativeDisableUnsafePtrRestriction
¨¨	 *
]
¨¨* +
internal
≠≠ 
UnsafeHashMapData
≠≠ "
*
≠≠" #
m_Buffer
≠≠$ ,
;
≠≠, -
internal
ÆÆ 
AllocatorManager
ÆÆ !
.
ÆÆ! "
AllocatorHandle
ÆÆ" 1
m_AllocatorLabel
ÆÆ2 B
;
ÆÆB C
public
µµ 
UnsafeHashMap
µµ 
(
µµ 
int
µµ  
capacity
µµ! )
,
µµ) *
AllocatorManager
µµ+ ;
.
µµ; <
AllocatorHandle
µµ< K
	allocator
µµL U
)
µµU V
{
∂∂ 	
CollectionHelper
∑∑ 
.
∑∑ 
CheckIsUnmanaged
∑∑ -
<
∑∑- .
TKey
∑∑. 2
>
∑∑2 3
(
∑∑3 4
)
∑∑4 5
;
∑∑5 6
CollectionHelper
∏∏ 
.
∏∏ 
CheckIsUnmanaged
∏∏ -
<
∏∏- .
TValue
∏∏. 4
>
∏∏4 5
(
∏∏5 6
)
∏∏6 7
;
∏∏7 8
m_AllocatorLabel
∫∫ 
=
∫∫ 
	allocator
∫∫ (
;
∫∫( )
UnsafeHashMapData
ºº 
.
ºº 
AllocateHashMap
ºº -
<
ºº- .
TKey
ºº. 2
,
ºº2 3
TValue
ºº4 :
>
ºº: ;
(
ºº; <
capacity
ºº< D
,
ººD E
capacity
ººF N
*
ººO P
$num
ººQ R
,
ººR S
	allocator
ººT ]
,
ºº] ^
out
ºº_ b
m_Buffer
ººc k
)
ººk l
;
ººl m
Clear
ææ 
(
ææ 
)
ææ 
;
ææ 
}
øø 	
public
≈≈ 
bool
≈≈ 
IsEmpty
≈≈ 
=>
≈≈ 
!
≈≈  
	IsCreated
≈≈  )
||
≈≈* ,
UnsafeHashMapData
≈≈- >
.
≈≈> ?
IsEmpty
≈≈? F
(
≈≈F G
m_Buffer
≈≈G O
)
≈≈O P
;
≈≈P Q
public
ÀÀ 
int
ÀÀ 
Count
ÀÀ 
(
ÀÀ 
)
ÀÀ 
=>
ÀÀ 
UnsafeHashMapData
ÀÀ /
.
ÀÀ/ 0
GetCount
ÀÀ0 8
(
ÀÀ8 9
m_Buffer
ÀÀ9 A
)
ÀÀA B
;
ÀÀB C
public
”” 
int
”” 
Capacity
”” 
{
‘‘ 	
get
’’ 
{
÷÷ 
UnsafeHashMapData
◊◊ !
*
◊◊! "
data
◊◊# '
=
◊◊( )
m_Buffer
◊◊* 2
;
◊◊2 3
return
ÿÿ 
data
ÿÿ 
->
ÿÿ 
keyCapacity
ÿÿ (
;
ÿÿ( )
}
ŸŸ 
set
€€ 
{
‹‹ 
UnsafeHashMapData
›› !
*
››! "
data
››# '
=
››( )
m_Buffer
››* 2
;
››2 3
UnsafeHashMapData
ﬁﬁ !
.
ﬁﬁ! "
ReallocateHashMap
ﬁﬁ" 3
<
ﬁﬁ3 4
TKey
ﬁﬁ4 8
,
ﬁﬁ8 9
TValue
ﬁﬁ: @
>
ﬁﬁ@ A
(
ﬁﬁA B
data
ﬁﬁB F
,
ﬁﬁF G
value
ﬁﬁH M
,
ﬁﬁM N
UnsafeHashMapData
ﬁﬁO `
.
ﬁﬁ` a
GetBucketSize
ﬁﬁa n
(
ﬁﬁn o
value
ﬁﬁo t
)
ﬁﬁt u
,
ﬁﬁu v
m_AllocatorLabelﬁﬁw á
)ﬁﬁá à
;ﬁﬁà â
}
ﬂﬂ 
}
‡‡ 	
public
ÊÊ 
void
ÊÊ 
Clear
ÊÊ 
(
ÊÊ 
)
ÊÊ 
{
ÁÁ 	
UnsafeHashMapBase
ËË 
<
ËË 
TKey
ËË "
,
ËË" #
TValue
ËË$ *
>
ËË* +
.
ËË+ ,
Clear
ËË, 1
(
ËË1 2
m_Buffer
ËË2 :
)
ËË: ;
;
ËË; <
}
ÈÈ 	
public
ÚÚ 
bool
ÚÚ 
TryAdd
ÚÚ 
(
ÚÚ 
TKey
ÚÚ 
key
ÚÚ  #
,
ÚÚ# $
TValue
ÚÚ% +
item
ÚÚ, 0
)
ÚÚ0 1
{
ÛÛ 	
return
ÙÙ 
UnsafeHashMapBase
ÙÙ $
<
ÙÙ$ %
TKey
ÙÙ% )
,
ÙÙ) *
TValue
ÙÙ+ 1
>
ÙÙ1 2
.
ÙÙ2 3
TryAdd
ÙÙ3 9
(
ÙÙ9 :
m_Buffer
ÙÙ: B
,
ÙÙB C
key
ÙÙD G
,
ÙÙG H
item
ÙÙI M
,
ÙÙM N
false
ÙÙO T
,
ÙÙT U
m_AllocatorLabel
ÙÙV f
)
ÙÙf g
;
ÙÙg h
}
ıı 	
public
˛˛ 
void
˛˛ 
Add
˛˛ 
(
˛˛ 
TKey
˛˛ 
key
˛˛  
,
˛˛  !
TValue
˛˛" (
item
˛˛) -
)
˛˛- .
{
ˇˇ 	
TryAdd
Ä	Ä	 
(
Ä	Ä	 
key
Ä	Ä	 
,
Ä	Ä	 
item
Ä	Ä	 
)
Ä	Ä	 
;
Ä	Ä	 
}
Å	Å	 	
public
à	à	 
bool
à	à	 
Remove
à	à	 
(
à	à	 
TKey
à	à	 
key
à	à	  #
)
à	à	# $
{
â	â	 	
return
ä	ä	 
UnsafeHashMapBase
ä	ä	 $
<
ä	ä	$ %
TKey
ä	ä	% )
,
ä	ä	) *
TValue
ä	ä	+ 1
>
ä	ä	1 2
.
ä	ä	2 3
Remove
ä	ä	3 9
(
ä	ä	9 :
m_Buffer
ä	ä	: B
,
ä	ä	B C
key
ä	ä	D G
,
ä	ä	G H
false
ä	ä	I N
)
ä	ä	N O
!=
ä	ä	P R
$num
ä	ä	S T
;
ä	ä	T U
}
ã	ã	 	
public
ì	ì	 
bool
ì	ì	 
TryGetValue
ì	ì	 
(
ì	ì	  
TKey
ì	ì	  $
key
ì	ì	% (
,
ì	ì	( )
out
ì	ì	* -
TValue
ì	ì	. 4
item
ì	ì	5 9
)
ì	ì	9 :
{
î	î	 	(
NativeMultiHashMapIterator
ï	ï	 &
<
ï	ï	& '
TKey
ï	ï	' +
>
ï	ï	+ ,
tempIt
ï	ï	- 3
;
ï	ï	3 4
return
ñ	ñ	 
UnsafeHashMapBase
ñ	ñ	 $
<
ñ	ñ	$ %
TKey
ñ	ñ	% )
,
ñ	ñ	) *
TValue
ñ	ñ	+ 1
>
ñ	ñ	1 2
.
ñ	ñ	2 3$
TryGetFirstValueAtomic
ñ	ñ	3 I
(
ñ	ñ	I J
m_Buffer
ñ	ñ	J R
,
ñ	ñ	R S
key
ñ	ñ	T W
,
ñ	ñ	W X
out
ñ	ñ	Y \
item
ñ	ñ	] a
,
ñ	ñ	a b
out
ñ	ñ	c f
tempIt
ñ	ñ	g m
)
ñ	ñ	m n
;
ñ	ñ	n o
}
ó	ó	 	
public
û	û	 
bool
û	û	 
ContainsKey
û	û	 
(
û	û	  
TKey
û	û	  $
key
û	û	% (
)
û	û	( )
{
ü	ü	 	
return
†	†	 
UnsafeHashMapBase
†	†	 $
<
†	†	$ %
TKey
†	†	% )
,
†	†	) *
TValue
†	†	+ 1
>
†	†	1 2
.
†	†	2 3$
TryGetFirstValueAtomic
†	†	3 I
(
†	†	I J
m_Buffer
†	†	J R
,
†	†	R S
key
†	†	T W
,
†	†	W X
out
†	†	Y \
var
†	†	] `
	tempValue
†	†	a j
,
†	†	j k
out
†	†	l o
var
†	†	p s
tempIt
†	†	t z
)
†	†	z {
;
†	†	{ |
}
°	°	 	
public
™	™	 
TValue
™	™	 
this
™	™	 
[
™	™	 
TKey
™	™	 
key
™	™	  #
]
™	™	# $
{
´	´	 	
get
¨	¨	 
{
≠	≠	 
TValue
Æ	Æ	 
res
Æ	Æ	 
;
Æ	Æ	 
TryGetValue
Ø	Ø	 
(
Ø	Ø	 
key
Ø	Ø	 
,
Ø	Ø	  
out
Ø	Ø	! $
res
Ø	Ø	% (
)
Ø	Ø	( )
;
Ø	Ø	) *
return
∞	∞	 
res
∞	∞	 
;
∞	∞	 
}
±	±	 
set
≥	≥	 
{
¥	¥	 
if
µ	µ	 
(
µ	µ	 
UnsafeHashMapBase
µ	µ	 %
<
µ	µ	% &
TKey
µ	µ	& *
,
µ	µ	* +
TValue
µ	µ	, 2
>
µ	µ	2 3
.
µ	µ	3 4$
TryGetFirstValueAtomic
µ	µ	4 J
(
µ	µ	J K
m_Buffer
µ	µ	K S
,
µ	µ	S T
key
µ	µ	U X
,
µ	µ	X Y
out
µ	µ	Z ]
var
µ	µ	^ a
item
µ	µ	b f
,
µ	µ	f g
out
µ	µ	h k
var
µ	µ	l o
iterator
µ	µ	p x
)
µ	µ	x y
)
µ	µ	y z
{
∂	∂	 
UnsafeHashMapBase
∑	∑	 %
<
∑	∑	% &
TKey
∑	∑	& *
,
∑	∑	* +
TValue
∑	∑	, 2
>
∑	∑	2 3
.
∑	∑	3 4
SetValue
∑	∑	4 <
(
∑	∑	< =
m_Buffer
∑	∑	= E
,
∑	∑	E F
ref
∑	∑	G J
iterator
∑	∑	K S
,
∑	∑	S T
ref
∑	∑	U X
value
∑	∑	Y ^
)
∑	∑	^ _
;
∑	∑	_ `
}
∏	∏	 
else
π	π	 
{
∫	∫	 
UnsafeHashMapBase
ª	ª	 %
<
ª	ª	% &
TKey
ª	ª	& *
,
ª	ª	* +
TValue
ª	ª	, 2
>
ª	ª	2 3
.
ª	ª	3 4
TryAdd
ª	ª	4 :
(
ª	ª	: ;
m_Buffer
ª	ª	; C
,
ª	ª	C D
key
ª	ª	E H
,
ª	ª	H I
value
ª	ª	J O
,
ª	ª	O P
false
ª	ª	Q V
,
ª	ª	V W
m_AllocatorLabel
ª	ª	X h
)
ª	ª	h i
;
ª	ª	i j
}
º	º	 
}
Ω	Ω	 
}
æ	æ	 	
public
ƒ	ƒ	 
bool
ƒ	ƒ	 
	IsCreated
ƒ	ƒ	 
=>
ƒ	ƒ	  
m_Buffer
ƒ	ƒ	! )
!=
ƒ	ƒ	* ,
null
ƒ	ƒ	- 1
;
ƒ	ƒ	1 2
public
…	…	 
void
…	…	 
Dispose
…	…	 
(
…	…	 
)
…	…	 
{
 	 	 	
UnsafeHashMapData
À	À	 
.
À	À	 
DeallocateHashMap
À	À	 /
(
À	À	/ 0
m_Buffer
À	À	0 8
,
À	À	8 9
m_AllocatorLabel
À	À	: J
)
À	À	J K
;
À	À	K L
m_Buffer
Ã	Ã	 
=
Ã	Ã	 
null
Ã	Ã	 
;
Ã	Ã	 
}
Õ	Õ	 	
[
‘	‘	 	 
NotBurstCompatible
‘	‘		 
]‘	‘	ú ù
public
’	’	 
	JobHandle
’	’	 
Dispose
’	’	  
(
’	’	  !
	JobHandle
’	’	! *
	inputDeps
’	’	+ 4
)
’	’	4 5
{
÷	÷	 	
var
◊	◊	 
	jobHandle
◊	◊	 
=
◊	◊	 
new
◊	◊	 %
UnsafeHashMapDisposeJob
◊	◊	  7
{
◊	◊	8 9
Data
◊	◊	: >
=
◊	◊	? @
m_Buffer
◊	◊	A I
,
◊	◊	I J
	Allocator
◊	◊	K T
=
◊	◊	U V
m_AllocatorLabel
◊	◊	W g
}
◊	◊	h i
.
◊	◊	i j
Schedule
◊	◊	j r
(
◊	◊	r s
	inputDeps
◊	◊	s |
)
◊	◊	| }
;
◊	◊	} ~
m_Buffer
ÿ	ÿ	 
=
ÿ	ÿ	 
null
ÿ	ÿ	 
;
ÿ	ÿ	 
return
Ÿ	Ÿ	 
	jobHandle
Ÿ	Ÿ	 
;
Ÿ	Ÿ	 
}
⁄	⁄	 	
public
·	·	 
NativeArray
·	·	 
<
·	·	 
TKey
·	·	 
>
·	·	  
GetKeyArray
·	·	! ,
(
·	·	, -
AllocatorManager
·	·	- =
.
·	·	= >
AllocatorHandle
·	·	> M
	allocator
·	·	N W
)
·	·	W X
{
‚	‚	 	
var
„	„	 
result
„	„	 
=
„	„	 
CollectionHelper
„	„	 )
.
„	„	) *
CreateNativeArray
„	„	* ;
<
„	„	; <
TKey
„	„	< @
>
„	„	@ A
(
„	„	A B
UnsafeHashMapData
„	„	B S
.
„	„	S T
GetCount
„	„	T \
(
„	„	\ ]
m_Buffer
„	„	] e
)
„	„	e f
,
„	„	f g
	allocator
„	„	h q
,
„	„	q r!
NativeArrayOptions„	„	s Ö
.„	„	Ö Ü#
UninitializedMemory„	„	Ü ô
)„	„	ô ö
;„	„	ö õ
UnsafeHashMapData
‰	‰	 
.
‰	‰	 
GetKeyArray
‰	‰	 )
(
‰	‰	) *
m_Buffer
‰	‰	* 2
,
‰	‰	2 3
result
‰	‰	4 :
)
‰	‰	: ;
;
‰	‰	; <
return
Â	Â	 
result
Â	Â	 
;
Â	Â	 
}
Ê	Ê	 	
public
Ì	Ì	 
NativeArray
Ì	Ì	 
<
Ì	Ì	 
TValue
Ì	Ì	 !
>
Ì	Ì	! "
GetValueArray
Ì	Ì	# 0
(
Ì	Ì	0 1
AllocatorManager
Ì	Ì	1 A
.
Ì	Ì	A B
AllocatorHandle
Ì	Ì	B Q
	allocator
Ì	Ì	R [
)
Ì	Ì	[ \
{
Ó	Ó	 	
var
Ô	Ô	 
result
Ô	Ô	 
=
Ô	Ô	 
CollectionHelper
Ô	Ô	 )
.
Ô	Ô	) *
CreateNativeArray
Ô	Ô	* ;
<
Ô	Ô	; <
TValue
Ô	Ô	< B
>
Ô	Ô	B C
(
Ô	Ô	C D
UnsafeHashMapData
Ô	Ô	D U
.
Ô	Ô	U V
GetCount
Ô	Ô	V ^
(
Ô	Ô	^ _
m_Buffer
Ô	Ô	_ g
)
Ô	Ô	g h
,
Ô	Ô	h i
	allocator
Ô	Ô	j s
,
Ô	Ô	s t!
NativeArrayOptionsÔ	Ô	u á
.Ô	Ô	á à#
UninitializedMemoryÔ	Ô	à õ
)Ô	Ô	õ ú
;Ô	Ô	ú ù
UnsafeHashMapData
		 
.
		 
GetValueArray
		 +
(
		+ ,
m_Buffer
		, 4
,
		4 5
result
		6 <
)
		< =
;
		= >
return
Ò	Ò	 
result
Ò	Ò	 
;
Ò	Ò	 
}
Ú	Ú	 	
public
˙	˙	 "
NativeKeyValueArrays
˙	˙	 #
<
˙	˙	# $
TKey
˙	˙	$ (
,
˙	˙	( )
TValue
˙	˙	* 0
>
˙	˙	0 1
GetKeyValueArrays
˙	˙	2 C
(
˙	˙	C D
AllocatorManager
˙	˙	D T
.
˙	˙	T U
AllocatorHandle
˙	˙	U d
	allocator
˙	˙	e n
)
˙	˙	n o
{
˚	˚	 	
var
¸	¸	 
result
¸	¸	 
=
¸	¸	 
new
¸	¸	 "
NativeKeyValueArrays
¸	¸	 1
<
¸	¸	1 2
TKey
¸	¸	2 6
,
¸	¸	6 7
TValue
¸	¸	8 >
>
¸	¸	> ?
(
¸	¸	? @
UnsafeHashMapData
¸	¸	@ Q
.
¸	¸	Q R
GetCount
¸	¸	R Z
(
¸	¸	Z [
m_Buffer
¸	¸	[ c
)
¸	¸	c d
,
¸	¸	d e
	allocator
¸	¸	f o
,
¸	¸	o p!
NativeArrayOptions¸	¸	q É
.¸	¸	É Ñ#
UninitializedMemory¸	¸	Ñ ó
)¸	¸	ó ò
;¸	¸	ò ô
UnsafeHashMapData
˝	˝	 
.
˝	˝	 
GetKeyValueArrays
˝	˝	 /
(
˝	˝	/ 0
m_Buffer
˝	˝	0 8
,
˝	˝	8 9
result
˝	˝	: @
)
˝	˝	@ A
;
˝	˝	A B
return
˛	˛	 
result
˛	˛	 
;
˛	˛	 
}
ˇ	ˇ	 	
public
Ö
Ö
 
ParallelWriter
Ö
Ö
 
AsParallelWriter
Ö
Ö
 .
(
Ö
Ö
. /
)
Ö
Ö
/ 0
{
Ü
Ü
 	
ParallelWriter
á
á
 
writer
á
á
 !
;
á
á
! "
writer
à
à
 
.
à
à
 
m_ThreadIndex
à
à
  
=
à
à
! "
$num
à
à
# $
;
à
à
$ %
writer
â
â
 
.
â
â
 
m_Buffer
â
â
 
=
â
â
 
m_Buffer
â
â
 &
;
â
â
& '
return
ä
ä
 
writer
ä
ä
 
;
ä
ä
 
}
ã
ã
 	
[
ì
ì
 	.
 NativeContainerIsAtomicWriteOnly
ì
ì
	 )
]
ì
ì
) *
[
î
î
 	
BurstCompatible
î
î
	 
(
î
î
 "
GenericTypeArguments
î
î
 -
=
î
î
. /
new
î
î
0 3
[
î
î
4 5
]
î
î
5 6
{
î
î
7 8
typeof
î
î
9 ?
(
î
î
? @
int
î
î
@ C
)
î
î
C D
,
î
î
D E
typeof
î
î
F L
(
î
î
L M
int
î
î
M P
)
î
î
P Q
}
î
î
R S
)
î
î
S T
]
î
î
T U
public
ï
ï
 
unsafe
ï
ï
 
struct
ï
ï
 
ParallelWriter
ï
ï
 +
{
ñ
ñ
 	
[
ó
ó
 /
!NativeDisableUnsafePtrRestriction
ó
ó
 .
]
ó
ó
. /
internal
ò
ò
 
UnsafeHashMapData
ò
ò
 &
*
ò
ò
& '
m_Buffer
ò
ò
( 0
;
ò
ò
0 1
[
ö
ö
 "
NativeSetThreadIndex
ö
ö
 !
]
ö
ö
! "
internal
õ
õ
 
int
õ
õ
 
m_ThreadIndex
õ
õ
 &
;
õ
õ
& '
public
°
°
 
int
°
°
 
Capacity
°
°
 
{
¢
¢
 
get
£
£
 
{
§
§
 
UnsafeHashMapData
•
•
 %
*
•
•
% &
data
•
•
' +
=
•
•
, -
m_Buffer
•
•
. 6
;
•
•
6 7
return
¶
¶
 
data
¶
¶
 
->
¶
¶
 !
keyCapacity
¶
¶
! ,
;
¶
¶
, -
}
ß
ß
 
}
®
®
 
public
±
±
 
bool
±
±
 
TryAdd
±
±
 
(
±
±
 
TKey
±
±
 #
key
±
±
$ '
,
±
±
' (
TValue
±
±
) /
item
±
±
0 4
)
±
±
4 5
{
≤
≤
 
Assert
≥
≥
 
.
≥
≥
 
IsTrue
≥
≥
 
(
≥
≥
 
m_ThreadIndex
≥
≥
 +
>=
≥
≥
, .
$num
≥
≥
/ 0
)
≥
≥
0 1
;
≥
≥
1 2
return
¥
¥
 
UnsafeHashMapBase
¥
¥
 (
<
¥
¥
( )
TKey
¥
¥
) -
,
¥
¥
- .
TValue
¥
¥
/ 5
>
¥
¥
5 6
.
¥
¥
6 7
TryAddAtomic
¥
¥
7 C
(
¥
¥
C D
m_Buffer
¥
¥
D L
,
¥
¥
L M
key
¥
¥
N Q
,
¥
¥
Q R
item
¥
¥
S W
,
¥
¥
W X
m_ThreadIndex
¥
¥
Y f
)
¥
¥
f g
;
¥
¥
g h
}
µ
µ
 
}
∂
∂
 	
public
º
º
 

Enumerator
º
º
 
GetEnumerator
º
º
 '
(
º
º
' (
)
º
º
( )
{
Ω
Ω
 	
return
æ
æ
 
new
æ
æ
 

Enumerator
æ
æ
 !
{
æ
æ
" #
m_Enumerator
æ
æ
$ 0
=
æ
æ
1 2
new
æ
æ
3 6)
UnsafeHashMapDataEnumerator
æ
æ
7 R
(
æ
æ
R S
m_Buffer
æ
æ
S [
)
æ
æ
[ \
}
æ
æ
] ^
;
æ
æ
^ _
}
ø
ø
 	
IEnumerator
∆
∆
 
<
∆
∆
 
KeyValue
∆
∆
 
<
∆
∆
 
TKey
∆
∆
 !
,
∆
∆
! "
TValue
∆
∆
# )
>
∆
∆
) *
>
∆
∆
* +
IEnumerable
∆
∆
, 7
<
∆
∆
7 8
KeyValue
∆
∆
8 @
<
∆
∆
@ A
TKey
∆
∆
A E
,
∆
∆
E F
TValue
∆
∆
G M
>
∆
∆
M N
>
∆
∆
N O
.
∆
∆
O P
GetEnumerator
∆
∆
P ]
(
∆
∆
] ^
)
∆
∆
^ _
{
«
«
 	
throw
»
»
 
new
»
»
 %
NotImplementedException
»
»
 -
(
»
»
- .
)
»
»
. /
;
»
»
/ 0
}
…
…
 	
IEnumerator
–
–
 
IEnumerable
–
–
 
.
–
–
  
GetEnumerator
–
–
  -
(
–
–
- .
)
–
–
. /
{
—
—
 	
throw
“
“
 
new
“
“
 %
NotImplementedException
“
“
 -
(
“
“
- .
)
“
“
. /
;
“
“
/ 0
}
”
”
 	
public
‹
‹
 
struct
‹
‹
 

Enumerator
‹
‹
  
:
‹
‹
! "
IEnumerator
‹
‹
# .
<
‹
‹
. /
KeyValue
‹
‹
/ 7
<
‹
‹
7 8
TKey
‹
‹
8 <
,
‹
‹
< =
TValue
‹
‹
> D
>
‹
‹
D E
>
‹
‹
E F
{
›
›
 	
internal
ﬁ
ﬁ
 )
UnsafeHashMapDataEnumerator
ﬁ
ﬁ
 0
m_Enumerator
ﬁ
ﬁ
1 =
;
ﬁ
ﬁ
= >
public
„
„
 
void
„
„
 
Dispose
„
„
 
(
„
„
  
)
„
„
  !
{
„
„
" #
}
„
„
$ %
public
È
È
 
bool
È
È
 
MoveNext
È
È
  
(
È
È
  !
)
È
È
! "
=>
È
È
# %
m_Enumerator
È
È
& 2
.
È
È
2 3
MoveNext
È
È
3 ;
(
È
È
; <
)
È
È
< =
;
È
È
= >
public
Ó
Ó
 
void
Ó
Ó
 
Reset
Ó
Ó
 
(
Ó
Ó
 
)
Ó
Ó
 
=>
Ó
Ó
  "
m_Enumerator
Ó
Ó
# /
.
Ó
Ó
/ 0
Reset
Ó
Ó
0 5
(
Ó
Ó
5 6
)
Ó
Ó
6 7
;
Ó
Ó
7 8
public
Ù
Ù
 
KeyValue
Ù
Ù
 
<
Ù
Ù
 
TKey
Ù
Ù
  
,
Ù
Ù
  !
TValue
Ù
Ù
" (
>
Ù
Ù
( )
Current
Ù
Ù
* 1
=>
Ù
Ù
2 4
m_Enumerator
Ù
Ù
5 A
.
Ù
Ù
A B

GetCurrent
Ù
Ù
B L
<
Ù
Ù
L M
TKey
Ù
Ù
M Q
,
Ù
Ù
Q R
TValue
Ù
Ù
S Y
>
Ù
Ù
Y Z
(
Ù
Ù
Z [
)
Ù
Ù
[ \
;
Ù
Ù
\ ]
object
ˆ
ˆ
 
IEnumerator
ˆ
ˆ
 
.
ˆ
ˆ
 
Current
ˆ
ˆ
 &
=>
ˆ
ˆ
' )
Current
ˆ
ˆ
* 1
;
ˆ
ˆ
1 2
}
˜
˜
 	
}
¯
¯
 
[
˙
˙
 
BurstCompile
˙
˙
 
]
˙
˙
 
internal
˚
˚
 
unsafe
˚
˚
 
struct
˚
˚
 %
UnsafeHashMapDisposeJob
˚
˚
 2
:
˚
˚
3 4
IJob
˚
˚
5 9
{
¸
¸
 
[
˝
˝
 	/
!NativeDisableUnsafePtrRestriction
˝
˝
	 *
]
˝
˝
* +
public
˛
˛
 
UnsafeHashMapData
˛
˛
  
*
˛
˛
  !
Data
˛
˛
" &
;
˛
˛
& '
public
ˇ
ˇ
 
AllocatorManager
ˇ
ˇ
 
.
ˇ
ˇ
  
AllocatorHandle
ˇ
ˇ
  /
	Allocator
ˇ
ˇ
0 9
;
ˇ
ˇ
9 :
public
ÅÅ 
void
ÅÅ 
Execute
ÅÅ 
(
ÅÅ 
)
ÅÅ 
{
ÇÇ 	
UnsafeHashMapData
ÉÉ 
.
ÉÉ 
DeallocateHashMap
ÉÉ /
(
ÉÉ/ 0
Data
ÉÉ0 4
,
ÉÉ4 5
	Allocator
ÉÉ6 ?
)
ÉÉ? @
;
ÉÉ@ A
}
ÑÑ 	
}
ÖÖ 
sealed
áá 

internal
áá 
class
áá ,
UnsafeHashMapDebuggerTypeProxy
áá 8
<
áá8 9
TKey
áá9 =
,
áá= >
TValue
áá? E
>
ááE F
where
àà 
TKey
àà 
:
àà 
struct
àà 
,
àà 

IEquatable
àà '
<
àà' (
TKey
àà( ,
>
àà, -
where
ââ 
TValue
ââ 
:
ââ 
struct
ââ 
{
ää 
UnsafeHashMap
åå 
<
åå 
TKey
åå 
,
åå 
TValue
åå "
>
åå" #
m_Target
åå$ ,
;
åå, -
public
éé ,
UnsafeHashMapDebuggerTypeProxy
éé -
(
éé- .
UnsafeHashMap
éé. ;
<
éé; <
TKey
éé< @
,
éé@ A
TValue
ééB H
>
ééH I
target
ééJ P
)
ééP Q
{
èè 	
m_Target
êê 
=
êê 
target
êê 
;
êê 
}
ëë 	
public
ìì 
List
ìì 
<
ìì 
Pair
ìì 
<
ìì 
TKey
ìì 
,
ìì 
TValue
ìì %
>
ìì% &
>
ìì& '
Items
ìì( -
{
îî 	
get
ïï 
{
ññ 
var
óó 
result
óó 
=
óó 
new
óó  
List
óó! %
<
óó% &
Pair
óó& *
<
óó* +
TKey
óó+ /
,
óó/ 0
TValue
óó1 7
>
óó7 8
>
óó8 9
(
óó9 :
)
óó: ;
;
óó; <
using
òò 
(
òò 
var
òò 
kva
òò 
=
òò  
m_Target
òò! )
.
òò) *
GetKeyValueArrays
òò* ;
(
òò; <
	Allocator
òò< E
.
òòE F
Temp
òòF J
)
òòJ K
)
òòK L
{
ôô 
for
öö 
(
öö 
var
öö 
i
öö 
=
öö  
$num
öö! "
;
öö" #
i
öö$ %
<
öö& '
kva
öö( +
.
öö+ ,
Length
öö, 2
;
öö2 3
++
öö4 6
i
öö6 7
)
öö7 8
{
õõ 
result
úú 
.
úú 
Add
úú "
(
úú" #
new
úú# &
Pair
úú' +
<
úú+ ,
TKey
úú, 0
,
úú0 1
TValue
úú2 8
>
úú8 9
(
úú9 :
kva
úú: =
.
úú= >
Keys
úú> B
[
úúB C
i
úúC D
]
úúD E
,
úúE F
kva
úúG J
.
úúJ K
Values
úúK Q
[
úúQ R
i
úúR S
]
úúS T
)
úúT U
)
úúU V
;
úúV W
}
ùù 
}
ûû 
return
üü 
result
üü 
;
üü 
}
†† 
}
°° 	
}
££ 
public
®® 

unsafe
®® 
struct
®® "
UntypedUnsafeHashMap
®® -
{
©© 
[
´´ 	/
!NativeDisableUnsafePtrRestriction
´´	 *
]
´´* +
UnsafeHashMapData
¨¨ 
*
¨¨ 
m_Buffer
¨¨ #
;
¨¨# $
AllocatorManager
≠≠ 
.
≠≠ 
AllocatorHandle
≠≠ (
m_AllocatorLabel
≠≠) 9
;
≠≠9 :
}
ØØ 
}∞∞ ç¶
iC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeMultiHashMap.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[ 
BurstCompatible 
(  
GenericTypeArguments )
=* +
new, /
[0 1
]1 2
{3 4
typeof5 ;
(; <
int< ?
)? @
}A B
)B C
]C D
public 

struct &
NativeMultiHashMapIterator ,
<, -
TKey- 1
>1 2
where 
TKey 
: 
struct 
{ 
internal 
TKey 
key 
; 
internal 
int 
NextEntryIndex #
;# $
internal 
int 

EntryIndex 
;  
public 
int 
GetEntryIndex  
(  !
)! "
=># %

EntryIndex& 0
;0 1
} 
[++ 
StructLayout++ 
(++ 

LayoutKind++ 
.++ 

Sequential++ '
)++' (
]++( )
[,, 
NativeContainer,, 
],, 
[-- 
DebuggerTypeProxy-- 
(-- 
typeof-- 
(-- /
#NativeMultiHashMapDebuggerTypeProxy-- A
<--A B
,--B C
>--C D
)--D E
)--E F
]--F G
[.. 
BurstCompatible.. 
(..  
GenericTypeArguments.. )
=..* +
new.., /
[..0 1
]..1 2
{..3 4
typeof..5 ;
(..; <
int..< ?
)..? @
,..@ A
typeof..B H
(..H I
int..I L
)..L M
}..N O
)..O P
]..P Q
public// 

unsafe// 
struct// 
NativeMultiHashMap// +
<//+ ,
TKey//, 0
,//0 1
TValue//2 8
>//8 9
:00 	
INativeDisposable00
 
,11 	
IEnumerable11
 
<11 
KeyValue11 
<11 
TKey11 #
,11# $
TValue11% +
>11+ ,
>11, -
where22 
TKey22 
:22 
struct22 
,22 

IEquatable22 '
<22' (
TKey22( ,
>22, -
where33 
TValue33 
:33 
struct33 
{44 
internal55 
UnsafeMultiHashMap55 #
<55# $
TKey55$ (
,55( )
TValue55* 0
>550 1
m_MultiHashMapData552 D
;55D E
internal88 
AtomicSafetyHandle88 #
m_Safety88$ ,
;88, -
internal99 
static99 
readonly99  
SharedStatic99! -
<99- .
int99. 1
>991 2
s_staticSafetyId993 C
=99D E
SharedStatic99F R
<99R S
int99S V
>99V W
.99W X
GetOrCreate99X c
<99c d
NativeMultiHashMap99d v
<99v w
TKey99w {
,99{ |
TValue	99} É
>
99É Ñ
>
99Ñ Ö
(
99Ö Ü
)
99Ü á
;
99á à
[== 	.
"NativeSetClassTypeToNullOnSchedule==	 +
]==+ ,
internal>> 
DisposeSentinel>>  
m_DisposeSentinel>>! 2
;>>2 3
publicGG 
NativeMultiHashMapGG !
(GG! "
intGG" %
capacityGG& .
,GG. /
AllocatorManagerGG0 @
.GG@ A
AllocatorHandleGGA P
	allocatorGGQ Z
)GGZ [
:HH 
thisHH 
(HH 
capacityHH 
,HH 
	allocatorHH &
,HH& '
$numHH( )
)HH) *
{II 	
}JJ 	
[LL 	
BurstCompatibleLL	 
(LL  
GenericTypeArgumentsLL -
=LL. /
newLL0 3
[LL3 4
]LL4 5
{LL6 7
typeofLL8 >
(LL> ?
AllocatorManagerLL? O
.LLO P
AllocatorHandleLLP _
)LL_ `
}LLa b
)LLb c
]LLc d
internalMM 
voidMM 

InitializeMM  
<MM  !
UMM! "
>MM" #
(MM# $
intMM$ '
capacityMM( 0
,MM0 1
refMM2 5
UMM6 7
	allocatorMM8 A
,MMA B
intMMC F%
disposeSentinelStackDepthMMG `
)MM` a
whereNN 
UNN 
:NN 
	unmanagedNN 
,NN  
AllocatorManagerNN! 1
.NN1 2

IAllocatorNN2 <
{OO 	
m_MultiHashMapDataPP 
=PP  
newPP! $
UnsafeMultiHashMapPP% 7
<PP7 8
TKeyPP8 <
,PP< =
TValuePP> D
>PPD E
(PPE F
capacityPPF N
,PPN O
	allocatorPPP Y
.PPY Z
HandlePPZ `
)PP` a
;PPa b
ifVV 
(VV 
	allocatorVV 
.VV 
IsCustomAllocatorVV +
)VV+ ,
{WW 
m_SafetyXX 
=XX 
AtomicSafetyHandleXX -
.XX- .
CreateXX. 4
(XX4 5
)XX5 6
;XX6 7
m_DisposeSentinelYY !
=YY" #
nullYY$ (
;YY( )
}ZZ 
else[[ 
{\\ 
DisposeSentinel]] 
.]]  
Create]]  &
(]]& '
out]]' *
m_Safety]]+ 3
,]]3 4
out]]5 8
m_DisposeSentinel]]9 J
,]]J K%
disposeSentinelStackDepth]]L e
,]]e f
	allocator]]g p
.]]p q
ToAllocator]]q |
)]]| }
;]]} ~
}^^ 
CollectionHelperaa 
.aa 
SetStaticSafetyIdaa .
<aa. /
NativeMultiHashMapaa/ A
<aaA B
TKeyaaB F
,aaF G
TValueaaH N
>aaN O
>aaO P
(aaP Q
refaaQ T
m_SafetyaaU ]
,aa] ^
refaa_ b
s_staticSafetyIdaac s
.aas t
Dataaat x
)aax y
;aay z
AtomicSafetyHandlebb 
.bb 2
&SetBumpSecondaryVersionOnScheduleWritebb E
(bbE F
m_SafetybbF N
,bbN O
truebbP T
)bbT U
;bbU V
}dd 	
NativeMultiHashMapff 
(ff 
intff 
capacityff '
,ff' (
AllocatorManagerff) 9
.ff9 :
AllocatorHandleff: I
	allocatorffJ S
,ffS T
intffU X%
disposeSentinelStackDepthffY r
)ffr s
{gg 	
thishh 
=hh 
defaulthh 
;hh 

Initializeii 
(ii 
capacityii 
,ii  
refii! $
	allocatorii% .
,ii. /%
disposeSentinelStackDepthii0 I
)iiI J
;iiJ K
}jj 	
publicpp 
boolpp 
IsEmptypp 
{qq 	
getrr 
{ss 
	CheckReadtt 
(tt 
)tt 
;tt 
returnuu 
m_MultiHashMapDatauu )
.uu) *
IsEmptyuu* 1
;uu1 2
}vv 
}ww 	
public~~ 
int~~ 
Count~~ 
(~~ 
)~~ 
{ 	
	CheckRead
ÄÄ 
(
ÄÄ 
)
ÄÄ 
;
ÄÄ 
return
ÅÅ  
m_MultiHashMapData
ÅÅ %
.
ÅÅ% &
Count
ÅÅ& +
(
ÅÅ+ ,
)
ÅÅ, -
;
ÅÅ- .
}
ÇÇ 	
public
ää 
int
ää 
Capacity
ää 
{
ãã 	
get
åå 
{
çç 
	CheckRead
éé 
(
éé 
)
éé 
;
éé 
return
èè  
m_MultiHashMapData
èè )
.
èè) *
Capacity
èè* 2
;
èè2 3
}
êê 
set
íí 
{
ìì 

CheckWrite
îî 
(
îî 
)
îî 
;
îî  
m_MultiHashMapData
ïï "
.
ïï" #
Capacity
ïï# +
=
ïï, -
value
ïï. 3
;
ïï3 4
}
ññ 
}
óó 	
public
ùù 
void
ùù 
Clear
ùù 
(
ùù 
)
ùù 
{
ûû 	

CheckWrite
üü 
(
üü 
)
üü 
;
üü  
m_MultiHashMapData
†† 
.
†† 
Clear
†† $
(
††$ %
)
††% &
;
††& '
}
°° 	
public
´´ 
void
´´ 
Add
´´ 
(
´´ 
TKey
´´ 
key
´´  
,
´´  !
TValue
´´" (
item
´´) -
)
´´- .
{
¨¨ 	

CheckWrite
≠≠ 
(
≠≠ 
)
≠≠ 
;
≠≠  
m_MultiHashMapData
ÆÆ 
.
ÆÆ 
Add
ÆÆ "
(
ÆÆ" #
key
ÆÆ# &
,
ÆÆ& '
item
ÆÆ( ,
)
ÆÆ, -
;
ÆÆ- .
}
ØØ 	
public
∂∂ 
int
∂∂ 
Remove
∂∂ 
(
∂∂ 
TKey
∂∂ 
key
∂∂ "
)
∂∂" #
{
∑∑ 	

CheckWrite
∏∏ 
(
∏∏ 
)
∏∏ 
;
∏∏ 
return
ππ  
m_MultiHashMapData
ππ %
.
ππ% &
Remove
ππ& ,
(
ππ, -
key
ππ- 0
)
ππ0 1
;
ππ1 2
}
∫∫ 	
public
¡¡ 
void
¡¡ 
Remove
¡¡ 
(
¡¡ (
NativeMultiHashMapIterator
¡¡ 5
<
¡¡5 6
TKey
¡¡6 :
>
¡¡: ;
it
¡¡< >
)
¡¡> ?
{
¬¬ 	

CheckWrite
√√ 
(
√√ 
)
√√ 
;
√√  
m_MultiHashMapData
ƒƒ 
.
ƒƒ 
Remove
ƒƒ %
(
ƒƒ% &
it
ƒƒ& (
)
ƒƒ( )
;
ƒƒ) *
}
≈≈ 	
public
ŒŒ 
bool
ŒŒ 
TryGetFirstValue
ŒŒ $
(
ŒŒ$ %
TKey
ŒŒ% )
key
ŒŒ* -
,
ŒŒ- .
out
ŒŒ/ 2
TValue
ŒŒ3 9
item
ŒŒ: >
,
ŒŒ> ?
out
ŒŒ@ C(
NativeMultiHashMapIterator
ŒŒD ^
<
ŒŒ^ _
TKey
ŒŒ_ c
>
ŒŒc d
it
ŒŒe g
)
ŒŒg h
{
œœ 	
	CheckRead
–– 
(
–– 
)
–– 
;
–– 
return
——  
m_MultiHashMapData
—— %
.
——% &
TryGetFirstValue
——& 6
(
——6 7
key
——7 :
,
——: ;
out
——< ?
item
——@ D
,
——D E
out
——F I
it
——J L
)
——L M
;
——M N
}
““ 	
public
⁄⁄ 
bool
⁄⁄ 
TryGetNextValue
⁄⁄ #
(
⁄⁄# $
out
⁄⁄$ '
TValue
⁄⁄( .
item
⁄⁄/ 3
,
⁄⁄3 4
ref
⁄⁄5 8(
NativeMultiHashMapIterator
⁄⁄9 S
<
⁄⁄S T
TKey
⁄⁄T X
>
⁄⁄X Y
it
⁄⁄Z \
)
⁄⁄\ ]
{
€€ 	
	CheckRead
‹‹ 
(
‹‹ 
)
‹‹ 
;
‹‹ 
return
››  
m_MultiHashMapData
›› %
.
››% &
TryGetNextValue
››& 5
(
››5 6
out
››6 9
item
››: >
,
››> ?
ref
››@ C
it
››D F
)
››F G
;
››G H
}
ﬁﬁ 	
public
ÂÂ 
bool
ÂÂ 
ContainsKey
ÂÂ 
(
ÂÂ  
TKey
ÂÂ  $
key
ÂÂ% (
)
ÂÂ( )
{
ÊÊ 	
return
ÁÁ 
TryGetFirstValue
ÁÁ #
(
ÁÁ# $
key
ÁÁ$ '
,
ÁÁ' (
out
ÁÁ) ,
var
ÁÁ- 0
temp0
ÁÁ1 6
,
ÁÁ6 7
out
ÁÁ8 ;
var
ÁÁ< ?
temp1
ÁÁ@ E
)
ÁÁE F
;
ÁÁF G
}
ËË 	
public
ÔÔ 
int
ÔÔ 
CountValuesForKey
ÔÔ $
(
ÔÔ$ %
TKey
ÔÔ% )
key
ÔÔ* -
)
ÔÔ- .
{
 	
if
ÒÒ 
(
ÒÒ 
!
ÒÒ 
TryGetFirstValue
ÒÒ !
(
ÒÒ! "
key
ÒÒ" %
,
ÒÒ% &
out
ÒÒ' *
var
ÒÒ+ .
value
ÒÒ/ 4
,
ÒÒ4 5
out
ÒÒ6 9
var
ÒÒ: =
iterator
ÒÒ> F
)
ÒÒF G
)
ÒÒG H
{
ÚÚ 
return
ÛÛ 
$num
ÛÛ 
;
ÛÛ 
}
ÙÙ 
var
ˆˆ 
count
ˆˆ 
=
ˆˆ 
$num
ˆˆ 
;
ˆˆ 
while
˜˜ 
(
˜˜ 
TryGetNextValue
˜˜ "
(
˜˜" #
out
˜˜# &
value
˜˜' ,
,
˜˜, -
ref
˜˜. 1
iterator
˜˜2 :
)
˜˜: ;
)
˜˜; <
{
¯¯ 
count
˘˘ 
++
˘˘ 
;
˘˘ 
}
˙˙ 
return
¸¸ 
count
¸¸ 
;
¸¸ 
}
˝˝ 	
public
ÖÖ 
bool
ÖÖ 
SetValue
ÖÖ 
(
ÖÖ 
TValue
ÖÖ #
item
ÖÖ$ (
,
ÖÖ( )(
NativeMultiHashMapIterator
ÖÖ* D
<
ÖÖD E
TKey
ÖÖE I
>
ÖÖI J
it
ÖÖK M
)
ÖÖM N
{
ÜÜ 	

CheckWrite
áá 
(
áá 
)
áá 
;
áá 
return
àà  
m_MultiHashMapData
àà %
.
àà% &
SetValue
àà& .
(
àà. /
item
àà/ 3
,
àà3 4
it
àà5 7
)
àà7 8
;
àà8 9
}
ââ 	
public
èè 
bool
èè 
	IsCreated
èè 
=>
èè   
m_MultiHashMapData
èè! 3
.
èè3 4
	IsCreated
èè4 =
;
èè= >
public
îî 
void
îî 
Dispose
îî 
(
îî 
)
îî 
{
ïï 	
DisposeSentinel
öö 
.
öö 
Dispose
öö #
(
öö# $
ref
öö$ '
m_Safety
öö( 0
,
öö0 1
ref
öö2 5
m_DisposeSentinel
öö6 G
)
ööG H
;
ööH I 
m_MultiHashMapData
ùù 
.
ùù 
Dispose
ùù &
(
ùù& '
)
ùù' (
;
ùù( )
}
ûû 	
[
•• 	 
NotBurstCompatible
••	 
]••ú ù
public
¶¶ 
	JobHandle
¶¶ 
Dispose
¶¶  
(
¶¶  !
	JobHandle
¶¶! *
	inputDeps
¶¶+ 4
)
¶¶4 5
{
ßß 	
DisposeSentinel
ØØ 
.
ØØ 
Clear
ØØ !
(
ØØ! "
ref
ØØ" %
m_DisposeSentinel
ØØ& 7
)
ØØ7 8
;
ØØ8 9
var
±± 
	jobHandle
±± 
=
±± 
new
±± )
UnsafeHashMapDataDisposeJob
±±  ;
{
±±< =
Data
±±> B
=
±±C D
new
±±E H&
UnsafeHashMapDataDispose
±±I a
{
±±b c
m_Buffer
±±d l
=
±±m n!
m_MultiHashMapData±±o Å
.±±Å Ç
m_Buffer±±Ç ä
,±±ä ã 
m_AllocatorLabel±±å ú
=±±ù û"
m_MultiHashMapData±±ü ±
.±±± ≤ 
m_AllocatorLabel±±≤ ¬
,±±¬ √
m_Safety±±ƒ Ã
=±±Õ Œ
m_Safety±±œ ◊
}±±ÿ Ÿ
}±±⁄ €
.±±€ ‹
Schedule±±‹ ‰
(±±‰ Â
	inputDeps±±Â Ó
)±±Ó Ô
;±±Ô  
AtomicSafetyHandle
≥≥ 
.
≥≥ 
Release
≥≥ &
(
≥≥& '
m_Safety
≥≥' /
)
≥≥/ 0
;
≥≥0 1 
m_MultiHashMapData
∑∑ 
.
∑∑ 
m_Buffer
∑∑ '
=
∑∑( )
null
∑∑* .
;
∑∑. /
return
ππ 
	jobHandle
ππ 
;
ππ 
}
∫∫ 	
public
ƒƒ 
NativeArray
ƒƒ 
<
ƒƒ 
TKey
ƒƒ 
>
ƒƒ  
GetKeyArray
ƒƒ! ,
(
ƒƒ, -
AllocatorManager
ƒƒ- =
.
ƒƒ= >
AllocatorHandle
ƒƒ> M
	allocator
ƒƒN W
)
ƒƒW X
{
≈≈ 	
	CheckRead
∆∆ 
(
∆∆ 
)
∆∆ 
;
∆∆ 
return
««  
m_MultiHashMapData
«« %
.
««% &
GetKeyArray
««& 1
(
««1 2
	allocator
««2 ;
)
««; <
;
««< =
}
»» 	
public
—— 
NativeArray
—— 
<
—— 
TValue
—— !
>
——! "
GetValueArray
——# 0
(
——0 1
AllocatorManager
——1 A
.
——A B
AllocatorHandle
——B Q
	allocator
——R [
)
——[ \
{
““ 	
	CheckRead
”” 
(
”” 
)
”” 
;
”” 
return
‘‘  
m_MultiHashMapData
‘‘ %
.
‘‘% &
GetValueArray
‘‘& 3
(
‘‘3 4
	allocator
‘‘4 =
)
‘‘= >
;
‘‘> ?
}
’’ 	
public
ﬁﬁ "
NativeKeyValueArrays
ﬁﬁ #
<
ﬁﬁ# $
TKey
ﬁﬁ$ (
,
ﬁﬁ( )
TValue
ﬁﬁ* 0
>
ﬁﬁ0 1
GetKeyValueArrays
ﬁﬁ2 C
(
ﬁﬁC D
AllocatorManager
ﬁﬁD T
.
ﬁﬁT U
AllocatorHandle
ﬁﬁU d
	allocator
ﬁﬁe n
)
ﬁﬁn o
{
ﬂﬂ 	
	CheckRead
‡‡ 
(
‡‡ 
)
‡‡ 
;
‡‡ 
return
··  
m_MultiHashMapData
·· %
.
··% &
GetKeyValueArrays
··& 7
(
··7 8
	allocator
··8 A
)
··A B
;
··B C
}
‚‚ 	
public
ËË 
ParallelWriter
ËË 
AsParallelWriter
ËË .
(
ËË. /
)
ËË/ 0
{
ÈÈ 	
ParallelWriter
ÍÍ 
writer
ÍÍ !
;
ÍÍ! "
writer
ÎÎ 
.
ÎÎ 
m_Writer
ÎÎ 
=
ÎÎ  
m_MultiHashMapData
ÎÎ 0
.
ÎÎ0 1
AsParallelWriter
ÎÎ1 A
(
ÎÎA B
)
ÎÎB C
;
ÎÎC D
writer
ÌÌ 
.
ÌÌ 
m_Safety
ÌÌ 
=
ÌÌ 
m_Safety
ÌÌ &
;
ÌÌ& '
CollectionHelper
ÓÓ 
.
ÓÓ 
SetStaticSafetyId
ÓÓ .
<
ÓÓ. /
ParallelWriter
ÓÓ/ =
>
ÓÓ= >
(
ÓÓ> ?
ref
ÓÓ? B
writer
ÓÓC I
.
ÓÓI J
m_Safety
ÓÓJ R
,
ÓÓR S
ref
ÓÓT W
s_staticSafetyId
ÓÓX h
.
ÓÓh i
Data
ÓÓi m
)
ÓÓm n
;
ÓÓn o
return
 
writer
 
;
 
}
ÒÒ 	
[
˘˘ 	
NativeContainer
˘˘	 
]
˘˘ 
[
˙˙ 	.
 NativeContainerIsAtomicWriteOnly
˙˙	 )
]
˙˙) *
[
˚˚ 	
BurstCompatible
˚˚	 
(
˚˚ "
GenericTypeArguments
˚˚ -
=
˚˚. /
new
˚˚0 3
[
˚˚4 5
]
˚˚5 6
{
˚˚7 8
typeof
˚˚9 ?
(
˚˚? @
int
˚˚@ C
)
˚˚C D
,
˚˚D E
typeof
˚˚F L
(
˚˚L M
int
˚˚M P
)
˚˚P Q
}
˚˚R S
)
˚˚S T
]
˚˚T U
public
¸¸ 
unsafe
¸¸ 
struct
¸¸ 
ParallelWriter
¸¸ +
{
˝˝ 	
internal
˛˛  
UnsafeMultiHashMap
˛˛ '
<
˛˛' (
TKey
˛˛( ,
,
˛˛, -
TValue
˛˛. 4
>
˛˛4 5
.
˛˛5 6
ParallelWriter
˛˛6 D
m_Writer
˛˛E M
;
˛˛M N
internal
ÅÅ  
AtomicSafetyHandle
ÅÅ '
m_Safety
ÅÅ( 0
;
ÅÅ0 1
internal
ÇÇ 
static
ÇÇ 
readonly
ÇÇ $
SharedStatic
ÇÇ% 1
<
ÇÇ1 2
int
ÇÇ2 5
>
ÇÇ5 6
s_staticSafetyId
ÇÇ7 G
=
ÇÇH I
SharedStatic
ÇÇJ V
<
ÇÇV W
int
ÇÇW Z
>
ÇÇZ [
.
ÇÇ[ \
GetOrCreate
ÇÇ\ g
<
ÇÇg h
ParallelWriter
ÇÇh v
>
ÇÇv w
(
ÇÇw x
)
ÇÇx y
;
ÇÇy z
public
ää 
int
ää 
m_ThreadIndex
ää $
=>
ää% '
m_Writer
ää( 0
.
ää0 1
m_ThreadIndex
ää1 >
;
ää> ?
public
êê 
int
êê 
Capacity
êê 
{
ëë 
get
íí 
{
ìì  
AtomicSafetyHandle
ïï &
.
ïï& '
CheckReadAndThrow
ïï' 8
(
ïï8 9
m_Safety
ïï9 A
)
ïïA B
;
ïïB C
return
óó 
m_Writer
óó #
.
óó# $
Capacity
óó$ ,
;
óó, -
}
òò 
}
ôô 
public
££ 
void
££ 
Add
££ 
(
££ 
TKey
££  
key
££! $
,
££$ %
TValue
££& ,
item
££- 1
)
££1 2
{
§§  
AtomicSafetyHandle
¶¶ "
.
¶¶" #/
!CheckWriteAndBumpSecondaryVersion
¶¶# D
(
¶¶D E
m_Safety
¶¶E M
)
¶¶M N
;
¶¶N O
m_Writer
®® 
.
®® 
Add
®® 
(
®® 
key
®®  
,
®®  !
item
®®" &
)
®®& '
;
®®' (
}
©© 
}
™™ 	
public
±± 

Enumerator
±± 
GetValuesForKey
±± )
(
±±) *
TKey
±±* .
key
±±/ 2
)
±±2 3
{
≤≤ 	 
AtomicSafetyHandle
¥¥ 
.
¥¥ 
CheckReadAndThrow
¥¥ 0
(
¥¥0 1
m_Safety
¥¥1 9
)
¥¥9 :
;
¥¥: ;
return
∂∂ 
new
∂∂ 

Enumerator
∂∂ !
{
∂∂" #
hashmap
∂∂$ +
=
∂∂, -
this
∂∂. 2
,
∂∂2 3
key
∂∂4 7
=
∂∂8 9
key
∂∂: =
,
∂∂= >
isFirst
∂∂? F
=
∂∂G H
true
∂∂I M
}
∂∂N O
;
∂∂O P
}
∑∑ 	
public
¿¿ 
struct
¿¿ 

Enumerator
¿¿  
:
¿¿! "
IEnumerator
¿¿# .
<
¿¿. /
TValue
¿¿/ 5
>
¿¿5 6
{
¡¡ 	
internal
¬¬  
NativeMultiHashMap
¬¬ '
<
¬¬' (
TKey
¬¬( ,
,
¬¬, -
TValue
¬¬. 4
>
¬¬4 5
hashmap
¬¬6 =
;
¬¬= >
internal
√√ 
TKey
√√ 
key
√√ 
;
√√ 
internal
ƒƒ 
bool
ƒƒ 
isFirst
ƒƒ !
;
ƒƒ! "
TValue
∆∆ 
value
∆∆ 
;
∆∆ (
NativeMultiHashMapIterator
«« &
<
««& '
TKey
««' +
>
««+ ,
iterator
««- 5
;
««5 6
public
ÃÃ 
void
ÃÃ 
Dispose
ÃÃ 
(
ÃÃ  
)
ÃÃ  !
{
ÃÃ" #
}
ÃÃ$ %
public
““ 
bool
““ 
MoveNext
““  
(
““  !
)
““! "
{
”” 
if
’’ 
(
’’ 
isFirst
’’ 
)
’’ 
{
÷÷ 
isFirst
◊◊ 
=
◊◊ 
false
◊◊ #
;
◊◊# $
return
ÿÿ 
hashmap
ÿÿ "
.
ÿÿ" #
TryGetFirstValue
ÿÿ# 3
(
ÿÿ3 4
key
ÿÿ4 7
,
ÿÿ7 8
out
ÿÿ9 <
value
ÿÿ= B
,
ÿÿB C
out
ÿÿD G
iterator
ÿÿH P
)
ÿÿP Q
;
ÿÿQ R
}
ŸŸ 
return
€€ 
hashmap
€€ 
.
€€ 
TryGetNextValue
€€ .
(
€€. /
out
€€/ 2
value
€€3 8
,
€€8 9
ref
€€: =
iterator
€€> F
)
€€F G
;
€€G H
}
‹‹ 
public
·· 
void
·· 
Reset
·· 
(
·· 
)
·· 
=>
··  "
isFirst
··# *
=
··+ ,
true
··- 1
;
··1 2
public
ÁÁ 
TValue
ÁÁ 
Current
ÁÁ !
=>
ÁÁ" $
value
ÁÁ% *
;
ÁÁ* +
object
ÈÈ 
IEnumerator
ÈÈ 
.
ÈÈ 
Current
ÈÈ &
=>
ÈÈ' )
Current
ÈÈ* 1
;
ÈÈ1 2
public
ÔÔ 

Enumerator
ÔÔ 
GetEnumerator
ÔÔ +
(
ÔÔ+ ,
)
ÔÔ, -
{
ÔÔ. /
return
ÔÔ0 6
this
ÔÔ7 ;
;
ÔÔ; <
}
ÔÔ= >
}
 	
public
˜˜  
KeyValueEnumerator
˜˜ !
GetEnumerator
˜˜" /
(
˜˜/ 0
)
˜˜0 1
{
¯¯ 	 
AtomicSafetyHandle
˙˙ 
.
˙˙ 2
$CheckGetSecondaryDataPointerAndThrow
˙˙ C
(
˙˙C D
m_Safety
˙˙D L
)
˙˙L M
;
˙˙M N
var
˚˚ 
ash
˚˚ 
=
˚˚ 
m_Safety
˚˚ 
;
˚˚  
AtomicSafetyHandle
¸¸ 
.
¸¸ !
UseSecondaryVersion
¸¸ 2
(
¸¸2 3
ref
¸¸3 6
ash
¸¸7 :
)
¸¸: ;
;
¸¸; <
return
˛˛ 
new
˛˛  
KeyValueEnumerator
˛˛ )
{
ˇˇ 
m_Safety
ÅÅ 
=
ÅÅ 
ash
ÅÅ 
,
ÅÅ 
m_Enumerator
ÉÉ 
=
ÉÉ 
new
ÉÉ ")
UnsafeHashMapDataEnumerator
ÉÉ# >
(
ÉÉ> ? 
m_MultiHashMapData
ÉÉ? Q
.
ÉÉQ R
m_Buffer
ÉÉR Z
)
ÉÉZ [
,
ÉÉ[ \
}
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
IEnumerator
åå 
<
åå 
KeyValue
åå 
<
åå 
TKey
åå !
,
åå! "
TValue
åå# )
>
åå) *
>
åå* +
IEnumerable
åå, 7
<
åå7 8
KeyValue
åå8 @
<
åå@ A
TKey
ååA E
,
ååE F
TValue
ååG M
>
ååM N
>
ååN O
.
ååO P
GetEnumerator
ååP ]
(
åå] ^
)
åå^ _
{
çç 	
throw
éé 
new
éé %
NotImplementedException
éé -
(
éé- .
)
éé. /
;
éé/ 0
}
èè 	
IEnumerator
ññ 
IEnumerable
ññ 
.
ññ  
GetEnumerator
ññ  -
(
ññ- .
)
ññ. /
{
óó 	
throw
òò 
new
òò %
NotImplementedException
òò -
(
òò- .
)
òò. /
;
òò/ 0
}
ôô 	
[
££ 	
NativeContainer
££	 
]
££ 
[
§§ 	'
NativeContainerIsReadOnly
§§	 "
]
§§" #
public
•• 
struct
••  
KeyValueEnumerator
•• (
:
••) *
IEnumerator
••+ 6
<
••6 7
KeyValue
••7 ?
<
••? @
TKey
••@ D
,
••D E
TValue
••F L
>
••L M
>
••M N
{
¶¶ 	
internal
®®  
AtomicSafetyHandle
®® '
m_Safety
®®( 0
;
®®0 1
internal
™™ )
UnsafeHashMapDataEnumerator
™™ 0
m_Enumerator
™™1 =
;
™™= >
public
ØØ 
void
ØØ 
Dispose
ØØ 
(
ØØ  
)
ØØ  !
{
ØØ" #
}
ØØ$ %
public
µµ 
unsafe
µµ 
bool
µµ 
MoveNext
µµ '
(
µµ' (
)
µµ( )
{
∂∂  
AtomicSafetyHandle
∏∏ "
.
∏∏" #
CheckReadAndThrow
∏∏# 4
(
∏∏4 5
m_Safety
∏∏5 =
)
∏∏= >
;
∏∏> ?
return
∫∫ 
m_Enumerator
∫∫ #
.
∫∫# $
MoveNext
∫∫$ ,
(
∫∫, -
)
∫∫- .
;
∫∫. /
}
ªª 
public
¿¿ 
void
¿¿ 
Reset
¿¿ 
(
¿¿ 
)
¿¿ 
{
¡¡  
AtomicSafetyHandle
√√ "
.
√√" #
CheckReadAndThrow
√√# 4
(
√√4 5
m_Safety
√√5 =
)
√√= >
;
√√> ?
m_Enumerator
≈≈ 
.
≈≈ 
Reset
≈≈ "
(
≈≈" #
)
≈≈# $
;
≈≈$ %
}
∆∆ 
public
ÃÃ 
KeyValue
ÃÃ 
<
ÃÃ 
TKey
ÃÃ  
,
ÃÃ  !
TValue
ÃÃ" (
>
ÃÃ( )
Current
ÃÃ* 1
{
ÕÕ 
get
ŒŒ 
{
œœ  
AtomicSafetyHandle
—— &
.
——& '
CheckReadAndThrow
——' 8
(
——8 9
m_Safety
——9 A
)
——A B
;
——B C
return
”” 
m_Enumerator
”” '
.
””' (

GetCurrent
””( 2
<
””2 3
TKey
””3 7
,
””7 8
TValue
””9 ?
>
””? @
(
””@ A
)
””A B
;
””B C
}
‘‘ 
}
’’ 
object
◊◊ 
IEnumerator
◊◊ 
.
◊◊ 
Current
◊◊ &
=>
◊◊' )
Current
◊◊* 1
;
◊◊1 2
}
ÿÿ 	
[
⁄⁄ 	
Conditional
⁄⁄	 
(
⁄⁄ 
$str
⁄⁄ 6
)
⁄⁄6 7
]
⁄⁄7 8
void
€€ 
	CheckRead
€€ 
(
€€ 
)
€€ 
{
‹‹ 	 
AtomicSafetyHandle
ﬁﬁ 
.
ﬁﬁ 
CheckReadAndThrow
ﬁﬁ 0
(
ﬁﬁ0 1
m_Safety
ﬁﬁ1 9
)
ﬁﬁ9 :
;
ﬁﬁ: ;
}
‡‡ 	
[
‚‚ 	
Conditional
‚‚	 
(
‚‚ 
$str
‚‚ 6
)
‚‚6 7
]
‚‚7 8
void
„„ 

CheckWrite
„„ 
(
„„ 
)
„„ 
{
‰‰ 	 
AtomicSafetyHandle
ÊÊ 
.
ÊÊ /
!CheckWriteAndBumpSecondaryVersion
ÊÊ @
(
ÊÊ@ A
m_Safety
ÊÊA I
)
ÊÊI J
;
ÊÊJ K
}
ËË 	
}
ÈÈ 
internal
ÎÎ 
sealed
ÎÎ 
class
ÎÎ 1
#NativeMultiHashMapDebuggerTypeProxy
ÎÎ =
<
ÎÎ= >
TKey
ÎÎ> B
,
ÎÎB C
TValue
ÎÎD J
>
ÎÎJ K
where
ÏÏ 
TKey
ÏÏ 
:
ÏÏ 
struct
ÏÏ 
,
ÏÏ 

IEquatable
ÏÏ '
<
ÏÏ' (
TKey
ÏÏ( ,
>
ÏÏ, -
,
ÏÏ- .
IComparable
ÏÏ/ :
<
ÏÏ: ;
TKey
ÏÏ; ?
>
ÏÏ? @
where
ÌÌ 
TValue
ÌÌ 
:
ÌÌ 
struct
ÌÌ 
{
ÓÓ  
NativeMultiHashMap
 
<
 
TKey
 
,
  
TValue
! '
>
' (
m_Target
) 1
;
1 2
public
ÚÚ 1
#NativeMultiHashMapDebuggerTypeProxy
ÚÚ 2
(
ÚÚ2 3 
NativeMultiHashMap
ÚÚ3 E
<
ÚÚE F
TKey
ÚÚF J
,
ÚÚJ K
TValue
ÚÚL R
>
ÚÚR S
target
ÚÚT Z
)
ÚÚZ [
{
ÛÛ 	
m_Target
ÙÙ 
=
ÙÙ 
target
ÙÙ 
;
ÙÙ 
}
ıı 	
public
˜˜ 
List
˜˜ 
<
˜˜ 
ListPair
˜˜ 
<
˜˜ 
TKey
˜˜ !
,
˜˜! "
List
˜˜# '
<
˜˜' (
TValue
˜˜( .
>
˜˜. /
>
˜˜/ 0
>
˜˜0 1
Items
˜˜2 7
{
¯¯ 	
get
˘˘ 
{
˙˙ 
var
˚˚ 
result
˚˚ 
=
˚˚ 
new
˚˚  
List
˚˚! %
<
˚˚% &
ListPair
˚˚& .
<
˚˚. /
TKey
˚˚/ 3
,
˚˚3 4
List
˚˚5 9
<
˚˚9 :
TValue
˚˚: @
>
˚˚@ A
>
˚˚A B
>
˚˚B C
(
˚˚C D
)
˚˚D E
;
˚˚E F
var
¸¸ 
keys
¸¸ 
=
¸¸ 
m_Target
¸¸ #
.
¸¸# $
GetUniqueKeyArray
¸¸$ 5
(
¸¸5 6
	Allocator
¸¸6 ?
.
¸¸? @
Temp
¸¸@ D
)
¸¸D E
;
¸¸E F
using
˛˛ 
(
˛˛ 
keys
˛˛ 
.
˛˛ 
Item1
˛˛ !
)
˛˛! "
{
ˇˇ 
for
ÄÄ 
(
ÄÄ 
var
ÄÄ 
k
ÄÄ 
=
ÄÄ  
$num
ÄÄ! "
;
ÄÄ" #
k
ÄÄ$ %
<
ÄÄ& '
keys
ÄÄ( ,
.
ÄÄ, -
Item2
ÄÄ- 2
;
ÄÄ2 3
++
ÄÄ4 6
k
ÄÄ6 7
)
ÄÄ7 8
{
ÅÅ 
var
ÇÇ 
values
ÇÇ "
=
ÇÇ# $
new
ÇÇ% (
List
ÇÇ) -
<
ÇÇ- .
TValue
ÇÇ. 4
>
ÇÇ4 5
(
ÇÇ5 6
)
ÇÇ6 7
;
ÇÇ7 8
if
ÉÉ 
(
ÉÉ 
m_Target
ÉÉ $
.
ÉÉ$ %
TryGetFirstValue
ÉÉ% 5
(
ÉÉ5 6
keys
ÉÉ6 :
.
ÉÉ: ;
Item1
ÉÉ; @
[
ÉÉ@ A
k
ÉÉA B
]
ÉÉB C
,
ÉÉC D
out
ÉÉE H
var
ÉÉI L
value
ÉÉM R
,
ÉÉR S
out
ÉÉT W
var
ÉÉX [
iterator
ÉÉ\ d
)
ÉÉd e
)
ÉÉe f
{
ÑÑ 
do
ÖÖ 
{
ÜÜ 
values
áá  &
.
áá& '
Add
áá' *
(
áá* +
value
áá+ 0
)
áá0 1
;
áá1 2
}
àà 
while
ââ !
(
ââ" #
m_Target
ââ# +
.
ââ+ ,
TryGetNextValue
ââ, ;
(
ââ; <
out
ââ< ?
value
ââ@ E
,
ââE F
ref
ââG J
iterator
ââK S
)
ââS T
)
ââT U
;
ââU V
}
ää 
result
åå 
.
åå 
Add
åå "
(
åå" #
new
åå# &
ListPair
åå' /
<
åå/ 0
TKey
åå0 4
,
åå4 5
List
åå6 :
<
åå: ;
TValue
åå; A
>
ååA B
>
ååB C
(
ååC D
keys
ååD H
.
ååH I
Item1
ååI N
[
ååN O
k
ååO P
]
ååP Q
,
ååQ R
values
ååS Y
)
ååY Z
)
ååZ [
;
åå[ \
}
çç 
}
éé 
return
êê 
result
êê 
;
êê 
}
ëë 
}
íí 	
}
îî 
[
ññ 
BurstCompatible
ññ 
]
ññ 
public
óó 

unsafe
óó 
static
óó 
class
óó *
NativeMultiHashMapExtensions
óó ;
{
òò 
[
ôô 	
BurstCompatible
ôô	 
(
ôô "
GenericTypeArguments
ôô -
=
ôô. /
new
ôô0 3
[
ôô3 4
]
ôô4 5
{
ôô6 7
typeof
ôô8 >
(
ôô> ?
int
ôô? B
)
ôôB C
,
ôôC D
typeof
ôôE K
(
ôôK L
int
ôôL O
)
ôôO P
,
ôôP Q
typeof
ôôR X
(
ôôX Y
AllocatorManager
ôôY i
.
ôôi j
AllocatorHandle
ôôj y
)
ôôy z
}
ôô{ |
)
ôô| }
]
ôô} ~
internal
öö 
static
öö 
void
öö 

Initialize
öö '
<
öö' (
TKey
öö( ,
,
öö, -
TValue
öö. 4
,
öö4 5
U
öö6 7
>
öö7 8
(
öö8 9
ref
öö9 <
this
öö= A 
NativeMultiHashMap
ööB T
<
ööT U
TKey
ööU Y
,
ööY Z
TValue
öö[ a
>
ööa b 
nativeMultiHashMap
ööc u
,
ööu v
int
õõ< ?
capacity
õõ@ H
,
õõH I
ref
úú< ?
U
úú@ A
	allocator
úúB K
,
úúK L
int
ùù< ?'
disposeSentinelStackDepth
ùù@ Y
=
ùùZ [
$num
ùù\ ]
)
ùù] ^
where
ûû 
TKey
ûû 
:
ûû 
struct
ûû 
,
ûû  

IEquatable
ûû! +
<
ûû+ ,
TKey
ûû, 0
>
ûû0 1
where
üü 
TValue
üü 
:
üü 
struct
üü !
where
†† 
U
†† 
:
†† 
	unmanaged
†† 
,
††  
AllocatorManager
††! 1
.
††1 2

IAllocator
††2 <
{
°° 	 
nativeMultiHashMap
¢¢ 
.
¢¢  
m_MultiHashMapData
¢¢ 1
=
¢¢2 3
new
¢¢4 7 
UnsafeMultiHashMap
¢¢8 J
<
¢¢J K
TKey
¢¢K O
,
¢¢O P
TValue
¢¢Q W
>
¢¢W X
(
¢¢X Y
capacity
¢¢Y a
,
¢¢a b
	allocator
¢¢c l
.
¢¢l m
Handle
¢¢m s
)
¢¢s t
;
¢¢t u
if
®® 
(
®® 
	allocator
®® 
.
®® 
IsCustomAllocator
®® +
)
®®+ ,
{
©©  
nativeMultiHashMap
™™ "
.
™™" #
m_Safety
™™# +
=
™™, - 
AtomicSafetyHandle
™™. @
.
™™@ A
Create
™™A G
(
™™G H
)
™™H I
;
™™I J 
nativeMultiHashMap
´´ "
.
´´" #
m_DisposeSentinel
´´# 4
=
´´5 6
null
´´7 ;
;
´´; <
}
¨¨ 
else
≠≠ 
{
ÆÆ 
DisposeSentinel
ØØ 
.
ØØ  
Create
ØØ  &
(
ØØ& '
out
ØØ' * 
nativeMultiHashMap
ØØ+ =
.
ØØ= >
m_Safety
ØØ> F
,
ØØF G
out
∞∞( + 
nativeMultiHashMap
∞∞, >
.
∞∞> ?
m_DisposeSentinel
∞∞? P
,
∞∞P Q'
disposeSentinelStackDepth
±±( A
,
±±A B
	allocator
≤≤( 1
.
≤≤1 2
ToAllocator
≤≤2 =
)
≤≤= >
;
≤≤> ?
}
≥≥ 
CollectionHelper
∂∂ 
.
∂∂ 
SetStaticSafetyId
∂∂ .
<
∂∂. / 
NativeMultiHashMap
∂∂/ A
<
∂∂A B
TKey
∂∂B F
,
∂∂F G
TValue
∂∂H N
>
∂∂N O
>
∂∂O P
(
∂∂P Q
ref
∂∂Q T 
nativeMultiHashMap
∂∂U g
.
∂∂g h
m_Safety
∂∂h p
,
∂∂p q
ref
∂∂r u!
NativeMultiHashMap∂∂v à
<∂∂à â
TKey∂∂â ç
,∂∂ç é
TValue∂∂è ï
>∂∂ï ñ
.∂∂ñ ó 
s_staticSafetyId∂∂ó ß
.∂∂ß ®
Data∂∂® ¨
)∂∂¨ ≠
;∂∂≠ Æ
}
∏∏ 	
}
ππ 
}∫∫ é„
mC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\xxHash3.StreamingState.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[ 
BurstCompatible 
] 
public 

static 
partial 
class 
xxHash3  '
{ 
[ 	
BurstCompatible	 
] 
public 
struct 
StreamingState $
{ 	
public&& 
StreamingState&& !
(&&! "
bool&&" &
isHash64&&' /
,&&/ 0
ulong&&1 6
seed&&7 ;
=&&; <
$num&&< =
)&&= >
{'' 
State(( 
=(( 
default(( 
;((  
Reset)) 
()) 
isHash64)) 
,)) 
seed))  $
)))$ %
;))% &
}** 
public22 
unsafe22 
void22 
Reset22 $
(22$ %
bool22% )
isHash6422* 2
,222 3
ulong224 9
seed22: >
=22> ?
$num22? B
)22B C
{33 
var55 
size55 
=55 
UnsafeUtility55 (
.55( )
SizeOf55) /
<55/ 0
StreamingStateData550 B
>55B C
(55C D
)55D E
;55E F
UnsafeUtility66 
.66 
MemClear66 &
(66& '
UnsafeUtility66' 4
.664 5
	AddressOf665 >
(66> ?
ref66? B
State66C H
)66H I
,66I J
size66K O
)66O P
;66P Q
State99 
.99 
IsHash6499 
=99  
isHash6499! )
?99* +
$num99, -
:99. /
$num990 1
;991 2
var<< 
acc<< 
=<< 
Acc<< 
;<< 
acc== 
[== 
$num== 
]== 
=== 
	PRIME32_3== "
;==" #
acc>> 
[>> 
$num>> 
]>> 
=>> 
	PRIME64_1>> "
;>>" #
acc?? 
[?? 
$num?? 
]?? 
=?? 
	PRIME64_2?? "
;??" #
acc@@ 
[@@ 
$num@@ 
]@@ 
=@@ 
	PRIME64_3@@ "
;@@" #
accAA 
[AA 
$numAA 
]AA 
=AA 
	PRIME64_4AA "
;AA" #
accBB 
[BB 
$numBB 
]BB 
=BB 
	PRIME32_2BB "
;BB" #
accCC 
[CC 
$numCC 
]CC 
=CC 
	PRIME64_5CC "
;CC" #
accDD 
[DD 
$numDD 
]DD 
=DD 
	PRIME32_1DD "
;DD" #
StateFF 
.FF 
SeedFF 
=FF 
seedFF !
;FF! "
fixedHH 
(HH 
byteHH 
*HH 
secretHH #
=HH$ %
xxHashDefaultKeyHH& 6
.HH6 7
kSecretHH7 >
)HH> ?
{II 
ifJJ 
(JJ 
seedJJ 
!=JJ 
$numJJ  !
)JJ! "
{KK 
EncodeSecretKeyMM '
(MM' (
	SecretKeyMM( 1
,MM1 2
secretMM3 9
,MM9 :
seedMM; ?
)MM? @
;MM@ A
}NN 
elseOO 
{PP 
UnsafeUtilityRR %
.RR% &
MemCpyRR& ,
(RR, -
	SecretKeyRR- 6
,RR6 7
secretRR8 >
,RR> ?
SECRET_KEY_SIZERR@ O
)RRO P
;RRP Q
}SS 
}TT 
}UU 
public]] 
unsafe]] 
void]] 
Update]] %
(]]% &
void]]& *
*]]* +
input]], 1
,]]1 2
int]]3 6
length]]7 =
)]]= >
{^^ 
var__ 
bInput__ 
=__ 
(__ 
byte__ "
*__" #
)__# $
input__% *
;__* +
var`` 
bEnd`` 
=`` 
bInput`` !
+``" #
length``$ *
;``* +
varaa 
isHash64aa 
=aa 
Stateaa $
.aa$ %
IsHash64aa% -
;aa- .
varbb 
secretbb 
=bb 
	SecretKeybb &
;bb& '
Statecc 
.cc 
TotalLengthcc !
+=cc" $
lengthcc% +
;cc+ ,
ifee 
(ee 
Stateee 
.ee 
BufferedSizeee &
+ee' (
lengthee) /
<=ee0 2 
INTERNAL_BUFFER_SIZEee3 G
)eeG H
{ff 
UnsafeUtilitygg !
.gg! "
MemCpygg" (
(gg( )
Buffergg) /
+gg0 1
Stategg2 7
.gg7 8
BufferedSizegg8 D
,ggD E
bInputggF L
,ggL M
lengthggN T
)ggT U
;ggU V
Statehh 
.hh 
BufferedSizehh &
+=hh' )
lengthhh* 0
;hh0 1
returnii 
;ii 
}jj 
ifll 
(ll 
Statell 
.ll 
BufferedSizell &
!=ll' )
$numll* +
)ll+ ,
{mm 
varnn 
loadSizenn  
=nn! " 
INTERNAL_BUFFER_SIZEnn# 7
-nn8 9
Statenn: ?
.nn? @
BufferedSizenn@ L
;nnL M
UnsafeUtilityoo !
.oo! "
MemCpyoo" (
(oo( )
Bufferoo) /
+oo0 1
Stateoo2 7
.oo7 8
BufferedSizeoo8 D
,ooD E
bInputooF L
,ooL M
loadSizeooN V
)ooV W
;ooW X
bInputpp 
+=pp 
loadSizepp &
;pp& '
ConsumeStripesrr "
(rr" #
Accrr# &
,rr& '
refrr( +
Staterr, 1
.rr1 2
NbStripesSoFarrr2 @
,rr@ A
BufferrrB H
,rrH I#
INTERNAL_BUFFER_STRIPESrrJ a
,rra b
secretrrc i
,rri j
isHash64rrk s
)rrs t
;rrt u
Statett 
.tt 
BufferedSizett &
=tt' (
$numtt) *
;tt* +
}uu 
ifww 
(ww 
bInputww 
+ww  
INTERNAL_BUFFER_SIZEww 1
<ww2 3
bEndww4 8
)ww8 9
{xx 
varyy 
limityy 
=yy 
bEndyy  $
-yy% & 
INTERNAL_BUFFER_SIZEyy' ;
;yy; <
dozz 
{{{ 
ConsumeStripes|| &
(||& '
Acc||' *
,||* +
ref||, /
State||0 5
.||5 6
NbStripesSoFar||6 D
,||D E
bInput||F L
,||L M#
INTERNAL_BUFFER_STRIPES||N e
,||e f
secret||g m
,||m n
isHash64||o w
)||w x
;||x y
bInput}} 
+=}} ! 
INTERNAL_BUFFER_SIZE}}" 6
;}}6 7
}~~ 
while~~ 
(~~ 
bInput~~ #
<~~$ %
limit~~& +
)~~+ ,
;~~, -
UnsafeUtility !
.! "
MemCpy" (
(( )
Buffer) /
+0 1 
INTERNAL_BUFFER_SIZE2 F
-G H

STRIPE_LENI S
,S T
bInputU [
-\ ]

STRIPE_LEN^ h
,h i

STRIPE_LENj t
)t u
;u v
}
ÄÄ 
if
ÇÇ 
(
ÇÇ 
bInput
ÇÇ 
<
ÇÇ 
bEnd
ÇÇ !
)
ÇÇ! "
{
ÉÉ 
var
ÑÑ 
newBufferedSize
ÑÑ '
=
ÑÑ( )
bEnd
ÑÑ* .
-
ÑÑ/ 0
bInput
ÑÑ1 7
;
ÑÑ7 8
UnsafeUtility
ÖÖ !
.
ÖÖ! "
MemCpy
ÖÖ" (
(
ÖÖ( )
Buffer
ÖÖ) /
,
ÖÖ/ 0
bInput
ÖÖ1 7
,
ÖÖ7 8
newBufferedSize
ÖÖ9 H
)
ÖÖH I
;
ÖÖI J
State
ÜÜ 
.
ÜÜ 
BufferedSize
ÜÜ &
=
ÜÜ' (
(
ÜÜ) *
int
ÜÜ* -
)
ÜÜ- .
newBufferedSize
ÜÜ/ >
;
ÜÜ> ?
}
áá 
}
àà 
[
êê 
BurstCompatible
êê 
(
êê "
GenericTypeArguments
êê 1
=
êê2 3
new
êê4 7
[
êê8 9
]
êê9 :
{
êê; <
typeof
êê= C
(
êêC D
int
êêD G
)
êêG H
}
êêI J
)
êêJ K
]
êêK L
public
ëë 
unsafe
ëë 
void
ëë 
Update
ëë %
<
ëë% &
T
ëë& '
>
ëë' (
(
ëë( )
in
ëë) +
T
ëë, -
input
ëë. 3
)
ëë3 4
where
ëë5 :
T
ëë; <
:
ëë= >
	unmanaged
ëë? H
{
íí 
Update
ìì 
(
ìì %
UnsafeUtilityExtensions
ìì .
.
ìì. /
	AddressOf
ìì/ 8
(
ìì8 9
input
ìì9 >
)
ìì> ?
,
ìì? @
UnsafeUtility
ììA N
.
ììN O
SizeOf
ììO U
<
ììU V
T
ììV W
>
ììW X
(
ììX Y
)
ììY Z
)
ììZ [
;
ìì[ \
}
îî 
public
õõ 
unsafe
õõ 
uint4
õõ 
DigestHash128
õõ  -
(
õõ- .
)
õõ. /
{
úú 
CheckKeySize
ùù 
(
ùù 
$num
ùù 
)
ùù 
;
ùù  
	unchecked
üü 
{
†† 
var
°° 
secret
°° 
=
°°  
	SecretKey
°°! *
;
°°* +
uint4
¢¢ 
hash
¢¢ 
;
¢¢ 
if
££ 
(
££ 
State
££ 
.
££ 
TotalLength
££ )
>
££* +
MIDSIZE_MAX
££, 7
)
££7 8
{
§§ 
var
•• 
acc
•• 
=
••  !

stackalloc
••" ,
ulong
••- 2
[
••2 3
ACC_NB
••3 9
]
••9 :
;
••: ;

DigestLong
¶¶ "
(
¶¶" #
acc
¶¶# &
,
¶¶& '
secret
¶¶( .
,
¶¶. /
$num
¶¶0 1
)
¶¶1 2
;
¶¶2 3
var
®® 
low64
®® !
=
®®" #
MergeAcc
®®$ ,
(
®®, -
acc
®®- 0
,
®®0 1
secret
®®2 8
+
®®9 :$
SECRET_MERGEACCS_START
®®; Q
,
®®Q R
(
©© 
ulong
©© "
)
©©" #
State
©©$ )
.
©©) *
TotalLength
©©* 5
*
©©6 7
	PRIME64_1
©©8 A
)
©©A B
;
©©B C
var
™™ 
high64
™™ "
=
™™# $
MergeAcc
™™% -
(
™™- .
acc
™™. 1
,
™™1 2
secret
™™3 9
+
™™: ;
SECRET_LIMIT
™™< H
-
™™I J$
SECRET_MERGEACCS_START
™™K a
,
™™a b
~
´´ 
(
´´ 
(
´´ 
ulong
´´ $
)
´´$ %
State
´´& +
.
´´+ ,
TotalLength
´´, 7
*
´´8 9
	PRIME64_2
´´: C
)
´´C D
)
´´D E
;
´´E F
hash
¨¨ 
=
¨¨ 
ToUint4
¨¨ &
(
¨¨& '
low64
¨¨' ,
,
¨¨, -
high64
¨¨. 4
)
¨¨4 5
;
¨¨5 6
}
≠≠ 
else
ÆÆ 
{
ØØ 
hash
∞∞ 
=
∞∞ 
Hash128
∞∞ &
(
∞∞& '
Buffer
∞∞' -
,
∞∞- .
State
∞∞/ 4
.
∞∞4 5
TotalLength
∞∞5 @
,
∞∞@ A
State
∞∞B G
.
∞∞G H
Seed
∞∞H L
)
∞∞L M
;
∞∞M N
}
±± 
Reset
≤≤ 
(
≤≤ 
State
≤≤ 
.
≤≤  
IsHash64
≤≤  (
==
≤≤( *
$num
≤≤* +
,
≤≤+ ,
State
≤≤- 2
.
≤≤2 3
Seed
≤≤3 7
)
≤≤7 8
;
≤≤8 9
return
≥≥ 
hash
≥≥ 
;
≥≥  
}
¥¥ 
}
µµ 
public
ªª 
unsafe
ªª 
uint2
ªª 
DigestHash64
ªª  ,
(
ªª, -
)
ªª- .
{
ºº 
CheckKeySize
ΩΩ 
(
ΩΩ 
$num
ΩΩ 
)
ΩΩ 
;
ΩΩ  
	unchecked
øø 
{
¿¿ 
var
¡¡ 
secret
¡¡ 
=
¡¡  
	SecretKey
¡¡! *
;
¡¡* +
uint2
¬¬ 
hash
¬¬ 
;
¬¬ 
if
√√ 
(
√√ 
State
√√ 
.
√√ 
TotalLength
√√ )
>
√√* +
MIDSIZE_MAX
√√, 7
)
√√7 8
{
ƒƒ 
var
≈≈ 
acc
≈≈ 
=
≈≈  !

stackalloc
≈≈" ,
ulong
≈≈- 2
[
≈≈2 3
ACC_NB
≈≈3 9
]
≈≈9 :
;
≈≈: ;

DigestLong
∆∆ "
(
∆∆" #
acc
∆∆# &
,
∆∆& '
secret
∆∆( .
,
∆∆. /
$num
∆∆0 1
)
∆∆1 2
;
∆∆2 3
hash
»» 
=
»» 
ToUint2
»» &
(
»»& '
MergeAcc
»»' /
(
»»/ 0
acc
»»0 3
,
»»3 4
secret
»»5 ;
+
»»< =$
SECRET_MERGEACCS_START
»»> T
,
»»T U
(
»»V W
ulong
»»W \
)
»»\ ]
State
»»^ c
.
»»c d
TotalLength
»»d o
*
»»p q
	PRIME64_1
»»r {
)
»»{ |
)
»»| }
;
»»} ~
}
…… 
else
   
{
ÀÀ 
hash
ÃÃ 
=
ÃÃ 
Hash64
ÃÃ %
(
ÃÃ% &
Buffer
ÃÃ& ,
,
ÃÃ, -
State
ÃÃ. 3
.
ÃÃ3 4
TotalLength
ÃÃ4 ?
,
ÃÃ? @
State
ÃÃA F
.
ÃÃF G
Seed
ÃÃG K
)
ÃÃK L
;
ÃÃL M
}
ÕÕ 
Reset
ŒŒ 
(
ŒŒ 
State
ŒŒ 
.
ŒŒ  
IsHash64
ŒŒ  (
==
ŒŒ( *
$num
ŒŒ* +
,
ŒŒ+ ,
State
ŒŒ- 2
.
ŒŒ2 3
Seed
ŒŒ3 7
)
ŒŒ7 8
;
ŒŒ8 9
return
œœ 
hash
œœ 
;
œœ  
}
–– 
}
—— 
private
◊◊ 
static
◊◊ 
readonly
◊◊ #
int
◊◊$ '
SECRET_LIMIT
◊◊( 4
=
◊◊5 6
SECRET_KEY_SIZE
◊◊7 F
-
◊◊G H

STRIPE_LEN
◊◊I S
;
◊◊S T
private
ÿÿ 
static
ÿÿ 
readonly
ÿÿ #
int
ÿÿ$ '"
NB_STRIPES_PER_BLOCK
ÿÿ( <
=
ÿÿ= >
SECRET_LIMIT
ÿÿ? K
/
ÿÿL M!
SECRET_CONSUME_RATE
ÿÿN a
;
ÿÿa b
private
ŸŸ 
static
ŸŸ 
readonly
ŸŸ #
int
ŸŸ$ '"
INTERNAL_BUFFER_SIZE
ŸŸ( <
=
ŸŸ= >
$num
ŸŸ? B
;
ŸŸB C
private
⁄⁄ 
static
⁄⁄ 
readonly
⁄⁄ #
int
⁄⁄$ '%
INTERNAL_BUFFER_STRIPES
⁄⁄( ?
=
⁄⁄@ A"
INTERNAL_BUFFER_SIZE
⁄⁄B V
/
⁄⁄W X

STRIPE_LEN
⁄⁄Y c
;
⁄⁄c d
unsafe
‡‡ 
ulong
‡‡ 
*
‡‡ 
Acc
‡‡ 
{
·· 
[
‚‚ !
DebuggerStepThrough
‚‚ $
]
‚‚$ %
get
„„ 
=>
„„ 
(
„„ 
ulong
„„ 
*
„„ 
)
„„ 
UnsafeUtility
„„  -
.
„„- .
	AddressOf
„„. 7
(
„„7 8
ref
„„8 ;
State
„„< A
.
„„A B
Acc
„„B E
)
„„E F
;
„„F G
}
‰‰ 
unsafe
ÊÊ 
byte
ÊÊ 
*
ÊÊ 
Buffer
ÊÊ 
{
ÁÁ 
[
ËË !
DebuggerStepThrough
ËË $
]
ËË$ %
get
ÈÈ 
=>
ÈÈ 
(
ÈÈ 
byte
ÈÈ 
*
ÈÈ 
)
ÈÈ 
UnsafeUtility
ÈÈ ,
.
ÈÈ, -
	AddressOf
ÈÈ- 6
(
ÈÈ6 7
ref
ÈÈ7 :
State
ÈÈ; @
.
ÈÈ@ A
Buffer
ÈÈA G
)
ÈÈG H
;
ÈÈH I
}
ÍÍ 
unsafe
ÏÏ 
byte
ÏÏ 
*
ÏÏ 
	SecretKey
ÏÏ "
{
ÌÌ 
[
ÓÓ !
DebuggerStepThrough
ÓÓ $
]
ÓÓ$ %
get
ÔÔ 
=>
ÔÔ 
(
ÔÔ 
byte
ÔÔ 
*
ÔÔ 
)
ÔÔ 
UnsafeUtility
ÔÔ ,
.
ÔÔ, -
	AddressOf
ÔÔ- 6
(
ÔÔ6 7
ref
ÔÔ7 :
State
ÔÔ; @
.
ÔÔ@ A
	SecretKey
ÔÔA J
)
ÔÔJ K
;
ÔÔK L
}
 
private
ˆˆ  
StreamingStateData
ˆˆ &
State
ˆˆ' ,
;
ˆˆ, -
[
¯¯ 
StructLayout
¯¯ 
(
¯¯ 

LayoutKind
¯¯ $
.
¯¯$ %
Explicit
¯¯% -
)
¯¯- .
]
¯¯. /
struct
˘˘  
StreamingStateData
˘˘ %
{
˙˙ 
[
˚˚ 
FieldOffset
˚˚ 
(
˚˚ 
$num
˚˚ 
)
˚˚ 
]
˚˚  
public
˚˚! '
ulong
˚˚( -
Acc
˚˚. 1
;
˚˚1 2
[
¸¸ 
FieldOffset
¸¸ 
(
¸¸ 
$num
¸¸ 
)
¸¸  
]
¸¸  !
public
¸¸" (
byte
¸¸) -
Buffer
¸¸. 4
;
¸¸4 5
[
˝˝ 
FieldOffset
˝˝ 
(
˝˝ 
$num
˝˝  
)
˝˝  !
]
˝˝! "
public
˝˝# )
int
˝˝* -
IsHash64
˝˝. 6
;
˝˝6 7
[
˛˛ 
FieldOffset
˛˛ 
(
˛˛ 
$num
˛˛  
)
˛˛  !
]
˛˛! "
public
˛˛# )
int
˛˛* -
BufferedSize
˛˛. :
;
˛˛: ;
[
ˇˇ 
FieldOffset
ˇˇ 
(
ˇˇ 
$num
ˇˇ  
)
ˇˇ  !
]
ˇˇ! "
public
ˇˇ# )
int
ˇˇ* -
NbStripesSoFar
ˇˇ. <
;
ˇˇ< =
[
ÄÄ 
FieldOffset
ÄÄ 
(
ÄÄ 
$num
ÄÄ  
)
ÄÄ  !
]
ÄÄ! "
public
ÄÄ# )
long
ÄÄ* .
TotalLength
ÄÄ/ :
;
ÄÄ: ;
[
ÅÅ 
FieldOffset
ÅÅ 
(
ÅÅ 
$num
ÅÅ  
)
ÅÅ  !
]
ÅÅ! "
public
ÅÅ# )
ulong
ÅÅ* /
Seed
ÅÅ0 4
;
ÅÅ4 5
[
ÇÇ 
FieldOffset
ÇÇ 
(
ÇÇ 
$num
ÇÇ  
)
ÇÇ  !
]
ÇÇ! "
public
ÇÇ# )
byte
ÇÇ* .
	SecretKey
ÇÇ/ 8
;
ÇÇ8 9
[
ÉÉ 
FieldOffset
ÉÉ 
(
ÉÉ 
$num
ÉÉ  
)
ÉÉ  !
]
ÉÉ! "
public
ÉÉ# )
byte
ÉÉ* .
_PadEnd
ÉÉ/ 6
;
ÉÉ6 7
}
ÑÑ 
private
ää 
unsafe
ää 
void
ää 

DigestLong
ää  *
(
ää* +
ulong
ää+ 0
*
ää0 1
acc
ää2 5
,
ää5 6
byte
ää7 ;
*
ää; <
secret
ää= C
,
ääC D
int
ääE H
isHash64
ääI Q
)
ääQ R
{
ãã 
UnsafeUtility
åå 
.
åå 
MemCpy
åå $
(
åå$ %
acc
åå% (
,
åå( )
Acc
åå* -
,
åå- .

STRIPE_LEN
åå/ 9
)
åå9 :
;
åå: ;
if
çç 
(
çç 
State
çç 
.
çç 
BufferedSize
çç &
>=
çç' )

STRIPE_LEN
çç* 4
)
çç4 5
{
éé 
var
èè 
totalNbStripes
èè &
=
èè' (
(
èè) *
State
èè* /
.
èè/ 0
BufferedSize
èè0 <
-
èè= >
$num
èè? @
)
èè@ A
/
èèB C

STRIPE_LEN
èèD N
;
èèN O
ConsumeStripes
êê "
(
êê" #
acc
êê# &
,
êê& '
ref
êê( +
State
êê, 1
.
êê1 2
NbStripesSoFar
êê2 @
,
êê@ A
Buffer
êêB H
,
êêH I
totalNbStripes
êêJ X
,
êêX Y
secret
êêZ `
,
êê` a
isHash64
êêb j
)
êêj k
;
êêk l
if
ìì 
(
ìì 
X86
ìì 
.
ìì 
Avx2
ìì  
.
ìì  !
IsAvx2Supported
ìì! 0
)
ìì0 1
{
îî 
Avx2Accumulate512
ïï )
(
ïï) *
acc
ïï* -
,
ïï- .
Buffer
ïï/ 5
+
ïï6 7
State
ïï8 =
.
ïï= >
BufferedSize
ïï> J
-
ïïK L

STRIPE_LEN
ïïM W
,
ïïW X
null
ïïY ]
,
ïï] ^
secret
ññ "
+
ññ# $
SECRET_LIMIT
ññ% 1
-
ññ2 3"
SECRET_LASTACC_START
ññ4 H
)
ññH I
;
ññI J
}
óó 
else
òò 
{
öö "
DefaultAccumulate512
õõ ,
(
õõ, -
acc
õõ- 0
,
õõ0 1
Buffer
õõ2 8
+
õõ9 :
State
õõ; @
.
õõ@ A
BufferedSize
õõA M
-
õõN O

STRIPE_LEN
õõP Z
,
õõZ [
null
õõ\ `
,
õõ` a
secret
úú "
+
úú# $
SECRET_LIMIT
úú% 1
-
úú2 3"
SECRET_LASTACC_START
úú4 H
,
úúH I
isHash64
úúJ R
)
úúR S
;
úúS T
}
ùù 
}
ûû 
else
üü 
{
†† 
var
°° 

lastStripe
°° "
=
°°# $

stackalloc
°°% /
byte
°°0 4
[
°°4 5

STRIPE_LEN
°°5 ?
]
°°? @
;
°°@ A
var
¢¢ 
catchupSize
¢¢ #
=
¢¢$ %

STRIPE_LEN
¢¢& 0
-
¢¢1 2
State
¢¢3 8
.
¢¢8 9
BufferedSize
¢¢9 E
;
¢¢E F
UnsafeUtility
££ !
.
££! "
MemCpy
££" (
(
££( )

lastStripe
££) 3
,
££3 4
Buffer
££5 ;
+
££< ="
INTERNAL_BUFFER_SIZE
££> R
-
££S T
catchupSize
££U `
,
££` a
catchupSize
££b m
)
££m n
;
££n o
UnsafeUtility
§§ !
.
§§! "
MemCpy
§§" (
(
§§( )

lastStripe
§§) 3
+
§§4 5
catchupSize
§§6 A
,
§§A B
Buffer
§§C I
,
§§I J
State
§§K P
.
§§P Q
BufferedSize
§§Q ]
)
§§] ^
;
§§^ _
if
¶¶ 
(
¶¶ 
X86
¶¶ 
.
¶¶ 
Avx2
¶¶  
.
¶¶  !
IsAvx2Supported
¶¶! 0
)
¶¶0 1
{
ßß 
Avx2Accumulate512
®® )
(
®®) *
acc
®®* -
,
®®- .

lastStripe
®®/ 9
,
®®9 :
null
®®; ?
,
®®? @
secret
®®A G
+
®®G H
SECRET_LIMIT
®®H T
-
®®T U"
SECRET_LASTACC_START
®®U i
)
®®i j
;
®®j k
}
©© 
else
™™ 
{
¨¨ "
DefaultAccumulate512
≠≠ ,
(
≠≠, -
acc
≠≠- 0
,
≠≠0 1

lastStripe
≠≠2 <
,
≠≠< =
null
≠≠> B
,
≠≠B C
secret
≠≠D J
+
≠≠J K
SECRET_LIMIT
≠≠K W
-
≠≠W X"
SECRET_LASTACC_START
≠≠X l
,
≠≠l m
isHash64
≠≠n v
)
≠≠v w
;
≠≠w x
}
ÆÆ 
}
ØØ 
}
∞∞ 
private
≤≤ 
unsafe
≤≤ 
void
≤≤ 
ConsumeStripes
≤≤  .
(
≤≤. /
ulong
≤≤/ 4
*
≤≤4 5
acc
≤≤6 9
,
≤≤9 :
ref
≤≤; >
int
≤≤? B
nbStripesSoFar
≤≤C Q
,
≤≤Q R
byte
≤≤S W
*
≤≤W X
input
≤≤Y ^
,
≤≤^ _
long
≤≤` d
totalStripes
≤≤e q
,
≤≤q r
byte
≥≥ 
*
≥≥ 
secret
≥≥ 
,
≥≥ 
int
≥≥ !
isHash64
≥≥" *
)
≥≥* +
{
¥¥ 
if
µµ 
(
µµ "
NB_STRIPES_PER_BLOCK
µµ (
-
µµ) *
nbStripesSoFar
µµ+ 9
<=
µµ: <
totalStripes
µµ= I
)
µµI J
{
∂∂ 
var
∑∑ 
	nbStripes
∑∑ !
=
∑∑" #"
NB_STRIPES_PER_BLOCK
∑∑$ 8
-
∑∑9 :
nbStripesSoFar
∑∑; I
;
∑∑I J
if
ππ 
(
ππ 
X86
ππ 
.
ππ 
Avx2
ππ  
.
ππ  !
IsAvx2Supported
ππ! 0
)
ππ0 1
{
∫∫ 
Avx2Accumulate
ªª &
(
ªª& '
acc
ªª' *
,
ªª* +
input
ªª, 1
,
ªª1 2
null
ªª3 7
,
ªª7 8
secret
ªª9 ?
+
ªª@ A
nbStripesSoFar
ªªB P
*
ªªQ R!
SECRET_CONSUME_RATE
ªªS f
,
ªªf g
	nbStripes
ªªh q
,
ªªq r
isHash64
ªªs {
)
ªª{ |
;
ªª| }
Avx2ScrambleAcc
ºº '
(
ºº' (
acc
ºº( +
,
ºº+ ,
secret
ºº- 3
+
ºº4 5
SECRET_LIMIT
ºº6 B
)
ººB C
;
ººC D
Avx2Accumulate
ΩΩ &
(
ΩΩ& '
acc
ΩΩ' *
,
ΩΩ* +
input
ΩΩ, 1
+
ΩΩ2 3
	nbStripes
ΩΩ4 =
*
ΩΩ> ?

STRIPE_LEN
ΩΩ@ J
,
ΩΩJ K
null
ΩΩL P
,
ΩΩP Q
secret
ΩΩR X
,
ΩΩX Y
totalStripes
ΩΩZ f
-
ΩΩg h
	nbStripes
ΩΩi r
,
ΩΩr s
isHash64
ΩΩt |
)
ΩΩ| }
;
ΩΩ} ~
}
ææ 
else
øø 
{
¡¡ 
DefaultAccumulate
¬¬ )
(
¬¬) *
acc
¬¬* -
,
¬¬- .
input
¬¬/ 4
,
¬¬4 5
null
¬¬6 :
,
¬¬: ;
secret
¬¬< B
+
¬¬C D
nbStripesSoFar
¬¬E S
*
¬¬T U!
SECRET_CONSUME_RATE
¬¬V i
,
¬¬i j
	nbStripes
¬¬k t
,
¬¬t u
isHash64
¬¬v ~
)
¬¬~ 
;¬¬ Ä 
DefaultScrambleAcc
√√ *
(
√√* +
acc
√√+ .
,
√√. /
secret
√√0 6
+
√√7 8
SECRET_LIMIT
√√9 E
)
√√E F
;
√√F G
DefaultAccumulate
ƒƒ )
(
ƒƒ) *
acc
ƒƒ* -
,
ƒƒ- .
input
ƒƒ/ 4
+
ƒƒ5 6
	nbStripes
ƒƒ7 @
*
ƒƒA B

STRIPE_LEN
ƒƒC M
,
ƒƒM N
null
ƒƒO S
,
ƒƒS T
secret
ƒƒU [
,
ƒƒ[ \
totalStripes
ƒƒ] i
-
ƒƒj k
	nbStripes
ƒƒl u
,
ƒƒu v
isHash64
ƒƒw 
)ƒƒ Ä
;ƒƒÄ Å
}
≈≈ 
nbStripesSoFar
«« "
=
««# $
(
««% &
int
««& )
)
««) *
totalStripes
««+ 7
-
««8 9
	nbStripes
««: C
;
««C D
}
»» 
else
…… 
{
   
if
ÃÃ 
(
ÃÃ 
X86
ÃÃ 
.
ÃÃ 
Avx2
ÃÃ  
.
ÃÃ  !
IsAvx2Supported
ÃÃ! 0
)
ÃÃ0 1
{
ÕÕ 
Avx2Accumulate
ŒŒ &
(
ŒŒ& '
acc
ŒŒ' *
,
ŒŒ* +
input
ŒŒ, 1
,
ŒŒ1 2
null
ŒŒ3 7
,
ŒŒ7 8
secret
ŒŒ9 ?
+
ŒŒ@ A
nbStripesSoFar
ŒŒB P
*
ŒŒQ R!
SECRET_CONSUME_RATE
ŒŒS f
,
ŒŒf g
totalStripes
ŒŒh t
,
ŒŒt u
isHash64
ŒŒv ~
)
ŒŒ~ 
;ŒŒ Ä
}
œœ 
else
–– 
{
““ 
DefaultAccumulate
”” )
(
””) *
acc
””* -
,
””- .
input
””/ 4
,
””4 5
null
””6 :
,
””: ;
secret
””< B
+
””C D
nbStripesSoFar
””E S
*
””T U!
SECRET_CONSUME_RATE
””V i
,
””i j
totalStripes
””k w
,
””w x
isHash64””y Å
)””Å Ç
;””Ç É
}
‘‘ 
nbStripesSoFar
÷÷ "
+=
÷÷# %
(
÷÷& '
int
÷÷' *
)
÷÷* +
totalStripes
÷÷, 8
;
÷÷8 9
}
◊◊ 
}
ÿÿ 
[
⁄⁄ 
Conditional
⁄⁄ 
(
⁄⁄ 
$str
⁄⁄ :
)
⁄⁄: ;
]
⁄⁄; <
[
€€ 
BurstDiscard
€€ 
]
€€ 
void
‹‹ 
CheckKeySize
‹‹ 
(
‹‹ 
int
‹‹ !
isHash64
‹‹" *
)
‹‹* +
{
›› 
if
ﬁﬁ 
(
ﬁﬁ 
State
ﬁﬁ 
.
ﬁﬁ 
IsHash64
ﬁﬁ "
!=
ﬁﬁ# %
isHash64
ﬁﬁ& .
)
ﬁﬁ. /
{
ﬂﬂ 
var
‡‡ 
s
‡‡ 
=
‡‡ 
State
‡‡ !
.
‡‡! "
IsHash64
‡‡" *
!=
‡‡+ -
$num
‡‡. /
?
‡‡0 1
$str
‡‡2 6
:
‡‡7 8
$str
‡‡9 >
;
‡‡> ?
throw
·· 
new
·· '
InvalidOperationException
·· 7
(
··7 8
$"
‚‚ 
$str
‚‚ =
{
‚‚= >
s
‚‚> ?
}
‚‚? @
$str‚‚@ †
"‚‚† °
)‚‚° ¢
;‚‚¢ £
}
„„ 
}
‰‰ 
}
ÁÁ 	
}
ËË 
}ÈÈ Ü©
eC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeBitArray.cs
	namespace 	
Unity
 
. 
Collections 
{		 
[ 
StructLayout 
( 

LayoutKind 
. 

Sequential '
)' (
]( )
[ 
NativeContainer 
] 
[ 
DebuggerDisplay 
( 
$str A
)A B
]B C
[ 
BurstCompatible 
] 
public 

unsafe 
struct 
NativeBitArray '
: 	
INativeDisposable
 
{ 
internal 
AtomicSafetyHandle #
m_Safety$ ,
;, -
static 
readonly 
SharedStatic $
<$ %
int% (
>( )
s_staticSafetyId* :
=; <
SharedStatic= I
<I J
intJ M
>M N
.N O
GetOrCreateO Z
<Z [
NativeBitArray[ i
>i j
(j k
)k l
;l m
[ 	.
"NativeSetClassTypeToNullOnSchedule	 +
]+ ,
DisposeSentinel 
m_DisposeSentinel )
;) *
["" 	-
!NativeDisableUnsafePtrRestriction""	 *
]""* +
internal## 
UnsafeBitArray## 

m_BitArray##  *
;##* +
public++ 
NativeBitArray++ 
(++ 
int++ !
numBits++" )
,++) *
AllocatorManager+++ ;
.++; <
AllocatorHandle++< K
	allocator++L U
,++U V
NativeArrayOptions++W i
options++j q
=++r s
NativeArrayOptions	++t Ü
.
++Ü á
ClearMemory
++á í
)
++í ì
:,, 
this,, 
(,, 
numBits,, 
,,, 
	allocator,, %
,,,% &
options,,' .
,,,. /
$num,,0 1
),,1 2
{-- 	
}.. 	
NativeBitArray00 
(00 
int00 
numBits00 "
,00" #
AllocatorManager00$ 4
.004 5
AllocatorHandle005 D
	allocator00E N
,00N O
NativeArrayOptions00P b
options00c j
,00j k
int00l o&
disposeSentinelStackDepth	00p â
)
00â ä
{11 	
CollectionHelper22 
.22 
CheckAllocator22 +
(22+ ,
	allocator22, 5
)225 6
;226 7
if77 
(77 
	allocator77 
.77 
IsCustomAllocator77 +
)77+ ,
{88 
m_Safety99 
=99 
AtomicSafetyHandle99 -
.99- .
Create99. 4
(994 5
)995 6
;996 7
m_DisposeSentinel:: !
=::" #
null::$ (
;::( )
};; 
else<< 
{== 
DisposeSentinel>> 
.>>  
Create>>  &
(>>& '
out>>' *
m_Safety>>+ 3
,>>3 4
out>>5 8
m_DisposeSentinel>>9 J
,>>J K%
disposeSentinelStackDepth>>L e
,>>e f
	allocator>>g p
.>>p q
ToAllocator>>q |
)>>| }
;>>} ~
}?? 
CollectionHelperBB 
.BB 
SetStaticSafetyIdBB .
(BB. /
refBB/ 2
m_SafetyBB3 ;
,BB; <
refBB= @
s_staticSafetyIdBBA Q
.BBQ R
DataBBR V
,BBV W
$strBBX z
)BBz {
;BB{ |

m_BitArrayDD 
=DD 
newDD 
UnsafeBitArrayDD +
(DD+ ,
numBitsDD, 3
,DD3 4
	allocatorDD5 >
,DD> ?
optionsDD@ G
)DDG H
;DDH I
}EE 	
publicKK 
boolKK 
	IsCreatedKK 
=>KK  

m_BitArrayKK! +
.KK+ ,
	IsCreatedKK, 5
;KK5 6
publicPP 
voidPP 
DisposePP 
(PP 
)PP 
{QQ 	
DisposeSentinelVV 
.VV 
DisposeVV #
(VV# $
refVV$ '
m_SafetyVV( 0
,VV0 1
refVV2 5
m_DisposeSentinelVV6 G
)VVG H
;VVH I

m_BitArrayZZ 
.ZZ 
DisposeZZ 
(ZZ 
)ZZ  
;ZZ  !
}[[ 	
[bb 	
NotBurstCompatiblebb	 
]
bbú ù
publiccc 
	JobHandlecc 
Disposecc  
(cc  !
	JobHandlecc! *
	inputDepscc+ 4
)cc4 5
{dd 	
DisposeSentinelll 
.ll 
Clearll !
(ll! "
refll" %
m_DisposeSentinelll& 7
)ll7 8
;ll8 9
varoo 
	jobHandleoo 
=oo 

m_BitArrayoo &
.oo& '
Disposeoo' .
(oo. /
	inputDepsoo/ 8
)oo8 9
;oo9 :
AtomicSafetyHandlerr 
.rr 
Releaserr &
(rr& '
m_Safetyrr' /
)rr/ 0
;rr0 1
returnuu 
	jobHandleuu 
;uu 
}vv 	
public|| 
int|| 
Length|| 
{}} 	
get~~ 
{ 
	CheckRead
ÄÄ 
(
ÄÄ 
)
ÄÄ 
;
ÄÄ 
return
ÅÅ 
CollectionHelper
ÅÅ '
.
ÅÅ' (
AssumePositive
ÅÅ( 6
(
ÅÅ6 7

m_BitArray
ÅÅ7 A
.
ÅÅA B
Length
ÅÅB H
)
ÅÅH I
;
ÅÅI J
}
ÇÇ 
}
ÉÉ 	
public
àà 
void
àà 
Clear
àà 
(
àà 
)
àà 
{
ââ 	

CheckWrite
ää 
(
ää 
)
ää 
;
ää 

m_BitArray
ãã 
.
ãã 
Clear
ãã 
(
ãã 
)
ãã 
;
ãã 
}
åå 	
[
ïï 	
BurstCompatible
ïï	 
(
ïï "
GenericTypeArguments
ïï -
=
ïï. /
new
ïï0 3
[
ïï4 5
]
ïï5 6
{
ïï7 8
typeof
ïï9 ?
(
ïï? @
int
ïï@ C
)
ïïC D
}
ïïE F
)
ïïF G
]
ïïG H
public
ññ 
NativeArray
ññ 
<
ññ 
T
ññ 
>
ññ 
AsNativeArray
ññ +
<
ññ+ ,
T
ññ, -
>
ññ- .
(
ññ. /
)
ññ/ 0
where
ññ1 6
T
ññ7 8
:
ññ9 :
	unmanaged
ññ; D
{
óó 	
CheckReadBounds
òò 
<
òò 
T
òò 
>
òò 
(
òò 
)
òò  
;
òò  !
var
öö 
bitsPerElement
öö 
=
öö  
UnsafeUtility
öö! .
.
öö. /
SizeOf
öö/ 5
<
öö5 6
T
öö6 7
>
öö7 8
(
öö8 9
)
öö9 :
*
öö; <
$num
öö= >
;
öö> ?
var
õõ 
length
õõ 
=
õõ 

m_BitArray
õõ #
.
õõ# $
Length
õõ$ *
/
õõ+ ,
bitsPerElement
õõ- ;
;
õõ; <
var
ùù 
array
ùù 
=
ùù &
NativeArrayUnsafeUtility
ùù 0
.
ùù0 1.
 ConvertExistingDataToNativeArray
ùù1 Q
<
ùùQ R
T
ùùR S
>
ùùS T
(
ùùT U

m_BitArray
ùùU _
.
ùù_ `
Ptr
ùù` c
,
ùùc d
length
ùùe k
,
ùùk l
	Allocator
ùùm v
.
ùùv w
None
ùùw {
)
ùù{ |
;
ùù| } 
AtomicSafetyHandle
üü 
.
üü !
UseSecondaryVersion
üü 2
(
üü2 3
ref
üü3 6
m_Safety
üü7 ?
)
üü? @
;
üü@ A&
NativeArrayUnsafeUtility
†† $
.
††$ %#
SetAtomicSafetyHandle
††% :
(
††: ;
ref
††; >
array
††? D
,
††D E
m_Safety
††F N
)
††N O
;
††O P
return
¢¢ 
array
¢¢ 
;
¢¢ 
}
££ 	
public
™™ 
void
™™ 
Set
™™ 
(
™™ 
int
™™ 
pos
™™ 
,
™™  
bool
™™! %
value
™™& +
)
™™+ ,
{
´´ 	

CheckWrite
¨¨ 
(
¨¨ 
)
¨¨ 
;
¨¨ 

m_BitArray
≠≠ 
.
≠≠ 
Set
≠≠ 
(
≠≠ 
pos
≠≠ 
,
≠≠ 
value
≠≠  %
)
≠≠% &
;
≠≠& '
}
ÆÆ 	
public
ªª 
void
ªª 
SetBits
ªª 
(
ªª 
int
ªª 
pos
ªª  #
,
ªª# $
bool
ªª% )
value
ªª* /
,
ªª/ 0
int
ªª1 4
numBits
ªª5 <
)
ªª< =
{
ºº 	

CheckWrite
ΩΩ 
(
ΩΩ 
)
ΩΩ 
;
ΩΩ 

m_BitArray
ææ 
.
ææ 
SetBits
ææ 
(
ææ 
pos
ææ "
,
ææ" #
value
ææ$ )
,
ææ) *
numBits
ææ+ 2
)
ææ2 3
;
ææ3 4
}
øø 	
public
œœ 
void
œœ 
SetBits
œœ 
(
œœ 
int
œœ 
pos
œœ  #
,
œœ# $
ulong
œœ% *
value
œœ+ 0
,
œœ0 1
int
œœ2 5
numBits
œœ6 =
=
œœ> ?
$num
œœ@ A
)
œœA B
{
–– 	

CheckWrite
—— 
(
—— 
)
—— 
;
—— 

m_BitArray
““ 
.
““ 
SetBits
““ 
(
““ 
pos
““ "
,
““" #
value
““$ )
,
““) *
numBits
““+ 2
)
““2 3
;
““3 4
}
”” 	
public
‚‚ 
ulong
‚‚ 
GetBits
‚‚ 
(
‚‚ 
int
‚‚  
pos
‚‚! $
,
‚‚$ %
int
‚‚& )
numBits
‚‚* 1
=
‚‚2 3
$num
‚‚4 5
)
‚‚5 6
{
„„ 	
	CheckRead
‰‰ 
(
‰‰ 
)
‰‰ 
;
‰‰ 
return
ÂÂ 

m_BitArray
ÂÂ 
.
ÂÂ 
GetBits
ÂÂ %
(
ÂÂ% &
pos
ÂÂ& )
,
ÂÂ) *
numBits
ÂÂ+ 2
)
ÂÂ2 3
;
ÂÂ3 4
}
ÊÊ 	
public
ÓÓ 
bool
ÓÓ 
IsSet
ÓÓ 
(
ÓÓ 
int
ÓÓ 
pos
ÓÓ !
)
ÓÓ! "
{
ÔÔ 	
	CheckRead
 
(
 
)
 
;
 
return
ÒÒ 

m_BitArray
ÒÒ 
.
ÒÒ 
IsSet
ÒÒ #
(
ÒÒ# $
pos
ÒÒ$ '
)
ÒÒ' (
;
ÒÒ( )
}
ÚÚ 	
public
ÅÅ 
void
ÅÅ 
Copy
ÅÅ 
(
ÅÅ 
int
ÅÅ 
dstPos
ÅÅ #
,
ÅÅ# $
int
ÅÅ% (
srcPos
ÅÅ) /
,
ÅÅ/ 0
int
ÅÅ1 4
numBits
ÅÅ5 <
)
ÅÅ< =
{
ÇÇ 	

CheckWrite
ÉÉ 
(
ÉÉ 
)
ÉÉ 
;
ÉÉ 

m_BitArray
ÑÑ 
.
ÑÑ 
Copy
ÑÑ 
(
ÑÑ 
dstPos
ÑÑ "
,
ÑÑ" #
srcPos
ÑÑ$ *
,
ÑÑ* +
numBits
ÑÑ, 3
)
ÑÑ3 4
;
ÑÑ4 5
}
ÖÖ 	
public
ïï 
void
ïï 
Copy
ïï 
(
ïï 
int
ïï 
dstPos
ïï #
,
ïï# $
ref
ïï% (
NativeBitArray
ïï) 7
srcBitArray
ïï8 C
,
ïïC D
int
ïïE H
srcPos
ïïI O
,
ïïO P
int
ïïQ T
numBits
ïïU \
)
ïï\ ]
{
ññ 	 
AtomicSafetyHandle
òò 
.
òò 
CheckReadAndThrow
òò 0
(
òò0 1
srcBitArray
òò1 <
.
òò< =
m_Safety
òò= E
)
òòE F
;
òòF G

CheckWrite
öö 
(
öö 
)
öö 
;
öö 

m_BitArray
õõ 
.
õõ 
Copy
õõ 
(
õõ 
dstPos
õõ "
,
õõ" #
ref
õõ$ '
srcBitArray
õõ( 3
.
õõ3 4

m_BitArray
õõ4 >
,
õõ> ?
srcPos
õõ@ F
,
õõF G
numBits
õõH O
)
õõO P
;
õõP Q
}
úú 	
public
•• 
int
•• 
Find
•• 
(
•• 
int
•• 
pos
•• 
,
••  
int
••! $
numBits
••% ,
)
••, -
{
¶¶ 	
	CheckRead
ßß 
(
ßß 
)
ßß 
;
ßß 
return
®® 

m_BitArray
®® 
.
®® 
Find
®® "
(
®®" #
pos
®®# &
,
®®& '
numBits
®®( /
)
®®/ 0
;
®®0 1
}
©© 	
public
≥≥ 
int
≥≥ 
Find
≥≥ 
(
≥≥ 
int
≥≥ 
pos
≥≥ 
,
≥≥  
int
≥≥! $
count
≥≥% *
,
≥≥* +
int
≥≥, /
numBits
≥≥0 7
)
≥≥7 8
{
¥¥ 	
	CheckRead
µµ 
(
µµ 
)
µµ 
;
µµ 
return
∂∂ 

m_BitArray
∂∂ 
.
∂∂ 
Find
∂∂ "
(
∂∂" #
pos
∂∂# &
,
∂∂& '
count
∂∂( -
,
∂∂- .
numBits
∂∂/ 6
)
∂∂6 7
;
∂∂7 8
}
∑∑ 	
public
¿¿ 
bool
¿¿ 
TestNone
¿¿ 
(
¿¿ 
int
¿¿  
pos
¿¿! $
,
¿¿$ %
int
¿¿& )
numBits
¿¿* 1
=
¿¿2 3
$num
¿¿4 5
)
¿¿5 6
{
¡¡ 	
	CheckRead
¬¬ 
(
¬¬ 
)
¬¬ 
;
¬¬ 
return
√√ 

m_BitArray
√√ 
.
√√ 
TestNone
√√ &
(
√√& '
pos
√√' *
,
√√* +
numBits
√√, 3
)
√√3 4
;
√√4 5
}
ƒƒ 	
public
ÕÕ 
bool
ÕÕ 
TestAny
ÕÕ 
(
ÕÕ 
int
ÕÕ 
pos
ÕÕ  #
,
ÕÕ# $
int
ÕÕ% (
numBits
ÕÕ) 0
=
ÕÕ1 2
$num
ÕÕ3 4
)
ÕÕ4 5
{
ŒŒ 	
	CheckRead
œœ 
(
œœ 
)
œœ 
;
œœ 
return
–– 

m_BitArray
–– 
.
–– 
TestAny
–– %
(
––% &
pos
––& )
,
––) *
numBits
––+ 2
)
––2 3
;
––3 4
}
—— 	
public
⁄⁄ 
bool
⁄⁄ 
TestAll
⁄⁄ 
(
⁄⁄ 
int
⁄⁄ 
pos
⁄⁄  #
,
⁄⁄# $
int
⁄⁄% (
numBits
⁄⁄) 0
=
⁄⁄1 2
$num
⁄⁄3 4
)
⁄⁄4 5
{
€€ 	
	CheckRead
‹‹ 
(
‹‹ 
)
‹‹ 
;
‹‹ 
return
›› 

m_BitArray
›› 
.
›› 
TestAll
›› %
(
››% &
pos
››& )
,
››) *
numBits
››+ 2
)
››2 3
;
››3 4
}
ﬁﬁ 	
public
ÁÁ 
int
ÁÁ 
	CountBits
ÁÁ 
(
ÁÁ 
int
ÁÁ  
pos
ÁÁ! $
,
ÁÁ$ %
int
ÁÁ& )
numBits
ÁÁ* 1
=
ÁÁ2 3
$num
ÁÁ4 5
)
ÁÁ5 6
{
ËË 	
	CheckRead
ÈÈ 
(
ÈÈ 
)
ÈÈ 
;
ÈÈ 
return
ÍÍ 

m_BitArray
ÍÍ 
.
ÍÍ 
	CountBits
ÍÍ '
(
ÍÍ' (
pos
ÍÍ( +
,
ÍÍ+ ,
numBits
ÍÍ- 4
)
ÍÍ4 5
;
ÍÍ5 6
}
ÎÎ 	
[
ÌÌ 	
Conditional
ÌÌ	 
(
ÌÌ 
$str
ÌÌ 6
)
ÌÌ6 7
]
ÌÌ7 8
void
ÓÓ 
	CheckRead
ÓÓ 
(
ÓÓ 
)
ÓÓ 
{
ÔÔ 	 
AtomicSafetyHandle
ÒÒ 
.
ÒÒ 
CheckReadAndThrow
ÒÒ 0
(
ÒÒ0 1
m_Safety
ÒÒ1 9
)
ÒÒ9 :
;
ÒÒ: ;
}
ÛÛ 	
[
ıı 	
Conditional
ıı	 
(
ıı 
$str
ıı 6
)
ıı6 7
]
ıı7 8
void
ˆˆ 
CheckReadBounds
ˆˆ 
<
ˆˆ 
T
ˆˆ 
>
ˆˆ 
(
ˆˆ  
)
ˆˆ  !
where
ˆˆ" '
T
ˆˆ( )
:
ˆˆ* +
	unmanaged
ˆˆ, 5
{
˜˜ 	
	CheckRead
¯¯ 
(
¯¯ 
)
¯¯ 
;
¯¯ 
var
˙˙ 
bitsPerElement
˙˙ 
=
˙˙  
UnsafeUtility
˙˙! .
.
˙˙. /
SizeOf
˙˙/ 5
<
˙˙5 6
T
˙˙6 7
>
˙˙7 8
(
˙˙8 9
)
˙˙9 :
*
˙˙; <
$num
˙˙= >
;
˙˙> ?
var
˚˚ 
length
˚˚ 
=
˚˚ 

m_BitArray
˚˚ #
.
˚˚# $
Length
˚˚$ *
/
˚˚+ ,
bitsPerElement
˚˚- ;
;
˚˚; <
if
˝˝ 
(
˝˝ 
length
˝˝ 
==
˝˝ 
$num
˝˝ 
)
˝˝ 
{
˛˛ 
throw
ˇˇ 
new
ˇˇ '
InvalidOperationException
ˇˇ 3
(
ˇˇ3 4
$"
ˇˇ4 6
$str
ˇˇ6 [
{
ˇˇ[ \

m_BitArray
ˇˇ\ f
.
ˇˇf g
Length
ˇˇg m
}
ˇˇm n
$strˇˇn õ
{ˇˇõ ú
UnsafeUtilityˇˇú ©
.ˇˇ© ™
SizeOfˇˇ™ ∞
<ˇˇ∞ ±
Tˇˇ± ≤
>ˇˇ≤ ≥
(ˇˇ≥ ¥
)ˇˇ¥ µ
*ˇˇ∂ ∑
$numˇˇ∏ π
}ˇˇπ ∫
$strˇˇ∫ ª
"ˇˇª º
)ˇˇº Ω
;ˇˇΩ æ
}
ÄÄ 
else
ÅÅ 
if
ÅÅ 
(
ÅÅ 

m_BitArray
ÅÅ 
.
ÅÅ  
Length
ÅÅ  &
!=
ÅÅ' )
bitsPerElement
ÅÅ* 8
*
ÅÅ8 9
length
ÅÅ: @
)
ÅÅ@ A
{
ÇÇ 
throw
ÉÉ 
new
ÉÉ '
InvalidOperationException
ÉÉ 3
(
ÉÉ3 4
$"
ÉÉ4 6
$str
ÉÉ6 [
{
ÉÉ[ \

m_BitArray
ÉÉ\ f
.
ÉÉf g
Length
ÉÉg m
}
ÉÉm n
$strÉÉn ã
{ÉÉã å
UnsafeUtilityÉÉå ô
.ÉÉô ö
SizeOfÉÉö †
<ÉÉ† °
TÉÉ° ¢
>ÉÉ¢ £
(ÉÉ£ §
)ÉÉ§ •
}ÉÉ• ¶
$strÉÉ¶ »
"ÉÉ» …
)ÉÉ…  
;ÉÉ  À
}
ÑÑ 
}
ÖÖ 	
[
áá 	
Conditional
áá	 
(
áá 
$str
áá 6
)
áá6 7
]
áá7 8
void
àà 

CheckWrite
àà 
(
àà 
)
àà 
{
ââ 	 
AtomicSafetyHandle
ãã 
.
ãã  
CheckWriteAndThrow
ãã 1
(
ãã1 2
m_Safety
ãã2 :
)
ãã: ;
;
ãã; <
}
çç 	
}
éé 
}èè 
	namespaceëë 	
Unity
ëë
 
.
ëë 
Collections
ëë 
.
ëë 
LowLevel
ëë $
.
ëë$ %
Unsafe
ëë% +
{íí 
[
ññ 
BurstCompatible
ññ 
]
ññ 
public
óó 

static
óó 
class
óó )
NativeBitArrayUnsafeUtility
óó 3
{
òò 
[
üü 	
BurstCompatible
üü	 
(
üü !
RequiredUnityDefine
üü ,
=
üü- .
$str
üü/ P
,
üüP Q
CompileTarget
üüR _
=
üü` a&
BurstCompatibleAttribute
üüb z
.
üüz {+
BurstCompatibleCompileTargetüü{ ó
.üüó ò
Editorüüò û
)üüû ü
]üüü †
public
†† 
static
††  
AtomicSafetyHandle
†† (#
GetAtomicSafetyHandle
††) >
(
††> ?
in
††? A
NativeBitArray
††B P
	container
††Q Z
)
††Z [
{
°° 	
return
¢¢ 
	container
¢¢ 
.
¢¢ 
m_Safety
¢¢ %
;
¢¢% &
}
££ 	
[
™™ 	
BurstCompatible
™™	 
(
™™ !
RequiredUnityDefine
™™ ,
=
™™- .
$str
™™/ P
,
™™P Q
CompileTarget
™™R _
=
™™` a&
BurstCompatibleAttribute
™™b z
.
™™z {+
BurstCompatibleCompileTarget™™{ ó
.™™ó ò
Editor™™ò û
)™™û ü
]™™ü †
public
´´ 
static
´´ 
void
´´ #
SetAtomicSafetyHandle
´´ 0
(
´´0 1
ref
´´1 4
NativeBitArray
´´5 C
	container
´´D M
,
´´M N 
AtomicSafetyHandle
´´O a
safety
´´b h
)
´´h i
{
¨¨ 	
	container
≠≠ 
.
≠≠ 
m_Safety
≠≠ 
=
≠≠  
safety
≠≠! '
;
≠≠' (
}
ÆÆ 	
public
∏∏ 
static
∏∏ 
unsafe
∏∏ 
NativeBitArray
∏∏ +1
#ConvertExistingDataToNativeBitArray
∏∏, O
(
∏∏O P
void
∏∏P T
*
∏∏T U
ptr
∏∏V Y
,
∏∏Y Z
int
∏∏[ ^
sizeInBytes
∏∏_ j
,
∏∏j k
AllocatorManager
∏∏l |
.
∏∏| }
AllocatorHandle∏∏} å
	allocator∏∏ç ñ
)∏∏ñ ó
{
ππ 	
return
∫∫ 
new
∫∫ 
NativeBitArray
∫∫ %
{
ªª 

m_BitArray
ºº 
=
ºº 
new
ºº  
UnsafeBitArray
ºº! /
(
ºº/ 0
ptr
ºº0 3
,
ºº3 4
sizeInBytes
ºº5 @
,
ºº@ A
	allocator
ººB K
)
ººK L
,
ººL M
}
ΩΩ 
;
ΩΩ 
}
ææ 	
}
øø 
}¿¿ Ö∂
mC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\UTF8ArrayUnsafeUtility.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[ 
BurstCompatible 
] 
public		 

static		 
unsafe		 
class		 "
UTF8ArrayUnsafeUtility		 5
{

 
public 
static 
	CopyError 
Copy  $
($ %
byte% )
** +
dest+ /
,/ 0
out1 4
int5 8

destLength9 C
,C D
intE H$
destUTF8MaxLengthInBytesI a
,a b
charc g
*h i
srci l
,l m
intn q
	srcLengthr {
){ |
{ 	
var 
error 
= 
Unicode 
.  
Utf16ToUtf8  +
(+ ,
src, /
,/ 0
	srcLength1 :
,: ;
dest< @
,@ A
outB E

destLengthF P
,P Q$
destUTF8MaxLengthInBytesR j
)j k
;k l
if 
( 
error 
== 
ConversionError (
.( )
None) -
)- .
return 
	CopyError  
.  !
None! %
;% &
return 
	CopyError 
. 

Truncation '
;' (
} 	
public(( 
static(( 
	CopyError(( 
Copy((  $
((($ %
byte((% )
*((* +
dest((+ /
,((/ 0
out((1 4
ushort((5 ;

destLength((< F
,((F G
ushort((H N$
destUTF8MaxLengthInBytes((O g
,((g h
char((i m
*((n o
src((o r
,((r s
int((t w
	srcLength	((x Å
)
((Å Ç
{)) 	
var** 
error** 
=** 
Unicode** 
.**  
Utf16ToUtf8**  +
(**+ ,
src**, /
,**/ 0
	srcLength**1 :
,**: ;
dest**< @
,**@ A
out**B E
var**F I
temp**J N
,**N O$
destUTF8MaxLengthInBytes**P h
)**h i
;**i j

destLength++ 
=++ 
(++ 
ushort++  
)++  !
temp++! %
;++% &
if,, 
(,, 
error,, 
==,, 
ConversionError,, (
.,,( )
None,,) -
),,- .
return-- 
	CopyError--  
.--  !
None--! %
;--% &
return.. 
	CopyError.. 
... 

Truncation.. '
;..' (
}// 	
public;; 
static;; 
	CopyError;; 
Copy;;  $
(;;$ %
byte;;% )
*;;* +
dest;;+ /
,;;/ 0
out;;1 4
int;;5 8

destLength;;9 C
,;;C D
int;;E H$
destUTF8MaxLengthInBytes;;I a
,;;a b
byte;;c g
*;;h i
src;;i l
,;;l m
int;;n q
	srcLength;;r {
);;{ |
{<< 	
var== 
error== 
=== 
Unicode== 
.==  

Utf8ToUtf8==  *
(==* +
src==+ .
,==. /
	srcLength==0 9
,==9 :
dest==; ?
,==? @
out==A D
var==E H
temp==I M
,==M N$
destUTF8MaxLengthInBytes==O g
)==g h
;==h i

destLength>> 
=>> 
temp>> 
;>> 
if?? 
(?? 
error?? 
==?? 
ConversionError?? (
.??( )
None??) -
)??- .
return@@ 
	CopyError@@  
.@@  !
None@@! %
;@@% &
returnAA 
	CopyErrorAA 
.AA 

TruncationAA '
;AA' (
}BB 	
publicNN 
staticNN 
	CopyErrorNN 
CopyNN  $
(NN$ %
byteNN% )
*NN* +
destNN+ /
,NN/ 0
outNN1 4
ushortNN5 ;

destLengthNN< F
,NNF G
ushortNNH N$
destUTF8MaxLengthInBytesNNO g
,NNg h
byteNNi m
*NNn o
srcNNo r
,NNr s
ushortNNt z
	srcLength	NN{ Ñ
)
NNÑ Ö
{OO 	
varPP 
errorPP 
=PP 
UnicodePP 
.PP  

Utf8ToUtf8PP  *
(PP* +
srcPP+ .
,PP. /
	srcLengthPP0 9
,PP9 :
destPP; ?
,PP? @
outPPA D
varPPE H
tempPPI M
,PPM N$
destUTF8MaxLengthInBytesPPO g
)PPg h
;PPh i

destLengthQQ 
=QQ 
(QQ 
ushortQQ  
)QQ  !
tempQQ! %
;QQ% &
ifRR 
(RR 
errorRR 
==RR 
ConversionErrorRR (
.RR( )
NoneRR) -
)RR- .
returnSS 
	CopyErrorSS  
.SS  !
NoneSS! %
;SS% &
returnTT 
	CopyErrorTT 
.TT 

TruncationTT '
;TT' (
}UU 	
publicaa 
staticaa 
	CopyErroraa 
Copyaa  $
(aa$ %
charaa% )
*aa* +
destaa+ /
,aa/ 0
outaa1 4
intaa5 8

destLengthaa9 C
,aaC D
intaaE H$
destUCS2MaxLengthInCharsaaI a
,aaa b
byteaac g
*aah i
srcaai l
,aal m
intaan q
	srcLengthaar {
)aa{ |
{bb 	
ifcc 
(cc 
ConversionErrorcc 
.cc  
Nonecc  $
==cc% '
Unicodecc( /
.cc/ 0
Utf8ToUtf16cc0 ;
(cc; <
srccc< ?
,cc? @
	srcLengthccA J
,ccJ K
destccL P
,ccP Q
outccR U

destLengthccV `
,cc` a$
destUCS2MaxLengthInCharsccb z
)ccz {
)cc{ |
returndd 
	CopyErrordd  
.dd  !
Nonedd! %
;dd% &
returnee 
	CopyErroree 
.ee 

Truncationee '
;ee' (
}ff 	
publicrr 
staticrr 
	CopyErrorrr 
Copyrr  $
(rr$ %
charrr% )
*rr* +
destrr+ /
,rr/ 0
outrr1 4
ushortrr5 ;

destLengthrr< F
,rrF G
ushortrrH N$
destUCS2MaxLengthInCharsrrO g
,rrg h
byterri m
*rrn o
srcrro r
,rrr s
ushortrrt z
	srcLength	rr{ Ñ
)
rrÑ Ö
{ss 	
vartt 
errortt 
=tt 
Unicodett 
.tt  
Utf8ToUtf16tt  +
(tt+ ,
srctt, /
,tt/ 0
	srcLengthtt1 :
,tt: ;
desttt< @
,tt@ A
outttB E
varttF I
tempttJ N
,ttN O$
destUCS2MaxLengthInCharsttP h
)tth i
;tti j

destLengthuu 
=uu 
(uu 
ushortuu  
)uu  !
tempuu! %
;uu% &
ifvv 
(vv 
errorvv 
==vv 
ConversionErrorvv (
.vv( )
Nonevv) -
)vv- .
returnww 
	CopyErrorww  
.ww  !
Noneww! %
;ww% &
returnxx 
	CopyErrorxx 
.xx 

Truncationxx '
;xx' (
}yy 	
public
àà 
static
àà 
FormatError
àà !
AppendUTF8Bytes
àà" 1
(
àà1 2
byte
àà2 6
*
àà6 7
dest
àà8 <
,
àà< =
ref
àà> A
int
ààB E

destLength
ààF P
,
ààP Q
int
ààR U
destCapacity
ààV b
,
ààb c
byte
ààd h
*
ààh i
src
ààj m
,
ààm n
int
àào r
	srcLength
ààs |
)
àà| }
{
ââ 	
if
ää 
(
ää 

destLength
ää 
+
ää 
	srcLength
ää &
>
ää' (
destCapacity
ää) 5
)
ää5 6
return
ãã 
FormatError
ãã "
.
ãã" #
Overflow
ãã# +
;
ãã+ ,
UnsafeUtility
åå 
.
åå 
MemCpy
åå  
(
åå  !
dest
åå! %
+
åå& '

destLength
åå( 2
,
åå2 3
src
åå4 7
,
åå7 8
	srcLength
åå9 B
)
ååB C
;
ååC D

destLength
çç 
+=
çç 
	srcLength
çç #
;
çç# $
return
éé 
FormatError
éé 
.
éé 
None
éé #
;
éé# $
}
èè 	
public
õõ 
static
õõ 
	CopyError
õõ 
Append
õõ  &
(
õõ& '
byte
õõ' +
*
õõ, -
dest
õõ- 1
,
õõ1 2
ref
õõ3 6
ushort
õõ7 =

destLength
õõ> H
,
õõH I
ushort
õõJ P&
destUTF8MaxLengthInBytes
õõQ i
,
õõi j
byte
õõk o
*
õõp q
src
õõq t
,
õõt u
ushort
õõv |
	srcLengthõõ} Ü
)õõÜ á
{
úú 	
var
ùù 
error
ùù 
=
ùù 
Unicode
ùù 
.
ùù  

Utf8ToUtf8
ùù  *
(
ùù* +
src
ùù+ .
,
ùù. /
	srcLength
ùù0 9
,
ùù9 :
dest
ùù; ?
+
ùù@ A

destLength
ùùB L
,
ùùL M
out
ùùN Q
var
ùùR U
temp
ùùV Z
,
ùùZ [&
destUTF8MaxLengthInBytes
ùù\ t
-
ùùu v

destLengthùùw Å
)ùùÅ Ç
;ùùÇ É

destLength
ûû 
+=
ûû 
(
ûû 
ushort
ûû !
)
ûû! "
temp
ûû" &
;
ûû& '
if
üü 
(
üü 
error
üü 
==
üü 
ConversionError
üü (
.
üü( )
None
üü) -
)
üü- .
return
†† 
	CopyError
††  
.
††  !
None
††! %
;
††% &
return
°° 
	CopyError
°° 
.
°° 

Truncation
°° '
;
°°' (
}
¢¢ 	
public
ÆÆ 
static
ÆÆ 
	CopyError
ÆÆ 
Append
ÆÆ  &
(
ÆÆ& '
byte
ÆÆ' +
*
ÆÆ, -
dest
ÆÆ- 1
,
ÆÆ1 2
ref
ÆÆ3 6
ushort
ÆÆ7 =

destLength
ÆÆ> H
,
ÆÆH I
ushort
ÆÆJ P&
destUTF8MaxLengthInBytes
ÆÆQ i
,
ÆÆi j
char
ÆÆk o
*
ÆÆp q
src
ÆÆq t
,
ÆÆt u
int
ÆÆv y
	srcLengthÆÆz É
)ÆÆÉ Ñ
{
ØØ 	
var
∞∞ 
error
∞∞ 
=
∞∞ 
Unicode
∞∞ 
.
∞∞  
Utf16ToUtf8
∞∞  +
(
∞∞+ ,
src
∞∞, /
,
∞∞/ 0
	srcLength
∞∞1 :
,
∞∞: ;
dest
∞∞< @
+
∞∞A B

destLength
∞∞C M
,
∞∞M N
out
∞∞O R
var
∞∞S V
temp
∞∞W [
,
∞∞[ \&
destUTF8MaxLengthInBytes
∞∞] u
-
∞∞v w

destLength∞∞x Ç
)∞∞Ç É
;∞∞É Ñ

destLength
±± 
+=
±± 
(
±± 
ushort
±± !
)
±±! "
temp
±±" &
;
±±& '
if
≤≤ 
(
≤≤ 
error
≤≤ 
==
≤≤ 
ConversionError
≤≤ (
.
≤≤( )
None
≤≤) -
)
≤≤- .
return
≥≥ 
	CopyError
≥≥  
.
≥≥  !
None
≥≥! %
;
≥≥% &
return
¥¥ 
	CopyError
¥¥ 
.
¥¥ 

Truncation
¥¥ '
;
¥¥' (
}
µµ 	
public
¡¡ 
static
¡¡ 
	CopyError
¡¡ 
Append
¡¡  &
(
¡¡& '
char
¡¡' +
*
¡¡, -
dest
¡¡- 1
,
¡¡1 2
ref
¡¡3 6
ushort
¡¡7 =

destLength
¡¡> H
,
¡¡H I
ushort
¡¡J P&
destUCS2MaxLengthInChars
¡¡Q i
,
¡¡i j
byte
¡¡k o
*
¡¡p q
src
¡¡q t
,
¡¡t u
ushort
¡¡v |
	srcLength¡¡} Ü
)¡¡Ü á
{
¬¬ 	
var
√√ 
error
√√ 
=
√√ 
Unicode
√√ 
.
√√  
Utf8ToUtf16
√√  +
(
√√+ ,
src
√√, /
,
√√/ 0
	srcLength
√√1 :
,
√√: ;
dest
√√< @
+
√√A B

destLength
√√C M
,
√√M N
out
√√O R
var
√√S V
temp
√√W [
,
√√[ \&
destUCS2MaxLengthInChars
√√] u
-
√√v w

destLength√√x Ç
)√√Ç É
;√√É Ñ

destLength
ƒƒ 
+=
ƒƒ 
(
ƒƒ 
ushort
ƒƒ !
)
ƒƒ! "
temp
ƒƒ" &
;
ƒƒ& '
if
≈≈ 
(
≈≈ 
error
≈≈ 
==
≈≈ 
ConversionError
≈≈ (
.
≈≈( )
None
≈≈) -
)
≈≈- .
return
∆∆ 
	CopyError
∆∆  
.
∆∆  !
None
∆∆! %
;
∆∆% &
return
«« 
	CopyError
«« 
.
«« 

Truncation
«« '
;
««' (
}
»» 	
internal
   
struct
   

Comparison
   "
{
ÀÀ 	
public
ÃÃ 
bool
ÃÃ 

terminates
ÃÃ "
;
ÃÃ" #
public
ÕÕ 
int
ÕÕ 
result
ÕÕ 
;
ÕÕ 
public
ŒŒ 

Comparison
ŒŒ 
(
ŒŒ 
Unicode
ŒŒ %
.
ŒŒ% &
Rune
ŒŒ& *
runeA
ŒŒ+ 0
,
ŒŒ0 1
ConversionError
ŒŒ2 A
errorA
ŒŒB H
,
ŒŒH I
Unicode
ŒŒJ Q
.
ŒŒQ R
Rune
ŒŒR V
runeB
ŒŒW \
,
ŒŒ\ ]
ConversionError
ŒŒ^ m
errorB
ŒŒn t
)
ŒŒt u
{
œœ 
if
–– 
(
–– 
errorA
–– 
!=
–– 
ConversionError
–– ,
.
––, -
None
––- 1
)
––1 2
runeA
—— 
.
—— 
value
—— 
=
——  !
$num
——" #
;
——# $
if
““ 
(
““ 
errorB
““ 
!=
““ 
ConversionError
““ ,
.
““, -
None
““- 1
)
““1 2
runeB
”” 
.
”” 
value
”” 
=
””  !
$num
””" #
;
””# $
if
‘‘ 
(
‘‘ 
runeA
‘‘ 
.
‘‘ 
value
‘‘ 
!=
‘‘ !
runeB
‘‘" '
.
‘‘' (
value
‘‘( -
)
‘‘- .
{
’’ 
result
÷÷ 
=
÷÷ 
runeA
÷÷ "
.
÷÷" #
value
÷÷# (
-
÷÷) *
runeB
÷÷+ 0
.
÷÷0 1
value
÷÷1 6
;
÷÷6 7

terminates
◊◊ 
=
◊◊  
true
◊◊! %
;
◊◊% &
}
ÿÿ 
else
ŸŸ 
{
⁄⁄ 
result
€€ 
=
€€ 
$num
€€ 
;
€€ 

terminates
‹‹ 
=
‹‹  
(
‹‹! "
runeA
‹‹" '
.
‹‹' (
value
‹‹( -
==
‹‹. 0
$num
‹‹1 2
&&
‹‹3 5
runeB
‹‹6 ;
.
‹‹; <
value
‹‹< A
==
‹‹B D
$num
‹‹E F
)
‹‹F G
;
‹‹G H
}
›› 
}
ﬁﬁ 
}
ﬂﬂ 	
public
ÎÎ 
static
ÎÎ 
int
ÎÎ 
StrCmp
ÎÎ  
(
ÎÎ  !
byte
ÎÎ! %
*
ÎÎ% &
utf8BufferA
ÎÎ' 2
,
ÎÎ2 3
int
ÎÎ4 7 
utf8LengthInBytesA
ÎÎ8 J
,
ÎÎJ K
byte
ÎÎL P
*
ÎÎP Q
utf8BufferB
ÎÎR ]
,
ÎÎ] ^
int
ÎÎ_ b 
utf8LengthInBytesB
ÎÎc u
)
ÎÎu v
{
ÏÏ 	
int
ÌÌ 

byteIndexA
ÌÌ 
=
ÌÌ 
$num
ÌÌ 
;
ÌÌ 
int
ÓÓ 

byteIndexB
ÓÓ 
=
ÓÓ 
$num
ÓÓ 
;
ÓÓ 
while
ÔÔ 
(
ÔÔ 
true
ÔÔ 
)
ÔÔ 
{
 
var
ÒÒ 

utf8ErrorA
ÒÒ 
=
ÒÒ  
Unicode
ÒÒ! (
.
ÒÒ( )
	Utf8ToUcs
ÒÒ) 2
(
ÒÒ2 3
out
ÒÒ3 6
var
ÒÒ7 :
	utf8RuneA
ÒÒ; D
,
ÒÒD E
utf8BufferA
ÒÒF Q
,
ÒÒQ R
ref
ÒÒR U

byteIndexA
ÒÒV `
,
ÒÒ` a 
utf8LengthInBytesA
ÒÒb t
)
ÒÒt u
;
ÒÒu v
var
ÚÚ 

utf8ErrorB
ÚÚ 
=
ÚÚ  
Unicode
ÚÚ! (
.
ÚÚ( )
	Utf8ToUcs
ÚÚ) 2
(
ÚÚ2 3
out
ÚÚ3 6
var
ÚÚ7 :
	utf8RuneB
ÚÚ; D
,
ÚÚD E
utf8BufferB
ÚÚF Q
,
ÚÚQ R
ref
ÚÚS V

byteIndexB
ÚÚW a
,
ÚÚa b 
utf8LengthInBytesB
ÚÚc u
)
ÚÚu v
;
ÚÚv w
var
ÛÛ 

comparison
ÛÛ 
=
ÛÛ  
new
ÛÛ! $

Comparison
ÛÛ% /
(
ÛÛ/ 0
	utf8RuneA
ÛÛ0 9
,
ÛÛ9 :

utf8ErrorA
ÛÛ; E
,
ÛÛE F
	utf8RuneB
ÛÛG P
,
ÛÛP Q

utf8ErrorB
ÛÛR \
)
ÛÛ\ ]
;
ÛÛ] ^
if
ÙÙ 
(
ÙÙ 

comparison
ÙÙ 
.
ÙÙ 

terminates
ÙÙ (
)
ÙÙ( )
return
ıı 

comparison
ıı %
.
ıı% &
result
ıı& ,
;
ıı, -
}
ˆˆ 
}
˜˜ 	
public
ÉÉ 
static
ÉÉ 
int
ÉÉ 
StrCmp
ÉÉ  
(
ÉÉ  !
char
ÉÉ! %
*
ÉÉ% &
utf16BufferA
ÉÉ' 3
,
ÉÉ3 4
int
ÉÉ5 8!
utf16LengthInCharsA
ÉÉ9 L
,
ÉÉL M
char
ÉÉN R
*
ÉÉR S
utf16BufferB
ÉÉT `
,
ÉÉ` a
int
ÉÉb e!
utf16LengthInCharsB
ÉÉf y
)
ÉÉy z
{
ÑÑ 	
int
ÖÖ 

charIndexA
ÖÖ 
=
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
int
ÜÜ 

charIndexB
ÜÜ 
=
ÜÜ 
$num
ÜÜ 
;
ÜÜ 
while
áá 
(
áá 
true
áá 
)
áá 
{
àà 
var
ââ 
utf16ErrorA
ââ 
=
ââ  !
Unicode
ââ" )
.
ââ) *

Utf16ToUcs
ââ* 4
(
ââ4 5
out
ââ5 8
var
ââ9 <

utf16RuneA
ââ= G
,
ââG H
utf16BufferA
ââI U
,
ââU V
ref
ââV Y

charIndexA
ââZ d
,
ââd e!
utf16LengthInCharsA
ââf y
)
âây z
;
ââz {
var
ää 
utf16ErrorB
ää 
=
ää  !
Unicode
ää" )
.
ää) *

Utf16ToUcs
ää* 4
(
ää4 5
out
ää5 8
var
ää9 <

utf16RuneB
ää= G
,
ääG H
utf16BufferB
ääI U
,
ääU V
ref
ääW Z

charIndexB
ää[ e
,
ääe f!
utf16LengthInCharsB
ääg z
)
ääz {
;
ää{ |
var
ãã 

comparison
ãã 
=
ãã  
new
ãã! $

Comparison
ãã% /
(
ãã/ 0

utf16RuneA
ãã0 :
,
ãã: ;
utf16ErrorA
ãã< G
,
ããG H

utf16RuneB
ããI S
,
ããS T
utf16ErrorB
ããU `
)
ãã` a
;
ããa b
if
åå 
(
åå 

comparison
åå 
.
åå 

terminates
åå (
)
åå( )
return
çç 

comparison
çç %
.
çç% &
result
çç& ,
;
çç, -
}
éé 
}
èè 	
public
óó 
static
óó 
bool
óó 
EqualsUTF8Bytes
óó *
(
óó* +
byte
óó+ /
*
óó/ 0
aBytes
óó1 7
,
óó7 8
int
óó9 <
aLength
óó= D
,
óóD E
byte
óóF J
*
óóJ K
bBytes
óóL R
,
óóR S
int
óóT W
bLength
óóX _
)
óó_ `
{
òò 	
return
ôô 
StrCmp
ôô 
(
ôô 
aBytes
ôô  
,
ôô  !
aLength
ôô" )
,
ôô) *
bBytes
ôô+ 1
,
ôô1 2
bLength
ôô3 :
)
ôô: ;
==
ôô< >
$num
ôô? @
;
ôô@ A
}
öö 	
public
¶¶ 
static
¶¶ 
int
¶¶ 
StrCmp
¶¶  
(
¶¶  !
byte
¶¶! %
*
¶¶% &

utf8Buffer
¶¶' 1
,
¶¶1 2
int
¶¶3 6
utf8LengthInBytes
¶¶7 H
,
¶¶H I
char
¶¶J N
*
¶¶N O
utf16Buffer
¶¶P [
,
¶¶[ \
int
¶¶] ` 
utf16LengthInChars
¶¶a s
)
¶¶s t
{
ßß 	
int
®® 
	byteIndex
®® 
=
®® 
$num
®® 
;
®® 
int
©© 
	charIndex
©© 
=
©© 
$num
©© 
;
©© 
while
™™ 
(
™™ 
true
™™ 
)
™™ 
{
´´ 
var
¨¨ 
	utf8Error
¨¨ 
=
¨¨ 
Unicode
¨¨  '
.
¨¨' (
	Utf8ToUcs
¨¨( 1
(
¨¨1 2
out
¨¨2 5
var
¨¨6 9
utf8Rune
¨¨: B
,
¨¨B C

utf8Buffer
¨¨D N
,
¨¨N O
ref
¨¨O R
	byteIndex
¨¨S \
,
¨¨\ ]
utf8LengthInBytes
¨¨^ o
)
¨¨o p
;
¨¨p q
var
≠≠ 

utf16Error
≠≠ 
=
≠≠  
Unicode
≠≠! (
.
≠≠( )

Utf16ToUcs
≠≠) 3
(
≠≠3 4
out
≠≠4 7
var
≠≠8 ;
	utf16Rune
≠≠< E
,
≠≠E F
utf16Buffer
≠≠G R
,
≠≠R S
ref
≠≠T W
	charIndex
≠≠X a
,
≠≠a b 
utf16LengthInChars
≠≠c u
)
≠≠u v
;
≠≠v w
var
ÆÆ 

comparison
ÆÆ 
=
ÆÆ  
new
ÆÆ! $

Comparison
ÆÆ% /
(
ÆÆ/ 0
utf8Rune
ÆÆ0 8
,
ÆÆ8 9
	utf8Error
ÆÆ: C
,
ÆÆC D
	utf16Rune
ÆÆE N
,
ÆÆN O

utf16Error
ÆÆP Z
)
ÆÆZ [
;
ÆÆ[ \
if
ØØ 
(
ØØ 

comparison
ØØ 
.
ØØ 

terminates
ØØ (
)
ØØ( )
return
∞∞ 

comparison
∞∞ %
.
∞∞% &
result
∞∞& ,
;
∞∞, -
}
±± 
}
≤≤ 	
public
ææ 
static
ææ 
int
ææ 
StrCmp
ææ  
(
ææ  !
char
ææ! %
*
ææ% &
utf16Buffer
ææ' 2
,
ææ2 3
int
ææ4 7 
utf16LengthInChars
ææ8 J
,
ææJ K
byte
ææL P
*
ææP Q

utf8Buffer
ææR \
,
ææ\ ]
int
ææ^ a
utf8LengthInBytes
ææb s
)
ææs t
{
øø 	
return
¿¿ 
-
¿¿ 
StrCmp
¿¿ 
(
¿¿ 

utf8Buffer
¿¿ %
,
¿¿% &
utf8LengthInBytes
¿¿' 8
,
¿¿8 9
utf16Buffer
¿¿: E
,
¿¿E F 
utf16LengthInChars
¿¿G Y
)
¿¿Y Z
;
¿¿Z [
}
¡¡ 	
}
√√ 
}ƒƒ ¸n
dC:\code\ispclone\Library\PackageCache\com.unity.collections@1.2.4\Unity.Collections\NativeHashSet.cs
	namespace 	
Unity
 
. 
Collections 
{ 
[ 
StructLayout 
( 

LayoutKind 
. 

Sequential '
)' (
]( )
[ 
DebuggerTypeProxy 
( 
typeof 
( *
NativeHashSetDebuggerTypeProxy <
<< =
>= >
)> ?
)? @
]@ A
[ 
BurstCompatible 
(  
GenericTypeArguments )
=* +
new, /
[0 1
]1 2
{3 4
typeof5 ;
(; <
int< ?
)? @
}A B
)B C
]C D
public 

unsafe 
struct 
NativeHashSet &
<& '
T' (
>( )
: 	
INativeDisposable
 
, 	
IEnumerable
 
< 
T 
> 
where 
T 
: 
	unmanaged 
, 

IEquatable '
<' (
T( )
>) *
{ 
internal 
static 
readonly  
SharedStatic! -
<- .
int. 1
>1 2
s_staticSafetyId3 C
=D E
SharedStaticF R
<R S
intS V
>V W
.W X
GetOrCreateX c
<c d
NativeHashSetd q
<q r
Tr s
>s t
>t u
(u v
)v w
;w x
internal 
NativeHashMap 
< 
T  
,  !
bool" &
>& '
m_Data( .
;. /
public$$ 
NativeHashSet$$ 
($$ 
int$$  
capacity$$! )
,$$) *
AllocatorManager$$+ ;
.$$; <
AllocatorHandle$$< K
	allocator$$L U
)$$U V
{%% 	
m_Data&& 
=&& 
new&& 
NativeHashMap&& &
<&&& '
T&&' (
,&&( )
bool&&* .
>&&. /
(&&/ 0
capacity&&0 8
,&&8 9
	allocator&&: C
)&&C D
;&&D E
CollectionHelper(( 
.(( 
SetStaticSafetyId(( .
<((. /
NativeHashSet((/ <
<((< =
T((= >
>((> ?
>((? @
(((@ A
ref((A D
m_Data((E K
.((K L
m_Safety((L T
,((T U
ref((V Y
s_staticSafetyId((Z j
.((j k
Data((k o
)((o p
;((p q
}** 	
public00 
bool00 
IsEmpty00 
=>00 
m_Data00 %
.00% &
IsEmpty00& -
;00- .
public66 
int66 
Count66 
(66 
)66 
=>66 
m_Data66 $
.66$ %
Count66% *
(66* +
)66+ ,
;66, -
public>> 
int>> 
Capacity>> 
{>> 
get>> !
=>>>" $
m_Data>>% +
.>>+ ,
Capacity>>, 4
;>>4 5
set>>6 9
=>>>: <
m_Data>>= C
.>>C D
Capacity>>D L
=>>M N
value>>O T
;>>T U
}>>V W
publicDD 
boolDD 
	IsCreatedDD 
=>DD  
m_DataDD! '
.DD' (
	IsCreatedDD( 1
;DD1 2
publicII 
voidII 
DisposeII 
(II 
)II 
=>II  
m_DataII! '
.II' (
DisposeII( /
(II/ 0
)II0 1
;II1 2
[PP 	
NotBurstCompatiblePP	 
]
PPú ù
publicQQ 
	JobHandleQQ 
DisposeQQ  
(QQ  !
	JobHandleQQ! *
	inputDepsQQ+ 4
)QQ4 5
=>QQ6 8
m_DataQQ9 ?
.QQ? @
DisposeQQ@ G
(QQG H
	inputDepsQQH Q
)QQQ R
;QQR S
publicWW 
voidWW 
ClearWW 
(WW 
)WW 
=>WW 
m_DataWW %
.WW% &
ClearWW& +
(WW+ ,
)WW, -
;WW- .
public^^ 
bool^^ 
Add^^ 
(^^ 
T^^ 
item^^ 
)^^ 
=>^^  "
m_Data^^# )
.^^) *
TryAdd^^* 0
(^^0 1
item^^1 5
,^^5 6
false^^7 <
)^^< =
;^^= >
publicee 
boolee 
Removeee 
(ee 
Tee 
itemee !
)ee! "
=>ee# %
m_Dataee& ,
.ee, -
Removeee- 3
(ee3 4
itemee4 8
)ee8 9
;ee9 :
publicll 
boolll 
Containsll 
(ll 
Tll 
itemll #
)ll# $
=>ll% '
m_Datall( .
.ll. /
ContainsKeyll/ :
(ll: ;
itemll; ?
)ll? @
;ll@ A
publicss 
NativeArrayss 
<ss 
Tss 
>ss 
ToNativeArrayss +
(ss+ ,
AllocatorManagerss, <
.ss< =
AllocatorHandless= L
	allocatorssM V
)ssV W
=>ssX Z
m_Datass[ a
.ssa b
GetKeyArrayssb m
(ssm n
	allocatorssn w
)ssw x
;ssx y
publicyy 
ParallelWriteryy 
AsParallelWriteryy .
(yy. /
)yy/ 0
{zz 	
ParallelWriter{{ 
writer{{ !
;{{! "
writer|| 
.|| 
m_Data|| 
=|| 
m_Data|| "
.||" #
AsParallelWriter||# 3
(||3 4
)||4 5
;||5 6
CollectionHelper~~ 
.~~ 
SetStaticSafetyId~~ .
<~~. /
ParallelWriter~~/ =
>~~= >
(~~> ?
ref~~? B
writer~~C I
.~~I J
m_Data~~J P
.~~P Q
m_Safety~~Q Y
,~~Y Z
ref~~[ ^
ParallelWriter~~_ m
.~~m n
s_staticSafetyId~~n ~
.~~~ 
Data	~~ É
)
~~É Ñ
;
~~Ñ Ö
return
ÄÄ 
writer
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
[
ââ 	.
 NativeContainerIsAtomicWriteOnly
ââ	 )
]
ââ) *
[
ää 	
BurstCompatible
ää	 
(
ää "
GenericTypeArguments
ää -
=
ää. /
new
ää0 3
[
ää4 5
]
ää5 6
{
ää7 8
typeof
ää9 ?
(
ää? @
int
ää@ C
)
ääC D
}
ääE F
)
ääF G
]
ääG H
public
ãã 
struct
ãã 
ParallelWriter
ãã $
{
åå 	
internal
éé 
static
éé 
readonly
éé $
SharedStatic
éé% 1
<
éé1 2
int
éé2 5
>
éé5 6
s_staticSafetyId
éé7 G
=
ééH I
SharedStatic
ééJ V
<
ééV W
int
ééW Z
>
ééZ [
.
éé[ \
GetOrCreate
éé\ g
<
éég h
ParallelWriter
ééh v
>
éév w
(
ééw x
)
ééx y
;
ééy z
internal
êê 
NativeHashMap
êê "
<
êê" #
T
êê# $
,
êê$ %
bool
êê& *
>
êê* +
.
êê+ ,
ParallelWriter
êê, :
m_Data
êê; A
;
êêA B
public
ññ 
int
ññ 
Capacity
ññ 
=>
ññ  "
m_Data
ññ# )
.
ññ) *
Capacity
ññ* 2
;
ññ2 3
public
ùù 
bool
ùù 
Add
ùù 
(
ùù 
T
ùù 
item
ùù "
)
ùù" #
=>
ùù$ &
m_Data
ùù' -
.
ùù- .
TryAdd
ùù. 4
(
ùù4 5
item
ùù5 9
,
ùù9 :
false
ùù; @
)
ùù@ A
;
ùùA B
}
ûû 	
public
§§ 

Enumerator
§§ 
GetEnumerator
§§ '
(
§§' (
)
§§( )
{
•• 	 
AtomicSafetyHandle
ßß 
.
ßß 2
$CheckGetSecondaryDataPointerAndThrow
ßß C
(
ßßC D
m_Data
ßßD J
.
ßßJ K
m_Safety
ßßK S
)
ßßS T
;
ßßT U
var
®® 
ash
®® 
=
®® 
m_Data
®® 
.
®® 
m_Safety
®® %
;
®®% & 
AtomicSafetyHandle
©© 
.
©© !
UseSecondaryVersion
©© 2
(
©©2 3
ref
©©3 6
ash
©©7 :
)
©©: ;
;
©©; <
return
´´ 
new
´´ 

Enumerator
´´ !
{
¨¨ 
m_Safety
ÆÆ 
=
ÆÆ 
ash
ÆÆ 
,
ÆÆ 
m_Enumerator
∞∞ 
=
∞∞ 
new
∞∞ ")
UnsafeHashMapDataEnumerator
∞∞# >
(
∞∞> ?
m_Data
∞∞? E
.
∞∞E F
m_HashMapData
∞∞F S
.
∞∞S T
m_Buffer
∞∞T \
)
∞∞\ ]
,
∞∞] ^
}
±± 
;
±± 
}
≤≤ 	
IEnumerator
ππ 
<
ππ 
T
ππ 
>
ππ 
IEnumerable
ππ "
<
ππ" #
T
ππ# $
>
ππ$ %
.
ππ% &
GetEnumerator
ππ& 3
(
ππ3 4
)
ππ4 5
{
∫∫ 	
throw
ªª 
new
ªª %
NotImplementedException
ªª -
(
ªª- .
)
ªª. /
;
ªª/ 0
}
ºº 	
IEnumerator
√√ 
IEnumerable
√√ 
.
√√  
GetEnumerator
√√  -
(
√√- .
)
√√. /
{
ƒƒ 	
throw
≈≈ 
new
≈≈ %
NotImplementedException
≈≈ -
(
≈≈- .
)
≈≈. /
;
≈≈/ 0
}
∆∆ 	
[
œœ 	
NativeContainer
œœ	 
]
œœ 
[
–– 	'
NativeContainerIsReadOnly
––	 "
]
––" #
public
—— 
struct
—— 

Enumerator
——  
:
——! "
IEnumerator
——# .
<
——. /
T
——/ 0
>
——0 1
{
““ 	
internal
‘‘  
AtomicSafetyHandle
‘‘ '
m_Safety
‘‘( 0
;
‘‘0 1
internal
÷÷ )
UnsafeHashMapDataEnumerator
÷÷ 0
m_Enumerator
÷÷1 =
;
÷÷= >
public
€€ 
void
€€ 
Dispose
€€ 
(
€€  
)
€€  !
{
€€" #
}
€€$ %
public
·· 
bool
·· 
MoveNext
··  
(
··  !
)
··! "
{
‚‚  
AtomicSafetyHandle
‰‰ "
.
‰‰" #
CheckReadAndThrow
‰‰# 4
(
‰‰4 5
m_Safety
‰‰5 =
)
‰‰= >
;
‰‰> ?
return
ÊÊ 
m_Enumerator
ÊÊ #
.
ÊÊ# $
MoveNext
ÊÊ$ ,
(
ÊÊ, -
)
ÊÊ- .
;
ÊÊ. /
}
ÁÁ 
public
ÏÏ 
void
ÏÏ 
Reset
ÏÏ 
(
ÏÏ 
)
ÏÏ 
{
ÌÌ  
AtomicSafetyHandle
ÔÔ "
.
ÔÔ" #
CheckReadAndThrow
ÔÔ# 4
(
ÔÔ4 5
m_Safety
ÔÔ5 =
)
ÔÔ= >
;
ÔÔ> ?
m_Enumerator
ÒÒ 
.
ÒÒ 
Reset
ÒÒ "
(
ÒÒ" #
)
ÒÒ# $
;
ÒÒ$ %
}
ÚÚ 
public
¯¯ 
T
¯¯ 
Current
¯¯ 
{
˘˘ 
get
˙˙ 
{
˚˚  
AtomicSafetyHandle
˝˝ &
.
˝˝& '
CheckReadAndThrow
˝˝' 8
(
˝˝8 9
m_Safety
˝˝9 A
)
˝˝A B
;
˝˝B C
return
ˇˇ 
m_Enumerator
ˇˇ '
.
ˇˇ' (
GetCurrentKey
ˇˇ( 5
<
ˇˇ5 6
T
ˇˇ6 7
>
ˇˇ7 8
(
ˇˇ8 9
)
ˇˇ9 :
;
ˇˇ: ;
}
ÄÄ 
}
ÅÅ 
object
ÜÜ 
IEnumerator
ÜÜ 
.
ÜÜ 
Current
ÜÜ &
=>
ÜÜ' )
Current
ÜÜ* 1
;
ÜÜ1 2
}
áá 	
}
àà 
sealed
ää 

internal
ää 
class
ää ,
NativeHashSetDebuggerTypeProxy
ää 8
<
ää8 9
T
ää9 :
>
ää: ;
where
ãã 
T
ãã 
:
ãã 
	unmanaged
ãã 
,
ãã 

IEquatable
ãã '
<
ãã' (
T
ãã( )
>
ãã) *
{
åå 
NativeHashSet
éé 
<
éé 
T
éé 
>
éé 
Data
éé 
;
éé 
public
êê ,
NativeHashSetDebuggerTypeProxy
êê -
(
êê- .
NativeHashSet
êê. ;
<
êê; <
T
êê< =
>
êê= >
data
êê? C
)
êêC D
{
ëë 	
Data
íí 
=
íí 
data
íí 
;
íí 
}
ìì 	
public
ïï 
List
ïï 
<
ïï 
T
ïï 
>
ïï 
Items
ïï 
{
ññ 	
get
óó 
{
òò 
var
ôô 
result
ôô 
=
ôô 
new
ôô  
List
ôô! %
<
ôô% &
T
ôô& '
>
ôô' (
(
ôô( )
)
ôô) *
;
ôô* +
using
öö 
(
öö 
var
öö 
keys
öö 
=
öö  !
Data
öö" &
.
öö& '
ToNativeArray
öö' 4
(
öö4 5
	Allocator
öö5 >
.
öö> ?
Temp
öö? C
)
ööC D
)
ööD E
{
õõ 
for
úú 
(
úú 
var
úú 
k
úú 
=
úú  
$num
úú! "
;
úú" #
k
úú$ %
<
úú& '
keys
úú( ,
.
úú, -
Length
úú- 3
;
úú3 4
++
úú5 7
k
úú7 8
)
úú8 9
{
ùù 
result
ûû 
.
ûû 
Add
ûû "
(
ûû" #
keys
ûû# '
[
ûû' (
k
ûû( )
]
ûû) *
)
ûû* +
;
ûû+ ,
}
üü 
}
†† 
return
¢¢ 
result
¢¢ 
;
¢¢ 
}
££ 
}
§§ 	
}
¶¶ 
}ßß 